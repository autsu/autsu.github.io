<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Flannel VXLAN 流程</title>
    <link href="/2025/04/04/IPVS%E5%AE%9E%E8%B7%B5/"/>
    <url>/2025/04/04/IPVS%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="单节点"><a href="#单节点" class="headerlink" title="单节点"></a>单节点</h2><p>问题：</p><p>curl ipvs ip 不通，但是 curl realserver ip 可以。</p><p>环境：</p><p>ipvs 和 realserver 都在同一个节点，这个场景其实有点类似 K8s 的 Service。（K8s Service 的 IPVS 模式会在每个节点创建一张 dummy 网卡，网卡分配了集群中所有 Service 的地址，同时指定了对应的 Service -&gt; Pod 的地址）</p><p>节点 eth0 ip：198.19.249.53&#x2F;24</p><p>在节点上运行了一个监听在 8085 的 http server，访问时会返回 hello，作为 realserver。可以通过 <code>curl 198.19.249.53:8085</code> 访问。</p><blockquote><p>[!tip]</p><p>可以使用 <code>python3 -m http.server 8085 --bind 0.0.0.0</code> 快速创建。</p></blockquote><p>接下来是 IPVS。在节点上执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ipvsadm -A -t 198.19.249.123:8085 -s rr<br>ipvsadm -a -t 198.19.249.123 -r 198.19.249.53 -m<br></code></pre></td></tr></table></figure><p>创建一个 vip 198.19.249.123，指向本节点的 http server。期望的效果是 <code>curl 198.19.249.123:8085</code> 会负载均衡到 <code>198.19.249.53:8085</code>。</p><p>现在的现象：</p><p>curl 198.19.249.123:8085 ：完全没反应<br>curl 198.19.249.53:8085：正常响应</p><p>curl 198.19.249.123:8085 抓包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">tcpdump -i any -n -vvv port 8085<br>tcpdump: data <span class="hljs-built_in">link</span> <span class="hljs-built_in">type</span> LINUX_SLL2<br>tcpdump: listening on any, link-type LINUX_SLL2 (Linux cooked v2), snapshot length 262144 bytes<br>17:37:22.508582 eth0  Out IP (tos 0x0, ttl 64, <span class="hljs-built_in">id</span> 12004, offset 0, flags [DF], proto TCP (6), length 60)<br>    198.19.249.53.38942 &gt; 198.19.249.53.8085: Flags [S], <span class="hljs-built_in">cksum</span> 0x7ec1 (incorrect -&gt; 0xdbfa), <span class="hljs-built_in">seq</span> 1306956786, win 64240, options [mss 1460,sackOK,TS val 3289093353 ecr 0,nop,wscale 7], length 0<br>17:37:22.508658 eth0  In  IP (tos 0x0, ttl 64, <span class="hljs-built_in">id</span> 12004, offset 0, flags [DF], proto TCP (6), length 60)<br>    198.19.249.53.38942 &gt; 198.19.249.53.8085: Flags [S], <span class="hljs-built_in">cksum</span> 0x7ec1 (incorrect -&gt; 0xdbfa), <span class="hljs-built_in">seq</span> 1306956786, win 64240, options [mss 1460,sackOK,TS val 3289093353 ecr 0,nop,wscale 7], length 0<br>17:37:23.510998 eth0  Out IP (tos 0x0, ttl 64, <span class="hljs-built_in">id</span> 12005, offset 0, flags [DF], proto TCP (6), length 60)<br>    198.19.249.53.38942 &gt; 198.19.249.53.8085: Flags [S], <span class="hljs-built_in">cksum</span> 0x7ec1 (incorrect -&gt; 0xd80f), <span class="hljs-built_in">seq</span> 1306956786, win 64240, options [mss 1460,sackOK,TS val 3289094356 ecr 0,nop,wscale 7], length 0<br>17:37:23.511039 eth0  In  IP (tos 0x0, ttl 64, <span class="hljs-built_in">id</span> 12005, offset 0, flags [DF], proto TCP (6), length 60)<br>    198.19.249.53.38942 &gt; 198.19.249.53.8085: Flags [S], <span class="hljs-built_in">cksum</span> 0x7ec1 (incorrect -&gt; 0xd80f), <span class="hljs-built_in">seq</span> 1306956786, win 64240, options [mss 1460,sackOK,TS val 3289094356 ecr 0,nop,wscale 7], length 0<br></code></pre></td></tr></table></figure><p>解决：</p><p>创建一张网卡，绑定 ipvs 的 VIP：</p><p>（也可以把 VIP 绑定到 eth0 上，应该任意一张网卡都可以。）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ip <span class="hljs-built_in">link</span> add ipvs-dummy <span class="hljs-built_in">type</span> dummy<br>sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> ipvs-dummy up<br>sudo ip addr add 198.19.249.123/32 dev ipvs-dummy<br>ip addr show ipvs-dummy<br></code></pre></td></tr></table></figure><p>ipvs 创建的 service ip 必须要绑定到一张网卡上，否则无法工作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">client          --&gt;   ipvs               -&gt; realserver<br>198.19.249.129       198.19.249.123         198.19.249.53<br><br><br><br><span class="hljs-built_in">echo</span> hello &gt; index.html<br>python3 -m http.server 8085 -d .<br><br><span class="hljs-comment"># rr    # 轮询</span><br><span class="hljs-comment"># wrr   # 加权轮询</span><br><span class="hljs-comment"># lc    # 最少连接</span><br><span class="hljs-comment"># wlc   # 加权最少连接</span><br><span class="hljs-comment"># sh    # 源哈希</span><br><span class="hljs-comment"># dh    # 目标哈希</span><br>ipvsadm -A -t 198.19.249.123:8085 -s rr<br>ipvsadm -a -t 198.19.249.123:8085 -r 198.19.249.53 -m<br><br><br><span class="hljs-comment"># 创建 dummy 网卡</span><br>sudo ip <span class="hljs-built_in">link</span> add ipvs-dummy <span class="hljs-built_in">type</span> dummy<br>sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> ipvs-dummy up<br>sudo ip addr add 198.19.249.123/32 dev ipvs-dummy<br>ip addr show ipvs-dummy<br><br><span class="hljs-comment">#-m: NAT 模式</span><br><br><span class="hljs-comment"># TCP  198.19.249.123:8085 rr</span><br><span class="hljs-comment">#  -&gt; 198.19.249.53:8085           Masq    1      0          0</span><br><br><br>root@client:~$ curl 198.19.249.53:8085 <span class="hljs-comment"># realserver, OK</span><br>root@client:~$ curl 198.19.249.123:8085 <span class="hljs-comment"># ipvs server, NOT OK</span><br></code></pre></td></tr></table></figure><h2 id="三节点"><a href="#三节点" class="headerlink" title="三节点"></a>三节点</h2><p>环境：</p><table><thead><tr><th></th><th>IP</th></tr></thead><tbody><tr><td>client</td><td>198.19.249.17</td></tr><tr><td>ipvs</td><td>198.19.249.123（用作ipvs，绑定在eth0）, 198.19.249.129（eth0）</td></tr><tr><td>rs</td><td>198.19.249.53:8085</td></tr><tr><td></td><td></td></tr></tbody></table><p>rs 执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 -m http.server 8085 --<span class="hljs-built_in">bind</span> 0.0.0.0<br></code></pre></td></tr></table></figure><p>ipvs 执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip addr add 198.19.249.123/32 dev eth0<br><br>ipvsadm -A -t 198.19.249.123:8085 -s rr<br>ipvsadm -a -t 198.19.249.123:8085 -r 198.19.249.53 -m<br></code></pre></td></tr></table></figure><p>client 执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl 198.19.249.123:8085<br></code></pre></td></tr></table></figure><p>结果是 client 上无法 curl 通，可以抓包分析一下。</p><p>分别抓包三台机器的 eth0 网卡，结果如下：</p><p><code>client</code></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250405004101.png" alt="image.png"></p><p>其实从这里就能看出问题了。client 首先发送的包的 dst 是 198.19.249.123，但是收到的包的 src 却是 198.19.249.53，二者不一致，所以 client 会给 198.19.249.53 发一个 RST 包中断 TCP 连接。</p><p>这个 198.19.249.53 正是 rs 的 IP，所以可以大胆猜想一下，是不是 ipvs 只做了 dnat，但是没有 snat？</p><p><code>ipvs</code></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250405004755.png" alt="image.png"></p><p>看起来确实是这样，它只做了 dnat。</p><p><code>rs</code></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250405004831.png" alt="image.png"></p><p>rs 这边用自己的 IP 回复，然后就收到了 client 的 RST 包。</p><p>解决：</p><p>可以在 ipvs 上设置一条 iptables 规则，对流出的包做 snat，把 src 改成 ipvs 的 IP，这样 rs 会回包给 ipvs，再由 ipvs 回包给 client。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 必须设置不然 iptables 不会做 snat</span><br>sysctl -w net.ipv4.vs.conntrack=1<br>sudo iptables -t nat -A POSTROUTING -d 198.19.249.53 -p tcp --dport 8085 -j MASQUERADE<br></code></pre></td></tr></table></figure><p>重新抓包 ipvs：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250405012142.png" alt="image.png"></p><p>可以看到 src 修改成了 ipvs eth0 的 IP。</p><p>结论：</p><p>ipvs nat 模式只会做 dnat，不会做 snat。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.dianduidian.com/post/lvs-snat%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">LVS+Iptables实现FULLNAT及原理分析 - XniLe - Ops 2.0</a></p><p><a href="https://medium.com/google-cloud/load-balancing-with-ipvs-1c0a48476c4d">Load balancing with IPVS | Google Cloud - Community</a></p><p><a href="https://zhuanlan.zhihu.com/p/94418251">IPVS从入门到精通kube-proxy实现原理</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>k8s</tag>
      
      <tag>k8s网络</tag>
      
      <tag>needSyncToBlog</tag>
      
      <tag>IPVS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K8s Service IPVS 实践</title>
    <link href="/2025/04/02/K8s%20Service%20IPVS%20%E5%AE%9E%E8%B7%B5/"/>
    <url>/2025/04/02/K8s%20Service%20IPVS%20%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<p>创建实验环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl create deploy nginx --image=nginx --replicas=2<br>kubectl create service clusterip nginx --tcp=80:80<br><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">k get svc,po -owide | grep nginx<br>service/nginx        ClusterIP   10.96.196.139   &lt;none&gt;        80/TCP    65s   app=nginx<br>pod/nginx-76d6c9b8c-qbfrs   1/1     Running   0          2m18s   10.244.2.13   kind-worker2   &lt;none&gt;           &lt;none&gt;<br>pod/nginx-76d6c9b8c-qxjfq   1/1     Running   0          2m18s   10.244.1.13   kind-worker    &lt;none&gt;           &lt;none&gt;<br></code></pre></td></tr></table></figure><p>有点乱，列个表格看一下：</p><table><thead><tr><th></th><th>IP</th></tr></thead><tbody><tr><td>Service</td><td>10.96.196.139</td></tr><tr><td>Pod1</td><td>10.244.2.13</td></tr><tr><td>Pod2</td><td>10.244.1.13</td></tr><tr><td>Node1</td><td>192.168.247.7&#x2F;24</td></tr><tr><td>Node2</td><td>192.168.247.10&#x2F;24</td></tr><tr><td></td><td></td></tr></tbody></table><p>IPVS 信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ipvsadm<br>IP Virtual Server version 1.2.1 (size=4096)<br>Prot LocalAddress:Port Scheduler Flags<br>  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn<br>TCP  10.96.196.139:http rr<br>  -&gt; 10.244.1.13:http             Masq    1      0          0<br>  -&gt; 10.244.2.13:http             Masq    1      0          0<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ipvsadm -S -n | grep 10.96.196.139<br>-A -t 10.96.196.139:80 -s rr<br>-a -t 10.96.196.139:80 -r 10.244.1.13:80 -m -w 1<br>-a -t 10.96.196.139:80 -r 10.244.2.13:80 -m -w 1<br></code></pre></td></tr></table></figure><p><code>kube-proxy</code> 会创建一个虚拟网卡，把集群内所有的 Service IP 添加到这张虚拟网卡中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ip a<br>5: kube-ipvs0: &lt;BROADCAST,NOARP&gt; mtu 1500 qdisc noop state DOWN group default<br>    <span class="hljs-built_in">link</span>/ether 2e:28:11:1f:f0:0d brd ff:ff:ff:ff:ff:ff<br>    inet 10.96.0.10/32 scope global kube-ipvs0<br>       valid_lft forever preferred_lft forever<br>    inet 10.96.0.1/32 scope global kube-ipvs0<br>       valid_lft forever preferred_lft forever<br>    inet 10.96.196.139/32 scope global kube-ipvs0<br>       valid_lft forever preferred_lft forever<br><br>$ k get svc -A | awk <span class="hljs-string">&#x27;&#123;printf &quot;%-20s %s\n&quot;, $2, $4&#125;&#x27;</span><br>NAME                 CLUSTER-IP<br>kubernetes           10.96.0.1<br>nginx                10.96.196.139<br>kube-dns             10.96.0.10<br></code></pre></td></tr></table></figure><p>这也意味着如果 <code>kube-proxy</code> 使用的是 <code>ipvs</code> 模式，是可以 ping 通 service 的 IP 的。</p><p>IPVS 的路由在 <code>local</code> 表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ip route show table <span class="hljs-built_in">local</span><br><span class="hljs-built_in">local</span> 10.96.0.1 dev kube-ipvs0 proto kernel scope host src 10.96.0.1<br><span class="hljs-built_in">local</span> 10.96.0.10 dev kube-ipvs0 proto kernel scope host src 10.96.0.10<br><span class="hljs-built_in">local</span> 10.96.196.139 dev kube-ipvs0 proto kernel scope host src 10.96.196.139<br></code></pre></td></tr></table></figure><p>— 草稿</p><p>问题：</p><p>curl ipvs ip 不通，但是 curl realserver ip 可以。</p><p>环境：</p><p>节点 eth0 ip：198.19.249.53&#x2F;24</p><p>在节点上运行了一个监听在 8085 的 http server，访问时会返回 hello。</p><p>然后在节点上执行 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ipvsadm -A -t 198.19.249.123:8085 -s rr<br>ipvsadm -a -t 198.19.249.123 -r 198.19.249.53 -m<br></code></pre></td></tr></table></figure><p>创建一个 vip，指向本节点的 http server。</p><p>现在的现象：</p><p>curl 198.19.249.123:8085 ：完全没反应<br>curl 198.19.249.53:8085：正常响应</p><p>curl 198.19.249.123:8085 抓包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">tcpdump -i any -n -vvv port 8085<br>tcpdump: data <span class="hljs-built_in">link</span> <span class="hljs-built_in">type</span> LINUX_SLL2<br>tcpdump: listening on any, link-type LINUX_SLL2 (Linux cooked v2), snapshot length 262144 bytes<br>17:37:22.508582 eth0  Out IP (tos 0x0, ttl 64, <span class="hljs-built_in">id</span> 12004, offset 0, flags [DF], proto TCP (6), length 60)<br>    198.19.249.53.38942 &gt; 198.19.249.53.8085: Flags [S], <span class="hljs-built_in">cksum</span> 0x7ec1 (incorrect -&gt; 0xdbfa), <span class="hljs-built_in">seq</span> 1306956786, win 64240, options [mss 1460,sackOK,TS val 3289093353 ecr 0,nop,wscale 7], length 0<br>17:37:22.508658 eth0  In  IP (tos 0x0, ttl 64, <span class="hljs-built_in">id</span> 12004, offset 0, flags [DF], proto TCP (6), length 60)<br>    198.19.249.53.38942 &gt; 198.19.249.53.8085: Flags [S], <span class="hljs-built_in">cksum</span> 0x7ec1 (incorrect -&gt; 0xdbfa), <span class="hljs-built_in">seq</span> 1306956786, win 64240, options [mss 1460,sackOK,TS val 3289093353 ecr 0,nop,wscale 7], length 0<br>17:37:23.510998 eth0  Out IP (tos 0x0, ttl 64, <span class="hljs-built_in">id</span> 12005, offset 0, flags [DF], proto TCP (6), length 60)<br>    198.19.249.53.38942 &gt; 198.19.249.53.8085: Flags [S], <span class="hljs-built_in">cksum</span> 0x7ec1 (incorrect -&gt; 0xd80f), <span class="hljs-built_in">seq</span> 1306956786, win 64240, options [mss 1460,sackOK,TS val 3289094356 ecr 0,nop,wscale 7], length 0<br>17:37:23.511039 eth0  In  IP (tos 0x0, ttl 64, <span class="hljs-built_in">id</span> 12005, offset 0, flags [DF], proto TCP (6), length 60)<br>    198.19.249.53.38942 &gt; 198.19.249.53.8085: Flags [S], <span class="hljs-built_in">cksum</span> 0x7ec1 (incorrect -&gt; 0xd80f), <span class="hljs-built_in">seq</span> 1306956786, win 64240, options [mss 1460,sackOK,TS val 3289094356 ecr 0,nop,wscale 7], length 0<br></code></pre></td></tr></table></figure><p>解决：</p><p>创建一张网卡，绑定 ipvs 的 VIP：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ip <span class="hljs-built_in">link</span> add ipvs-dummy <span class="hljs-built_in">type</span> dummy<br>sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> ipvs-dummy up<br>sudo ip addr add 198.19.249.123/32 dev ipvs-dummy<br>ip addr show ipvs-dummy<br></code></pre></td></tr></table></figure><p>ipvs 创建的 service ip 必须要绑定到一张网卡上，否则无法工作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">client          --&gt;   ipvs               -&gt; realserver<br>198.19.249.129       198.19.249.123         198.19.249.53<br><br><br><br><span class="hljs-built_in">echo</span> hello &gt; index.html<br>python3 -m http.server 8085 -d .<br><br><span class="hljs-comment"># rr    # 轮询</span><br><span class="hljs-comment"># wrr   # 加权轮询</span><br><span class="hljs-comment"># lc    # 最少连接</span><br><span class="hljs-comment"># wlc   # 加权最少连接</span><br><span class="hljs-comment"># sh    # 源哈希</span><br><span class="hljs-comment"># dh    # 目标哈希</span><br>ipvsadm -A -t 198.19.249.123:8085 -s rr<br>ipvsadm -a -t 198.19.249.123 -r 198.19.249.53 -m<br><br><br><span class="hljs-comment"># 创建 dummy 网卡</span><br>sudo ip <span class="hljs-built_in">link</span> add ipvs-dummy <span class="hljs-built_in">type</span> dummy<br>sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> ipvs-dummy up<br>sudo ip addr add 198.19.249.123/32 dev ipvs-dummy<br>ip addr show ipvs-dummy<br><br><span class="hljs-comment">#-m: NAT 模式</span><br><br><span class="hljs-comment"># TCP  198.19.249.123:8085 rr</span><br><span class="hljs-comment">#  -&gt; 198.19.249.53:8085           Masq    1      0          0</span><br><br><br>root@client:~$ curl 198.19.249.53:8085 <span class="hljs-comment"># realserver, OK</span><br>root@client:~$ curl 198.19.249.123:8085 <span class="hljs-comment"># ipvs server, NOT OK</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>k8s网络</tag>
      
      <tag>needSyncToBlog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ipip 实践</title>
    <link href="/2025/03/22/ipip%20%E5%AE%9E%E8%B7%B5/"/>
    <url>/2025/03/22/ipip%20%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="点对点"><a href="#点对点" class="headerlink" title="点对点"></a>点对点</h2><p>配置的是点到点的 tun 设备，需要明确指定 local 和 remote。（ipip 似乎只支持点到点？要想多对多，似乎得另辟蹊径）</p><p><code>ip tunnel add tun1 mode ipip remote &#123;&#123; remote_ip &#125;&#125; local &#123;&#123; local_ip &#125;&#125;</code></p><p>remote_ip：外层目的 IP，指向对端设备的 IP。<br>local_ip：外层源 IP，也就是本设备的 IP。</p><p><code>ip addr add &#123;&#123; internal_local_ip &#125;&#125; peer &#123;&#123; internal_remote_ip &#125;&#125; dev tun1</code></p><p>internal_local_ip 和 internal_remote_ip：其实就是原始报文的源 IP 和目的 IP。</p><p>当这个原始报文发送给 tunl 设备时，tunl 会把原始报文包在一个外层报文里面，像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">+-------------------+-------------------+-------------------+-------------------+<br>| dst: 外层目的IP    | dst：内部目的IP     | TCP/UDP           | payload           |<br>| src: 外层源IP      | src：内部源IP      |                   |                   |<br>+-------------------+-------------------+-------------------+-------------------+<br></code></pre></td></tr></table></figure><p>开始实验：</p><p>node1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 隧道外层 IP</span><br>ip tunnel add tun1 mode ipip remote 198.19.249.129 <span class="hljs-built_in">local</span> 198.19.249.53<br>ip addr add 10.0.1.1 peer 10.0.2.1 dev tun1 <span class="hljs-comment"># 隧道内侧 IP</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> tun1 up<br></code></pre></td></tr></table></figure><p>node2:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip tunnel add tun1 mode ipip remote 198.19.249.53 <span class="hljs-built_in">local</span> 198.19.249.129<br>ip addr add 10.0.2.1 peer 10.0.1.1 dev tun1<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> tun1 up<br></code></pre></td></tr></table></figure><p>创建出来的设备：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># node1</span><br>13: tun1@NONE: &lt;POINTOPOINT,NOARP,UP,LOWER_UP&gt; mtu 1480 qdisc noqueue state UNKNOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ipip 198.19.249.53 peer 198.19.249.129<br>    inet 10.0.1.1 peer 10.0.2.1/32 scope global tun1<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::5efe:c613:f935/64 scope <span class="hljs-built_in">link</span><br>       valid_lft forever preferred_lft forever<br><br><span class="hljs-comment"># node2</span><br>8: tun1@NONE: &lt;POINTOPOINT,NOARP,UP,LOWER_UP&gt; mtu 1480 qdisc noqueue state UNKNOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ipip 198.19.249.129 peer 198.19.249.53<br>    inet 10.0.2.1 peer 10.0.1.1/32 scope global tun1<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::5efe:c613:f981/64 scope <span class="hljs-built_in">link</span><br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping 10.0.2.1<br></code></pre></td></tr></table></figure><p>抓包 node1 上的 eth0：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250322221616.png" alt="image.png"></p><p>可以看到内层 IP 和外层 IP</p><p>对  tunl 设备抓包：</p><p>只有内层 IP</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250322221824.png" alt="image.png"></p><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>ipip 也支持多对多，区别就是在创建时无需指定 local 和 remote，也无需指定 <code>ip addr add 10.0.1.1 peer 10.0.2.1 dev tun1</code>。只需要 <code>ip tunnel add mode ipip</code> 简单创建即可。</p><blockquote><p>[!info]</p><p>使用 <code>ip tunnel add mode ipip</code> 默认创建出的设备名是 tunl0，且无法显式指定名称。这样创建出来的 tun 设备的 remote 和 local 都为 any，代表接收任何源地址和目的地址的包。</p><p>如果你想创建一个 ipip 设备并自行指定名称，可以明确指定 local 参数，比如下面这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip <span class="hljs-built_in">link</span> add test.ipip <span class="hljs-built_in">type</span> ipip <span class="hljs-built_in">local</span> 192.168.1.2 remote any dev eth0  <br></code></pre></td></tr></table></figure><p>（通过 Flannel 的 IPIP 部分源码得知）</p></blockquote><p>创建出来的设备长这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tunl0@NONE: &lt;NOARP,UP,LOWER_UP&gt; mtu 1480 qdisc noqueue state UNKNOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ipip 0.0.0.0 brd 0.0.0.0<br></code></pre></td></tr></table></figure><p>那 ipip 设备如何知道目标 IP 从而进行封包呢？答案是依靠路由表。</p><p>以下面这条为例：</p><p><code>ip route add 10.0.2.0/24 via 198.19.249.129 dev tunl0 proto bird onlink</code></p><p>它代表所有发往 10.0.2.0&#x2F;24 的包，都使用 198.19.249.129 作为下一跳，通过 tunl0，也就是 ipip 设备发出。后面的 proto bird 暂时不用关注。</p><p>tunl0 收到这个包后，就会进行封包操作。它把之前的原始包封到一个新的包中，目的地址就是 via 198.19.249.129，源地址的话，暂时应该还不会设置（这里是我猜的，因为 tunl0 本身又没设置 IP 地址）。</p><p>然后这个包会重新流入到网络协议栈，协议栈继续查找路由表，看如何到达 198.19.249.129，同时填充 src ip。最后这个完整的包就会到达 198.19.249.129。</p><p>下面做一个实验验证一下，结构如下所示，两个节点三层可达。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">+------------------------------------+       +------------------------------------+<br>|              Node1                 |       |              Node2                 |<br>|                                    |       |                                    |<br>|  +---------------------------+     |       |  +---------------------------+     |<br>|  |          ns1              |     |       |  |          ns1              |     |<br>|  |  veth1 (10.0.1.10/24)     |     |       |  |  veth1 (10.0.2.10/24)     |     |<br>|  +---------------------------+     |       |  +---------------------------+     |<br>|              |                     |       |              |                     |<br>|  +---------------------------+     |       |  +---------------------------+     |<br>|  |         veth2 (proxy_arp) |     |       |  |         veth2 (proxy_arp) |     |<br>|  +---------------------------+     |       |  +---------------------------+     |<br>|                                    |       |                                    |<br>|  +---------------------------+     |       |  +---------------------------+     |<br>|  |          tunl0 (IPIP)     |     |       |  |          tunl0 (IPIP)     |     |<br>|  +---------------------------+     |       |  +---------------------------+     |<br>|                                    |       |                                    |<br>|  +---------------------------+     |       |  +---------------------------+     |<br>|  |         eth0: 198.19.249.53    |       |  |         eth0: 198.19.249.129   |<br>|  +---------------------------+     |       |  +---------------------------+     |<br>+------------------------------------+       +------------------------------------+<br>                   |                                       |<br>                   +---------------------------------------+<br>                                 |<br>                                 v<br>                         External Network<br>                 <br>                 <br>+--------------------------------------------------------------------------------+<br>|                                    路由表                                       |<br>+--------------------------------------------------------------------------------+<br>| Node1 ns1 路由表:                                                               |<br>|   - 169.254.1.1 dev veth1 scope link                                           |<br>|   - default via 169.254.1.1                                                    |<br>|                                                                                |<br>| Node1 宿主机路由表:                                                              |<br>|   - 10.0.1.10 dev veth2                                                        |<br>|   - 10.0.2.0/24 via 198.19.249.129 dev tunl0 proto bird onlink                 |<br>|   - 198.19.249.0/24 dev eth0 （如何到达 198.19.249.53 的路由，这里只是演示)         |<br>|                                                                                |<br>+--------------------------------------------------------------------------------+                               |                                                                                |<br>| Node2 ns1 路由表:                                                               |<br>|   - 169.254.1.1 dev veth1 scope link                                           |<br>|   - default via 169.254.1.1                                                    |<br>|                                                                                |<br>| Node2 宿主机路由表:                                                              |<br>|   - 10.0.2.10 dev veth2                                                        |<br>|   - 10.0.1.0/24 via 198.19.249.53 dev tunl0 proto bird onlink                  |<br>|   - 198.19.249.0/24 dev eth0 （如何到达 198.19.249.53 的路由，这里只是演示)         |<br>+--------------------------------------------------------------------------------+<br></code></pre></td></tr></table></figure><p>Node1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip netns add ns1<br>ip <span class="hljs-built_in">link</span> add veth1 <span class="hljs-built_in">type</span> veth peer name veth2<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 netns ns1<br>ip netns <span class="hljs-built_in">exec</span> ns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 up<br>ip netns <span class="hljs-built_in">exec</span> ns1 ip route add 169.254.1.1 dev veth1 scope <span class="hljs-built_in">link</span><br>ip netns <span class="hljs-built_in">exec</span> ns1 ip route add default via 169.254.1.1<br>ip netns <span class="hljs-built_in">exec</span> ns1 ip addr add 10.0.1.10/24 dev veth1<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2 up<br>ip route add 10.0.1.10 dev veth2 <span class="hljs-comment"># 这个路由必须有</span><br><span class="hljs-comment"># 删掉默认添加的路由，让包全部走 default </span><br>ip netns <span class="hljs-built_in">exec</span> ns1 ip route del 10.0.1.0/24 dev veth1 proto kernel scope <span class="hljs-built_in">link</span> src 10.0.1.10<br><span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/conf/veth2/proxy_arp<br><span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward<br><br><span class="hljs-comment"># ipip</span><br>ip tunnel add mode ipip <span class="hljs-comment"># 不指定名字的话默认是 tunl0</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> tunl0 up<br>ip route add 10.0.2.0/24 via 198.19.249.129 dev tunl0 proto bird onlink<br></code></pre></td></tr></table></figure><p>Node2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip netns add ns1<br>ip <span class="hljs-built_in">link</span> add veth1 <span class="hljs-built_in">type</span> veth peer name veth2<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 netns ns1<br>ip netns <span class="hljs-built_in">exec</span> ns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 up<br>ip netns <span class="hljs-built_in">exec</span> ns1 ip route add 169.254.1.1 dev veth1 scope <span class="hljs-built_in">link</span><br>ip netns <span class="hljs-built_in">exec</span> ns1 ip route add default via 169.254.1.1<br>ip netns <span class="hljs-built_in">exec</span> ns1 ip addr add 10.0.2.10/24 dev veth1<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2 up<br>ip route add 10.0.2.10 dev veth2 <span class="hljs-comment"># 这个路由必须有</span><br><span class="hljs-comment"># 删掉默认添加的路由，让包全部走 default </span><br>ip netns <span class="hljs-built_in">exec</span> ns1 ip route del 10.0.2.0/24 dev veth1 proto kernel scope <span class="hljs-built_in">link</span> src 10.0.2.10<br><span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/conf/veth2/proxy_arp<br><span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward<br><br><span class="hljs-comment"># ipip</span><br>ip tunnel add mode ipip <span class="hljs-comment"># 不指定名字的话默认是 tunl0</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> tunl0 up<br>ip route add 10.0.1.0/24 via 198.19.249.53 dev tunl0 proto bird onlink<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># node1 执行</span><br>ip netns <span class="hljs-built_in">exec</span> ns1 ping 10.0.2.10<br><br><span class="hljs-comment"># 把这条路由删掉就 ping 不通了，说明 ipip 设备封号包后，会继续根据路由表进行转发。</span><br>ip r d 10.0.2.0/24 via 198.19.249.129 dev tunl0 proto bird onlink<br></code></pre></td></tr></table></figure><p>抓 node1 的 tunl0：</p><p><code>tcpdump -nep  -i tunl0 -w ipip.pcap</code></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250324145902.png" alt="image.png"></p><p>抓 node1 的出网卡 eth0：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250324150007.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>k8s</tag>
      
      <tag>k8s网络</tag>
      
      <tag>needSyncToBlog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>proxy_arp</title>
    <link href="/2025/03/11/proxy_arp/"/>
    <url>/2025/03/11/proxy_arp/</url>
    
    <content type="html"><![CDATA[<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>网络拓扑：ns1 &lt;- eth111 &lt;—&gt; veth0 -&gt; host</p><p>veth 一端 eth111 放到 namespace 中（另一端 veth0 默认在主机的网络协议栈），然后 namespace 这边的 veth 尝试执行 ping 操作。</p><p>namespace 设置了两条路由，所有包的下一跳都将会是 169.254.1.1。这是一个虚拟地址，用来实验 proxy_arp。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip netns add ns1<br><br>ip <span class="hljs-built_in">link</span> add veth0 <span class="hljs-built_in">type</span> veth peer name eth111<br><br>ip addr add 10.1.1.3/24 dev veth0<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth0 up<br><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth111 netns ns1<br>ip netns <span class="hljs-built_in">exec</span> ns1 ip addr add 10.1.1.2/24 dev eth111<br>ip netns <span class="hljs-built_in">exec</span> ns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth111 up<br><br><br><span class="hljs-comment"># 路由添加有先后顺序</span><br><span class="hljs-comment"># 如果先添加 default 这一条，会报错 Error: Nexthop has invalid gateway.</span><br><span class="hljs-comment"># 因为它不知道下一跳如何路由</span><br>ip netns <span class="hljs-built_in">exec</span> ns1 ip r a 169.254.1.1 dev eth111 scope <span class="hljs-built_in">link</span><br>ip netns <span class="hljs-built_in">exec</span> ns1 ip r a default via 169.254.1.1 dev eth111<br><br></code></pre></td></tr></table></figure><p>我们暂时先不开启 proxy_arp，抓包看看。</p><p>开启三个终端，分别执行以下命令，抓包命令最好在 ping 命令之前执行。</p><p>ping 命令：</p><p><code>ip netns exec ns1 ping 1.1.1.1</code></p><p>抓包 namespace 内的 veth 设备：</p><p><code>ip netns exec ns1 tcpdump -i any arp -e -w proxy_arp.pcap</code></p><p>抓包另一个 veth：</p><p><code>tcpdump -i veth0 -e -w proxy_arp.pcap</code></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250312150714.png" alt="image.png"></p><p>首先说一下流程。namespace 执行了一个 Ping 命令，根据路由表指示，所有请求都会将 169.254.1.1 作为下一跳地址，所以网络协议栈需要获取该 IP 对应的地址以构建报文的二层，所以它会发一个 ARP 请求，并使用 eth111 发送，因为是一个 Veth 设备，所以会到达另一端的设备 veth0 。</p><p>veth0 看了下它的目标 IP 并不是自己的，所以正常来说不会回复。为了解决这个问题，就需要开启 <code>proxy_arp</code>，也正是这篇文章的主角。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开启 proxy_arp</span><br><span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/conf/veth0/proxy_arp<br></code></pre></td></tr></table></figure><blockquote><p>PS：proxy_arp 是针对某个设备开启的。不像 ip_forward 那样。</p></blockquote><p>开启后，当 veth0 收到 ARP 请求报文后，会直接用自己的地址回复，抓包结果如下：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250312164645.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250312164917.png" alt="image.png"></p><p>然后 ICMP 报文就会发送给 veth0，也就是来到主机的网络协议栈上，然后继续根据路由表进行转发，</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>三层在同一网段，但是二层不通</p><p>正常 ARP：<br>主机 A —&gt; ARP 请求：”谁是 192.168.1.100?” —&gt; 主机 B 直接回应</p><p>Proxy ARP：<br>主机 A —&gt; ARP 请求：”谁是 192.168.1.100?” —&gt; 路由器代替主机 B 回应</p><p>网段 A (192.168.1.0&#x2F;24) — 路由器 — 网段 B (192.168.1.0&#x2F;25)<br>                            启用<br>                          Proxy ARP</p><p>即使是相同网段，也可以通过路由器通信</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>1&gt; 设备收到 ARP 请求包以后，它是如何判断自己是否要作为一个 proxy_arp 进行回复的呢？</p><p><del>经过我的实验，如果我 ping 的地址在主机路由表上不存在，比如 ping 1.1.1.1，那么 veth0 是不会进行响应的。而如果 ping 的是路由表上存在的，比如 198.19.249.100 就可以。</del></p><p><del>主机路由表如下：</del></p><p><del>default via 198.19.249.1 dev eth0 proto dhcp src 198.19.249.53 metric 100</del><br><del>0.250.250.200 via 198.19.249.1 dev eth0 proto dhcp src 198.19.249.53 metric 100</del><br><del>10.1.1.0&#x2F;24 dev veth0 proto kernel scope link src 10.1.1.3</del><br><del>198.19.249.0&#x2F;24 dev eth0 proto kernel scope link src 198.19.249.53 metric 100</del><br><del>198.19.249.1 dev eth0 proto dhcp scope link src 198.19.249.53 metric 100</del></p><p><del>莫名其妙，又能响应了</del></p><blockquote><p>更新：判断 veth0 是否回复，我是通过抓 ARP 包分析的，如果没抓到就认为 veth0 没响应。但是实际上是因为 veth0 之前已经回复过了，所以这条记录已经缓存到了 ARP 表，之后可以直接拿到 169.254.1.1 对应的 MAC 地址（也就是 veth0 的 MAC），不需要再发 ARP 请求了。</p></blockquote><p>看起来和路由表没关系？只要这个设备开启了 proxy_arp，那么只要收到 arp 请求包，就一律用自己的 MAC 回复。</p><p>证据：</p><p>在 namespace 中 ping 一个路由表中不存在对应规则的 IP</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250313102937.png" alt="image.png"></p><p>抓包发现 proxy_arp 依然进行了回复。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250313103027.png" alt="image.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/1495301">戳穿 Calico 的谎言-腾讯云开发者社区-腾讯云</a></p><p><a href="https://www.myway5.com/index.php/2021/07/19/proxy-arp-in-calico/">proxy_arp在calico中的妙用 - 一只安静的猫</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>k8s</tag>
      
      <tag>k8s网络</tag>
      
      <tag>needSyncToBlog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ip_forward 实践</title>
    <link href="/2025/03/10/ip_forward/"/>
    <url>/2025/03/10/ip_forward/</url>
    
    <content type="html"><![CDATA[<h2 id="ip-forward-是什么？"><a href="#ip-forward-是什么？" class="headerlink" title="ip_forward 是什么？"></a>ip_forward 是什么？</h2><p>ip_forward 是 Linux 内核提供的一项功能，它允许系统将接收到的网络数据包从一个网络接口转发到另一个网络接口。简单来说，启用 ip_forward 可以让 Linux 系统充当路由器，将不同网络之间的数据包进行传递。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ul><li>当一个数据包到达某个网络接口时，系统会检查数据包的目标 IP 地址。</li><li>如果目标 IP 不是本机的 IP 地址，且 ip_forward 已启用，系统会根据路由表决定将数据包转发到哪个接口。然后这个包重新进入内核网络协议栈，进行下一步处理，也就是转发。</li><li>如果 ip_forward 未启用，系统会直接丢弃该数据包。</li></ul><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>实验环境：</p><p>ns1(10.1.1.2&#x2F;24) -&gt; veth1 -&gt; br0(10.1.1.1&#x2F;24) &lt;- br1 (10.2.2.1&#x2F;24) &lt;- veth2 &lt;- ns2(10.2.2.2&#x2F;24) </p><p>ns1 和 ns2 属于两个子网，现在想让彼此之间能够通信。</p><p>创建设备的完整命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 1. 创建网络命名空间</span><br>sudo ip netns add ns1<br>sudo ip netns add ns2<br><br><span class="hljs-comment"># 2. 创建两个网桥（模拟两个子网的接入点）</span><br>sudo ip <span class="hljs-built_in">link</span> add br0 <span class="hljs-built_in">type</span> bridge<br>sudo ip <span class="hljs-built_in">link</span> add br1 <span class="hljs-built_in">type</span> bridge<br>sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> br0 up<br>sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> br1 up<br>sudo ip addr add 10.1.1.1/24 dev br0<br>sudo ip addr add 10.2.2.1/24 dev br1<br><br><span class="hljs-comment"># 3. 创建 veth pairs</span><br>sudo ip <span class="hljs-built_in">link</span> add veth1 <span class="hljs-built_in">type</span> veth peer name veth1_peer<br>sudo ip <span class="hljs-built_in">link</span> add veth2 <span class="hljs-built_in">type</span> veth peer name veth2_peer<br><br><span class="hljs-comment"># 4. 将 veth 一端放入命名空间</span><br>sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1_peer netns ns1<br>sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2_peer netns ns2<br><br><span class="hljs-comment"># 5. 将 veth 另一端接入网桥</span><br>sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 master br0<br>sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2 master br1<br>sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 up<br>sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2 up<br><br><span class="hljs-comment"># 6. 配置 ns1</span><br>sudo ip netns <span class="hljs-built_in">exec</span> ns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1_peer name veth1<br>sudo ip netns <span class="hljs-built_in">exec</span> ns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 up<br>sudo ip netns <span class="hljs-built_in">exec</span> ns1 ip addr add 10.1.1.2/24 dev veth1<br><br><br><span class="hljs-comment"># 7. 配置 ns2</span><br>sudo ip netns <span class="hljs-built_in">exec</span> ns2 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2_peer name veth2<br>sudo ip netns <span class="hljs-built_in">exec</span> ns2 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2 up<br>sudo ip netns <span class="hljs-built_in">exec</span> ns2 ip addr add 10.2.2.2/24 dev veth2<br><br><span class="hljs-comment"># 添加路由</span><br>sudo ip netns <span class="hljs-built_in">exec</span> ns1 ip r add 10.2.2.0/24 via 10.1.1.1 dev veth1<br>sudo ip netns <span class="hljs-built_in">exec</span> ns2 ip r add 10.1.1.0/24 via 10.2.2.1 dev veth2<br><br></code></pre></td></tr></table></figure><p>执行 <code>sudo ip netns exec ns1 ping 10.2.2.2</code> 测试，发现没有问题，可以 ping 通。</p><p>在创建网桥时，宿主机自动添加了路由 <code>10.2.2.0/24 dev br1 proto kernel scope link src 10.2.2.1</code> 。</p><blockquote><p>[!info]<br>也可以试试把这条路由删掉，看会发生什么。</p><p>结论：无法转发，报错 Destination Net Unreachable</p></blockquote><p>ns1 发出的包首先根据 ns1 namespace 上的路由 <code>10.2.2.0/24 via 10.1.1.1 dev veth1</code>，来到 br0 网桥。</p><p>然后 br0 根据上面提到的宿主机上的路由 <code>10.2.2.0/24 dev br1 proto kernel scope link src 10.2.2.1</code>，继续转发给 br1 设备，最终到达 veth2。</p><p>本来想抓个包<code>tcpdump -i br0 -e -nn -vvv</code> 看看 br0 给 br1 发的包长啥样，结果发现抓不到，只有 veth1 -&gt; br0 以及 br0 -&gt; veth1 的包。可能 linux bridge 间转发包是内核处理的，不会产生包。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250311095410.png" alt="image.png"></p><p>不过不关键，现在我们主要关注的是 ip_forward 的作用。通过上面的例子不难看出，br0 实际充当了路由器的功能，它在收到包后，会查找路由表，继续进行转发，而 ip_forward 正是控制是否打开 “转发”这项功能的钥匙。</p><p>不信的话，可以关掉这个配置，执行 <code>sudo sysctl -w net.ipv4.ip_forward=0</code> ，然后再重新 ping 一下。</p><p>关闭后，ping 命令会直接卡住。</p><p>可以对 br1 抓一下包，就会发现它并没有收到任何包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// Linux 内核网络栈简化流程<br>数据包到达 <br>   ↓<br>查询路由表     // 这步不受 ip_forward 影响<br>   ↓<br>判断目标地址<br>   ├── 发往本机 → 继续处理<br>   └── 需要转发 → 检查 ip_forward<br>                   ├── ip_forward=1 → 转发数据包<br>                   └── ip_forward=0 → 丢弃数据包<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3MzUzMjIxNA==&mid=2247485805&idx=1&sn=0cf58152624859e7b3e9a3f07e9d9710&">Linux中路由功能及ip_forward转发配置</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>k8s</tag>
      
      <tag>k8s网络</tag>
      
      <tag>needSyncToBlog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VXLAN 实践</title>
    <link href="/2025/03/05/VXLAN%E5%AE%9E%E8%B7%B5/"/>
    <url>/2025/03/05/VXLAN%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker-实践"><a href="#Docker-实践" class="headerlink" title="Docker 实践"></a>Docker 实践</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>两台虚拟机</li><li>安装好 Docker</li></ul><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>在两台虚拟机上执行 <code>docker network create --subnet 172.18.0.0/16 mynetwork</code>，这会创建一个网桥设备 <code>br-xxx</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">brctl show<br>bridge namebridge <span class="hljs-built_in">id</span>STP enabledinterfaces<br>br-6950db7451948000.26e602abb899novethfb71f8c<br>docker08000.56354f9f8f74no<br></code></pre></td></tr></table></figure><p>分别创建容器，接入网桥。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">## VM1</span><br>docker run -itd --net mynetwork --ip 172.18.0.10 centos<br><span class="hljs-comment">## VM2</span><br>docker run -itd --net mynetwork --ip 172.18.0.11 centos<br><br><span class="hljs-comment">#--net指定自定义网络</span><br><span class="hljs-comment">#--ip指定IP地址</span><br><span class="hljs-comment">#centos指定image</span><br></code></pre></td></tr></table></figure><p>此时两个容器之间是无法通信的。</p><p>添加 VXLAN 设备：</p><p>命令中的 remote 写对方的，即 VM1 的 remote 写 VM2 的 IP。</p><p>remote 是对端 VTEP 所在主机的 IP。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">## VM1</span><br>ip <span class="hljs-built_in">link</span> add vxlan_docker <span class="hljs-built_in">type</span> vxlan <span class="hljs-built_in">id</span> 200 remote 198.19.249.210 dstport 4789 dev eth0<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> vxlan_docker up<br>brctl addif br-96bfb0c154e1 vxlan_docker<br><br><span class="hljs-comment">## VM2</span><br>ip <span class="hljs-built_in">link</span> add vxlan_docker <span class="hljs-built_in">type</span> vxlan <span class="hljs-built_in">id</span> 200 remote 198.19.249.129 dstport 4789 dev eth0<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> vxlan_docker up<br>brctl addif br-6950db745194 vxlan_docker<br></code></pre></td></tr></table></figure><p>VM1 执行前，路由表：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip route<br>default via 198.19.249.1 dev eth0 proto dhcp src 198.19.249.129 metric 100<br>0.250.250.200 via 198.19.249.1 dev eth0 proto dhcp src 198.19.249.129 metric 100<br>172.17.0.0/16 dev docker0 proto kernel scope <span class="hljs-built_in">link</span> src 172.17.0.1 linkdown<br>172.18.0.0/16 dev br-96bfb0c154e1 proto kernel scope <span class="hljs-built_in">link</span> src 172.18.0.1<br>198.19.249.0/24 dev eth0 proto kernel scope <span class="hljs-built_in">link</span> src 198.19.249.129 metric 100<br>198.19.249.1 dev eth0 proto dhcp scope <span class="hljs-built_in">link</span> src 198.19.249.129 metric 100<br></code></pre></td></tr></table></figure><p>执行后的路由表：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">default via 198.19.249.1 dev eth0 proto dhcp src 198.19.249.129 metric 100<br>0.250.250.200 via 198.19.249.1 dev eth0 proto dhcp src 198.19.249.129 metric 100<br>172.17.0.0/16 dev docker0 proto kernel scope <span class="hljs-built_in">link</span> src 172.17.0.1 linkdown<br>172.18.0.0/16 dev br-96bfb0c154e1 proto kernel scope <span class="hljs-built_in">link</span> src 172.18.0.1<br>198.19.249.0/24 dev eth0 proto kernel scope <span class="hljs-built_in">link</span> src 198.19.249.129 metric 100<br>198.19.249.1 dev eth0 proto dhcp scope <span class="hljs-built_in">link</span> src 198.19.249.129 metric 100<br></code></pre></td></tr></table></figure><p>发现没什么变化，</p><p>创建完后，发现容器可以通信了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it 2a1 sh<br>sh-4.4<span class="hljs-comment"># ping 172.18.0.11</span><br>PING 172.18.0.11 (172.18.0.11) 56(84) bytes of data.<br>64 bytes from 172.18.0.11: icmp_seq=1 ttl=64 time=0.439 ms<br>64 bytes from 172.18.0.11: icmp_seq=2 ttl=64 time=0.279 ms<br>64 bytes from 172.18.0.11: icmp_seq=3 ttl=64 time=0.419 ms<br></code></pre></td></tr></table></figure><h2 id="实践-2"><a href="#实践-2" class="headerlink" title="实践 2"></a>实践 2</h2><p>准备</p><p>两台虚拟机，三层互通。</p><p>节点 1 脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># 在节点1上执行的脚本</span><br><br><span class="hljs-comment"># 配置信息</span><br>NODE1_IP=<span class="hljs-string">&quot;198.19.249.53&quot;</span> <span class="hljs-comment"># 改成你虚拟机的出网卡的 IP</span><br>NODE2_IP=<span class="hljs-string">&quot;198.19.249.129&quot;</span> <span class="hljs-comment"># 同上</span><br>NODE1_CONTAINER_CIDR=<span class="hljs-string">&quot;10.244.1.0/24&quot;</span><br>NODE2_CONTAINER_CIDR=<span class="hljs-string">&quot;10.244.2.0/24&quot;</span><br>VXLAN_ID=1<br>VXLAN_PORT=8472<br>VXLAN_DEVICE=<span class="hljs-string">&quot;flannel.1&quot;</span><br><br><span class="hljs-comment"># 确保加载必要的内核模块</span><br>modprobe vxlan<br>modprobe br_netfilter<br><br><span class="hljs-comment"># 启用IP转发</span><br><span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward<br><span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/net/bridge/bridge-nf-call-iptables<br><br><span class="hljs-comment"># 创建VXLAN设备</span><br>ip <span class="hljs-built_in">link</span> add <span class="hljs-variable">$VXLAN_DEVICE</span> <span class="hljs-built_in">type</span> vxlan \<br>    <span class="hljs-built_in">id</span> <span class="hljs-variable">$VXLAN_ID</span> \<br>    dev eth0 \<br>    <span class="hljs-built_in">local</span> <span class="hljs-variable">$NODE1_IP</span> \<br>    dstport <span class="hljs-variable">$VXLAN_PORT</span> \<br>    nolearning<br><br><span class="hljs-comment"># 配置VXLAN设备</span><br>ip addr add 10.244.1.0/32 dev <span class="hljs-variable">$VXLAN_DEVICE</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> <span class="hljs-variable">$VXLAN_DEVICE</span> up<br><br><span class="hljs-comment"># 添加FDB条目（转发数据库）</span><br>bridge fdb append 00:00:00:00:00:00 dev <span class="hljs-variable">$VXLAN_DEVICE</span> dst <span class="hljs-variable">$NODE2_IP</span><br><br><span class="hljs-comment"># 添加路由</span><br>ip route add <span class="hljs-variable">$NODE2_CONTAINER_CIDR</span> via 10.244.2.0 dev <span class="hljs-variable">$VXLAN_DEVICE</span> onlink<br><br><span class="hljs-comment"># 创建模拟容器网络命名空间</span><br>ip netns add container1<br>ip <span class="hljs-built_in">link</span> add veth1 <span class="hljs-built_in">type</span> veth peer name veth1c<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1c netns container1<br>ip netns <span class="hljs-built_in">exec</span> container1 ip addr add 10.244.1.2/24 dev veth1c<br>ip netns <span class="hljs-built_in">exec</span> container1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1c up<br>ip netns <span class="hljs-built_in">exec</span> container1 ip route add default via 10.244.1.1<br><br><span class="hljs-comment"># 创建网桥并连接veth</span><br>ip <span class="hljs-built_in">link</span> add cni0 <span class="hljs-built_in">type</span> bridge<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> cni0 up<br>ip addr add 10.244.1.1/24 dev cni0<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 up<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 master cni0<br><br><span class="hljs-comment"># 添加从容器到外部网络的路由</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ip route add 10.244.0.0/16 via 10.244.1.1<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;节点1配置完成&quot;</span><br></code></pre></td></tr></table></figure><p>节点 2 脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># 在节点2上执行的脚本</span><br><br><span class="hljs-comment"># 配置信息</span><br>NODE1_IP=<span class="hljs-string">&quot;198.19.249.53&quot;</span> <span class="hljs-comment"># 改成你虚拟机的出网卡的 IP</span><br>NODE2_IP=<span class="hljs-string">&quot;198.19.249.129&quot;</span> <span class="hljs-comment"># 同上</span><br>NODE1_CONTAINER_CIDR=<span class="hljs-string">&quot;10.244.1.0/24&quot;</span><br>NODE2_CONTAINER_CIDR=<span class="hljs-string">&quot;10.244.2.0/24&quot;</span><br>VXLAN_ID=1<br>VXLAN_PORT=8472<br>VXLAN_DEVICE=<span class="hljs-string">&quot;flannel.1&quot;</span><br><br><span class="hljs-comment"># 确保加载必要的内核模块</span><br>modprobe vxlan<br>modprobe br_netfilter<br><br><span class="hljs-comment"># 启用IP转发</span><br><span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward<br><span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/net/bridge/bridge-nf-call-iptables<br><br><span class="hljs-comment"># 创建VXLAN设备</span><br>ip <span class="hljs-built_in">link</span> add <span class="hljs-variable">$VXLAN_DEVICE</span> <span class="hljs-built_in">type</span> vxlan \<br>    <span class="hljs-built_in">id</span> <span class="hljs-variable">$VXLAN_ID</span> \<br>    dev eth0 \<br>    <span class="hljs-built_in">local</span> <span class="hljs-variable">$NODE2_IP</span> \<br>    dstport <span class="hljs-variable">$VXLAN_PORT</span> \<br>    nolearning<br><br><span class="hljs-comment"># 配置VXLAN设备</span><br>ip addr add 10.244.2.0/32 dev <span class="hljs-variable">$VXLAN_DEVICE</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> <span class="hljs-variable">$VXLAN_DEVICE</span> up<br><br><span class="hljs-comment"># 添加FDB条目（转发数据库）</span><br>bridge fdb append 00:00:00:00:00:00 dev <span class="hljs-variable">$VXLAN_DEVICE</span> dst <span class="hljs-variable">$NODE1_IP</span><br><br><span class="hljs-comment"># 添加路由</span><br>ip route add <span class="hljs-variable">$NODE1_CONTAINER_CIDR</span> via 10.244.1.0 dev <span class="hljs-variable">$VXLAN_DEVICE</span> onlink<br><br><span class="hljs-comment"># 创建模拟容器网络命名空间</span><br>ip netns add container2<br>ip <span class="hljs-built_in">link</span> add veth2 <span class="hljs-built_in">type</span> veth peer name veth2c<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2c netns container2<br>ip netns <span class="hljs-built_in">exec</span> container2 ip addr add 10.244.2.2/24 dev veth2c<br>ip netns <span class="hljs-built_in">exec</span> container2 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2c up<br>ip netns <span class="hljs-built_in">exec</span> container2 ip route add default via 10.244.2.1<br><br><span class="hljs-comment"># 创建网桥并连接veth</span><br>ip <span class="hljs-built_in">link</span> add cni0 <span class="hljs-built_in">type</span> bridge<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> cni0 up<br>ip addr add 10.244.2.1/24 dev cni0<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2 up<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2 master cni0<br><br><span class="hljs-comment"># 添加从容器到外部网络的路由</span><br>ip netns <span class="hljs-built_in">exec</span> container2 ip route add 10.244.0.0/16 via 10.244.2.1<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;节点2配置完成&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>k8s</tag>
      
      <tag>k8s网络</tag>
      
      <tag>needSyncToBlog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flannel 部署实践（kind）</title>
    <link href="/2025/03/03/flannel%20%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5%EF%BC%88kind%EF%BC%89/"/>
    <url>/2025/03/03/flannel%20%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5%EF%BC%88kind%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>集群 yaml 如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># cluster.yaml</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Cluster</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kind.x-k8s.io/v1alpha4</span><br><span class="hljs-attr">networking:</span><br>  <span class="hljs-attr">disableDefaultCNI:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 禁用默认的 CNI</span><br>  <span class="hljs-attr">podSubnet:</span> <span class="hljs-string">&quot;10.244.0.0/16&quot;</span>  <span class="hljs-comment"># Flannel 默认使用的网段</span><br><span class="hljs-attr">nodes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">control-plane</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">worker</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">worker</span><br></code></pre></td></tr></table></figure><p>创建集群：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kind create cluster --name flanneltest --config kind-without-cni-config.yaml<br></code></pre></td></tr></table></figure><p>启动以后，会发现 Node 全部处于 NotReady 状态，报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">KubeletNotReady              container runtime network not ready: NetworkReady=false reason:NetworkPluginNotReady message:Network plugin returns error: cni plugin not initialized<br></code></pre></td></tr></table></figure><p>而且你还会发现一些 Pod 也异常了，当然，CNI 还没安装，它们拿不到 IP，节点也全部处于 NotReady 状态，无法被调度。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">k get po -A -owide<br>NAMESPACE            NAME                                                READY   STATUS    RESTARTS   AGE   IP              NODE                        NOMINATED NODE   READINESS GATES<br>kube-system          coredns-565d847f94-57qhk                            0/1     Pending   0          17m   &lt;none&gt;          &lt;none&gt;                      &lt;none&gt;           &lt;none&gt;<br>kube-system          coredns-565d847f94-8nvpw                            0/1     Pending   0          17m   &lt;none&gt;          &lt;none&gt;                      &lt;none&gt;           &lt;none&gt;<br>kube-system          etcd-flanneltest-control-plane                      1/1     Running   0          17m   192.168.247.6   flanneltest-control-plane   &lt;none&gt;           &lt;none&gt;<br>kube-system          kube-apiserver-flanneltest-control-plane            1/1     Running   0          17m   192.168.247.6   flanneltest-control-plane   &lt;none&gt;           &lt;none&gt;<br>kube-system          kube-controller-manager-flanneltest-control-plane   1/1     Running   0          17m   192.168.247.6   flanneltest-control-plane   &lt;none&gt;           &lt;none&gt;<br>kube-system          kube-proxy-5kts9                                    1/1     Running   0          17m   192.168.247.8   flanneltest-worker          &lt;none&gt;           &lt;none&gt;<br>kube-system          kube-proxy-95mtz                                    1/1     Running   0          17m   192.168.247.7   flanneltest-worker2         &lt;none&gt;           &lt;none&gt;<br>kube-system          kube-proxy-mkxkh                                    1/1     Running   0          17m   192.168.247.6   flanneltest-control-plane   &lt;none&gt;           &lt;none&gt;<br>kube-system          kube-scheduler-flanneltest-control-plane            1/1     Running   0          17m   192.168.247.6   flanneltest-control-plane   &lt;none&gt;           &lt;none&gt;<br>local-path-storage   local-path-provisioner-684f458cdd-n8qdj             0/1     Pending   0          17m   &lt;none&gt;          &lt;none&gt;                      &lt;none&gt;           &lt;none&gt;<br></code></pre></td></tr></table></figure><p>但是为什么有些 Pod 拿到 IP 了并且处于 Running 状态？</p><p>因为它们是 <strong>静态 Pod</strong>，关于此，参考 [[静态 Pod]]</p><p>执行 yaml：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml<br></code></pre></td></tr></table></figure><p>执行完后，发现 Node 都变成 Ready 了，但是 Pod 卡在创建状态，查看事件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Warning  FailedCreatePodSandBox  4m30s                  kubelet            Failed to create pod sandbox: rpc error: code = Unknown desc = failed to setup network <span class="hljs-keyword">for</span> sandbox <span class="hljs-string">&quot;f7711fed8f024a3b5562ce244a567e1ed77bbcecb73ce5a0a0ececab6916b062&quot;</span>: plugin <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;flannel&quot;</span> failed (add): failed to delegate add: failed to find plugin <span class="hljs-string">&quot;bridge&quot;</span> <span class="hljs-keyword">in</span> path [/opt/cni/bin]<br></code></pre></td></tr></table></figure><p>看报错是节点的 cni 目录缺少 <code>bridge</code> 这个二进制文件。</p><p>这个文件似乎是由 <a href="https://github.com/containernetworking/plugins">containernetworking&#x2F;plugins</a> 提供的，flannel 只提供它本身的二进制可执行文件 flannel。</p><p>写了一个脚本，来为 Kind 的每个节点安装标准网络插件，你需要按需修改前三个变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置 CNI 插件版本和架构</span><br>CNI_VERSION=<span class="hljs-string">&quot;v1.6.2&quot;</span>  <span class="hljs-comment"># 您可以根据需要更改版本</span><br>CNI_ARCH=<span class="hljs-string">&quot;arm64&quot;</span>      <span class="hljs-comment"># 根据您的系统架构选择</span><br>KIND_CLUSTER_CONTEXT=<span class="hljs-string">&quot;flanneltest&quot;</span><br><br><span class="hljs-comment"># 下载 CNI 插件</span><br>url=<span class="hljs-string">&quot;https://github.com/containernetworking/plugins/releases/download/<span class="hljs-variable">$&#123;CNI_VERSION&#125;</span>/cni-plugins-linux-<span class="hljs-variable">$&#123;CNI_ARCH&#125;</span>-<span class="hljs-variable">$&#123;CNI_VERSION&#125;</span>.tgz&quot;</span> <br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;下载地址：<span class="hljs-variable">$&#123;url&#125;</span>&quot;</span><br><br>curl -L <span class="hljs-variable">$&#123;url&#125;</span> -o cni-plugins.tgz<br><br><span class="hljs-comment"># 获取节点列表</span><br><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$KIND_CLUSTER_CONTEXT</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    NODES=$(kind get nodes -n <span class="hljs-variable">$KIND_CLUSTER_CONTEXT</span>)<br><span class="hljs-keyword">else</span><br>    NODES=$(kind get nodes)<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 安装 CNI 插件到每个节点</span><br><span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> <span class="hljs-variable">$NODES</span>; <span class="hljs-keyword">do</span><br>    docker <span class="hljs-built_in">cp</span> cni-plugins.tgz <span class="hljs-variable">$&#123;node&#125;</span>:/<br>    docker <span class="hljs-built_in">exec</span> <span class="hljs-variable">$&#123;node&#125;</span> <span class="hljs-built_in">mkdir</span> -p /opt/cni/bin<br>    docker <span class="hljs-built_in">exec</span> <span class="hljs-variable">$&#123;node&#125;</span> tar -xzf /cni-plugins.tgz -C /opt/cni/bin<br><span class="hljs-keyword">done</span><br><br><span class="hljs-comment"># 清理临时文件</span><br><span class="hljs-built_in">rm</span> cni-plugins.tgz<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;清理完成&quot;</span><br><br></code></pre></td></tr></table></figure><p>执行完成后，每个节点的 &#x2F;opt&#x2F;cni&#x2F;bin 目录如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">ls</span><br>LICENSE    bridge  firewall     host-local  macvlan  sbr     tuning<br>README.md  dhcp    flannel      ipvlan      portmap  static  vlan<br>bandwidth  dummy   host-device  loopback    ptp      tap     vrf<br></code></pre></td></tr></table></figure><p>现在再看看，发现之前的 Pod 都已经成功运行了，也都分配到了 IP。</p><p>测试一下跨节点 Pod 的通信：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">k create deploy nginx --image=nginx --replicas=3<br></code></pre></td></tr></table></figure><p>懒得写了，反正没有问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>k8s</tag>
      
      <tag>k8s网络</tag>
      
      <tag>needSyncToBlog</tag>
      
      <tag>Flannel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flannel VXLAN 流程</title>
    <link href="/2025/03/02/Flannel%20VXLAN%20%E6%B5%81%E7%A8%8B/"/>
    <url>/2025/03/02/Flannel%20VXLAN%20%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><del><a href="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250302213305.png">image.png</a></del></p><p>直接参考这张图也可以</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250316000302.png" alt="image.png"></p><p><del>假设现在位于 <code>Node1</code> 的 <code>container-1</code> 想要和位于 <code>Node2</code> 的 <code>container-2</code> 进行通信（图中有颜色的线）。</del></p><p>下面是我自己总结的，</p><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><ul><li><p>Worker1：</p><ul><li>节点 IP 192.168.247.8，podCIDR: 10.244.1.0&#x2F;24</li></ul></li><li><p>Worker2：</p><ul><li>节点 IP 192.168.247.7，podCIDR: 10.244.2.0&#x2F;24</li></ul></li><li><p>container-1：运行在 Node1，eth0 10.244.1.4&#x2F;24</p></li><li><p>container-2：运行在 Node2，eth0 10.244.2.5&#x2F;24</p></li><li><p>flannel.1 in Node1：IP 10.244.1.0&#x2F;32</p></li><li><p>flannel.1 in Node2：IP 10.244.2.0&#x2F;32</p></li></ul><p>现在，在 container-2 中 curl container-1 的 IP 10.244.1.4。</p><p>流程如下：</p><h2 id="Flannel-VXLAN-数据包转发详细流程"><a href="#Flannel-VXLAN-数据包转发详细流程" class="headerlink" title="Flannel VXLAN 数据包转发详细流程"></a>Flannel VXLAN 数据包转发详细流程</h2><h3 id="container-gt-cni0"><a href="#container-gt-cni0" class="headerlink" title="container -&gt; cni0"></a>container -&gt; cni0</h3><p>container-2 的 eth0 准备发出，它开始构建报文，其中目标 IP 是目标容器 IP 10.244.1.4，然后它查找路由表，看对应目标 IP 的路由规则：</p><p>在 container-2 中执行 <code>ip r</code> 查看：</p><p><code>10.244.0.0/16 via 10.244.2.1 dev eth0</code></p><p>得知下一跳是 10.244.2.1，由 eth0 发出，这代表源 IP，源 MAC 是 eth0 的，而目标 MAC 是 10.244.2.1 设备对应的 MAC。</p><p>可以在容器的宿主机 Node2 上看一下这是什么设备：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">cni0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether da:23:59:ec:67:b8 brd ff:ff:ff:ff:ff:ff<br>    inet 10.244.2.1/24 brd 10.244.2.255 scope global cni0<br></code></pre></td></tr></table></figure><p>正是 cni0 网桥。</p><p>然后就可以通过 ARP 来获取 cni0 的 MAC 地址，最终报文构建完成，发送给 cni0。</p><p>PS：可以在容器内执行 <code>tcpdump -i eth0 -nn -e</code>，通过抓包查看流程。</p><p>抓包分析：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250306142338.png" alt="image.png"></p><blockquote><p>[!error]</p><p>因为重启，导致实验用的 Pod IP 发生了变化，所以抓包里的一些数据和文字记录的有出入，但是不关键，主要是为了了解报文里字段的结构</p></blockquote><h3 id="cni0-gt-flannel-1"><a href="#cni0-gt-flannel-1" class="headerlink" title="cni0 -&gt; flannel.1"></a>cni0 -&gt; flannel.1</h3><p>cni0 收到包后，查询路由表，发现匹配的是这条规则：</p><p><code>10.244.1.0/24 via 10.244.1.0 dev flannel.1 onlink</code></p><p>它会由 flannel.1 发出，下一跳地址是 10.244.1.0。 这个地址正是 Node1 上 flannel.1 的地址。</p><p>所以 cni0 会：</p><p>获取 10.244.1.0 的 MAC 地址（通过ARP）</p><p>在 ARP 表中已经存在对应的记录了，该记录由 flanneld 维护。</p><blockquote><p>[!info] 🤔<br>问题：为什么要由 flanneld 维护？如果不维护，通过自学习可以吗？</p><p>不可以，Overlay 网络同一个网段可能在物理上是分布在不同的二层，ARP 请求无法正常工作，无法填充 ARP 表。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip neigh<br><br>10.244.1.0 dev flannel.1 lladdr 5a:9b:51:5a:29:be PERMANENT<br></code></pre></td></tr></table></figure><p>重新构建报文的二层，源 MAC 是 Node2 上 flannel.1 的 MAC，因为根据路由表，它将通过 flannel.1 发送。</p><p>而目标 MAC 就是上面我们通过 ARP 查出来的 10.244.1.0的 MAC，也就是 Node1 上的 flannel.1 的 MAC 地址。</p><blockquote><p>[!info]<br>PS：Linux 网桥有三层的功能，所以可以通过路由表转发</p><p>来自 Claude 3.5-Sonnect</p><p>当 cni0 收到包时：</p><ol><li><p>检查目标 MAC</p></li><li><p>如果是自己的 MAC：</p><ul><li>不做二层转发</li><li>将包交给 Linux 网络协议栈处理</li><li>这就是”上送到三层处理”</li></ul></li><li><p>如果不是自己的 MAC：</p><ul><li>进行二层转发</li><li>查找 FDB 表</li><li>转发到对应端口</li></ul></li></ol></blockquote><p>没抓到 cni0 发给 flannel.1 的包，不知道为啥，问 GPT 说是直接在内核处理了，所以不会构建包，不知道对不对。</p><h3 id="Node2-flannel-1-gt-Node1-flannel-1"><a href="#Node2-flannel-1-gt-Node1-flannel-1" class="headerlink" title="Node2 flannel.1 -&gt; Node1 flannel.1"></a>Node2 flannel.1 -&gt; Node1 flannel.1</h3><p>数据包通过 cni0 到达 Node2 上的 flannel.1，接下来，它开始进行封包操作，首先在已有的报文前面添加一个 VXLAN header（VNI 是创建 VXLAN 时指定的），然后把这整个包作为传输层的 payload，放到一个 UDP 报文中。</p><p>接下来需要构建三层和二层报文。这个包最终要发给的是 Node1 上的 flannel.1，也就是“隧道”的出口，所以对于三层而言，它的 Dst IP 应该是 Node1 的 IP，而二层的 Dst MAC 自然就是 Node1 的 MAC 了，这样这个报文就会发送到 Node1 上。</p><p>但是如何拿到 Node1 的 IP 呢？通过 FDB 表可以，这张表里面记录了 MAC 对应的 IP 地址。FDB 表由 Flanneld 进行维护。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">bridge fdb show<br>5a:9b:51:5a:29:be dev flannel.1 dst 192.168.247.8 self permanent<br></code></pre></td></tr></table></figure><p>因为 Node2 和 Node1 是通的，所以它们的二层 MAC 自然也是维护好的，直接通过 ARP 拿到即可。</p><p>flannel 收到的报文如下：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250306143941.png" alt="image.png"></p><p>然后 flannel.1 会进行封包操作，最后由 Node1 的 eth0 发出。</p><p>通过抓包 Node2 上的 eth0 分析一下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tcpdump -i eth0 -nn -vv -X <span class="hljs-string">&#x27;host 192.168.247.8&#x27;</span> -w vxlan.pcap<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250306135547.png" alt="image.png"></p><p>内层即原始报文，外层是 flannel.1 封装的外层报文。外层报文用于将包发送给 Node1，然后 Node1 上的 flannel.1 收到后，会拆出内部的原始报文，最终让数据流转到 Node1 的 container 上。</p><h3 id="Node1-eth0-收到包"><a href="#Node1-eth0-收到包" class="headerlink" title="Node1 eth0 收到包"></a>Node1 eth0 收到包</h3><p>抓包看一下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tcpdump -i eth0 -nn -vv -X <span class="hljs-string">&#x27;host 192.168.247.8&#x27;</span> -w node1_eth0.pcap<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250306150158.png" alt="image.png"></p><p>抓包 Node1 上的 flannel.1 看一下：</p><p>分别看一下收到的包和发出的包。</p><p>收到的包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tcpdump -i flannel.1 -nn -vv -X <span class="hljs-string">&#x27;host 10.244.1.5&#x27;</span> -Q <span class="hljs-keyword">in</span> -w node1_flannel1_in.pcap<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250306151811.png" alt="image.png"></p><p>可以看到收到的已经是内部的原始包了，所以拆包操作实际发生在系统内核，而不是由 flannel.1 来完成。内核会根据包中的 VNI，将其发送到对应的 VTEP 设备。（疑问：那内层包的 MAC 地址还有啥用呢？内核直接根据 VNI 发送到对应的 VTEP 了，难道仅仅是为了做个校验吗？校验包的目标 MAC 必须和自身的 MAC 相同？）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>vtep 如何知道对方 vtep 的 IP？</strong></p><p>由 Flanneld 维护路由表，在路由表的 via 中指定了对端 vtep 的 IP。比如：<code>ip route add $NODE2_CONTAINER_CIDR via 10.244.2.0 dev $VXLAN_DEVICE onlink</code>，10.244.2.0 就是对端 vtep 的 IP。</p><p><strong>vtep 如何知道对方 vtep 的 MAC？</strong></p><p>上个问题说明了如何拿到 IP，而根据 IP 拿到 MAC 自然由 ARP 来解决。Flanneld 会维护 ARP 表，可以直接拿到 MAC 地址。</p><p><strong>FDB 表的作用</strong></p><p>通过目标 MAC 拿到目标 VTEP 设备所在节点的 IP，这样才能把包发出去。</p><p>所以综上：</p><p>VTEP 设备要想和另一个 VTEP 设备组成隧道，需要知道两个东西：<strong>对端 VTEP 的 MAC 地址</strong>，用于填充内部包的二层目的 MAC；<strong>对端 VTEP 所在节点的 IP</strong>，用于填充外部包的三层目的 IP。</p><p>要拿到 MAC，首先需要知道 VTEP 的 IP，这个 IP 由 flannel 写入到路由表的 via。知道了 IP 就可以通过 ARP 表拿到对应的 MAC，ARP 同样由 Flannel 写入。最后可以通过 VTEP 的 MAC，从 FDB 表中拿到对方所在节点的 IP，这个同样由 Flannel 维护。</p><p><del>&#x2F;&#x2F; 以下废弃</del></p><p><del>按照上图来说，匹配的路由规则应该会指示下一跳为 <code>10.1.16.0</code>。然后通过 ARP，发现 ARP 表中有一条 <code>10.1.16.0 dev flannel.1 lladdr 5a:9b:51:5a:29:be PERMANENT</code>，发现对应的 MAC 地址是 flannel.1 的，那么就用这个地址作为目标 MAC 地址。</del></p><p><del>然后这个包到达网桥。网桥根据报文的目标 MAC 地址，查找 FDB 表，看具体要转发给它连接的哪个设备，按照规则，应该会转发到 VETP，也就是 flannel.1。</del></p><p><del>flannel.1 拿到包后，它去掉其中的二层，因为接下来，这个包要发给的是对端的 flannel.1，所以需要填上它的 MAC 地址。这个 MAC 地址</del></p><p><del>接下来需要构建三层和二层。</del></p><ol><li><del>首先 <code>Container1</code> 构建报文的 <strong>数据部分</strong> 和 <strong>内部 IP 报头</strong>（ Dst IP 就是 Container2 的 IP，即目标容器的 IP）。</del></li><li><del>接着需要构建 <strong>内部以太网报头</strong> ，根据流程图所示，这个报文期望发送到 <code>Node2</code> 的 <code>flannel.1</code> 设备，通过 ARP 可以拿到对应的 Mac 地址。</del></li><li><del>接着构建 <strong>VXLAN Header</strong>，这里指定了 <strong>VNI</strong>，即虚拟子网的标号。</del></li><li><del>最后把上面所有部分作为一个 UDP Data，然后加上一个 UDP Header，至此，一个报文的传输层部分就构建完成了。</del></li><li><del>然后就是报文剩余的网络层和数据链路层了，网络层 IP Header 就是 Node2 eth0 的 IP，Mac 也是 eth0 的 Mac。</del></li><li><del>然后这个报文发送到了 Node2 的 eth0，Node2 内核检查该报文，发现里面有 VXLAN Header，于是就拿到里面的 VNI，然后解析出这个报文内部的报文，将这个报文发送到本节点对应 VNI 的 VETP 设备（flannel.1）。</del></li><li><del>flannel.1 进行拆包，拿到包裹在报文内部的原始报文，最终发给 docker0，然后再由 docker0 发给 container-2</del></li></ol><h2 id="VXLAN-的概念"><a href="#VXLAN-的概念" class="headerlink" title="VXLAN 的概念"></a><del>VXLAN 的概念</del></h2><p><del>看这里 [[Prog&#x2F;Network&#x2F;VXLAN&#x2F;Sample|Sample]]</del></p><p><del>VTEP 设备由 Flanneld 进行创建。</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>k8s</tag>
      
      <tag>k8s网络</tag>
      
      <tag>needSyncToBlog</tag>
      
      <tag>Flannel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flannel Host-gw</title>
    <link href="/2025/02/24/Flannel%20Host-gw/"/>
    <url>/2025/02/24/Flannel%20Host-gw/</url>
    
    <content type="html"><![CDATA[<h2 id="大致原理"><a href="#大致原理" class="headerlink" title="大致原理"></a>大致原理</h2><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250224105310.png" alt="image.png"></p><p>以上图为例：</p><p>这张图展示了 Flannel 的 host-gw 模式下两个节点间的网络通信原理：</p><ol><li>网络拓扑结构：</li></ol><ul><li><p>左边是 Node 1，右边是 Node 2</p></li><li><p>每个节点都有两个网络接口：</p></li><li><p>eth0：用于节点间通信的物理网卡</p></li><li><p>cni0：容器网络的网桥接口</p></li></ul><ol start="2"><li>IP 分配情况：</li></ol><ul><li><p>Node 1 的容器子网是 10.244.0.0&#x2F;24</p></li><li><p>Node 2 的容器子网是 10.244.1.0&#x2F;24</p></li><li><p>物理网络使用 10.168.0.0&#x2F;24 网段</p></li></ul><ol start="3"><li>路由表分析</li></ol><p>首先这两个节点是通的，所以路由表里肯定已经配好了对应的路由（比如上图中的 <code>10.168.0.0/24 dev eth0 proto kernel scope link src 192.168.0.2</code> 这一条。</p><p>然后是 <code>10.244.1.0/24 dev cni0 proto kernel scope link src 10.244.0.1</code> 这一条，它用于同一个节点下的容器之间的通信。</p><p>剩下的一条 <code>10.244.1.0/24 via 10.168.0.3 dev eth0</code>，就是用于跨节点通信的，它直接把目标容器所在节点作为网关，即 <code>10.168.0.3</code>，所以首先这个报文会通过本节点 <code>10.168.0.2</code> 的 eth0 发送到 <code>10.168.0.3</code> 的 eth0（对应前文提到的第一条路由），然后到了 <code>10.168.0.3</code> 后，再匹配到该节点对应的 <code>10.244.1.0/24 dev cni0 proto kernel scope link src 10.244.0.1</code> 这一条，发送到 cni0 设备。cni0 设备实际是一个网桥，连接了本节点所有的容器，所以它会继续将报文发送给对应的容器。</p><p>上面这一条路由就是由 Flannel 写入的。</p><h2 id="Flannel-处理流程"><a href="#Flannel-处理流程" class="headerlink" title="Flannel 处理流程"></a>Flannel 处理流程</h2><p>Host-gw 模式比较简单，Flannel 启动时会存储每个节点的 subnet 信息，以 k8s Annotation 方式为例，它会在每个节点的 Annotation 存储出网网卡 IP 以及 PodCIDR，然后运行一个 Node Informer 做 ListAndWatch，拿到 <strong>除自身外的</strong> 节点的 IP 和 PodCIDR，然后添加路由表即可，格式：<code>&#123;&#123; PodCIDR &#125;&#125; via &#123;&#123; NodeIP &#125;&#125;</code>。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">routeAdd</span><span class="hljs-params">(route *netlink.Route, ipFamily <span class="hljs-type">int</span>, addToRouteList, removeFromRouteList <span class="hljs-keyword">func</span>(netlink.Route)</span></span>) &#123;<br><span class="hljs-comment">// 1. 首先将路由添加到内部路由列表</span><br>addToRouteList(*route)<br><span class="hljs-comment">// Check if route exists before attempting to add it</span><br><span class="hljs-comment">// 根据 dst 过滤查询</span><br>routeList, err := netlink.RouteListFiltered(ipFamily, &amp;netlink.Route&#123;Dst: route.Dst&#125;, netlink.RT_FILTER_DST)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Warningf(<span class="hljs-string">&quot;Unable to list routes: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 2. 检查是否已存在相同目标的路由</span><br><span class="hljs-comment">// 这里为啥只检查第一条？不可能存在多条相同目标的路由吗？</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(routeList) &gt; <span class="hljs-number">0</span> &amp;&amp; !routeEqual(routeList[<span class="hljs-number">0</span>], *route) &#123;<br><span class="hljs-comment">// 如果存在路由但网关或链路索引不同，则删除旧路由</span><br><span class="hljs-comment">// Same Dst different Gw or different link index. Remove it, correct route will be added below.</span><br>log.Warningf(<span class="hljs-string">&quot;Replacing existing route to %v with %v&quot;</span>, routeList[<span class="hljs-number">0</span>], route)<br><span class="hljs-keyword">if</span> err := netlink.RouteDel(&amp;routeList[<span class="hljs-number">0</span>]); err != <span class="hljs-literal">nil</span> &#123;<br>log.Errorf(<span class="hljs-string">&quot;Effor deleteing route to %v: %v&quot;</span>, routeList[<span class="hljs-number">0</span>].Dst, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>removeFromRouteList(routeList[<span class="hljs-number">0</span>])<br>&#125;<br>routeList, err = netlink.RouteListFiltered(ipFamily, &amp;netlink.Route&#123;Dst: route.Dst&#125;, netlink.RT_FILTER_DST)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Warningf(<span class="hljs-string">&quot;Unable to list routes: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 3. 添加新路由</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(routeList) &gt; <span class="hljs-number">0</span> &amp;&amp; routeEqual(routeList[<span class="hljs-number">0</span>], *route) &#123;<br><span class="hljs-comment">// 如果完全相同的路由已存在，跳过添加</span><br><span class="hljs-comment">// Same Dst and same Gw, keep it and do not attempt to add it.</span><br>log.Infof(<span class="hljs-string">&quot;Route to %v already exists, skipping.&quot;</span>, route)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> err := netlink.RouteAdd(route); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 否则添加新路由</span><br>log.Errorf(<span class="hljs-string">&quot;Error adding route to %v: %s&quot;</span>, route, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>_, err = netlink.RouteListFiltered(ipFamily, &amp;netlink.Route&#123;Dst: route.Dst&#125;, netlink.RT_FILTER_DST)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Warningf(<span class="hljs-string">&quot;Unable to list routes: %v&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *RouteNetwork)</span></span> handleSubnetEvents(batch []subnet.Event) &#123;<br><span class="hljs-keyword">for</span> _, evt := <span class="hljs-keyword">range</span> batch &#123;<br><span class="hljs-keyword">switch</span> evt.Type &#123;<br><span class="hljs-keyword">case</span> subnet.EventAdded:<br><span class="hljs-keyword">if</span> evt.Lease.Attrs.BackendType != n.BackendType &#123;<br>log.Warningf(<span class="hljs-string">&quot;Ignoring non-%v subnet: type=%v&quot;</span>, n.BackendType, evt.Lease.Attrs.BackendType)<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-keyword">if</span> evt.Lease.EnableIPv4 &#123;<br>log.Infof(<span class="hljs-string">&quot;Subnet added: %v via %v&quot;</span>, evt.Lease.Subnet, evt.Lease.Attrs.PublicIP)<br><br><span class="hljs-comment">// 实际的实现</span><br><span class="hljs-comment">// n.GetRoute = func(lease *subnet.Lease) *netlink.Route &#123;</span><br><span class="hljs-comment">// return &amp;netlink.Route&#123;</span><br><span class="hljs-comment">// Dst:       lease.Subnet.ToIPNet(),</span><br><span class="hljs-comment">// Gw:        lease.Attrs.PublicIP.ToIP(),</span><br><span class="hljs-comment">// LinkIndex: n.LinkIndex,</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// &#125;</span><br>route := n.GetRoute(&amp;evt.Lease)<br>routeAdd(route, netlink.FAMILY_V4, n.addToRouteList, n.removeFromV4RouteList)<br>&#125;<br><br><span class="hljs-keyword">if</span> evt.Lease.EnableIPv6 &#123;<br>log.Infof(<span class="hljs-string">&quot;Subnet added: %v via %v&quot;</span>, evt.Lease.IPv6Subnet, evt.Lease.Attrs.PublicIPv6)<br><br>route := n.GetV6Route(&amp;evt.Lease)<br>routeAdd(route, netlink.FAMILY_V6, n.addToV6RouteList, n.removeFromV6RouteList)<br>&#125;<br><br><span class="hljs-keyword">case</span> subnet.EventRemoved:<br><span class="hljs-keyword">if</span> evt.Lease.Attrs.BackendType != n.BackendType &#123;<br>log.Warningf(<span class="hljs-string">&quot;Ignoring non-%v subnet: type=%v&quot;</span>, n.BackendType, evt.Lease.Attrs.BackendType)<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-keyword">if</span> evt.Lease.EnableIPv4 &#123;<br>log.Info(<span class="hljs-string">&quot;Subnet removed: &quot;</span>, evt.Lease.Subnet)<br><br>route := n.GetRoute(&amp;evt.Lease)<br><span class="hljs-comment">// Always remove the route from the route list.</span><br>n.removeFromV4RouteList(*route)<br><br><span class="hljs-keyword">if</span> err := netlink.RouteDel(route); err != <span class="hljs-literal">nil</span> &#123;<br>log.Errorf(<span class="hljs-string">&quot;Error deleting route to %v: %v&quot;</span>, evt.Lease.Subnet, err)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> evt.Lease.EnableIPv6 &#123;<br>log.Info(<span class="hljs-string">&quot;Subnet removed: &quot;</span>, evt.Lease.IPv6Subnet)<br><br>route := n.GetV6Route(&amp;evt.Lease)<br><span class="hljs-comment">// Always remove the route from the route list.</span><br>n.removeFromV6RouteList(*route)<br><br><span class="hljs-keyword">if</span> err := netlink.RouteDel(route); err != <span class="hljs-literal">nil</span> &#123;<br>log.Errorf(<span class="hljs-string">&quot;Error deleting route to %v: %v&quot;</span>, evt.Lease.IPv6Subnet, err)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">default</span>:<br>log.Error(<span class="hljs-string">&quot;Internal error: unknown event type: &quot;</span>, <span class="hljs-type">int</span>(evt.Type))<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>k8s</tag>
      
      <tag>k8s网络</tag>
      
      <tag>needSyncToBlog</tag>
      
      <tag>Flannel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K8s Service iptables 实践</title>
    <link href="/2024/11/09/K8s%20Service%20iptables%20%E5%AE%9E%E8%B7%B5/"/>
    <url>/2024/11/09/K8s%20Service%20iptables%20%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="NodePort-类型的-Service"><a href="#NodePort-类型的-Service" class="headerlink" title="NodePort 类型的 Service"></a>NodePort 类型的 Service</h2><p>创建如下 Deploy 和 Service：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>          <span class="hljs-attr">ports:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br><br><br></code></pre></td></tr></table></figure><p>看一下对应的 Serivce 和 Pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">k get svc,po -owide | grep nginx<br><br>service/nginx        NodePort    10.96.55.228   &lt;none&gt;        80:30977/TCP   3d17h   app=nginx<br>pod/nginx-86c8757776-b5mmh   1/1     Running   2 (28m ago)   3d17h   10.244.2.2   k8s-playground-worker   &lt;none&gt;           &lt;none&gt;<br></code></pre></td></tr></table></figure><p>然后去任意一个 k8s 节点，执行 <code>iptables-save -t nat | grep &#39;default/nginx&#39;</code>，查看该 Service 对应的 iptables 规则：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">-A KUBE-EXT-2CMXP7HKUVJN7L6M -m comment --comment &quot;masquerade traffic for default/nginx external destinations&quot; -j KUBE-MARK-MASQ<br>-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;default/nginx&quot; -m tcp --dport 30977 -j KUBE-EXT-2CMXP7HKUVJN7L6M<br>-A KUBE-SEP-HUXRPHBUO34UVPEF -s 10.244.2.2/32 -m comment --comment &quot;default/nginx&quot; -j KUBE-MARK-MASQ<br>-A KUBE-SEP-HUXRPHBUO34UVPEF -p tcp -m comment --comment &quot;default/nginx&quot; -m tcp -j DNAT --to-destination 10.244.2.2:80<br>-A KUBE-SERVICES -d 10.96.55.228/32 -p tcp -m comment --comment &quot;default/nginx cluster IP&quot; -m tcp --dport 80 -j KUBE-SVC-2CMXP7HKUVJN7L6M<br>-A KUBE-SVC-2CMXP7HKUVJN7L6M ! -s 10.244.0.0/16 -d 10.96.55.228/32 -p tcp -m comment --comment &quot;default/nginx cluster IP&quot; -m tcp --dport 80 -j KUBE-MARK-MASQ<br>-A KUBE-SVC-2CMXP7HKUVJN7L6M -m comment --comment &quot;default/nginx -&gt; 10.244.2.2:80&quot; -j KUBE-SEP-HUXRPHBUO34UVPEF<br>root@k8s-playground-control-plane:/# iptables-save -t nat | grep &#x27;default/nginx&#x27;<br>-A KUBE-EXT-2CMXP7HKUVJN7L6M -m comment --comment &quot;masquerade traffic for default/nginx external destinations&quot; -j KUBE-MARK-MASQ<br>-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;default/nginx&quot; -m tcp --dport 30977 -j KUBE-EXT-2CMXP7HKUVJN7L6M<br>-A KUBE-SEP-HUXRPHBUO34UVPEF -s 10.244.2.2/32 -m comment --comment &quot;default/nginx&quot; -j KUBE-MARK-MASQ<br>-A KUBE-SEP-HUXRPHBUO34UVPEF -p tcp -m comment --comment &quot;default/nginx&quot; -m tcp -j DNAT --to-destination 10.244.2.2:80<br>-A KUBE-SERVICES -d 10.96.55.228/32 -p tcp -m comment --comment &quot;default/nginx cluster IP&quot; -m tcp --dport 80 -j KUBE-SVC-2CMXP7HKUVJN7L6M<br>-A KUBE-SVC-2CMXP7HKUVJN7L6M ! -s 10.244.0.0/16 -d 10.96.55.228/32 -p tcp -m comment --comment &quot;default/nginx cluster IP&quot; -m tcp --dport 80 -j KUBE-MARK-MASQ<br>-A KUBE-SVC-2CMXP7HKUVJN7L6M -m comment --comment &quot;default/nginx -&gt; 10.244.2.2:80&quot; -j KUBE-SEP-HUXRPHBUO34UVPEF<br></code></pre></td></tr></table></figure><p><del>NodePort 类型的 Service 可以使用集群内任意一个节点 IP 进行访问，此时就又出现了两种情况：1) 直接请求 localhost，2) 请求其他节点，这两种情况下 iptables 的规则流向也是不同的。</del></p><p>假设现在的 K8s 节点 IP 是 192.168.247.4，直接在该节点上通过 localhost 请求该 Serivce，对应的 iptables 流转流程如下：</p><p>1.首先走 K8s Service 默认添加的 PREROUTING 规则：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">-A PREROUTING -m <span class="hljs-built_in">comment</span> --<span class="hljs-built_in">comment</span> <span class="hljs-string">&quot;kubernetes service portals&quot;</span> -j KUBE-SERVICES<br></code></pre></td></tr></table></figure><p>这代表所有的流量都会继续走 KUBE-SERVICES 链。</p><p>2.继续匹配到这条链上的这条规则，因为这条链指定了 –dst-type LOCAL。</p><blockquote><p>疑问：如果请求的 IP 是其他节点的 IP，那还会走这条规则吗？</p><p>不会，因为这条规则指定了只针对目的地址为本机的请求。那么这个包就会正常发送给对应的节点，到了那个节点以后，就可以匹配到那个节点上的这条规则了。</p></blockquote><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">-A KUBE-SERVICES -m <span class="hljs-built_in">comment</span> --<span class="hljs-built_in">comment</span> <span class="hljs-string">&quot;kubernetes service nodeports; NOTE: this must be the last rule in this chain&quot;</span> -m addrtype --dst-<span class="hljs-built_in">type</span> <span class="hljs-keyword">LOCAL</span> -j KUBE-NODEPORTS<br></code></pre></td></tr></table></figure><p><code>-m addrtype --dst-type LOCAL</code>: 使用 addrtype 模块匹配目标地址类型为本地地址的流量。</p><blockquote><p>为什么注释里说这条规则要放到最后？<br>NOTE: this must be the last rule in this chain</p></blockquote><p>3.继续走下面这条规则，通过 Comment 可以知道对应的正是我们创建的 Pod，端口是 Service 的 NodePort IP：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">-<span class="hljs-selector-tag">A</span> KUBE-NODEPORTS -<span class="hljs-selector-tag">p</span> tcp -m comment <span class="hljs-attr">--comment</span> &quot;default/nginx&quot; -m tcp <span class="hljs-attr">--dport</span> <span class="hljs-number">30977</span> -j KUBE-EXT-<span class="hljs-number">2CM</span>XP7HKUVJN7L6M<br></code></pre></td></tr></table></figure><ol start="4"><li>继续走 <code>KUBE-SVC-2CMXP7HKUVJN7L6M</code> 这条链</li></ol><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nsis">iptables-save -t nat | grep -- <span class="hljs-string">&#x27;KUBE-EXT-2CMXP7HKUVJN7L6M&#x27;</span><br><br>-A KUBE-EXT-<span class="hljs-number">2</span>CMXP7<span class="hljs-params">HKU</span>VJN7L6M -m comment --comment <span class="hljs-string">&quot;masquerade traffic for default/nginx external destinations&quot;</span> -j KUBE-MARK-MASQ<br>-A KUBE-EXT-<span class="hljs-number">2</span>CMXP7<span class="hljs-params">HKU</span>VJN7L6M -j KUBE-SVC-<span class="hljs-number">2</span>CMXP7<span class="hljs-params">HKU</span>VJN7L6M<br></code></pre></td></tr></table></figure><ol start="5"><li>继续走 <code>KUBE-SEP-KYLNC6JSBVGAD4BC</code> 这条链</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">-<span class="hljs-selector-tag">A</span> KUBE-SVC-<span class="hljs-number">2CM</span>XP7HKUVJN7L6M ! -s <span class="hljs-number">10.244</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">16</span> -d <span class="hljs-number">10.96</span>.<span class="hljs-number">55.228</span>/<span class="hljs-number">32</span> -<span class="hljs-selector-tag">p</span> tcp -m comment <span class="hljs-attr">--comment</span> &quot;default/nginx cluster IP&quot; -m tcp <span class="hljs-attr">--dport</span> <span class="hljs-number">80</span> -j KUBE-<span class="hljs-selector-tag">MARK</span>-MASQ<br>-<span class="hljs-selector-tag">A</span> KUBE-SVC-<span class="hljs-number">2CM</span>XP7HKUVJN7L6M -m comment <span class="hljs-attr">--comment</span> &quot;default/nginx -&gt; <span class="hljs-number">10.244</span>.<span class="hljs-number">2.2</span>:<span class="hljs-number">80</span><span class="hljs-string">&quot; -j KUBE-SEP-HUXRPHBUO34UVPEF</span><br></code></pre></td></tr></table></figure><ol start="6"><li>最后通过 DNAT 操作，修改报文的目的地址为 Pod 的 IP（10.244.2.2:80），因为 Deployment 的 Replicas 为 1，所以只有 1 个 Pod，因此没有负载均衡的相关操作。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">-<span class="hljs-selector-tag">A</span> KUBE-SEP-HUXRPHBUO34UVPEF -s <span class="hljs-number">10.244</span>.<span class="hljs-number">2.2</span>/<span class="hljs-number">32</span> -m comment <span class="hljs-attr">--comment</span> &quot;default/nginx&quot; -j KUBE-<span class="hljs-selector-tag">MARK</span>-MASQ<br>-<span class="hljs-selector-tag">A</span> KUBE-SEP-HUXRPHBUO34UVPEF -<span class="hljs-selector-tag">p</span> tcp -m comment <span class="hljs-attr">--comment</span> &quot;default/nginx&quot; -m tcp -j DNAT <span class="hljs-attr">--to-destination</span> <span class="hljs-number">10.244</span>.<span class="hljs-number">2.2</span>:<span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.247.4</span>:xxxx -&gt; localhost:<span class="hljs-number">30977</span><br>                      |<br>                      |  DNAT<br>                      V<br><span class="hljs-number">192.168.247.4</span>:xxxX -&gt; <span class="hljs-number">10</span>.<span class="hljs-number">244</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span>:<span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>之后会走 cni 设备对容器进行访问，比如 flannel.1，此时就需要对报文的源地址进行修改，修改为 flannel.1 设备的 IP，这样当对方回包时，才能够被 flannel.1 正常接收。（如果源地址依然为节点 IP，那对方回包时就会把目的地址设置为节点 IP，在 flannel.1 收到后会直接扔掉，因为它发现这个包的目的地址不是自己）</p><p>修改报文源地址的操作就是 SNAT，之前可以看到有很多<code>-j KUBE-MARK-MASQ</code> 的操作，正是这个操作进行 SNAT 的：</p><p>首先它会给报文打一个 0x4000 标记：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">-<span class="hljs-selector-tag">A</span> KUBE-<span class="hljs-selector-tag">MARK</span>-MASQ -j <span class="hljs-selector-tag">MARK</span> <span class="hljs-attr">--set-xmark</span> <span class="hljs-number">0</span>x4000/<span class="hljs-number">0</span>x4000<br></code></pre></td></tr></table></figure><p>然后来到 POSTROUTING 链：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">iptables-save -t nat | grep -- <span class="hljs-string">&#x27;-A POSTROUTING&#x27;</span><br>-A POSTROUTING -m comment --comment <span class="hljs-string">&quot;kubernetes postrouting rules&quot;</span> -j KUBE-POSTROUTING<br></code></pre></td></tr></table></figure><p>继续走 <code>KUBE-POSTROUTING</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">iptables-save -t nat | grep -- <span class="hljs-string">&#x27;-A KUBE-POSTROUTING&#x27;</span><br>-A KUBE-POSTROUTING -m mark ! --mark 0x4000/0x4000 -j RETURN<br>-A KUBE-POSTROUTING -j MARK --set-xmark 0x4000/0x0<br>-A KUBE-POSTROUTING -m comment --comment <span class="hljs-string">&quot;kubernetes service traffic requiring SNAT&quot;</span> -j MASQUERADE --random-fully<br></code></pre></td></tr></table></figure><p>首先是第一条，意思是如果这个包没有被打过 0x4000 标记，则跳过后续的规则，相当于只处理被打过标记的包。</p><p>第二条不知道干嘛的</p><p>第三条就是 SNAT 操作了：</p><p><code>-j MASQUERADE</code></p><p>用于进行源地址转换（SNAT），即将流量的源地址伪装成本地节点的 IP 地址。</p><p><code>--random-fully</code></p><ul><li><code>--random-fully</code> 是 <code>MASQUERADE</code> 动作的一个选项，它会对源 IP 地址的端口部分进行随机化，增加流量的不可预测性。这个选项可以帮助防止外部系统因为频繁的连接来自同一个源 IP 地址（特别是在 NAT 环境中）而做出限制。</li><li>启用 <code>--random-fully</code> 后，每个连接的源端口将随机化，以避免多个连接使用相同的端口号，从而增加负载均衡的效果和避免 IP 地址冲突。</li></ul><p>因为这个包最终会由 CNI 设备发出，所以 SNAT 会修改报文的源地址为该设备的 IP，假设为 10.244.0.0。最终整个流程如下：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.247.4</span>:xxxx -&gt; localhost:<span class="hljs-number">30977</span><br>                      |<br>                      |  DNAT<br>                      V<br><span class="hljs-number">192.168.247.4</span>:xxxX -&gt; <span class="hljs-number">10</span>.<span class="hljs-number">244</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span>:<span class="hljs-number">80</span><br>                      |<br>                      |  SNAT<br>                      V<br><span class="hljs-number">10.244.0.0</span>:xxxx -&gt; <span class="hljs-number">10</span>.<span class="hljs-number">244</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span>:<span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>service 的 ip 是一个 vip，但是为什么 ping 不通，却可以 curl 通呢？</p><p>因为 service 对应的 iptables 规则指定了 -p tcp，所以可以处理 tcp 报文，而 ping 发送的是 icmp 报文自然不会被 iptables 处理。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/94418251">IPVS从入门到精通kube-proxy实现原理</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>k8s网络</tag>
      
      <tag>needSyncToBlog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DevicePlugin 工作机制及实现</title>
    <link href="/2024/08/20/DevicePlugin%20%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/08/20/DevicePlugin%20%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="工作机制及实现"><a href="#工作机制及实现" class="headerlink" title="工作机制及实现"></a>工作机制及实现</h1><p>Device Plugin 的大致信息：</p><ul><li>Device Plugin 是一个以 unix socket 方式监听的 grpc server，它直接与节点上的 kubelet 通信。</li></ul><p>Device Plugin 的工作机制：</p><p>作为一个 grpc server，它需要实现对应的 server interface，该 interface 定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> DevicePluginServer <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// GetDevicePluginOptions returns options to be communicated with Device</span><br><span class="hljs-comment">// Manager</span><br>GetDevicePluginOptions(context.Context, *Empty) (*DevicePluginOptions, <span class="hljs-type">error</span>)<br><span class="hljs-comment">// ListAndWatch returns a stream of List of Devices</span><br><span class="hljs-comment">// Whenever a Device state change or a Device disappears, ListAndWatch</span><br><span class="hljs-comment">// returns the new list</span><br>ListAndWatch(*Empty, DevicePlugin_ListAndWatchServer) <span class="hljs-type">error</span><br><span class="hljs-comment">// GetPreferredAllocation returns a preferred set of devices to allocate</span><br><span class="hljs-comment">// from a list of available ones. The resulting preferred allocation is not</span><br><span class="hljs-comment">// guaranteed to be the allocation ultimately performed by the</span><br><span class="hljs-comment">// devicemanager. It is only designed to help the devicemanager make a more</span><br><span class="hljs-comment">// informed allocation decision when possible.</span><br>GetPreferredAllocation(context.Context, *PreferredAllocationRequest) (*PreferredAllocationResponse, <span class="hljs-type">error</span>)<br><span class="hljs-comment">// Allocate is called during container creation so that the Device</span><br><span class="hljs-comment">// Plugin can run device specific operations and instruct Kubelet</span><br><span class="hljs-comment">// of the steps to make the Device available in the container</span><br>Allocate(context.Context, *AllocateRequest) (*AllocateResponse, <span class="hljs-type">error</span>)<br><span class="hljs-comment">// PreStartContainer is called, if indicated by Device Plugin during registeration phase,</span><br><span class="hljs-comment">// before each container start. Device plugin can run device specific operations</span><br><span class="hljs-comment">// such as resetting the device before making devices available to the container</span><br>PreStartContainer(context.Context, *PreStartContainerRequest) (*PreStartContainerResponse, <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>主要关注 <code>ListAndWatch</code> 和 <code>Allocate</code> 这两个方法即可。</p><p>其中：</p><p><code>ListAndWatch</code> 负责上报本节点所拥有的设备信息给 kubelet，和 k8s 的 ListAndWatch 类似，也是先 List 拿到当前所有的设备列表，之后当有设备发生变更时，再进行增量更新。</p><p>上报的设备信息如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Device <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// A unique ID assigned by the device plugin used</span><br><span class="hljs-comment">// to identify devices during the communication</span><br><span class="hljs-comment">// Max length of this field is 63 characters</span><br>ID <span class="hljs-type">string</span> <span class="hljs-string">`protobuf:&quot;bytes,1,opt,name=ID,proto3&quot; json:&quot;ID,omitempty&quot;`</span><br><span class="hljs-comment">// Health of the device, can be healthy or unhealthy, see constants.go</span><br>Health <span class="hljs-type">string</span> <span class="hljs-string">`protobuf:&quot;bytes,2,opt,name=health,proto3&quot; json:&quot;health,omitempty&quot;`</span><br><span class="hljs-comment">// Topology for device</span><br>Topology             *TopologyInfo <span class="hljs-string">`protobuf:&quot;bytes,3,opt,name=topology,proto3&quot; json:&quot;topology,omitempty&quot;`</span><br>XXX_NoUnkeyedLiteral <span class="hljs-keyword">struct</span>&#123;&#125;      <span class="hljs-string">`json:&quot;-&quot;`</span><br>XXX_sizecache        <span class="hljs-type">int32</span>         <span class="hljs-string">`json:&quot;-&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>主要就是 <code>ID</code> 和 <code>Health</code> 这两个字段。</p><p><code>Allocate</code> </p><p>先说一下 Device Plugin 的使用方式，当我们部署好了以后，可以在 Pod 的 resources 里指定需要的设备资源数量，就和 resources.requests.memory 一样。比如我们部署了一个名为 fake.io&#x2F;gpu 的 Device Plugin，那么就可以在 yaml 中这样申请资源：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">gpu</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gpu</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">gpu</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">requests:</span><br>          <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;128Mi&quot;</span><br>          <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;500m&quot;</span><br>          <span class="hljs-attr">fake.io/gpu:</span> <span class="hljs-number">10</span><br>        <span class="hljs-attr">limits:</span><br>          <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;128Mi&quot;</span><br>          <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;500m&quot;</span><br>          <span class="hljs-attr">fake.io/gpu:</span> <span class="hljs-number">10</span><br>      <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>这代表这个 Pod 只会被调度到拥有 10 个数量的 fake.io&#x2F;gpu 设备的节点上。</p><p>当这个 Pod 调度到某个节点上时，这个节点的 kubelet 就会请求 Device Plugin 的 Allocate 方法，它请求的内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> AllocateRequest <span class="hljs-keyword">struct</span> &#123;<br>ContainerRequests    []*ContainerAllocateRequest <br><span class="hljs-comment">// ... 省略无关字段以及 tag</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ContainerAllocateRequest <span class="hljs-keyword">struct</span> &#123;<br>DevicesIDs           []<span class="hljs-type">string</span><br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其实就是一系列设备 ID 的集合，这里的设备 ID，自然就是 <code>ListAndWatch</code> 上报给 kubelet 的那些，kubelet 会从里面挑选一些。</p><p>拿到设备 ID 后的具体处理就由 Device Plugin 自行实现了（比如：据 kubelet 传过来的设备 ID，去寻找这个设备 ID 对应的设备路径、驱动目录以及环境变量），最后会返回一些信息，包括环境变量，HostPath，ContainerPath 等，对应的容器会根据这些信息进行设备的挂载。</p><p>同时，该节点的设备数量会对应减少掉 Pod 所申请的数量个数。比如该节点有 10 个 fakegpu，那么在上面这个 Pod 调度过来以后，该节点剩余 10 - 10 &#x3D; 0 个 fakegpu。后续如果还有需要 fakegpu 的 Pod，则不会被调度到该节点，因为该节点已经没有任何 fakegpu 了。</p><p>到这里一个 Device Plugin 的核心实现流程就结束了，剩下还有一些要做的工作：</p><p>注册 Device Plugin 到 kubelet：这一步主要是告诉 kubelet 自己的信息，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> RegisterRequest <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Version of the API the Device Plugin was built against</span><br>Version <span class="hljs-type">string</span> <span class="hljs-string">`protobuf:&quot;bytes,1,opt,name=version,proto3&quot; json:&quot;version,omitempty&quot;`</span><br><span class="hljs-comment">// Name of the unix socket the device plugin is listening on</span><br><span class="hljs-comment">// PATH = path.Join(DevicePluginPath, endpoint)</span><br>Endpoint <span class="hljs-type">string</span> <span class="hljs-string">`protobuf:&quot;bytes,2,opt,name=endpoint,proto3&quot; json:&quot;endpoint,omitempty&quot;`</span><br><span class="hljs-comment">// Schedulable resource name. As of now it&#x27;s expected to be a DNS Label</span><br>ResourceName <span class="hljs-type">string</span> <span class="hljs-string">`protobuf:&quot;bytes,3,opt,name=resource_name,json=resourceName,proto3&quot; json:&quot;resource_name,omitempty&quot;`</span><br><span class="hljs-comment">// Options to be communicated with Device Manager</span><br>Options              *DevicePluginOptions <span class="hljs-string">`protobuf:&quot;bytes,4,opt,name=options,proto3&quot; json:&quot;options,omitempty&quot;`</span><br>XXX_NoUnkeyedLiteral <span class="hljs-keyword">struct</span>&#123;&#125;             <span class="hljs-string">`json:&quot;-&quot;`</span><br>XXX_sizecache        <span class="hljs-type">int32</span>                <span class="hljs-string">`json:&quot;-&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其实主要就是 ResourceName 和 Endpoint，ResourceName 就是自己的名字，比如 <code>fake.io/gpu</code>，这样在 Pod 的 resources 中写入 <code>fake.io/gpu</code> 时，kubelet 才能知道这是一个什么设备，由哪个 Device Plugin 进行处理。Endpoint 是 Device Plugin 的 unix socket 名字（它会直接在 DevicePluginPath，也就是 <code>/var/lib/kubelet/device-plugins/</code> 下查找，所以你的 unix socket 需要在该目录下），这样 kubelet 就能和你的 Device Plugin 建立连接了。</p><h1 id="UnexpectedAdmissionError"><a href="#UnexpectedAdmissionError" class="headerlink" title="UnexpectedAdmissionError"></a>UnexpectedAdmissionError</h1><p><a href="https://izsk.me/2022/01/27/Kubernetes-pod-status-is-UnexpectedAdmissionError/">pod的状态出现UnexpectedAdmissionError是什么鬼? | Z.S.K.’s Records</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/yunqishequ/p/12196389.html">从零开始入门 K8s | GPU 管理和 Device Plugin 工作机制 - 阿里云云栖号 - 博客园</a></p><p><a href="https://www.myway5.com/index.php/2020/03/24/kubernetes-device-plugin/">Kubernetes开发知识-device-plugin的实现 - 一只安静的猫</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>needSyncToBlog</tag>
      
      <tag>devicePlugin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s informer controller 源码</title>
    <link href="/2024/06/12/k8s-informer-controller-md/"/>
    <url>/2024/06/12/k8s-informer-controller-md/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s informer reflector 源码</title>
    <link href="/2024/06/10/k8s-informer-reflector-md/"/>
    <url>/2024/06/10/k8s-informer-reflector-md/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Reflector 是 K8s Informer 的核心组件之一，它主要负责对指定的资源做 ListAndWatch，并存储起来。在 Informer 中，它存储的去处实际是一个 queue， 通过 push 到这个队列，其他组件就可以从该队列中 pop 出事件进一步进行处理。</p><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>下面是一个 reflector 的基本使用示例，大致流程就是编写一个实现了 ListerWatcher 接口的 struct，然后 new 一个 reflector 和 store，最后再启动 reflector 即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// LW 实现了 ListerWatcher 接口</span><br><span class="hljs-keyword">var</span> _ cache.ListerWatcher = &amp;LW&#123;&#125;<br><br><span class="hljs-keyword">type</span> LW <span class="hljs-keyword">struct</span> &#123;<br>ListFunc  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(options metav1.ListOptions)</span></span> (runtime.Object, <span class="hljs-type">error</span>)<br>WatchFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(options metav1.ListOptions)</span></span> (watch.Interface, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LW)</span></span> List(options metav1.ListOptions) (runtime.Object, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> l.ListFunc(options)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LW)</span></span> Watch(options metav1.ListOptions) (watch.Interface, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> l.WatchFunc(options)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ctx := context.TODO()<br>cfg, err := clientcmd.BuildConfigFromFlags(<span class="hljs-string">&quot;&quot;</span>, clientcmd.RecommendedHomeFile)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>cli, err := kubernetes.NewForConfig(cfg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>lw := &amp;LW&#123;<br>    <span class="hljs-comment">// List 具体的实现</span><br>ListFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(opt metav1.ListOptions)</span></span> (runtime.Object, <span class="hljs-type">error</span>) &#123;<br>klog.Info(<span class="hljs-string">&quot;start list...&quot;</span>)<br>      <span class="hljs-comment">// 获取 default namespace 下的所有 pod</span><br><span class="hljs-keyword">return</span> cli.CoreV1().Pods(metav1.NamespaceDefault).List(ctx, opt)<br>&#125;,<br>WatchFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(opt metav1.ListOptions)</span></span> (watch.Interface, <span class="hljs-type">error</span>) &#123;<br>klog.Info(<span class="hljs-string">&quot;start watch...&quot;</span>)<br><span class="hljs-keyword">return</span> cli.CoreV1().Pods(metav1.NamespaceDefault).Watch(ctx, opt)<br>&#125;,<br>&#125;<br><br><span class="hljs-comment">// 创建一个 store</span><br>s := cache.NewStore(cache.MetaNamespaceKeyFunc)<br><span class="hljs-comment">// 创建一个 reflector</span><br>r := cache.NewReflector(lw, &amp;corev1.Pod&#123;&#125;, s, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// 启动 reflector</span><br><span class="hljs-keyword">go</span> r.Run(wait.NeverStop)<br>  <br>  <span class="hljs-comment">// 之后就可以观察 store 的状态了，比如下面这样。。。</span><br>  <span class="hljs-comment">// 可以手动使用 kubectl 对 pod 执行操作，看看这里输出的变化。。。</span><br>  <span class="hljs-keyword">for</span> &#123;<br>  klog.Info(s.ListKeys())<br>    time.Sleep(time.Second*<span class="hljs-number">3</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="ListAndWatch"><a href="#ListAndWatch" class="headerlink" title="ListAndWatch"></a>ListAndWatch</h3><p>ListAndWatch 应该是 Reflector 最核心的方法了。顾名思义，它就是用来做资源的 ListAndWatch 的，大致流程如下：</p><ol><li>调用 r.list 执行 List 操作</li><li>如果需要执行 resync 的话，还会开一个 goroutine 去执行 resync 操作（resync 是什么，这里暂时先不提）</li><li>尝试调用 r.listerWatcher.Watch，建立 watch 连接</li><li>watchHandler 开始 watch 对应的资源并进行处理</li></ol><p>以下是精简后的源码部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reflector)</span></span> ListAndWatch(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// 执行 list 操作</span><br>err := r.list(stopCh)<br><br><span class="hljs-comment">// 执行 resync 操作</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>resyncCh, cleanup := r.resyncChan()<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> r.ShouldResync == <span class="hljs-literal">nil</span> || r.ShouldResync() &#123;<br><span class="hljs-keyword">if</span> err := r.store.Resync(); err != <span class="hljs-literal">nil</span> &#123;<br>resyncerrc &lt;- err<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;()<br><br>retry := NewRetryWithDeadline(r.MaxInternalErrorRetryDuration, time.Minute, apierrors.IsInternalError, r.clock)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// watch 的超时时间，如果超过该时间没有 watch 到任何资源，则中断</span><br>timeoutSeconds := <span class="hljs-type">int64</span>(minWatchTimeout.Seconds() * (rand.Float64() + <span class="hljs-number">1.0</span>))<br>options := metav1.ListOptions&#123;<br>TimeoutSeconds: &amp;timeoutSeconds,<br>&#125;<br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// 创建 watch 连接</span><br>w, err := r.listerWatcher.Watch(options)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 如果建立连接失败，看一下是否能重试</span><br><span class="hljs-keyword">if</span> utilnet.IsConnectionRefused(err) || apierrors.IsTooManyRequests(err) &#123;<br>&lt;-r.initConnBackoffManager.Backoff().C()<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// watch 连接建立成功，开始 watch 事件并处理</span><br>err = watchHandler(start, w, r.store, r.expectedType, r.expectedGVK, r.name, r.expectedTypeName, r.setLastSyncResourceVersion, r.clock, resyncerrc, stopCh)<br><br>retry.After(err)<br><span class="hljs-comment">// 如果处理事件发生错误，判断能否重试，可以看到一些 case 是 continue，其他 case 则</span><br><span class="hljs-comment">// 是会输出日志（为了精简，我这里省略了），最终走到最后的 return nil 结束整个函数</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err != errorStopRequested &#123;<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> isExpiredError(err):<br><span class="hljs-comment">// ... 省略输出日志部分</span><br><span class="hljs-keyword">case</span> apierrors.IsTooManyRequests(err):<br>&lt;-r.initConnBackoffManager.Backoff().C()<br><span class="hljs-keyword">continue</span><br><span class="hljs-keyword">case</span> apierrors.IsInternalError(err) &amp;&amp; retry.ShouldRetry():<br><span class="hljs-keyword">continue</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，ListAndWatch 最终还会被 BackoffUntil 包裹， BackoffUntil 会定期执行指定的函数，在这里实际是重试操作，因为正常情况下，ListAndWatch 是会在一个死循环中持续处理 watch 事件的，并不会返回，只有当 </p><ol><li>List 发生 err 时 </li><li>初始化 Watch 发生 err 时 </li><li>handle watch 发生部分 err 时（比如网络中断）<br>这个函数才会结束，此时会由 BackoffUntil 重新执行，重新执行意味着会做一次全量的 List 操作。这也意味着如果我们在 watch 过程中发生网络中断等问题，会重新 List 一次全量数据，来弥补这段时间遗漏的事件。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">wait.BackoffUntil(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>klog.Info(<span class="hljs-string">&quot;wait.BackoffUntil callback&quot;</span>)<br><span class="hljs-keyword">if</span> err := r.ListAndWatch(stopCh); err != <span class="hljs-literal">nil</span> &#123;<br>r.watchErrorHandler(r, err)<br>&#125;<br>&#125;, r.backoffManager, <span class="hljs-literal">true</span>, stopCh)<br></code></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list 方法会调用 Reflector.ListerWatcher.List() 方法，拿到全量数据。</p><p>在具体实现中，它会用 pager 包裹 List 方法， pager 这个包会在内部尝试通过分页的方式从 apiserver 拿到数据，避免一次性拿取太多资源而对 apiserver 造成过大压力。</p><p>最后，它解析出拿到的 list 对象，调用 syncWith（底层继续调用 r.store.Replace）对队列进行更新。为什么这里调用的是 Replace 而不是 Add？我猜是因为：前面提到，在 watch 阶段如果出现一些错误，是会导致 ListAndWatch 这个函数直接 return 结束掉，此时会重新执行 ListAndWatch，进行一次全量 List 操作。而先前队列中已经存在一些元素了，所以 List 需要去 Replace 而不是 Add。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reflector)</span></span> list(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><br>pager := pager.New(pager.SimplePageFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(opts metav1.ListOptions)</span></span> (runtime.Object, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> r.listerWatcher.List(opts)<br>&#125;))<br><span class="hljs-comment">// ...</span><br><br>list, paginatedResult, err = pager.List(context.Background(), options)<br><span class="hljs-keyword">if</span> isExpiredError(err) || isTooLargeResourceVersionError(err) &#123;<br>r.setIsLastSyncResourceVersionUnavailable(<span class="hljs-literal">true</span>)<br>list, paginatedResult, err = pager.List(context.Background(), metav1.ListOptions&#123;ResourceVersion: r.relistResourceVersion()&#125;)<br>&#125;<br><span class="hljs-built_in">close</span>(listCh)<br>&#125;()<br><span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// ExtractList 将 obj 的 Items 元素作为 []runtime.Object 返回。如果 obj 不是</span><br><span class="hljs-comment">// List 类型（没有 Items 成员），则返回错误。</span><br>items, err := meta.ExtractList(list)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unable to understand list result %#v (%v)&quot;</span>, list, err)<br>&#125;<br><br><span class="hljs-comment">// 用 list 拿到的 items 更新 store</span><br><span class="hljs-keyword">if</span> err := r.syncWith(items, resourceVersion); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unable to sync list result: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="watchHandler"><a href="#watchHandler" class="headerlink" title="watchHandler"></a>watchHandler</h3><p>watchHandler 通过传入的 watch.Interface 源源不断拿到 watch 事件，并进行处理，将事件存储到 store 中。它会根据事件类型对 store 做对应的操作，比如 新增&#x2F;更新&#x2F;删除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">watchHandler</span><span class="hljs-params">(start time.Time,</span></span><br><span class="hljs-params"><span class="hljs-function">w watch.Interface,</span></span><br><span class="hljs-params"><span class="hljs-function">store Store,</span></span><br><span class="hljs-params"><span class="hljs-function">// ...</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> <span class="hljs-type">error</span> &#123;<br><br><br><span class="hljs-keyword">defer</span> w.Stop()<br><br>loop:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// 有事件产生了</span><br><span class="hljs-keyword">case</span> event, ok := &lt;-w.ResultChan():<br><span class="hljs-comment">// watch 的 channel 被关闭了（什么情况下会被关闭？这需要看 watch 部分的</span><br><span class="hljs-comment">// 源码了，这里先不管</span><br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">break</span> loop<br>&#125;<br><span class="hljs-keyword">if</span> event.Type == watch.Error &#123;<br><span class="hljs-keyword">return</span> apierrors.FromObject(event.Object)<br>&#125;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// 根据事件类型的不同做不同的处理</span><br><span class="hljs-keyword">switch</span> event.Type &#123;<br><span class="hljs-keyword">case</span> watch.Added:<br>err := store.Add(event.Object)<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">case</span> watch.Modified:<br>err := store.Update(event.Object)<br><span class="hljs-keyword">case</span> watch.Deleted:<br>err := store.Delete(event.Object)<br><span class="hljs-keyword">case</span> watch.Bookmark:<br><span class="hljs-comment">// A `Bookmark` means watch has synced here, just update the resourceVersion</span><br><span class="hljs-keyword">default</span>:<br>utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to understand watch event %#v&quot;</span>, name, event))<br>&#125;<br><span class="hljs-comment">// ...</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kube-proxy 源码阅读</title>
    <link href="/2024/05/04/kube-proxy%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/2024/05/04/kube-proxy%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>本文只做简单的源码阅读。</p><p>只分析了 service informer 以及 iptables 的相关源码。</p><p>首先是入口：</p><p>kubernetes&#x2F;cmd&#x2F;kube-proxy&#x2F;app&#x2F;server.go</p><p>在 <code>func (o *Options) AddFlag</code> 中</p><p>指定了如下参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">fs.Var(&amp;o.config.Mode, <span class="hljs-string">&quot;proxy-mode&quot;</span>, <span class="hljs-string">&quot;Which proxy mode to use: &#x27;iptables&#x27; (Linux-only), &#x27;ipvs&#x27; (Linux-only), &#x27;kernelspace&#x27; (Windows-only), or &#x27;userspace&#x27; (Linux/Windows, deprecated). The default value is &#x27;iptables&#x27; on Linux and &#x27;userspace&#x27; on Windows.&quot;</span>+<br><span class="hljs-string">&quot;This parameter is ignored if a config file is specified by --config.&quot;</span>)<br></code></pre></td></tr></table></figure><p>这样就可以通过 –proxy-mode 来提供 kube-proxy 的工作模式了</p><p><del>执行 iptables 相关命令是由 kubelet 来完成的（kubernetes&#x2F;pkg&#x2F;kubelet&#x2F;kubelet_network_linux.go）</del> （并不是，kube-proxy 运行在所有 worker 节点上，kubelet 也会创建一些 iptables 规则，不过不知道具体是干嘛的，参加 <code>func (kl *Kubelet) syncNetworkUtil</code>）</p><p>kubeproxy 运行会启动 service, endpoint（或者 endpointSlice） informer，如果开启了TopologyAwareHints features，还会启动 node informer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *ProxyServer)</span></span> Run() <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// ... 省略</span><br>serviceConfig := config.NewServiceConfig(informerFactory.Core().V1().Services(), s.ConfigSyncPeriod)<br>serviceConfig.RegisterEventHandler(s.Proxier)<br><span class="hljs-keyword">go</span> serviceConfig.Run(wait.NeverStop)<br>&#125;<br></code></pre></td></tr></table></figure><p>下面的是 service informer 相关代码，注册了事件处理函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServiceConfig</span><span class="hljs-params">(serviceInformer coreinformers.ServiceInformer, resyncPeriod time.Duration)</span></span> *ServiceConfig &#123;<br>result := &amp;ServiceConfig&#123;<br>listerSynced: serviceInformer.Informer().HasSynced,<br>&#125;<br><br>serviceInformer.Informer().AddEventHandlerWithResyncPeriod(<br>cache.ResourceEventHandlerFuncs&#123;<br>AddFunc:    result.handleAddService,<br>UpdateFunc: result.handleUpdateService,<br>DeleteFunc: result.handleDeleteService,<br>&#125;,<br>resyncPeriod,<br>)<br><br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>这些 handler 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *ServiceConfig)</span></span> handleAddService(obj <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-comment">// 省略 ...</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> c.eventHandlers &#123;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Calling handler.OnServiceAdd&quot;</span>)<br>c.eventHandlers[i].OnServiceAdd(service)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *ServiceConfig)</span></span> handleUpdateService(oldObj, newObj <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-comment">// 省略 ...</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> c.eventHandlers &#123;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Calling handler.OnServiceUpdate&quot;</span>)<br>c.eventHandlers[i].OnServiceUpdate(oldService, service)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *ServiceConfig)</span></span> handleDeleteService(obj <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-comment">// 省略 ...</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> c.eventHandlers &#123;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Calling handler.OnServiceDelete&quot;</span>)<br>c.eventHandlers[i].OnServiceDelete(service)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 c.eventHandlers 类型是 <code>[]ServiceHandler</code>，ServiceHandler 是一个接口类型，具体的实现正好对应了 kube-proxy 的几种 mode，比如有 iptables 和 ipvs，在<br><code>serviceConfig.RegisterEventHandler(s.Proxier)</code> 这里注册（没搞懂为啥定义成一个数组类型，明明只会注册一个）。</p><p>看一下 iptables 的对应实现：</p><p>kubernetes&#x2F;pkg&#x2F;proxy&#x2F;iptables&#x2F;proxier.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// OnServiceAdd is called whenever creation of new service object</span><br><span class="hljs-comment">// is observed.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proxier *Proxier)</span></span> OnServiceAdd(service *v1.Service) &#123;<br>proxier.OnServiceUpdate(<span class="hljs-literal">nil</span>, service)<br>&#125;<br><br><span class="hljs-comment">// OnServiceUpdate is called whenever modification of an existing</span><br><span class="hljs-comment">// service object is observed.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proxier *Proxier)</span></span> OnServiceUpdate(oldService, service *v1.Service) &#123;<br><span class="hljs-keyword">if</span> proxier.serviceChanges.Update(oldService, service) &amp;&amp; proxier.isInitialized() &#123;<br>proxier.Sync()<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// OnServiceDelete is called whenever deletion of an existing service</span><br><span class="hljs-comment">// object is observed.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proxier *Proxier)</span></span> OnServiceDelete(service *v1.Service) &#123;<br>proxier.OnServiceUpdate(service, <span class="hljs-literal">nil</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上都是调用 OnServiceUpdate 函数，OnServiceUpdate 调用的 <code>proxier.serviceChanges.Update</code> 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sct *ServiceChangeTracker)</span></span> Update(previous, current *v1.Service) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// ....</span><br>namespacedName := types.NamespacedName&#123;Namespace: svc.Namespace, Name: svc.Name&#125;<br><br>change, exists := sct.items[namespacedName]<br><span class="hljs-keyword">if</span> !exists &#123;<br>change = &amp;serviceChange&#123;&#125;<br>change.previous = sct.serviceToServiceMap(previous)<br>sct.items[namespacedName] = change<br>&#125;<br>change.current = sct.serviceToServiceMap(current)<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(sct.items) &gt; <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><p>其实就是用传入的 service，去更新 proxier.serviceChanges.items</p><p>如果 items 发生了变更，则 Update 会返回 true，此时会继续执行  proxier.Sync，该函数定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Sync is called to synchronize the proxier state to iptables as soon as possible.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proxier *Proxier)</span></span> Sync() &#123;<br><span class="hljs-keyword">if</span> proxier.healthzServer != <span class="hljs-literal">nil</span> &#123;<br>proxier.healthzServer.QueuedUpdate()<br>&#125;<br>metrics.SyncProxyRulesLastQueuedTimestamp.SetToCurrentTime()<br>proxier.syncRunner.Run()<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 Sync 是为了尽快将 proxier 状态同步到 iptables</p><p>这里的 syncRunner 实际是一个 <code>BoundedFrequencyRunner</code>，它的 Run 方法用于通知：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bfr *BoundedFrequencyRunner)</span></span> Run() &#123;<br><span class="hljs-comment">// If it takes a lot of time to run the underlying function, noone is really</span><br><span class="hljs-comment">// processing elements from &lt;run&gt; channel. So to avoid blocking here on the</span><br><span class="hljs-comment">// putting element to it, we simply skip it if there is already an element</span><br><span class="hljs-comment">// in it.</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> bfr.run &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;:<br><span class="hljs-keyword">default</span>:<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后 bfr 有一个 Loop 方法，用于处理通知：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bfr *BoundedFrequencyRunner)</span></span> Loop(stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>klog.V(<span class="hljs-number">3</span>).Infof(<span class="hljs-string">&quot;%s Loop running&quot;</span>, bfr.name)<br>bfr.timer.Reset(bfr.maxInterval)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-stop:<br>bfr.stop()<br>klog.V(<span class="hljs-number">3</span>).Infof(<span class="hljs-string">&quot;%s Loop stopping&quot;</span>, bfr.name)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> &lt;-bfr.timer.C():<br>bfr.tryRun()<br><span class="hljs-keyword">case</span> &lt;-bfr.run:<br>bfr.tryRun()<br><span class="hljs-keyword">case</span> &lt;-bfr.retry:<br>bfr.doRetry()<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当接收到来自 bft.run 的信号时，它会执行 tryRun：</p><p>tryRun 执行的实际是 bfr.fn：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// assumes the lock is not held</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bfr *BoundedFrequencyRunner)</span></span> tryRun() &#123;<br>bfr.mu.Lock()<br><span class="hljs-keyword">defer</span> bfr.mu.Unlock()<br><br><span class="hljs-keyword">if</span> bfr.limiter.TryAccept() &#123;<br><span class="hljs-comment">// We&#x27;re allowed to run the function right now.</span><br><span class="hljs-comment">// 这个是执行的函数</span><br>bfr.fn()<br>&#125;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>这里的 fn() 在这里初始化：</p><p>NewProxier</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">proxier.syncRunner = async.NewBoundedFrequencyRunner(<span class="hljs-string">&quot;sync-runner&quot;</span>, proxier.syncProxyRules, minSyncPeriod, time.Hour, burstSyncs)<br></code></pre></td></tr></table></figure><p>第二个参数就是 fn，所以我们看一下这个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proxier *Proxier)</span></span> syncProxyRules() &#123;<br>serviceUpdateResult := proxier.serviceMap.Update(proxier.serviceChanges)<br><br><span class="hljs-keyword">for</span> svcName, svc := <span class="hljs-keyword">range</span> proxier.serviceMap &#123;<br>svcInfo, ok := svc.(*serviceInfo)<br><br><span class="hljs-comment">// nodePort 类型的 service</span><br><span class="hljs-keyword">if</span> svcInfo.NodePort() != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">len</span>(nodeAddresses) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> hasEndpoints &#123;<br><span class="hljs-comment">// Jump to the external destination chain.  For better or for</span><br><span class="hljs-comment">// worse, nodeports are not subect to loadBalancerSourceRanges,</span><br><span class="hljs-comment">// and we can&#x27;t change that.</span><br>proxier.natRules.Write(<br><span class="hljs-string">&quot;-A&quot;</span>, <span class="hljs-type">string</span>(kubeNodePortsChain),<br><span class="hljs-string">&quot;-m&quot;</span>, <span class="hljs-string">&quot;comment&quot;</span>, <span class="hljs-string">&quot;--comment&quot;</span>, svcNameString,<br><span class="hljs-string">&quot;-m&quot;</span>, protocol, <span class="hljs-string">&quot;-p&quot;</span>, protocol,<br><span class="hljs-string">&quot;--dport&quot;</span>, strconv.Itoa(svcInfo.NodePort()),<br><span class="hljs-string">&quot;-j&quot;</span>, <span class="hljs-type">string</span>(externalTrafficChain))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// No endpoints.</span><br>proxier.filterRules.Write(<br><span class="hljs-string">&quot;-A&quot;</span>, <span class="hljs-type">string</span>(kubeExternalServicesChain),<br><span class="hljs-string">&quot;-m&quot;</span>, <span class="hljs-string">&quot;comment&quot;</span>, <span class="hljs-string">&quot;--comment&quot;</span>, fmt.Sprintf(<span class="hljs-string">`&quot;%s has no endpoints&quot;`</span>, svcNameString),<br><span class="hljs-string">&quot;-m&quot;</span>, <span class="hljs-string">&quot;addrtype&quot;</span>, <span class="hljs-string">&quot;--dst-type&quot;</span>, <span class="hljs-string">&quot;LOCAL&quot;</span>,<br><span class="hljs-string">&quot;-m&quot;</span>, protocol, <span class="hljs-string">&quot;-p&quot;</span>, protocol,<br><span class="hljs-string">&quot;--dport&quot;</span>, strconv.Itoa(svcInfo.NodePort()),<br><span class="hljs-string">&quot;-j&quot;</span>, <span class="hljs-string">&quot;REJECT&quot;</span>,<br>)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Sync rules.</span><br>proxier.iptablesData.Reset()<br>proxier.iptablesData.WriteString(<span class="hljs-string">&quot;*filter\n&quot;</span>)<br>proxier.iptablesData.Write(proxier.filterChains.Bytes())<br>proxier.iptablesData.Write(proxier.filterRules.Bytes())<br>proxier.iptablesData.WriteString(<span class="hljs-string">&quot;COMMIT\n&quot;</span>)<br>proxier.iptablesData.WriteString(<span class="hljs-string">&quot;*nat\n&quot;</span>)<br>proxier.iptablesData.Write(proxier.natChains.Bytes())<br>proxier.iptablesData.Write(proxier.natRules.Bytes())<br>proxier.iptablesData.WriteString(<span class="hljs-string">&quot;COMMIT\n&quot;</span>)<br><br>err = proxier.iptables.RestoreAll(proxier.iptablesData.Bytes(), utiliptables.NoFlushTables, utiliptables.RestoreCounters)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数根据之前的 serviceChanges 去更新 serviceMap，然后基于 serviceMap 里的 service 信息去写入 iptables 规则</p><p>会先写入到类似 proxier.natRules，proxier.filterRules 这种 utilproxy.LineBuffer 类型的缓冲区里面（根据注释说明，以下缓冲区用于重用内存并避免显着影响性能的分配），然后再写入到 proxier.iptablesData</p><p>然后好像会调用 <code>proxier.iptables.RestoreAll</code> 把 iptables 刷到主机？（看了下这个函数，貌似就是会调用 exec 执行命令，确实是这样，kube-proxy 会部署在每个工作节点上）</p><p>（这个函数有 700 多行，太长了，具体的逻辑就先不看了）</p><p>PS: BoundedFrequencyRunner 是干什么用的？</p><p>来自 ChatGPT 的回答：</p><blockquote><p>在 Kubernetes 的代码库中，BoundedFrequencyRunner 是设计用来控制任务执行频率的工具。它确保给定的任务在指定的最小和最大频率限制内运行。这对于 Kubernetes 内的一些组件来说是非常有用的，特别是那些需要定期执行但又要考虑系统资源和响应时间的场景，例如定期同步、健康检查或者元数据更新等。</p><p>核心特性</p><ul><li>最小频率限制：保证指定任务在达到最小频率之前不会运行。这可以避免任务的过于频繁执行，帮助减轻对系统资源的压力。</li><li>最大频率限制：确保在达到最大频率限制时，即使任务触发，也会被延迟执行，这是为了避免长时间未执行任务时的突发执行，帮助平滑系统负载。</li></ul><p>应用场景</p><p>BoundedFrequencyRunner 的应用场景非常广泛，主要包括但不限于：</p><ul><li>定期任务执行，如缓存更新、状态同步等，需要维护最小和最大执行频率以优化资源使用。</li><li>系统健康检查或者监控任务，通过控制检查的频率来达到及时发现问题和避免资源浪费的平衡。</li><li>在外部事件触发时执行的任务，可以通过 BoundedFrequencyRunner 控制实际执行的频率，防止过于频繁的触发导致的性能问题。</li></ul><p>实现方式</p><p>BoundedFrequencyRunner 通常通过一个调度循环来实现，调度循环参考最小和最大频率限制来决定任务的执行时机。该工具通常提供了一些方法来触发任务执行请求，在内部会计算是否满足频率限制条件来决定是否立即执行任务或者延迟执行。</p><p>使用BoundedFrequencyRunner</p><p>在 Kubernetes 的代码库或者相关项目中使用 BoundedFrequencyRunner，通常涉及创建一个实例，设置相应的频率限制，然后将需要定时执行的任务传递给它。具体实现细节和接口可能因 Kubernetes 版本而异，但大致思想是一致的。</p><p>结语</p><p>BoundedFrequencyRunner 是 Kubernetes 系统中一个用于控制任务执行频率的实用工具，通过保证任务在给定的频率限制内运行，它帮助优化了任务调度，同时减轻了系统资源的压力。</p></blockquote><p>貌似就是用来限制 iptables 操作频率的一个东西？如果集群 service 数量太多可能会导致频繁操作 iptables 影响性能？不太清楚</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bfr *BoundedFrequencyRunner)</span></span> Loop(stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>klog.V(<span class="hljs-number">3</span>).Infof(<span class="hljs-string">&quot;%s Loop running&quot;</span>, bfr.name)<br>bfr.timer.Reset(bfr.maxInterval)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-stop:<br>bfr.stop()<br>klog.V(<span class="hljs-number">3</span>).Infof(<span class="hljs-string">&quot;%s Loop stopping&quot;</span>, bfr.name)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> &lt;-bfr.timer.C():<br>bfr.tryRun()<br><span class="hljs-keyword">case</span> &lt;-bfr.run:<br>bfr.tryRun()<br><span class="hljs-keyword">case</span> &lt;-bfr.retry:<br>bfr.doRetry()<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看它的这个函数，貌似就是当到达间隔时间，或者收到 run 信号时才会运行函数</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>kube-proxy 会运行 service informer，这个 informer 只负责更新 serviceChanges 缓存，然后核心的方法主要是 syncProxyRules，这个函数会根据变动，去更新已经保存的 service  map，然后遍历这个 map，根据其中的每个 service，写入对应的 iptables 规则到节点。syncProxyRules 由 BoundedFrequencyRunner 来控制执行，当 serviceChanges 发生变化，或者到达间隔时间后执行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>k8s网络</tag>
      
      <tag>needSyncToBlog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s patch</title>
    <link href="/2023/10/29/k8s-patch-md/"/>
    <url>/2023/10/29/k8s-patch-md/</url>
    
    <content type="html"><![CDATA[<p>k8s patch 操作允许对资源进行部分更新。</p><h1 id="Patch-类型"><a href="#Patch-类型" class="headerlink" title="Patch 类型"></a>Patch 类型</h1><p>patch 操作有以下几种类型：</p><h2 id="JSON-Patch"><a href="#JSON-Patch" class="headerlink" title="JSON Patch"></a>JSON Patch</h2><p>JSON Patch 的详细说明可以阅读对应的 <a href="https://www.rfc-editor.org/rfc/rfc6902.html">RFC 文档</a> 。</p><p>JSON Patch 通过如下格式来对资源进行操作：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>     <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;op&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/a/b/c&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;foo&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;op&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;remove&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/a/b/c&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;op&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;add&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/a/b/c&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;foo&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;bar&quot;</span> <span class="hljs-punctuation">]</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;op&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;replace&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/a/b/c&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">42</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;op&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;move&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;from&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/a/b/c&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/a/b/d&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;op&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;copy&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;from&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/a/b/d&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/a/b/e&quot;</span> <span class="hljs-punctuation">&#125;</span><br> <span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>可以看到在上面的示例中，每个 json 对象都包含了 op，path 这 2 个字段，其中，op 代表的就是具体的操作，比如 replace 代表的就是替换；path 则是 json 文档中要操作的字段所在的位置，然后对于不同的 op 还会有一些不同的特殊字段，比如 move 和 copy 会有一个 from 字段，而 add，remove 和 test 会有一个 value 字段，这些字段通过名字就可以很容易的了解到它们的用处，这里就不再赘述了。</p><p>总的来说，这种 patch 类型还是比较好理解的，下面摘录了 RFC 文档中给出的一些示例，通过这些示例就可以很容易的了解这种 patch 的使用方式（可以在 RFC 文档中阅读完整的示例来进一步理解）：</p><table><thead><tr><th>原始 JSON 文档</th><th>Patch</th><th>Patch 后的 JSON 文档</th></tr></thead><tbody><tr><td>{ “foo”: “bar”}</td><td>[  <br/>    { “op”: “add”, “path”: “&#x2F;baz”, “value”: “qux” }   <br/> ]</td><td>{<br/>     “baz”: “qux”,<br/>     “foo”: “bar”<br/>   }</td></tr><tr><td>{ “foo”: [ “bar”, “baz” ] }</td><td>[<br/>     { “op”: “add”, “path”: “&#x2F;foo&#x2F;1”, “value”: “qux” }<br/>   ]</td><td>{ “foo”: [ “bar”, “qux”, “baz” ] }</td></tr><tr><td>{<br/>     “foo”: {<br/>       “bar”: “baz”,<br/>       “waldo”: “fred”<br/>     },<br/>     “qux”: {<br/>       “corge”: “grault”<br/>     }<br/>   }</td><td>[<br/>     { “op”: “move”, “from”: “&#x2F;foo&#x2F;waldo”, “path”: “&#x2F;qux&#x2F;thud” }<br/>   ]</td><td>{<br/>     “foo”: {<br/>       “bar”: “baz”<br/>     },<br/>     “qux”: {<br/>       “corge”: “grault”,<br/>       “thud”: “fred”<br/>     }<br/>   }</td></tr></tbody></table><p>需要注意的一点是，如果你想操作的 path 是一个数组类型，那么你需要额外指定一下要操作的数组的 index，比如第二个例子中，path 指定为了 &#x2F;foo&#x2F;1，代表要将 value 添加到 foo 的第二个位置（index 从 0 开始算起）。</p><h2 id="JSON-Merge-Patch"><a href="#JSON-Merge-Patch" class="headerlink" title="JSON Merge Patch"></a>JSON Merge Patch</h2><p>JSON Merge Patch 的详细说明可以阅读对应的 <a href="https://www.rfc-editor.org/rfc/rfc7396.html">RFC 文档</a> 。</p><p>JSON Merge Patch 是一系列差异的集合。差异就是指 原始 Json 文件 和 目标 Json 文件 的不同。</p><p>如果是删除某个字段，则需要将字段置为 null，如果是修改某个字段，则需要将新的 value 值写在对应的 key 上。</p><p>作为一个简单的例子（<a href="https://tools.ietf.org/html/rfc7386#section-1">取自 RFC</a>），如果我们有以下文档：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>&quot;<span class="hljs-selector-tag">a</span>&quot;: <span class="hljs-string">&quot;b&quot;</span>,<br><span class="hljs-string">&quot;c&quot;</span>: &#123;<br>&quot;d&quot;: <span class="hljs-string">&quot;e&quot;</span>,<br><span class="hljs-string">&quot;f&quot;</span>: <span class="hljs-string">&quot;g&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们可以在其上运行以下 patch：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;z&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;c&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;f&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这将更改 <code>&quot;a&quot;</code> 的值为 <code>&quot;z&quot;</code> 并删除 <code>&quot;f&quot;</code> 这个 key。</p><p>这种 patch 的方式也比较容易理解，相比 JSON Patch，这种方式的弊端在于：</p><ul><li>删除某个键值，需要在 patch 文件中将对应的值置成 null，但是如果我们就是要把某个值设置成 null，那就几乎无解了，因为对于 JSON Merge Patch 而言，它无法分辨 patch 到底是要删除还是赋值。</li><li>如果想向数组添加一个元素，或改变其中任何元素，都必须将整个数组包含在 patch 中，即使实际更改的部分很少。</li><li>不会报错，无论什么情况，都会 patch 成功。在真实使用场景下，还需要做额外的校验。</li></ul><h2 id="Strategic-Merge-Patch"><a href="#Strategic-Merge-Patch" class="headerlink" title="Strategic Merge Patch"></a>Strategic Merge Patch</h2><p>这种方式称为策略合并，它是 k8s 特有的一种 patch 方式，顾名思义，它是通过指定的策略去执行对应的 patch 操作，是合并还是覆盖，都取决于具体的策略，那策略在哪里定义呢？</p><p>实际上，这些策略定义在了 k8s 源码中资源 struct 的 tag 里面，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PodSpec <span class="hljs-keyword">struct</span> &#123;<br>  ...<br>  Containers []Container <span class="hljs-string">`json:&quot;containers&quot; patchStrategy:&quot;merge&quot; patchMergeKey:&quot;name&quot; ...`</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>（也可以在 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.28/#podspec-v1-core">Kubernetes API 文档</a> 中看到 patch 策略。）</p><p>可以看到其中有两个关键信息：patchStrategy:”merge” patchMergeKey:”name” 。这就代表了，containers 列表使用 strategic merge patch 策略更新时，会执行合并策略，并且会把下面每个元素中的 name 字段看作 key。</p><p>简单来说，在我们 patch 更新 containers 不再需要指定下标序号了（JSON Patch 的方式需要指定 index），而是指定 name 来修改，K8s 会把 name 作为 key 来计算 merge。比如针对以下的 patch 操作：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">kubectl <span class="hljs-keyword">patch</span> deployment/foo -p \<br>  &#x27;&#123;<span class="hljs-string">&quot;spec&quot;</span>:&#123;<span class="hljs-string">&quot;template&quot;</span>:&#123;<span class="hljs-string">&quot;spec&quot;</span>:&#123;<span class="hljs-string">&quot;containers&quot;</span>:[&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;nginx&quot;</span>,<span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;nginx:mainline&quot;</span>&#125;]&#125;&#125;&#125;&#125;&#x27;<br></code></pre></td></tr></table></figure><p>如果 K8s 发现当前 containers 中已经有名字为 nginx 的容器，则只会把 image 更新上去；而如果当前 containers 中没有 nginx 容器，K8s 会把这个容器插入 containers 列表。</p><p>如果 tag 中没有 <code>patchStrategy</code> 键，那么执行的将会是覆盖策略，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PodSpec <span class="hljs-keyword">struct</span> &#123;<br>  ...<br>  Tolerations []Toleration <span class="hljs-string">`json:&quot;tolerations,omitempty&quot; protobuf:&quot;bytes,22,opt,name=tolerations&quot;`</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 patch 中包含了对 Tolertions 的修改，那么执行的将会是替换操作，而不是 Containers 的合并操作。</p><blockquote><p>此外还要说明的是，目前 strategic 策略只能用于原生 K8s 资源以及 Aggregated API 方式的自定义资源，对于 CRD 定义的资源对象，是无法使用的。这很好理解，因为 kube-apiserver 无法得知 CRD 资源的结构和 merge 策略。如果用 kubectl patch 命令更新一个 CR，则默认会采用 merge patch 的策略来操作。</p></blockquote><h2 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h2><p>在 Clientset 中为每个资源都提供了一个 Patch 方法，通过这个方法就可以对具体的资源执行 Patch 操作，代码类似下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">patchDeploy, err := clientset.AppsV1().Deployments(metav1.NamespaceDefault).Patch(context.TODO(), deploy.Name, types.StrategicMergePatchType, patchData, metav1.PatchOptions&#123;&#125;)<br></code></pre></td></tr></table></figure><p>其中，第三个参数指定的是 Patch 的类型，第四个参数则是 Patch 的内容，是一个 []byte。</p><p>在 client-go 中，定义了以下几种 Patch 类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PatchType <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> (<br>JSONPatchType           PatchType = <span class="hljs-string">&quot;application/json-patch+json&quot;</span><br>MergePatchType          PatchType = <span class="hljs-string">&quot;application/merge-patch+json&quot;</span><br>StrategicMergePatchType PatchType = <span class="hljs-string">&quot;application/strategic-merge-patch+json&quot;</span><br>ApplyPatchType          PatchType = <span class="hljs-string">&quot;application/apply-patch+yaml&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>可以看到里面包含了我们上面提到的那 3 种类型，此外还多了一种 Apply Patch，这个暂时还没太去了解。</p><p>完整代码可以在 <a href="https://github.com/autsu/kubemisc/tree/master/clientgo/patch">https://github.com/autsu/kubemisc/tree/master/clientgo/patch</a> 下获得。</p><h3 id="Strategic-Merge-Patch-1"><a href="#Strategic-Merge-Patch-1" class="headerlink" title="Strategic Merge Patch"></a>Strategic Merge Patch</h3><p>k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;util 下提供了一个 strategicpatch 包，里面包含了一些相关的方法。</p><p>比如下面这个例子中，使用了 strategicpatch.CreateTwoWayMergePatch ，通过原始对象和修改后对象之间的差异获得对应的 Patch，然后我们就可以将这个 Patch 作为参数传递给 Patch()，从而进行资源的 Patch 操作了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// StrategicMergePatch2K8sUseCreateTwoWayMergePatch 调用 strategicpatch.CreateTwoWayMergePatch 获取两个 obj 之间的 patch，</span><br><span class="hljs-comment">// 然后再用这个 patch 对对象执行 Patch 操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StrategicMergePatch2K8sUseCreateTwoWayMergePatch</span><span class="hljs-params">()</span></span> &#123;<br>deploy, dropFunc := initTestResource(<span class="hljs-literal">true</span>)<br><span class="hljs-keyword">if</span> dropFunc != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">defer</span> dropFunc()<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;before patch: \n\n&quot;</span>)<br>printhelper.ObjJSON(deploy.Spec.Template.Spec.Containers)<br>printhelper.ObjJSON(deploy.Spec.Template.Spec.Tolerations)<br><br>newDeploy := deploy.DeepCopy()<br>newDeploy.Spec.Template.Spec.Containers = <span class="hljs-built_in">append</span>(deploy.Spec.Template.Spec.Containers, corev1.Container&#123;<br>Name:  <span class="hljs-string">&quot;patch-demo-ctr-2&quot;</span>,<br>Image: <span class="hljs-string">&quot;redis&quot;</span>,<br>&#125;)<br>newDeploy.Spec.Template.Spec.Tolerations = newDeploy.Spec.Template.Spec.Tolerations[:<span class="hljs-number">0</span>]<br>newDeploy.Spec.Template.Spec.Tolerations = <span class="hljs-built_in">append</span>(newDeploy.Spec.Template.Spec.Tolerations, corev1.Toleration&#123;<br>Key:               <span class="hljs-string">&quot;disktype&quot;</span>,<br>Operator:          <span class="hljs-string">&quot;&quot;</span>,<br>Value:             <span class="hljs-string">&quot;ssd&quot;</span>,<br>Effect:            <span class="hljs-string">&quot;NoSchedule&quot;</span>,<br>TolerationSeconds: <span class="hljs-literal">nil</span>,<br>&#125;)<br><br>origin, err := json.Marshal(deploy)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>mod, err := json.Marshal(newDeploy)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>patchData, err := strategicpatch.CreateTwoWayMergePatch(origin, mod, &amp;appsv1.Deployment&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;patch data: &quot;</span>, <span class="hljs-type">string</span>(patchData))<br><br>cli := helper.NewClientSetOrDie()<br><br>patchDeploy, err := cli.AppsV1().Deployments(metav1.NamespaceDefault).Patch(<br>context.TODO(), deploy.Name, types.StrategicMergePatchType, patchData, metav1.PatchOptions&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-comment">//fmt.Println(patchDeploy.Labels)</span><br>fmt.Println(<span class="hljs-string">&quot;after patch: &quot;</span>)<br>printhelper.ObjJSON(patchDeploy.Spec.Template.Spec.Containers)<br>printhelper.ObjJSON(patchDeploy.Spec.Template.Spec.Tolerations)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JSON-Patch-1"><a href="#JSON-Patch-1" class="headerlink" title="JSON Patch"></a>JSON Patch</h3><p>对于 JSON Patch 的话，似乎没有包能够像上面那样，通过两个对象计算出对应的 Patch，只能自行手动编写 Patch：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">JsonPatch2K8s</span><span class="hljs-params">()</span></span> &#123;<br>    deploy, dropFunc := initTestResource(<span class="hljs-literal">true</span>)<br>    <span class="hljs-keyword">if</span> dropFunc != <span class="hljs-literal">nil</span> &#123;<br>       <span class="hljs-keyword">defer</span> dropFunc()<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;before patch: &quot;</span>)<br>    printhelper.ObjJSON(deploy.Spec.Template.Spec.Containers)<br>    printhelper.ObjJSON(deploy.Spec.Template.Spec.Tolerations)<br><br>    cli := helper.NewClientSetOrDie()<br>    patchData := []<span class="hljs-type">byte</span>(<span class="hljs-string">`</span><br><span class="hljs-string">[</span><br><span class="hljs-string">  &#123;</span><br><span class="hljs-string">    &quot;op&quot;: &quot;add&quot;,</span><br><span class="hljs-string">    &quot;path&quot;: &quot;/metadata/labels&quot;,</span><br><span class="hljs-string">    &quot;value&quot;: &#123;</span><br><span class="hljs-string">       &quot;new-labels&quot;: &quot;new-value&quot;,</span><br><span class="hljs-string">       &quot;patch&quot;: &quot;true&quot;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  &#125;,</span><br><span class="hljs-string">  &#123;</span><br><span class="hljs-string">    &quot;op&quot;: &quot;add&quot;,</span><br><span class="hljs-string">    &quot;path&quot;: &quot;/spec/template/spec/containers/1&quot;,</span><br><span class="hljs-string">    &quot;value&quot;: </span><br><span class="hljs-string">      &#123;</span><br><span class="hljs-string">        &quot;name&quot;: &quot;patch-demo-ctr-2&quot;,</span><br><span class="hljs-string">        &quot;image&quot;: &quot;redis&quot;</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">  &#125;,</span><br><span class="hljs-string">  &#123;</span><br><span class="hljs-string">    &quot;op&quot;: &quot;add&quot;,</span><br><span class="hljs-string">    &quot;path&quot;: &quot;/spec/template/spec/tolerations&quot;,</span><br><span class="hljs-string">    &quot;value&quot;: [</span><br><span class="hljs-string">      &#123;</span><br><span class="hljs-string">        &quot;effect&quot;: &quot;NoSchedule&quot;,</span><br><span class="hljs-string">        &quot;key&quot;: &quot;disktype&quot;,</span><br><span class="hljs-string">        &quot;value&quot;: &quot;ssd&quot;</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">    ]</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">]</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span>)<br>    patchDeploy, err := cli.AppsV1().Deployments(<br>       metav1.NamespaceDefault).Patch(context.TODO(), deploy.Name, types.JSONPatchType, patchData, metav1.PatchOptions&#123;&#125;)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;after patch: &quot;</span>)<br>    printhelper.ObjJSON(patchDeploy.Spec.Template.Spec.Containers)<br>    printhelper.ObjJSON(patchDeploy.Spec.Template.Spec.Tolerations)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Merge-Patch"><a href="#Merge-Patch" class="headerlink" title="Merge Patch"></a>Merge Patch</h3><p>Merge Patch 的话可以通过 jsonpatch.CreateMergePatch 计算出 Patch。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MergePatch2K8sUseCreateMergePatch</span><span class="hljs-params">()</span></span> &#123;<br>deploy, dropFunc := initTestResource(<span class="hljs-literal">true</span>)<br><span class="hljs-keyword">if</span> dropFunc != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">defer</span> dropFunc()<br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;before patch: &quot;</span>)<br>printhelper.ObjJSON(deploy.Spec.Template.Spec.Containers)<br>printhelper.ObjJSON(deploy.Spec.Template.Spec.Tolerations)<br><br>newDeploy := deploy.DeepCopy()<br>newDeploy.Spec.Template.Spec.Containers = <span class="hljs-built_in">append</span>(deploy.Spec.Template.Spec.Containers, corev1.Container&#123;<br>Name:  <span class="hljs-string">&quot;patch-demo-ctr-2&quot;</span>,<br>Image: <span class="hljs-string">&quot;redis&quot;</span>,<br>&#125;)<br>newDeploy.Spec.Template.Spec.Tolerations = newDeploy.Spec.Template.Spec.Tolerations[:<span class="hljs-number">0</span>]<br>newDeploy.Spec.Template.Spec.Tolerations = <span class="hljs-built_in">append</span>(newDeploy.Spec.Template.Spec.Tolerations, corev1.Toleration&#123;<br>Key:               <span class="hljs-string">&quot;disktype&quot;</span>,<br>Operator:          <span class="hljs-string">&quot;&quot;</span>,<br>Value:             <span class="hljs-string">&quot;ssd&quot;</span>,<br>Effect:            <span class="hljs-string">&quot;NoSchedule&quot;</span>,<br>TolerationSeconds: <span class="hljs-literal">nil</span>,<br>&#125;)<br><br>origin, err := json.Marshal(deploy)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>mod, err := json.Marshal(newDeploy)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>cli := helper.NewClientSetOrDie()<br><br><span class="hljs-comment">// patchData 根据 origin 和 mod 生成 patch</span><br>patchData, err := jsonpatch.CreateMergePatch(origin, mod)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;patch data: &quot;</span>, <span class="hljs-type">string</span>(patchData))<br><br>patchDeploy, err := cli.AppsV1().Deployments(<br>metav1.NamespaceDefault).Patch(context.TODO(), deploy.Name, types.MergePatchType, patchData, metav1.PatchOptions&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;after patch: &quot;</span>)<br>printhelper.ObjJSON(patchDeploy.Spec.Template.Spec.Containers)<br>printhelper.ObjJSON(patchDeploy.Spec.Template.Spec.Tolerations)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Apply-Patch"><a href="#Apply-Patch" class="headerlink" title="Apply Patch"></a>Apply Patch</h3><p>这种方式貌似网上找不到什么资料，先搁置</p><h1 id="Patch-和-Update-的区别"><a href="#Patch-和-Update-的区别" class="headerlink" title="Patch 和 Update 的区别"></a>Patch 和 Update 的区别</h1><h3 id="Update-机制"><a href="#Update-机制" class="headerlink" title="Update 机制"></a>Update 机制</h3><p>Kubernetes 中的所有资源对象，都有一个全局唯一的版本号（metadata.resourceVersion）。每个资源对象从创建开始就会有一个版本号，而后每次被修改（不管是 update 还是 patch 修改），版本号都会发生变化。</p><p><a href="https://mp.weixin.qq.com/s/jWH7jVxj20bmc60_C-w9wQ">官方文档 </a> 告诉我们，这个版本号是一个 K8s 的内部机制，用户不应该假设它是一个数字或者通过比较两个版本号大小来确定资源对象的新旧，唯一能做的就是通过比较版本号相等来确定对象是否是同一个版本（即是否发生了变化）。而 resourceVersion 一个重要的用处，就是来做 update 请求的版本控制。</p><p>K8s 要求用户 update 请求中提交的对象必须带有 resourceVersion，也就是说我们提交 update 的数据必须先来源于 K8s 中已经存在的对象。因此，一次完整的 update 操作流程是：</p><ol><li>首先，从 K8s 中拿到一个已经存在的对象（可以选择直接从 K8s 中查询；如果在客户端做了 list watch，推荐从本地 informer 中获取）；</li><li>然后，基于这个取出来的对象做一些修改，比如将 Deployment 中的 replicas 做增减，或是将 image 字段修改为一个新版本的镜像；</li><li>最后，将修改后的对象通过 update 请求提交给 K8s；</li><li>此时，kube-apiserver 会校验用户 update 请求提交对象中的 resourceVersion 一定要和当前 K8s 中这个对象最新的 resourceVersion 一致，才能接受本次 update。否则，K8s 会拒绝请求，并告诉用户发生了版本冲突（Conflict）。</li></ol><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/k8s_update.png"></p><p>上图展示了多个用户同时 update 某一个资源对象时会发生的事情。而如果如果发生了 Conflict 冲突，对于 User A 而言应该做的就是做一次重试，再次获取到最新版本的对象，修改后重新提交 update。</p><h3 id="Patch-机制"><a href="#Patch-机制" class="headerlink" title="Patch 机制"></a>Patch 机制</h3><p>相比于 update 的版本控制，K8s 的 patch 机制则显得更加简单。</p><p>当用户对某个资源对象提交一个 patch 请求时，kube-apiserver 不会考虑版本问题，而是“无脑”地接受用户的请求（只要请求发送的 patch 内容合法），也就是将 patch 打到对象上、同时更新版本号。</p><h1 id="参考-x2F-抄袭"><a href="#参考-x2F-抄袭" class="headerlink" title="参考&#x2F;抄袭"></a>参考&#x2F;抄袭</h1><p>&#x2F;&#x2F; +Patch 类型相关</p><p><a href="https://fafucoder.github.io/2020/09/09/kubernetes-update-patch/">kubernetes update跟patch区别</a></p><p><a href="https://www.jianshu.com/p/8eb47409bc6d">k8s patch 的几种方式</a></p><p><a href="https://erosb.github.io/post/json-patch-vs-merge-patch/">JSON Patch and JSON Merge Patch</a>&#x2F;&#x2F; +介绍了两种方式的区别</p><p><a href="https://kubernetes.io/zh-cn/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/">使用 kubectl patch 更新 API 对象</a></p><p>&#x2F;&#x2F; +Patch 和 Update 的区别</p><p><a href="https://mp.weixin.qq.com/s/jWH7jVxj20bmc60_C-w9wQ">理解 K8s 资源更新机制，从一个 OpenKruise 用户疑问开始</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go net/http Transport 源码阅读</title>
    <link href="/2023/09/30/go-http-transport/"/>
    <url>/2023/09/30/go-http-transport/</url>
    
    <content type="html"><![CDATA[<p>涉及到的内容非常多</p><h1 id="关键的-struct"><a href="#关键的-struct" class="headerlink" title="关键的 struct"></a>关键的 struct</h1><ul><li><p>transferWriter：负责将 Request 或 Response 的内容写入到 http 底层的 TCP 连接（更准确的说法是根据 go http 库里面的 Request 和 Response 这两个 struct 的信息，构建出相应的 http 请求和响应报文，然后写入到连接）</p></li><li><p>Request：</p></li><li><p>persistConn：</p></li></ul><h1 id="暂时不关注的地方"><a href="#暂时不关注的地方" class="headerlink" title="暂时不关注的地方"></a>暂时不关注的地方</h1><ol><li>proxy 相关</li><li>TLS 相关</li><li>HTTP2 相关</li><li>http trace 相关</li></ol><h1 id="transferWriter"><a href="#transferWriter" class="headerlink" title="transferWriter"></a>transferWriter</h1><h2 id="writeHeader"><a href="#writeHeader" class="headerlink" title="writeHeader"></a>writeHeader</h2><p>根据 t 的信息，构建出 http request 的 header 部分，并写入到 w</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 根据 t 的信息，构建出 http request 的 header 部分，并写入到 w</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *transferWriter)</span></span> writeHeader(w io.Writer, trace *httptrace.ClientTrace) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> t.Close &amp;&amp; !hasToken(t.Header.get(<span class="hljs-string">&quot;Connection&quot;</span>), <span class="hljs-string">&quot;close&quot;</span>) &#123;<br><span class="hljs-keyword">if</span> _, err := io.WriteString(w, <span class="hljs-string">&quot;Connection: close\r\n&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> trace != <span class="hljs-literal">nil</span> &amp;&amp; trace.WroteHeaderField != <span class="hljs-literal">nil</span> &#123;<br>trace.WroteHeaderField(<span class="hljs-string">&quot;Connection&quot;</span>, []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;close&quot;</span>&#125;)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Write Content-Length and/or Transfer-Encoding whose values are a</span><br><span class="hljs-comment">// function of the sanitized field triple (Body, ContentLength,</span><br><span class="hljs-comment">// TransferEncoding)</span><br><span class="hljs-comment">// 下面就是根据 t 的信息去填充一些请求头，比如 Content-Length and/or Transfer-Encoding </span><br><br><span class="hljs-comment">// 判断请求头是否需要携带 Content-Length</span><br><span class="hljs-keyword">if</span> t.shouldSendContentLength() &#123;<br><span class="hljs-keyword">if</span> _, err := io.WriteString(w, <span class="hljs-string">&quot;Content-Length: &quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> _, err := io.WriteString(w, strconv.FormatInt(t.ContentLength, <span class="hljs-number">10</span>)+<span class="hljs-string">&quot;\r\n&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> trace != <span class="hljs-literal">nil</span> &amp;&amp; trace.WroteHeaderField != <span class="hljs-literal">nil</span> &#123;<br>trace.WroteHeaderField(<span class="hljs-string">&quot;Content-Length&quot;</span>, []<span class="hljs-type">string</span>&#123;strconv.FormatInt(t.ContentLength, <span class="hljs-number">10</span>)&#125;)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> chunked(t.TransferEncoding) &#123;<br><span class="hljs-keyword">if</span> _, err := io.WriteString(w, <span class="hljs-string">&quot;Transfer-Encoding: chunked\r\n&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> trace != <span class="hljs-literal">nil</span> &amp;&amp; trace.WroteHeaderField != <span class="hljs-literal">nil</span> &#123;<br>trace.WroteHeaderField(<span class="hljs-string">&quot;Transfer-Encoding&quot;</span>, []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;chunked&quot;</span>&#125;)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Write Trailer header</span><br><span class="hljs-comment">// http trailer header，这个具体可以查一下，大致是得配合 http chunckd 使用，在发送完 body 后（也就是发送 0\r\n）</span><br><span class="hljs-comment">// 可以再接着发送 trailer 里面设置的 header</span><br><span class="hljs-comment">// 具体可以看这篇博客：https://github.com/ma6174/blog/issues/22</span><br><span class="hljs-keyword">if</span> t.Trailer != <span class="hljs-literal">nil</span> &#123;<br>keys := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(t.Trailer))<br><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> t.Trailer &#123;<br>k = CanonicalHeaderKey(k)<br><span class="hljs-keyword">switch</span> k &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Transfer-Encoding&quot;</span>, <span class="hljs-string">&quot;Trailer&quot;</span>, <span class="hljs-string">&quot;Content-Length&quot;</span>:<br><span class="hljs-keyword">return</span> badStringError(<span class="hljs-string">&quot;invalid Trailer key&quot;</span>, k)<br>&#125;<br>keys = <span class="hljs-built_in">append</span>(keys, k)<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(keys) &gt; <span class="hljs-number">0</span> &#123;<br>sort.Strings(keys)<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> could do better allocation-wise here, but trailers are rare,</span><br><span class="hljs-comment">// so being lazy for now.</span><br><span class="hljs-keyword">if</span> _, err := io.WriteString(w, <span class="hljs-string">&quot;Trailer: &quot;</span>+strings.Join(keys, <span class="hljs-string">&quot;,&quot;</span>)+<span class="hljs-string">&quot;\r\n&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> trace != <span class="hljs-literal">nil</span> &amp;&amp; trace.WroteHeaderField != <span class="hljs-literal">nil</span> &#123;<br>trace.WroteHeaderField(<span class="hljs-string">&quot;Trailer&quot;</span>, keys)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><br><span class="hljs-comment">// 判断请求头是否需要携带 Content-Length</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *transferWriter)</span></span> shouldSendContentLength() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// 使用 Transfer-Encoding: chunked 头部来分块传输请求主体，而不需要提前知道主体的总长度。这时不需要发送 Content-Length 头部</span><br><span class="hljs-keyword">if</span> chunked(t.TransferEncoding) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> t.ContentLength &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">if</span> t.ContentLength &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// Many servers expect a Content-Length for these methods</span><br><span class="hljs-keyword">if</span> t.Method == <span class="hljs-string">&quot;POST&quot;</span> || t.Method == <span class="hljs-string">&quot;PUT&quot;</span> || t.Method == <span class="hljs-string">&quot;PATCH&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-comment">// Transfer-Encoding: identity 表示消息主体没有经过任何编码，它是原始的、未经压缩或分块处理的数据。</span><br><span class="hljs-keyword">if</span> t.ContentLength == <span class="hljs-number">0</span> &amp;&amp; isIdentity(t.TransferEncoding) &#123;<br><span class="hljs-keyword">if</span> t.Method == <span class="hljs-string">&quot;GET&quot;</span> || t.Method == <span class="hljs-string">&quot;HEAD&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Transport"><a href="#Transport" class="headerlink" title="Transport"></a>Transport</h1><h2 id="连接池相关"><a href="#连接池相关" class="headerlink" title="连接池相关"></a>连接池相关</h2><h3 id="tryPutIdleConn"><a href="#tryPutIdleConn" class="headerlink" title="tryPutIdleConn"></a>tryPutIdleConn</h3><h3 id="queueForIdleConn"><a href="#queueForIdleConn" class="headerlink" title="queueForIdleConn"></a>queueForIdleConn</h3><h3 id="dialConn"><a href="#dialConn" class="headerlink" title="dialConn"></a>dialConn</h3><h2 id="roundTrip"><a href="#roundTrip" class="headerlink" title="roundTrip"></a>roundTrip</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// roundTrip implements a RoundTripper over HTTP.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Transport)</span></span> roundTrip(req *Request) (*Response, <span class="hljs-type">error</span>) &#123;<br>t.nextProtoOnce.Do(t.onceSetNextProtoDefaults)<br>ctx := req.Context()<br>trace := httptrace.ContextClientTrace(ctx)<br><br><span class="hljs-keyword">if</span> req.URL == <span class="hljs-literal">nil</span> &#123;<br>req.closeBody()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;http: nil Request.URL&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> req.Header == <span class="hljs-literal">nil</span> &#123;<br>req.closeBody()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;http: nil Request.Header&quot;</span>)<br>&#125;<br>scheme := req.URL.Scheme<br>isHTTP := scheme == <span class="hljs-string">&quot;http&quot;</span> || scheme == <span class="hljs-string">&quot;https&quot;</span><br>  <span class="hljs-comment">// 如果 req.scheme 是 http，那么需要校验请求头 key/value 的有效性，即是否符合 http 规范</span><br><span class="hljs-keyword">if</span> isHTTP &#123;<br><span class="hljs-keyword">for</span> k, vv := <span class="hljs-keyword">range</span> req.Header &#123;<br><span class="hljs-keyword">if</span> !httpguts.ValidHeaderFieldName(k) &#123;<br>req.closeBody()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;net/http: invalid header field name %q&quot;</span>, k)<br>&#125;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> vv &#123;<br><span class="hljs-keyword">if</span> !httpguts.ValidHeaderFieldValue(v) &#123;<br>req.closeBody()<br><span class="hljs-comment">// Don&#x27;t include the value in the error, because it may be sensitive.</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;net/http: invalid header field value for %q&quot;</span>, k)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br>origReq := req<br>cancelKey := cancelKey&#123;origReq&#125;<br>  <span class="hljs-comment">// 没搞明白 setupRewindBody 这个函数的作用，先不管了</span><br>req = setupRewindBody(req)<br><br>  <span class="hljs-comment">// 判断是否使用注册的 RoundTrip 来处理对应的 scheme</span><br>  <span class="hljs-comment">// 关于这块这里可以移步 RegisterProtocol 这一节，简单的说，就是 transport 提供了一个 RegisterProtocol 方法，可以</span><br>  <span class="hljs-comment">// 让用户自行设定 scheme 对应的 RoundTrip，然后下面这段逻辑就是判断是否当前 req 的 scheme 是否需要走用户自行设定的</span><br>  <span class="hljs-comment">// RoundTrip 的，不过里面还有一些细节处理，比如如果 scheme 是 https，或者是 websocket 升级的请求（即 header 里拥有 </span><br>  <span class="hljs-comment">// Connection: Upgrade 和 Upgrade: websocket 这两个 kv 的请求）是不会走自定义 RoundTrip 的</span><br>  <span class="hljs-comment">// （为啥 websocket 升级请求不走 RounTrip？）</span><br><span class="hljs-keyword">if</span> altRT := t.alternateRoundTripper(req); altRT != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 有的话，调用自定义的 RoundTrip() 对 req 进行处理，并且返回 resp</span><br><span class="hljs-keyword">if</span> resp, err := altRT.RoundTrip(req); err != ErrSkipAltProtocol &#123;<br><span class="hljs-keyword">return</span> resp, err<br>&#125;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>req, err = rewindBody(req)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br>  <span class="hljs-comment">// 后续仅处理 URL scheme 为 http 或 https 的连接</span><br><span class="hljs-keyword">if</span> !isHTTP &#123;<br>req.closeBody()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, badStringError(<span class="hljs-string">&quot;unsupported protocol scheme&quot;</span>, scheme)<br>&#125;<br>  <span class="hljs-comment">// 做一些校验，不多赘述</span><br><span class="hljs-keyword">if</span> req.Method != <span class="hljs-string">&quot;&quot;</span> &amp;&amp; !validMethod(req.Method) &#123;<br>req.closeBody()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;net/http: invalid method %q&quot;</span>, req.Method)<br>&#125;<br><span class="hljs-keyword">if</span> req.URL.Host == <span class="hljs-string">&quot;&quot;</span> &#123;<br>req.closeBody()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;http: no Host in request URL&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>req.closeBody()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ctx.Err()<br><span class="hljs-keyword">default</span>:<br>&#125;<br><br><span class="hljs-comment">// treq gets modified by roundTrip, so we need to recreate for each retry.</span><br>treq := &amp;transportRequest&#123;Request: req, trace: trace, cancelKey: cancelKey&#125;<br>cm, err := t.connectMethodForRequest(treq)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>req.closeBody()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-comment">// Get the cached or newly-created connection to either the</span><br><span class="hljs-comment">// host (for http or https), the http proxy, or the http proxy</span><br><span class="hljs-comment">// pre-CONNECTed to https server. In any case, we&#x27;ll be ready</span><br><span class="hljs-comment">// to send it requests.</span><br>pconn, err := t.getConn(treq, cm)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>t.setReqCanceler(cancelKey, <span class="hljs-literal">nil</span>)<br>req.closeBody()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">var</span> resp *Response<br><span class="hljs-keyword">if</span> pconn.alt != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// HTTP/2 path.</span><br>t.setReqCanceler(cancelKey, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// not cancelable with CancelRequest</span><br>resp, err = pconn.alt.RoundTrip(req)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>resp, err = pconn.roundTrip(treq)<br>&#125;<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>resp.Request = origReq<br><span class="hljs-keyword">return</span> resp, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Failed. Clean up and determine whether to retry.</span><br><span class="hljs-keyword">if</span> http2isNoCachedConnError(err) &#123;<br><span class="hljs-keyword">if</span> t.removeIdleConn(pconn) &#123;<br>t.decConnsPerHost(pconn.cacheKey)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> !pconn.shouldRetryRequest(req, err) &#123;<br><span class="hljs-comment">// Issue 16465: return underlying net.Conn.Read error from peek,</span><br><span class="hljs-comment">// as we&#x27;ve historically done.</span><br><span class="hljs-keyword">if</span> e, ok := err.(nothingWrittenError); ok &#123;<br>err = e.<span class="hljs-type">error</span><br>&#125;<br><span class="hljs-keyword">if</span> e, ok := err.(transportReadFromServerError); ok &#123;<br>err = e.err<br>&#125;<br><span class="hljs-keyword">if</span> b, ok := req.Body.(*readTrackingBody); ok &amp;&amp; !b.didClose &#123;<br><span class="hljs-comment">// Issue 49621: Close the request body if pconn.roundTrip</span><br><span class="hljs-comment">// didn&#x27;t do so already. This can happen if the pconn</span><br><span class="hljs-comment">// write loop exits without reading the write request.</span><br>req.closeBody()<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>testHookRoundTripRetried()<br><br><span class="hljs-comment">// Rewind the body if we&#x27;re able to.</span><br>req, err = rewindBody(req)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="getConn"><a href="#getConn" class="headerlink" title="getConn"></a>getConn</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// getConn dials and creates a new persistConn to the target as</span><br><span class="hljs-comment">// specified in the connectMethod. This includes doing a proxy CONNECT</span><br><span class="hljs-comment">// and/or setting up TLS.  If this doesn&#x27;t return an error, the persistConn</span><br><span class="hljs-comment">// is ready to write requests to.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Transport)</span></span> getConn(treq *transportRequest, cm connectMethod) (pc *persistConn, err <span class="hljs-type">error</span>) &#123;<br>req := treq.Request<br>trace := treq.trace<br>ctx := req.Context()<br><span class="hljs-keyword">if</span> trace != <span class="hljs-literal">nil</span> &amp;&amp; trace.GetConn != <span class="hljs-literal">nil</span> &#123;<br>trace.GetConn(cm.addr())<br>&#125;<br><br>w := &amp;wantConn&#123;<br>cm:         cm,<br>key:        cm.key(),<br>ctx:        ctx,<br>ready:      <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>),<br>beforeDial: testHookPrePendingDial,<br>afterDial:  testHookPostPendingDial,<br>&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>w.cancel(t, err)<br>&#125;<br>&#125;()<br><br><span class="hljs-comment">// Queue for idle connection.</span><br><span class="hljs-keyword">if</span> delivered := t.queueForIdleConn(w); delivered &#123;<br>pc := w.pc<br><span class="hljs-comment">// Trace only for HTTP/1.</span><br><span class="hljs-comment">// HTTP/2 calls trace.GotConn itself.</span><br><span class="hljs-keyword">if</span> pc.alt == <span class="hljs-literal">nil</span> &amp;&amp; trace != <span class="hljs-literal">nil</span> &amp;&amp; trace.GotConn != <span class="hljs-literal">nil</span> &#123;<br>trace.GotConn(pc.gotIdleConnTrace(pc.idleAt))<br>&#125;<br><span class="hljs-comment">// set request canceler to some non-nil function so we</span><br><span class="hljs-comment">// can detect whether it was cleared between now and when</span><br><span class="hljs-comment">// we enter roundTrip</span><br>t.setReqCanceler(treq.cancelKey, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">error</span>)</span></span> &#123;&#125;)<br><span class="hljs-keyword">return</span> pc, <span class="hljs-literal">nil</span><br>&#125;<br><br>cancelc := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, <span class="hljs-number">1</span>)<br>t.setReqCanceler(treq.cancelKey, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> &#123; cancelc &lt;- err &#125;)<br><br><span class="hljs-comment">// Queue for permission to dial.</span><br>t.queueForDial(w)<br><br><span class="hljs-comment">// Wait for completion or cancellation.</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-w.ready:<br><span class="hljs-comment">// Trace success but only for HTTP/1.</span><br><span class="hljs-comment">// HTTP/2 calls trace.GotConn itself.</span><br><span class="hljs-keyword">if</span> w.pc != <span class="hljs-literal">nil</span> &amp;&amp; w.pc.alt == <span class="hljs-literal">nil</span> &amp;&amp; trace != <span class="hljs-literal">nil</span> &amp;&amp; trace.GotConn != <span class="hljs-literal">nil</span> &#123;<br>trace.GotConn(httptrace.GotConnInfo&#123;Conn: w.pc.conn, Reused: w.pc.isReused()&#125;)<br>&#125;<br><span class="hljs-keyword">if</span> w.err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// If the request has been canceled, that&#x27;s probably</span><br><span class="hljs-comment">// what caused w.err; if so, prefer to return the</span><br><span class="hljs-comment">// cancellation error (see golang.org/issue/16049).</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-req.Cancel:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errRequestCanceledConn<br><span class="hljs-keyword">case</span> &lt;-req.Context().Done():<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, req.Context().Err()<br><span class="hljs-keyword">case</span> err := &lt;-cancelc:<br><span class="hljs-keyword">if</span> err == errRequestCanceled &#123;<br>err = errRequestCanceledConn<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// return below</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> w.pc, w.err<br><span class="hljs-keyword">case</span> &lt;-req.Cancel:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errRequestCanceledConn<br><span class="hljs-keyword">case</span> &lt;-req.Context().Done():<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, req.Context().Err()<br><span class="hljs-keyword">case</span> err := &lt;-cancelc:<br><span class="hljs-keyword">if</span> err == errRequestCanceled &#123;<br>err = errRequestCanceledConn<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="persistConn"><a href="#persistConn" class="headerlink" title="persistConn"></a>persistConn</h1><h2 id="readLoop"><a href="#readLoop" class="headerlink" title="readLoop"></a>readLoop</h2><h2 id="writeLoop"><a href="#writeLoop" class="headerlink" title="writeLoop"></a>writeLoop</h2><h2 id="roundTrip-1"><a href="#roundTrip-1" class="headerlink" title="roundTrip"></a>roundTrip</h2><p>一个 http 事务的流程，接收一个 request，返回一个 response</p><h1 id="wantConnQueue"><a href="#wantConnQueue" class="headerlink" title="wantConnQueue"></a>wantConnQueue</h1><h1 id="wantConn"><a href="#wantConn" class="headerlink" title="wantConn"></a>wantConn</h1><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="RegisterProtocol"><a href="#RegisterProtocol" class="headerlink" title="RegisterProtocol"></a>RegisterProtocol</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> fooProto <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fooProto)</span></span> RoundTrip(req *http.Request) (*http.Response, <span class="hljs-type">error</span>) &#123;<br>res := &amp;http.Response&#123;<br>Status:     <span class="hljs-string">&quot;200 OK&quot;</span>,<br>StatusCode: <span class="hljs-number">200</span>,<br>Header:     <span class="hljs-built_in">make</span>(http.Header),<br>Body:       io.NopCloser(strings.NewReader(<span class="hljs-string">&quot;You wanted &quot;</span> + req.URL.String())),<br>&#125;<br><span class="hljs-keyword">return</span> res, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tr := &amp;http.Transport&#123;&#125;<br>c := &amp;http.Client&#123;Transport: tr&#125;<br><span class="hljs-comment">// 注册一个新的协议 foo 到 transport，并且用 fooProto 这个 RoundTripper 来处理该协议</span><br>tr.RegisterProtocol(<span class="hljs-string">&quot;foo&quot;</span>, fooProto&#123;&#125;)<br><span class="hljs-comment">// 请求的 url scheme 为 foo，这样就会走我们自定义的 RoundTripper 了</span><br>res, err := c.Get(<span class="hljs-string">&quot;foo://bar.com/path&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>bodyb, err := io.ReadAll(res.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>body := <span class="hljs-type">string</span>(bodyb)<br><span class="hljs-keyword">if</span> e := <span class="hljs-string">&quot;You wanted foo://bar.com/path&quot;</span>; body != e &#123;<br>fmt.Errorf(<span class="hljs-string">&quot;got response %q, want %q&quot;</span>, body, e)<br>&#125;<br>fmt.Println(body)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac + Clashx Pro 构建网关旁路由</title>
    <link href="/2023/08/27/mac-clashx-bridge-mode/"/>
    <url>/2023/08/27/mac-clashx-bridge-mode/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间搞了台台式当服务器用，用的是 Windows + Linux 虚拟机的方式，然后 Windows 装上 Clash for windows 并且开启 Tun 模式，这样虚拟机也可以享受 Clash 的代理，但是使用过程中发现一个问题，就是这些虚拟机虽然能科学上网了，但是速度相比宿主机非常慢， 同样的一个 Github 上的包，在 Windows 上下载有几 m&#x2F;s 的速度，到了虚拟机这边只有 10k&#x2F;m，导致使用起来的体验非常差，也不知道是不是 Clash for windows 这个狗屎玩意的原因，为了解决这个问题，我在网上看到了一种使用旁路由的方法，大概意思就是让一台设备使用软件科学上网，然后将这台设备作为一个旁路由，让其他设备去连接它，连上以后直接就拥有了翻墙的能力，设备本身无需安装和配置任何工具，相当于是走了透明代理，非常方便，我手里刚好还有一台 Macbook，可以用这台来实验一下。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>首先 Mac 上需要安装好 Clashx Pro，注意是 Pro 而不是普通的 Clashx，因为只有 Pro 才有增强模式，装好以后配置好你的机场，然后开启 <strong>设置为系统代理</strong> 和 <strong>增强模式</strong> 这两个选项（允许局域网连接不开貌似也没影响），这些基本操作没什么好说的，效果如下：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/clashx1.jpg"></p><p>然后需要将 Mac 设置为静态 IP，在 【设置 - 网络 - Wi-Fi - 详细信息 - TCP&#x2F;IP】里，将 【配置 IPv4 】改为手动，然后设置你的 IP 地址，子网掩码等信息，IP 地址只要和路由器 IP 在同一网段即可，大概像下面这样：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/clashx2.jpg"></p><p>我这里的路由器 IP 是 192.168.31.1，然后子网掩码是 255.255.255.0，代表 192.168.31 这部分是网络号，那我们设置的静态 IP 就只需要改最后一部分即可，比如我改成了 192.168.31.254。</p><p>然后还需要注意一下这里的 DNS，这个 DNS 貌似是 Clashx 的 DNS，这个地方不需要改，而且后面其他设备连接时需要用到：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/clashx3.jpg"></p><p>设置完上面的东西以后，Mac 这边就算完事了，其他设备就可以连接这台旁路由了，连接方法如下：</p><p>将要连接的设备的 IP 也改为手动静态方式，IP 和子网掩码就不多说了，主要是路由器 IP（网关地址）和 DNS 这里，路由器 IP 要配置为 Mac 的 IP 地址（也就是我们前面给 Mac 设置好的静态 IP），DNS 就写 Clashx 的 DNS，比如 ios 可以配置成下面这样：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/clashx4.jpg"></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/clashx5.jpg"></p><p>没什么好说的，就是把路由器地址设置为 Mac 的 IP，然后 DNS 设置为固定的 198.18.0.2 即可。</p><p>Windows 也是一样的，只要注意配置的静态 IP 别和其他设备冲突即可，类似下面这样即可：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/clashx6.png"></p><p>Windows 还需要注意的一点是，得确认一下当前网络连接的设备是什么，直接改 WiFi 里面的配置可能无效，我这里就踩坑了，得去控制面板里看一下当前网络使用的网络设备，比如我这里就是 vEthernet 这个鬼东西，好像是 WSL 还是 hyper-v 给搞得一个东西：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/clashx7.png"></p><p>然后再去改这个设备的网络配置信息：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/clashx8.png"></p><p>然后就可以愉快的享受科学上网了~</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面提到的这种方法可能稍微麻烦一些，需要改每台连接设备的配置，好像还有一种修改路由器 DHCP 的方法，直接在路由器层面进行配置，这样其他设备就可以直接连接了，相对来说方便一些，我这里因为一些原因就先不实践了，具体可以看一下 <a href="https://qust.me/post/clashxProMac/">这篇文章</a>。</p><p>整体用下来感觉还不错，手机上用起来感觉速度比小火箭快一些，虚拟机里面下载 Github 包的速度也能上 m&#x2F;s 了，不过我这个机场不是太给力，经常报一些 SSL 错误和 EOF 错误，不过总体用下来比 CFW 的 Tun 模式还是要好不少的。</p><p>然后我这里还遇到一个问题，就是 Mac 上的 Clash 退出以后，Mac 就上不了网了，这种情况需要将网络设置重新改回自动分配 IP 地址。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://qust.me/post/clashxProMac/">https://qust.me/post/clashxProMac/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式锁实现</title>
    <link href="/2023/07/26/redis-fen-bu-shi-suo/"/>
    <url>/2023/07/26/redis-fen-bu-shi-suo/</url>
    
    <content type="html"><![CDATA[<h1 id="何为分布式锁"><a href="#何为分布式锁" class="headerlink" title="何为分布式锁"></a>何为分布式锁</h1><p>分布式锁其实和普通的锁（比如 go 里面的 sync.Mutex）类似，也是用来保护同一资源的互斥访问，避免出现竞争条件和数据不一致等问题的一种手段罢了，只不过相比普通的锁而言，其针对的是分布式场景，也就是说，分布式锁可以跨进程使用，这是其和普通锁的根本区别。比如我在服务器 A 上运行了 a 进程，在服务器 B 上运行了 b 进程，如果想让这两个进程互斥的访问同一个资源，那普通的 sync.Mutex 肯定是不行的，因为这都是两台独立的机器了，就算是同一台机器上的两个进程，它们彼此之间也是独立的，地址空间都不一样，普通的锁一样也无法工作，这个时候就必须得上分布式锁了。</p><h1 id="如何实现（基于-Redis）"><a href="#如何实现（基于-Redis）" class="headerlink" title="如何实现（基于 Redis）"></a>如何实现（基于 Redis）</h1><p>跨进程通信的一个常规方法就是通过网络，所以一般实现分布式锁都需要依赖一个外部中间件，比如 Redis 之类的，然后不同的进程通过网络去操作这个中间件，来实现类似锁的功能。比如如果是 Redis 实现的话，大致逻辑就是二者去操作同一个 key，加锁就是 set key，如果该 key 不存在则说明加锁成功，否则说明该锁已经被别人拿到了，该进程需要阻塞等待，就和 sync.Mutex 的工作机制一毛一样，同理，解锁就是 delete 掉这个 key。当然这只是一个大致的逻辑，实际的实现会有很多细节上的考虑。</p><p>实现分布式锁有以下几个要点：</p><ol><li>互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li></ol><p>基于上面几点，可以给出基于 redis 实现的分布式锁的加锁伪代码：</p><h2 id="初版代码"><a href="#初版代码" class="headerlink" title="初版代码"></a>初版代码</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">if</span> (<span class="hljs-title function_">setnx</span>(<span class="hljs-built_in">key</span>, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-title function_">expire</span>(<span class="hljs-built_in">key</span>, <span class="hljs-number">30</span>)<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// TODO 业务逻辑</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-title function_">del</span>(<span class="hljs-built_in">key</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑很简单，先执行 setnx 设置 key，如果返回 1 表示该 key 不存在，也就代表当前进程可以持有锁，这样就满足了上面的要点 1：互斥性。接下来为这个锁设置过期时间，这样就能保证在当前持有锁的进程因为特殊原因挂掉，无法正常解锁这种意外情况下，锁依然能够被释放，一定程度避免了死锁的发生，满足了第 2 个要点。但是第 3 点这里的代码没有体现，只是简单的 delete 掉这个 key，这里后面会展开讨论。</p><p>上述锁实现方式存在一些问题：</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><h3 id="1-SETNX-和-EXPIRE-非原子性"><a href="#1-SETNX-和-EXPIRE-非原子性" class="headerlink" title="1. SETNX 和 EXPIRE 非原子性"></a>1. SETNX 和 EXPIRE 非原子性</h3><p>比如执行完 <code>if (setnx(key, 1) == 1) </code> 这一行了，但在继续执行 <code>expire(key, 30)</code> 之前，程序崩溃了，导致这个 key 没有被设置过期时间，从而变成死锁。根本原因就在于这两个命令是非原子性的，也就是说它们不是一个整体，可能存在一个命令执行成功，一个执行失败的情况。</p><p>其实上面的这个实现有点老了，redis 已经废弃掉了 setnx 这个命令，在 <a href="https://redis.io/commands/setnx/">redis 官方文档</a> 中也已经给出了说明：</p><blockquote><p>SETNX (deprecated)</p><p>As of Redis version 2.6.12, this command is regarded as deprecated.</p><p>It can be replaced by <a href="https://redis.io/commands/set"><code>SET</code></a> with the <code>NX</code> argument when migrating or writing new code.</p></blockquote><p>正如文档所说，新的实现方式是使用 <code>SET</code> 命令，并且追加 <code>NX</code> 参数，表示不存在时才执行，此外该命令同样还提供了 <code>EX</code> 和 <code>PX</code> 参数，用于指定该 key 的过期时间，EX 和 PX 分别表示过期时间的单位为秒和毫秒，这样一来，之前的两条命令就可以整合成类似 <code>SET KEYS[1] ARGV[1] PX ARGV[2] NX</code> 这样的一条命令，也就不存在非原子的问题了。</p><p>此外还存在一种情况，就是项目依赖的 redis 版本比较老，只能用 SETNX 命令，这种情况下就只能使用 lua 脚本来实现原子性了，比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;setnx&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]) &lt; <span class="hljs-number">1</span>)<br><span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span>;<br>redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">2</span>]));<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>// 使用实例<br>EVAL <span class="hljs-string">&quot;if (redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]) &lt; 1) then return 0; end; redis.call(&#x27;expire&#x27;,KEYS[1],tonumber(ARGV[2])); return 1;&quot;</span> <span class="hljs-number">1</span> key value <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h3 id="2-锁误解除"><a href="#2-锁误解除" class="headerlink" title="2. 锁误解除"></a>2. 锁误解除</h3><p>正如我们之前所说，要点 3 中的 <code>解铃还须系铃人</code> 这一点在开头的初版伪代码中没有体现，这里先来说一下，什么情况下，会发生锁误解除这种情况：</p><table><thead><tr><th></th><th>进程 A</th><th>进程 B</th></tr></thead><tbody><tr><td>时间 T1</td><td>拿到分布式锁</td><td></td></tr><tr><td>时间 T2</td><td></td><td>尝试获取锁，但是锁已被占用，阻塞等待</td></tr><tr><td>…</td><td>业务处理</td><td></td></tr><tr><td></td><td>达到锁的超时时间，锁被释放</td><td></td></tr><tr><td></td><td></td><td>拿到锁</td></tr><tr><td></td><td>业务处理完成</td><td></td></tr><tr><td></td><td>继续执行下面的释放锁代码</td><td></td></tr><tr><td></td><td>释放锁（但是此时锁已经被 B 持有了，也就是释放了不属于自己的锁）</td><td></td></tr></tbody></table><p>解决办法也很简单：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">// 加锁<br>String uuid = UUID.randomUUID().toString().replaceAll(<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>SET key uuid NX EX <span class="hljs-number">30</span><br><br>// 解锁<br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>我们首先需要某个东西用来标识当前进程，然后在获取锁操作 set 操作中，将这个东西作为 value 设置给这个 key，比如上面的代码中，使用了 uuid 来作为一个标识，同时用一个变量保存，然后执行 <code>SET key uuid NX EX 30</code> 将其设置为 value。在解锁时，需要先 get 一下这个 key，看看它的 value 还是不是我们之前创建的标识（我们将其用一个变量保存起来了，所以使用这个变量对比即可），如果是的话，就说明这个锁还是属于当前进程的，那么就可以正常释放，也就是执行接下来的 <code>del</code> 语句，否则则说明这个锁已经被过期释放，被另一个进程占用了，那我们就不能释放这个锁了。</p><p><strong>锁误解除会导致什么问题？</strong>比如当前持有锁的是进程 B，但是因为上面提到的原因，进程 A 把该锁给误释放了，然后另一个尝试获取锁的进程 C 此时拿到了锁，执行它的业务，然后 B 此时也在执行自己的业务，这导致同一时间 B 和 C 都在处理业务，发生这种现象的原因就在于本来应该由 B 在其执行完自己的业务后自行释放锁，但是现在 A 错误的把锁释放了。</p><p>需要注意的是，我们的 <strong>解锁代码是使用 lua 实现的</strong>，在 redis 中，使用 lua 脚本可以保证原子性，为什么要这么做呢？看下面这种情况：</p><p>下面这段代码是使用 Java 实现的，思路基本一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wrongReleaseLock2</span><span class="hljs-params">(Jedis jedis, String lockKey, String requestId)</span> &#123;<br>    <span class="hljs-comment">// 判断加锁与解锁是不是同一个客户端</span><br>    <span class="hljs-keyword">if</span> (requestId.equals(jedis.get(lockKey))) &#123;<br>        jedis.del(lockKey);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码看起来没什么问题，但是存在这样一种极端情况：</p><ol><li><p>当前进程 A 走到 <code>if (requestId.equals(jedis.get(lockKey)))</code> 这一行，并且判断为 true，准备接着执行下面的 <code>jedis.del</code> 。</p></li><li><p>但是在执行前，该锁刚好超时了，导致其被自动释放掉了。</p></li><li><p>然后又很不巧的，该锁被另一个进程 B 拿到了。</p></li><li><p>然后此时 A 才开始执行 <code>jedis.del</code>，但这把锁现在已经属于 B 了，这就导致进程 A 把本不属于自己的锁给释放掉了。</p></li></ol><p>导致这个问题的原因是因为解锁操作要执行 get 和 del 2 个命令，而在上面的实现中，我们无法保证 get 和 del 执行期间不被其他命令干扰，比如我们期望的是执行完 get 后接着执行 del，即 get -&gt; del 这种操作顺序，但是实际可能存在 get -&gt; del（来自其他客户端） -&gt; get（来自其他客户端） -&gt; del 这种操作。为了解决这个问题，我们就需要用 lua 将这两个操作写成一个脚本，然后 redis 就会将其作为一个整体去执行，基于 redis 单线程执行命令的特性，其执行到这个 lua 脚本时，会等待执行完成后，再执行其他的命令，这样就保证了不被其他命令干扰。</p><h3 id="3-超时解锁导致并发"><a href="#3-超时解锁导致并发" class="headerlink" title="3. 超时解锁导致并发"></a>3. 超时解锁导致并发</h3><p>还是上面的问题，我们已经解决了锁误解除的问题，但是还存在一个问题，就是锁超时自动释放后，进程 A 依旧在执行它的业务，然后此时进程 B 又拿到锁了，它也可以开始执行它的业务，这导致两个进程都在执行各自的业务，这种情况下，锁就已经失去了它的作用。</p><p>解决这个问题一般有两种方法：</p><ul><li>将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。</li><li>为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。</li></ul><p>第一种感觉不是特别好用，因为代码逻辑的执行时间可能不是那么好预估的，而且如果设置的过长可能会导致其他进程被长时间阻塞，影响性能。</p><p>第二种看起来还不错，只要在拿到锁后额外启动一条线程，去不断 “续约” 即可，比如我找到一个 <a href="https://github.com/jiaxwu/lock/blob/main/lock.go">现成的实现</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *Lock)</span></span> TryLock(ctx context.Context) <span class="hljs-type">error</span> &#123;<br>success, err := l.client.SetNX(ctx, l.resource, l.randomValue, l.ttl).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-comment">// 加锁失败</span><br><span class="hljs-keyword">if</span> !success &#123;<br><span class="hljs-keyword">return</span> ErrLockFailed<br>&#125;<br><span class="hljs-comment">// 加锁成功，启动看门狗</span><br><span class="hljs-keyword">go</span> l.startWatchDog()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *Lock)</span></span> startWatchDog() &#123;<br>ticker := time.NewTicker(l.ttl / <span class="hljs-number">3</span>)<br><span class="hljs-keyword">defer</span> ticker.Stop()<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ticker.C:<br><span class="hljs-comment">// 延长锁的过期时间</span><br>ctx, cancel := context.WithTimeout(context.Background(), l.ttl/<span class="hljs-number">3</span>*<span class="hljs-number">2</span>)<br>ok, err := l.client.Expire(ctx, l.resource, l.ttl).Result()<br>cancel()<br><span class="hljs-comment">// 异常或锁已经不存在则不再续期</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> || !ok &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">case</span> &lt;-l.watchDog:<br><span class="hljs-comment">// 已经解锁</span><br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码使用 Go 实现，大致逻辑是当执行 TryLock 成功拿到锁后，会启动一个 goroutine 去不断续约，直到业务逻辑已经执行完成，执行 unlock ，此时会 close 掉 l.watchDog，进而会让 select 走 <code>case &lt;-l.watchDog</code> 这个分支，将这个续约 goroutine return 掉从而停止续约。</p><blockquote><p>🤔 感觉这个实现有点小问题，就是 Go 里面的 select 是没有优先级的，如果多个 case 都满足，则会随机选择一个，那可不可能存在这样一种情况：已经执行 unlock 了，但是刚好此时的 ticker.C 也被触发了，也就是说 <code>case &lt;-ticker.C</code> 和 <code>case &lt;- l.watchDog</code> 这 2 个 case 都满足，然后 select 选择进入 <code>case &lt;- ticker.C</code> 这个分支，导致又被延长了一轮时间</p><p>不过感觉好像问题也不是特别大？而且应该不会再延长时间了，因为执行完 unlock 后 key 已经被删除了，就算进入到 <code>case &lt;-ticker.C</code> 分支也会因为 key 不存在而导致 Expire 执行失败，进而直接 return 掉这个函数</p></blockquote><h3 id="4-分布式场景"><a href="#4-分布式场景" class="headerlink" title="4. 分布式场景"></a>4. 分布式场景</h3><blockquote><p>以下内容引用自：<a href="http://zhangtielei.com/posts/blog-redlock-reasoning.html">基于Redis的分布式锁到底安全吗（上）？</a></p></blockquote><p>假如 Redis 节点宕机了，那么所有客户端就都无法获得锁了，服务变得不可用。为了提高可用性，我们可以给这个 Redis 节点挂一个 Slave，当 Master 节点不可用的时候，系统自动切到 Slave 上（failover）。但由于 Redis 的主从复制（replication）是异步的，这可能导致在 failover 过程中丧失锁的安全性。考虑下面的执行序列：</p><ol><li>客户端1 从 Master 获取了锁。</li><li>Master 宕机了，存储锁的 key 还没有来得及同步到 Slave 上。</li><li>Slave 升级为 Master。</li><li>客户端 2 从新的 Master 获取到了对应同一个资源的锁。</li></ol><p>这样就出现了两个客户端都持有锁的情况，为了解决上面的问题，可以使用 Readlock，其大致工作机制是：</p><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><ol><li>获取当前时间（毫秒数）。</li><li>按顺序依次向 N 个 Redis 节点执行 <strong>获取锁</strong> 的操作。这个获取操作跟前面基于单 Redis 节点的 <strong>获取锁</strong> 的过程相同，包含随机字符串 <code>my_random_value</code>（即唯一标识当前进程的字段，防止误解除），也包含过期时间 (比如 <code>PX 30000</code>，即锁的 <strong>有效时间</strong>)。为了保证在某个 Redis 节点不可用的时候算法能够继续运行，这个 <strong>获取锁</strong> 的操作还有一个超时时间  (time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个 Redis 节点获取锁失败以后，应该立即尝试下一个 Redis 节点。这里的失败，应该包含任何类型的失败，比如该 Redis 节点不可用，或者该 Redis 节点上的锁已经被其它客户端持有（注：Redlock 原文中这里只提到了 Redis 节点不可用的情况，但也应该包含其它的失败情况）。</li><li><strong>计算整个获取锁的过程总共消耗了多长时间</strong>，计算方法是用当前时间减去第 1 步记录的时间。如果客户端从大多数 Redis 节点（&gt;&#x3D;  N&#x2F;2+1）成功获取到了锁，并且 <strong>获取锁总共消耗的时间没有超过锁的有效时间</strong> (lock validity time)，那么 <strong>这时客户端才认为最终获取锁成功</strong>；否则，认为最终获取锁失败。</li><li>如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第 3 步计算出来的获取锁消耗的时间。</li><li>如果最终获取锁失败了（可能由于获取到锁的 Redis 节点个数少于 N&#x2F;2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有 Redis 节点发起 <strong>释放锁</strong> 的操作（即前面介绍的 Redis Lua 脚本的方式）。</li></ol><p>在 <a href="https://github.com/go-redsync/redsync">Github</a> 上找到一个 redlock 的实现，下面截取了加锁部分的源码，可以看到和上面的实现思路基本相同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> LockContext(ctx context.Context) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> ctx == <span class="hljs-literal">nil</span> &#123;<br>ctx = context.Background()<br>&#125;<br><br>    <span class="hljs-comment">// 随机值</span><br>value, err := m.genValueFunc()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>    <span class="hljs-comment">// 自旋重试</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m.tries; i++ &#123;<br><span class="hljs-keyword">if</span> i != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br><span class="hljs-comment">// Exit early if the context is done.</span><br><span class="hljs-keyword">return</span> ErrFailed<br><span class="hljs-keyword">case</span> &lt;-time.After(m.delayFunc(i)):<br><span class="hljs-comment">// Fall-through when the delay timer completes.</span><br>&#125;<br>&#125;<br><br>        <span class="hljs-comment">// 记录当前时间</span><br>start := time.Now()<br><br>        <span class="hljs-comment">// 向 pool 中的每个 redis 实例申请锁，返回申请成功的数量</span><br>n, err := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>ctx, cancel := context.WithTimeout(ctx, time.Duration(<span class="hljs-type">int64</span>(<span class="hljs-type">float64</span>(m.expiry)*m.timeoutFactor)))<br><span class="hljs-keyword">defer</span> cancel()<br><span class="hljs-keyword">return</span> m.actOnPoolsAsync(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pool redis.Pool)</span></span> (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> m.acquire(ctx, pool, value)<br>&#125;)<br>&#125;()<br><br>        <span class="hljs-comment">// 计算加锁花费的时间</span><br>now := time.Now()<br>until := now.Add(m.expiry - now.Sub(start) - time.Duration(<span class="hljs-type">int64</span>(<span class="hljs-type">float64</span>(m.expiry)*m.driftFactor)))<br>        <span class="hljs-comment">// 如果成功的数量超过总结点的半数 + 1，且花费时间没有超过锁的有效时间，则加锁成功，return nil</span><br><span class="hljs-keyword">if</span> n &gt;= m.quorum &amp;&amp; now.Before(until) &#123;<br>m.value = value<br>m.until = until<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>        <span class="hljs-comment">// 否则走到这里说明加锁失败了，那么对所有节点执行释放锁操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>ctx, cancel := context.WithTimeout(ctx, time.Duration(<span class="hljs-type">int64</span>(<span class="hljs-type">float64</span>(m.expiry)*m.timeoutFactor)))<br><span class="hljs-keyword">defer</span> cancel()<br><span class="hljs-keyword">return</span> m.actOnPoolsAsync(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pool redis.Pool)</span></span> (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> m.release(ctx, pool, value)<br>&#125;)<br>&#125;()<br><span class="hljs-keyword">if</span> i == m.tries<span class="hljs-number">-1</span> &amp;&amp; err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> ErrFailed<br>&#125;<br></code></pre></td></tr></table></figure><p>给单个实例加锁的代码如下，思路和我们之前的基本一样，就是简单的 <code>SETNX</code>  和超时，并没有做可重入锁的处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> acquire(ctx context.Context, pool redis.Pool, value <span class="hljs-type">string</span>) (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br>conn, err := pool.Get(ctx)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br>reply, err := conn.SetNX(m.name, value, m.expiry)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> reply, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a><strong>解锁</strong></h4><p>解锁操作比较简单，只需要客户端向所有 Redis 节点发起 <strong>释放锁</strong> 的操作，不管这些节点当时在获取锁的时候成功与否。释放锁操作和我们前面提到的一样，使用 Lua 脚本来执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> UnlockContext(ctx context.Context) (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br>n, err := m.actOnPoolsAsync(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pool redis.Pool)</span></span> (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> m.release(ctx, pool, m.value)<br>&#125;)<br><span class="hljs-keyword">if</span> n &lt; m.quorum &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><br><span class="hljs-keyword">var</span> deleteScript = redis.NewScript(<span class="hljs-number">1</span>, <span class="hljs-string">`</span><br><span class="hljs-string">if redis.call(&quot;GET&quot;, KEYS[1]) == ARGV[1] then</span><br><span class="hljs-string">return redis.call(&quot;DEL&quot;, KEYS[1])</span><br><span class="hljs-string">else</span><br><span class="hljs-string">return 0</span><br><span class="hljs-string">end</span><br><span class="hljs-string">`</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> release(ctx context.Context, pool redis.Pool, value <span class="hljs-type">string</span>) (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br>conn, err := pool.Get(ctx)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br>status, err := conn.Eval(deleteScript, m.name, value)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> status != <span class="hljs-type">int64</span>(<span class="hljs-number">0</span>), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="续期"><a href="#续期" class="headerlink" title="续期"></a>续期</h4><p>续期的代码如下，使用 Lua 实现，先判断是不是属于自己的 value，然后调用 <code>PEXPIRE</code> 重置超时时间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> ExtendContext(ctx context.Context) (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br>start := time.Now()<br>n, err := m.actOnPoolsAsync(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pool redis.Pool)</span></span> (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br>        <span class="hljs-comment">// 重新设置改 key 的过期时间为 m.expiry</span><br>        <span class="hljs-comment">// 因为调用的是 PEXPIRE 命令，所以需要转换为毫秒</span><br><span class="hljs-keyword">return</span> m.touch(ctx, pool, m.value, <span class="hljs-type">int</span>(m.expiry/time.Millisecond))<br>&#125;)<br><span class="hljs-keyword">if</span> n &lt; m.quorum &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>&#125;<br>now := time.Now()<br>until := now.Add(m.expiry - now.Sub(start) - time.Duration(<span class="hljs-type">int64</span>(<span class="hljs-type">float64</span>(m.expiry)*m.driftFactor)))<br><span class="hljs-keyword">if</span> now.Before(until) &#123;<br>m.until = until<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, ErrExtendFailed<br>&#125;<br><br><span class="hljs-keyword">var</span> touchScript = redis.NewScript(<span class="hljs-number">1</span>, <span class="hljs-string">`</span><br><span class="hljs-string">if redis.call(&quot;GET&quot;, KEYS[1]) == ARGV[1] then</span><br><span class="hljs-string">return redis.call(&quot;PEXPIRE&quot;, KEYS[1], ARGV[2])</span><br><span class="hljs-string">else</span><br><span class="hljs-string">return 0</span><br><span class="hljs-string">end</span><br><span class="hljs-string">`</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> touch(ctx context.Context, pool redis.Pool, value <span class="hljs-type">string</span>, expiry <span class="hljs-type">int</span>) (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br>conn, err := pool.Get(ctx)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br>status, err := conn.Eval(touchScript, m.name, value, expiry)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> status != <span class="hljs-type">int64</span>(<span class="hljs-number">0</span>), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>🤔 为什么需要用 Lua 实现？</p></blockquote><h2 id="几种实现"><a href="#几种实现" class="headerlink" title="几种实现"></a>几种实现</h2><h3 id="go-zero"><a href="#go-zero" class="headerlink" title="go-zero"></a>go-zero</h3><p>地址：<a href="https://github.com/zeromicro/go-zero/blob/master/core/stores/redis/redislock.go">https://github.com/zeromicro/go-zero/blob/master/core/stores/redis/redislock.go</a></p><p>大名鼎鼎的微服务框架，它的加解锁操作都是使用 lua 脚本来实现的，貌似是因为它支持可重入特性？整体实现看起来也比较简单，但是好像没有实现看门狗机制？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> redis<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;sync/atomic&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br>red <span class="hljs-string">&quot;github.com/go-redis/redis/v8&quot;</span><br><br><span class="hljs-string">&quot;github.com/zeromicro/go-zero/core/logx&quot;</span><br><span class="hljs-string">&quot;github.com/zeromicro/go-zero/core/stringx&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>randomLen       = <span class="hljs-number">16</span><br>tolerance       = <span class="hljs-number">500</span> <span class="hljs-comment">// milliseconds</span><br>millisPerSecond = <span class="hljs-number">1000</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>lockScript = NewScript(<span class="hljs-string">`if redis.call(&quot;GET&quot;, KEYS[1]) == ARGV[1] then</span><br><span class="hljs-string">    redis.call(&quot;SET&quot;, KEYS[1], ARGV[1], &quot;PX&quot;, ARGV[2])</span><br><span class="hljs-string">    return &quot;OK&quot;</span><br><span class="hljs-string">else</span><br><span class="hljs-string">    return redis.call(&quot;SET&quot;, KEYS[1], ARGV[1], &quot;NX&quot;, &quot;PX&quot;, ARGV[2])</span><br><span class="hljs-string">end`</span>)<br>delScript = NewScript(<span class="hljs-string">`if redis.call(&quot;GET&quot;, KEYS[1]) == ARGV[1] then</span><br><span class="hljs-string">    return redis.call(&quot;DEL&quot;, KEYS[1])</span><br><span class="hljs-string">else</span><br><span class="hljs-string">    return 0</span><br><span class="hljs-string">end`</span>)<br>)<br><br><span class="hljs-comment">// A RedisLock is a redis lock.</span><br><span class="hljs-keyword">type</span> RedisLock <span class="hljs-keyword">struct</span> &#123;<br>store   *Redis<br>seconds <span class="hljs-type">uint32</span><br>key     <span class="hljs-type">string</span><br>id      <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>rand.Seed(time.Now().UnixNano())<br>&#125;<br><br><span class="hljs-comment">// NewRedisLock returns a RedisLock.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewRedisLock</span><span class="hljs-params">(store *Redis, key <span class="hljs-type">string</span>)</span></span> *RedisLock &#123;<br><span class="hljs-keyword">return</span> &amp;RedisLock&#123;<br>store: store,<br>key:   key,<br>id:    stringx.Randn(randomLen),<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Acquire acquires the lock.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rl *RedisLock)</span></span> Acquire() (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> rl.AcquireCtx(context.Background())<br>&#125;<br><br><span class="hljs-comment">// AcquireCtx acquires the lock with the given ctx.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rl *RedisLock)</span></span> AcquireCtx(ctx context.Context) (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br>seconds := atomic.LoadUint32(&amp;rl.seconds)<br>resp, err := rl.store.ScriptRunCtx(ctx, lockScript, []<span class="hljs-type">string</span>&#123;rl.key&#125;, []<span class="hljs-type">string</span>&#123;<br>rl.id, strconv.Itoa(<span class="hljs-type">int</span>(seconds)*millisPerSecond + tolerance),<br>&#125;)<br><span class="hljs-keyword">if</span> err == red.Nil &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, <span class="hljs-literal">nil</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>logx.Errorf(<span class="hljs-string">&quot;Error on acquiring lock for %s, %s&quot;</span>, rl.key, err.Error())<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> resp == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br>reply, ok := resp.(<span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> ok &amp;&amp; reply == <span class="hljs-string">&quot;OK&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br>logx.Errorf(<span class="hljs-string">&quot;Unknown reply when acquiring lock for %s: %v&quot;</span>, rl.key, resp)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Release releases the lock.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rl *RedisLock)</span></span> Release() (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> rl.ReleaseCtx(context.Background())<br>&#125;<br><br><span class="hljs-comment">// ReleaseCtx releases the lock with the given ctx.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rl *RedisLock)</span></span> ReleaseCtx(ctx context.Context) (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br>resp, err := rl.store.ScriptRunCtx(ctx, delScript, []<span class="hljs-type">string</span>&#123;rl.key&#125;, []<span class="hljs-type">string</span>&#123;rl.id&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>&#125;<br><br>reply, ok := resp.(<span class="hljs-type">int64</span>)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">return</span> reply == <span class="hljs-number">1</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// SetExpire sets the expiration.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rl *RedisLock)</span></span> SetExpire(seconds <span class="hljs-type">int</span>) &#123;<br>atomic.StoreUint32(&amp;rl.seconds, <span class="hljs-type">uint32</span>(seconds))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="社区实现"><a href="#社区实现" class="headerlink" title="社区实现"></a>社区实现</h3><p>源码：<a href="https://github.com/jiaxwu/lock">https://github.com/jiaxwu/lock</a></p><p>博客：<a href="https://juejin.cn/post/7148391514966589477#heading-6">https://juejin.cn/post/7148391514966589477#heading-6</a></p><p>比较简短的一个库，不过基本功能差不多都实现了</p><h3 id="redsync"><a href="#redsync" class="headerlink" title="redsync"></a>redsync</h3><p>地址：<a href="https://github.com/go-redsync/redsync">https://github.com/go-redsync/redsync</a></p><p>redlock 的实现，star 数还挺多的，看起来比较完善</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mp.weixin.qq.com/s/qJK61ew0kCExvXrqb7-RSg">Redis 分布式锁的正确实现方式（ Java 版 ）</a></p><p><a href="https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/">小米信息部技术团队——分布式锁的实现之 redis 篇</a></p><p><a href="http://zhangtielei.com/posts/blog-redlock-reasoning.html">基于Redis的分布式锁到底安全吗（上）？</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划入门.打家劫舍</title>
    <link href="/2023/07/14/dong-tai-gui-hua-ru-men-50-ti-lc-198/"/>
    <url>/2023/07/14/dong-tai-gui-hua-ru-men-50-ti-lc-198/</url>
    
    <content type="html"><![CDATA[<h1 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[1,2,3,1]<br>输出：4<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 2), 偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 9)，接着偷窃<span class="hljs-number"> 5 </span>号房屋 (金额 = 1)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 12 </span>。<br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs stylus">因为不能连续偷取相邻的房子，所以对于某个坐标，要想偷到最多的钱，将面临两种情况的抉择，下面举例介绍：<br><br><span class="hljs-selector-attr">[2,7,9,3,1]</span><br>     ^<br>比如小偷要想在到达这里时偷到最多的钱，其面临着一个抉择：是从 <span class="hljs-number">2</span> 开始偷，偷完再偷 <span class="hljs-number">9</span>，还是从 <span class="hljs-number">7</span> 开始偷，然后跳过这里呢？（因为不能连续偷取相邻房屋）<br>在这个例子中，显然是偷完 <span class="hljs-number">2</span> 再偷 <span class="hljs-number">9</span> 的收益更高。<br><br>（其实看到这里如果有 dp 基础的话，就已经可以推出方程了，即 dp<span class="hljs-selector-attr">[i]</span> = <span class="hljs-built_in">max</span>(dp<span class="hljs-selector-attr">[i-2]</span>+nums<span class="hljs-selector-attr">[i]</span>, dp<span class="hljs-selector-attr">[i-1]</span>) ）<br><br><span class="hljs-selector-attr">[2,7,9,3,1]</span><br>         ^<br>又比如如果我们要计算到达这里时能偷到最多的钱，也存在两种情况：要不然从 <span class="hljs-selector-attr">[2]</span> 开始，再到 <span class="hljs-selector-attr">[4]</span>，要不然从 <span class="hljs-selector-attr">[3]</span> 开始，忽略 <span class="hljs-selector-attr">[4]</span>，和上面讲的情况完全相同<br>但是我们如何知道 <span class="hljs-selector-attr">[0]</span> 到 <span class="hljs-selector-attr">[2]</span> 之间最多能偷多少钱呢？又如何知道 <span class="hljs-selector-attr">[0]</span> 到 <span class="hljs-selector-attr">[3]</span> 之间最多能偷多少钱呢？不然我们无法判断哪种选择收益高<br><br>这里就可以运用动态规划的知识，对之前的状态进行保存。<br><br>我们可以准备一个 dp 数组，dp<span class="hljs-selector-attr">[i]</span> 代表到达这里时，可以偷到的最大金钱。<br><br>根据上面的分析，可以求得状态转移方程为 dp<span class="hljs-selector-attr">[i]</span> = <span class="hljs-built_in">max</span>(dp<span class="hljs-selector-attr">[i-2]</span>+nums<span class="hljs-selector-attr">[i]</span>, dp<span class="hljs-selector-attr">[i-1]</span>)<br><br>但是 dp 的前两个元素需要进行额外处理，下面开始分析：<br><br>为了利益最大化，我们可以选择从第一个房子开始偷，也可以跳过第一个房子，从第二个开始偷<br>比如 <span class="hljs-selector-attr">[2,7,1,10]</span> 这个例子，如果从 <span class="hljs-number">2</span> 开始偷，那么路径为 <span class="hljs-number">2</span> -&gt; <span class="hljs-number">10</span>，而从 <span class="hljs-number">7</span> 开始偷，路径为 <span class="hljs-number">7</span> -&gt; <span class="hljs-number">10</span>，显然是从 <span class="hljs-number">7</span> 开始偷收益高<br><br>所以我们可以为这两个房子设置对应 dp 数组的初值，其中，第一个元素将设置为与 nums<span class="hljs-selector-attr">[0]</span> 相同的值，这个没什么好说的<br>而第二个房子的值要设置为 <span class="hljs-selector-attr">[0]</span> 和 <span class="hljs-selector-attr">[1]</span> 中的较大值，为的是应对这种情况：<br><br><span class="hljs-selector-attr">[2,1,1,2]</span><br><br>这个的最优解是从 <span class="hljs-selector-attr">[0]</span> 直接到 <span class="hljs-selector-attr">[3]</span>，一共可以偷取金额 <span class="hljs-number">4</span><br>如果我们设置 dp<span class="hljs-selector-attr">[0]</span> = <span class="hljs-number">2</span>, dp<span class="hljs-selector-attr">[1]</span> = <span class="hljs-number">1</span>，那么最终的 dp 数组为 <span class="hljs-selector-attr">[2, 1, 3, 3]</span>，显然与结果不符<br>而如果设置 dp<span class="hljs-selector-attr">[1]</span> 为 <span class="hljs-built_in">max</span>(nums<span class="hljs-selector-attr">[0]</span>, nums<span class="hljs-selector-attr">[1]</span>) = <span class="hljs-number">2</span>，那么最终的 dp 数组为 <span class="hljs-selector-attr">[2, 2, 3, 4]</span>，与结果相符<br><br>后续的元素就只要按照状态转移方程赋值即可。<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">front</span>();<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(nums[i] + dp[i<span class="hljs-number">-2</span>], dp[i<span class="hljs-number">-1</span>]);<br>            ret = <span class="hljs-built_in">max</span>(ret, dp[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="打家劫舍-II"><a href="#打家劫舍-II" class="headerlink" title="打家劫舍 II"></a>打家劫舍 II</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,2]<br>输出：3<br>解释：你不能先偷窃<span class="hljs-number"> 1 </span>号房屋（金额 = 2），然后偷窃<span class="hljs-number"> 3 </span>号房屋（金额 = 2）, 因为他们是相邻的。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,3,1]<br>输出：4<br>解释：你可以先偷窃<span class="hljs-number"> 1 </span>号房屋（金额 = 1），然后偷窃<span class="hljs-number"> 3 </span>号房屋（金额 = 3）。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,2,3]</span><br><span class="hljs-string">输出：3</span><br></code></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>这道题加了一个首尾相连的条件，也就意味着我们不能同时偷取第一间和最后一间，<del>我刚开始想的是设置一个变量记录一下有没有偷过第一间，如果</del></p><p>解决方法也很简单，我们直接沿用打家劫舍 1 的代码，只是传递的参数 nums 不同，我们先将 nums[0] 置为 0，即不偷取第一间，然后调用打家劫舍 1，求得此时的最大金钱 res1；然后再将 nums[last] 置为 0，即不偷最后一间，然后再调用打家劫舍 1，求得结果 res2，最后再比较一下二者那个最大即可，大的那个便是结果。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>我一开始写的，比较简单粗暴，不过没什么问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">front</span>();<br>        &#125;<br>        <span class="hljs-type">int</span> n0 = nums[<span class="hljs-number">0</span>];<span class="hljs-comment">// 备份一下</span><br>        nums[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">// 第一间屋子置为 0</span><br>        <span class="hljs-type">int</span> ret1 = <span class="hljs-built_in">rob1</span>(nums);<span class="hljs-comment">// 求得结果 1</span><br>        nums[<span class="hljs-number">0</span>] = n0;<span class="hljs-comment">// 还原第一间屋子的值</span><br>        nums.<span class="hljs-built_in">back</span>() = <span class="hljs-number">0</span>;<span class="hljs-comment">// 将最后一间屋子置为 0</span><br>        <span class="hljs-type">int</span> ret2 = <span class="hljs-built_in">rob1</span>(nums);<span class="hljs-comment">// 求得结果 2</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(ret1, ret2);<br>    &#125;<br><br>    <span class="hljs-comment">// 打家劫舍 1 的代码</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob1</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> ret = dp[<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(nums[i] + dp[i<span class="hljs-number">-2</span>], dp[i<span class="hljs-number">-1</span>]);<br>            ret = <span class="hljs-built_in">max</span>(ret, dp[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ret;  <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>看了一下题解，还有一种写法，貌似稍微优雅一点？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">front</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<br>            <span class="hljs-built_in">rob1</span>(nums, <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>()), <br>            <span class="hljs-built_in">rob1</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob1</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(end)</span></span>;<br>        dp[begin] = nums[begin];<br>        dp[begin+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[begin], nums[begin+<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> ret = dp[begin+<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = begin+<span class="hljs-number">2</span>; i &lt; end; i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(nums[i] + dp[i<span class="hljs-number">-2</span>], dp[i<span class="hljs-number">-1</span>]);<br>            ret = <span class="hljs-built_in">max</span>(ret, dp[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ret;  <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划入门.爬楼梯的最少成本</title>
    <link href="/2023/07/13/dong-tai-gui-hua-ru-men-50-ti-offer-II-088/"/>
    <url>/2023/07/13/dong-tai-gui-hua-ru-men-50-ti-offer-II-088/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.bilibili.com/video/BV1aa411f7uT/?p=1&vd_source=2ff613424b86c58a71ba91b7304ffe9b">英雄哪里来</a></p></blockquote><h1 id="剑指-Offer-II-088-爬楼梯的最少成本"><a href="#剑指-Offer-II-088-爬楼梯的最少成本" class="headerlink" title="剑指 Offer II 088. 爬楼梯的最少成本"></a>剑指 Offer II 088. 爬楼梯的最少成本</h1><p>数组的每个下标作为一个阶梯，第 <code>i</code> 个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>（下标从 <code>0</code> 开始）。</p><p>每当爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：cost = <span class="hljs-comment">[10, 15, 20]</span><br>输出：15<br>解释：最低花费是从 cost<span class="hljs-comment">[1]</span> 开始，然后走两步即可到阶梯顶，一共花费 15 。<br></code></pre></td></tr></table></figure><p> <strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：cost = <span class="hljs-comment">[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br>输出：6<br>解释：最低花费方式是从 cost<span class="hljs-comment">[0]</span> 开始，逐个经过那些 1 ，跳过 cost<span class="hljs-comment">[3]</span> ，一共花费 6 。<br></code></pre></td></tr></table></figure><p>解释：</p><p>示例 2 的流程如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tap">[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br> ^ <br> 可以选择下标<span class="hljs-number"> 0 </span>或<span class="hljs-number"> 1 </span>作为初始阶梯，这里我们选择下标 0<br> 然后我们可以支付下标对应的值作为体力花费，前进一个或者两个阶梯<br> <br>[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>         ^ 我们支付了<span class="hljs-number"> 1 </span>体力，前进了两个阶梯，到达了这里，至此，我们总共花费了<span class="hljs-number"> 1 </span>体力<br><br>[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>               ^ 我们支付了<span class="hljs-number"> 1 </span>体力，然后选择前进两个阶梯到达这里，至此，我们总共花费了<span class="hljs-number"> 2 </span>体力<br><br>[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>                       ^ 我们继续支付<span class="hljs-number"> 1 </span>体力，然后选择前进两个阶梯到达这里，至此，我们总共花费了<span class="hljs-number"> 3 </span>体力<br>                       <br>[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>                          ^ 我们继续支付<span class="hljs-number"> 1 </span>体力，然后选择前进一个阶梯到达这里，至此，我们总共花费了<span class="hljs-number"> 4 </span>体力<br><br>[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>                                  ^ 我们继续支付<span class="hljs-number"> 1 </span>体力，然后选择前进两个阶梯到达这里，至此，我们总共花费了<span class="hljs-number"> 5 </span>体力<br><br>[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>                                      ^ 我们继续支付<span class="hljs-number"> 1 </span>体力，此时不管前进几步都可以到达楼顶，至此，我们总共花费了<span class="hljs-number"> 6 </span>体力<br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><br><br><span class="hljs-comment">[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br>         ^<br>         要想到达 <span class="hljs-comment">[2]</span> 这个位置，只有两种可能：要不从 <span class="hljs-comment">[0]</span> 出发前进两格，要不从 <span class="hljs-comment">[1]</span> 出发前进一格<br>         我们只需要比较 <span class="hljs-comment">[0]</span> 和 <span class="hljs-comment">[1]</span> 哪个的体力花费小即可，小的那个便是到达这里要花费的体力值<br>         在这个例子里显然是 <span class="hljs-comment">[0]</span> = 1 比较小，所以到达这里的最小花费为 1<br><br><span class="hljs-comment">[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br>            ^<br>            同理，要到达 <span class="hljs-comment">[3]</span> 这里，只能从 <span class="hljs-comment">[1]</span> 或者 <span class="hljs-comment">[2]</span> 出发。<br>            <br>            如果从 <span class="hljs-comment">[1]</span> 出发，需要耗费 100 体力，因为 <span class="hljs-comment">[1]</span> 是起始坐标，所以我们无需考虑之前的路径。<br>            <br>            如果从 <span class="hljs-comment">[2]</span> 出发，需要耗费的体力为 1，但是与 <span class="hljs-comment">[1]</span> 不同的是，这不是一个起始坐标，所以我<br>            们还需要考虑一下，从起始坐标到 <span class="hljs-comment">[2]</span> 这里需要花费多少体力，将这个体力加上 <span class="hljs-comment">[2]</span> 本身耗费的<br>            体力，才是到达 <span class="hljs-comment">[3]</span> 花费的总体力。很巧的是，我们上一步正好求出了起始坐标到 <span class="hljs-comment">[2]</span> 需要花费<br>            的最少体力，所以这里可以直接沿用之前的结果。<br>            最终求得最小体力花费为 1 (到 <span class="hljs-comment">[2]</span> 所花费的最小体力) + 1 (<span class="hljs-comment">[2]</span> 本身需要花费的体力) = 2。<br>            <br>            现在我们就需要进行选择了，是从 <span class="hljs-comment">[1]</span> 出发到达 <span class="hljs-comment">[3]</span>，还是从 <span class="hljs-comment">[2]</span> 出发到达 <span class="hljs-comment">[3]</span>，很显然，哪个<br>            耗费的体力小选哪个，我们这里当然就选择从 <span class="hljs-comment">[2]</span> 出发了。 <br>            也就是说，我们确定了到达这里的一条最小体力路径：<span class="hljs-comment">[0]</span> -&gt; <span class="hljs-comment">[2]</span> -&gt; <span class="hljs-comment">[3]</span><br>            <br><span class="hljs-comment">[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br>               ^<br>               同理，要到达 <span class="hljs-comment">[4]</span> 这里，只能从 <span class="hljs-comment">[2]</span> 或者 <span class="hljs-comment">[3]</span> 出发。<br>               从 <span class="hljs-comment">[2]</span> 到 <span class="hljs-comment">[4]</span>，最小体力为 1 (到 <span class="hljs-comment">[2]</span> 所花费的最小体力) + 1 (<span class="hljs-comment">[4]</span> 本身需要花费的体力) = 2<br>               从 <span class="hljs-comment">[3]</span> 到 <span class="hljs-comment">[4]</span>，最小体力为 2 + 1 = 3<br>               所以我们这里选择从 <span class="hljs-comment">[2]</span> 出发到达 <span class="hljs-comment">[4]</span>，路径为 <span class="hljs-comment">[0]</span> -&gt; <span class="hljs-comment">[2]</span> -&gt; <span class="hljs-comment">[4]</span>，共耗费体力 2<br><br>以此类推。。。。<br><br><br>看完上面的分析，我们知道需要定义一个 dp 数组，用来保存到达每个坐标的耗费的最小体力数，并且也可以得出计算每个坐标的最小体力数的递推方程是：<br><br>dp<span class="hljs-comment">[i]</span> = min(dp<span class="hljs-comment">[i-1]</span> + cost<span class="hljs-comment">[i-1]</span>, dp<span class="hljs-comment">[i-2]</span> + cost<span class="hljs-comment">[i-2]</span>)<br><br>其中 dp<span class="hljs-comment">[i-1]</span> 保存到达 cost<span class="hljs-comment">[i-1]</span> 花费的最小体力数，cost<span class="hljs-comment">[i-1]</span> 则是从这里出发所耗费的体力数，二者相加就是从 cost<span class="hljs-comment">[i-1]</span> 出发到达下一个位置<br>所耗费的最小体力数，前面也多次提到过了。<br><br>所以我们就可以定义 dp 数组了，dp<span class="hljs-comment">[i]</span> 的含义是，到达这里花费的最少体力值。<br>因为 <span class="hljs-comment">[0]</span> 和 <span class="hljs-comment">[1]</span> 是起始坐标，所以不存在 “到达” 这个说法，所以可以设置为 0。<br><br>最后还有一个要注意的地方是，题目要求的是爬到顶层，即超过数组的最后一个元素，比如：<br><span class="hljs-comment">[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br>                                      ^ 到这里<br>                                      <br>这就要求我们的 dp 数组要比 cost 数组多一个位置，用来存放到达 “顶层” 的最小体力数。<br><br><span class="hljs-comment">[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br>                              ^   ^<br>                              |   |_________________到达这里需要的体力数为 5<br>                              |_______ 按照上面的规则，计算出到达这里需要的体力数为 4<br>                              <br>然后我们就可以推算出到达顶层的最小体力数为 min(100 + 4, 1 + 5) = 6，这正是正确的结果。<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>分析中给出的内容应该比较清晰了，所以可以直接写出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size()+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; dp.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i] = <span class="hljs-built_in">min</span>(cost[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-1</span>], cost[i<span class="hljs-number">-2</span>] + dp[i<span class="hljs-number">-2</span>]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>题外话：</p><p>我第一次写这道题的时候，凭感觉一顿操作写出了如下代码，居然也给过了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size())</span></span>;<br>        dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; dp.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i] = cost[i] + <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-2</span>]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[dp.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>], dp[dp.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>私有镜像仓库 harbor 部署实践</title>
    <link href="/2023/07/04/harbor-try/"/>
    <url>/2023/07/04/harbor-try/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>参考官方文档 + 网上的一些博客，其实部署还是比较容易的，但是我在实践过程中还是踩了一些坑，特此记录一下。</p><p>我使用的是 Helm 的部署方式，会将其部署到 k8s 上。</p><p>这篇文章目前只是简单记录了一下搭建的过程和 harbor 的简单使用，并没用对 harbor 进行详细的探索。</p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>使用 Helm 部署，首先需要准备一份 values.yaml，这个 yaml 的模版可以从 <a href="https://github.com/goharbor/harbor-helm">这个 repo</a> 里获取（你也可以直接复制我下面提供的），然后需要根据自己的需求，对这个模版进行修改。</p><p>这里我修改了这几部分：</p><ul><li><p>type：用于指定 harbor 的 service 的类型，我修改成了 nodePort。</p></li><li><p>commonName：如果开启了 TLS 则必填，且必须和 externalURL 的域名部分相同，即 https:&#x2F;&#x2F; 后面的，但是端口号可以忽略，比如如果 externalURL 为 <a href="https://core.harbor.domain:30003/">https://core.harbor.domain:30003</a> ，那么 commonName 需要指定为 core.harbor.domain。如果 commonName 和 externalURL 域名部分不同，会导致一些操作（比如 docker 的 login 和 push ）出现证书验证失败的问题。</p><blockquote><p>如果你和我一样不小心掉到坑里了，把 commonName 配置的和 externalURL 域名部分不一致，导致出现 <code> x509: certificate is valid for harbor-cert, not core.harbor.domain</code> 错误，那么恭喜你，可以重头再来了。。。开玩笑的，其实只要更新一下 values.yaml，然后执行 <code>helm upgrade harbor harbor/harbor -f values.yaml -n harbor</code> 更新一下 release 就可以了。</p></blockquote></li><li><p>externalURL：指定 harbor 的访问域名，这里要注意的是，<strong>如果指定的是 nodePort 类型的，那么必须要加上端口号</strong>，比如 <a href="https://core.harbor.domain:30003/">https://core.harbor.domain:30003</a> 这样。</p></li></ul><p>tls 这里我为了方便就直接让 Harbor 自动创建证书文件了，没有像 <a href="https://icloudnative.io/posts/install-harbor-on-kubernetes/#1-harbor-%E7%AE%80%E4%BB%8B">其他博客</a> 一样创建自定义证书，所以 <code>certSource: auto</code> 这里保持原样即可，无需修改。</p><p>还有一个需要注意的地方是 <code>harborAdminPassword: &quot;Harbor12345&quot;</code> 这里，指定的是 harbor admin 用户的登录密码，这里要不要改就看自己的需求了，如果只是测试一下，感觉没啥改的必要。</p><p>还有如果指定的 service type 是 nodeport 的话，这个 yaml 会把 nodePort 的端口写死，比如默认 http 对应的 nodePort 端口是 30002，而 https 是 30003。这个要不要改也是看自己的需求了，我这里是没改。</p><p>下面是我修改后的文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">expose:</span><br>  <span class="hljs-comment"># Set how to expose the service. Set the type as &quot;ingress&quot;, &quot;clusterIP&quot;, &quot;nodePort&quot; or &quot;loadBalancer&quot;</span><br>  <span class="hljs-comment"># and fill the information in the corresponding section</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">nodePort</span><br>  <span class="hljs-attr">tls:</span><br>    <span class="hljs-comment"># Enable TLS or not.</span><br>    <span class="hljs-comment"># Delete the &quot;ssl-redirect&quot; annotations in &quot;expose.ingress.annotations&quot; when TLS is disabled and &quot;expose.type&quot; is &quot;ingress&quot;</span><br>    <span class="hljs-comment"># <span class="hljs-doctag">Note:</span> if the &quot;expose.type&quot; is &quot;ingress&quot; and TLS is disabled,</span><br>    <span class="hljs-comment"># the port must be included in the command when pulling/pushing images.</span><br>    <span class="hljs-comment"># Refer to https://github.com/goharbor/harbor/issues/5291 for details.</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># The source of the tls certificate. Set as &quot;auto&quot;, &quot;secret&quot;</span><br>    <span class="hljs-comment"># or &quot;none&quot; and fill the information in the corresponding section</span><br>    <span class="hljs-comment"># 1) auto: generate the tls certificate automatically</span><br>    <span class="hljs-comment"># 2) secret: read the tls certificate from the specified secret.</span><br>    <span class="hljs-comment"># The tls certificate can be generated manually or by cert manager</span><br>    <span class="hljs-comment"># 3) none: configure no tls certificate for the ingress. If the default</span><br>    <span class="hljs-comment"># tls certificate is configured in the ingress controller, choose this option</span><br>    <span class="hljs-attr">certSource:</span> <span class="hljs-string">auto</span><br>    <span class="hljs-attr">auto:</span><br>      <span class="hljs-comment"># The common name used to generate the certificate, it&#x27;s necessary</span><br>      <span class="hljs-comment"># when the type isn&#x27;t &quot;ingress&quot;</span><br>      <span class="hljs-attr">commonName:</span> <span class="hljs-string">&quot;core.harbor.domain&quot;</span> <span class="hljs-comment"># 必填，如果开启 TLS，貌似必须和 externalURL 的域名部分相同，即 https:// 后面的</span><br>    <span class="hljs-attr">secret:</span><br>      <span class="hljs-comment"># The name of secret which contains keys named:</span><br>      <span class="hljs-comment"># &quot;tls.crt&quot; - the certificate</span><br>      <span class="hljs-comment"># &quot;tls.key&quot; - the private key</span><br>      <span class="hljs-attr">secretName:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">ingress:</span><br>    <span class="hljs-attr">hosts:</span><br>      <span class="hljs-attr">core:</span> <span class="hljs-string">core.harbor.domain</span><br>    <span class="hljs-comment"># set to the type of ingress controller if it has specific requirements.</span><br>    <span class="hljs-comment"># leave as `default` for most ingress controllers.</span><br>    <span class="hljs-comment"># set to `gce` if using the GCE ingress controller</span><br>    <span class="hljs-comment"># set to `ncp` if using the NCP (NSX-T Container Plugin) ingress controller</span><br>    <span class="hljs-comment"># set to `alb` if using the ALB ingress controller</span><br>    <span class="hljs-comment"># set to `f5-bigip` if using the F5 BIG-IP ingress controller</span><br>    <span class="hljs-attr">controller:</span> <span class="hljs-string">default</span><br>    <span class="hljs-comment">## Allow .Capabilities.KubeVersion.Version to be overridden while creating ingress</span><br>    <span class="hljs-attr">kubeVersionOverride:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">className:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">annotations:</span><br>      <span class="hljs-comment"># note different ingress controllers may require a different ssl-redirect annotation</span><br>      <span class="hljs-comment"># for Envoy, use ingress.kubernetes.io/force-ssl-redirect: &quot;true&quot; and remove the nginx lines below</span><br>      <span class="hljs-attr">ingress.kubernetes.io/ssl-redirect:</span> <span class="hljs-string">&quot;true&quot;</span><br>      <span class="hljs-attr">ingress.kubernetes.io/proxy-body-size:</span> <span class="hljs-string">&quot;0&quot;</span><br>      <span class="hljs-attr">nginx.ingress.kubernetes.io/ssl-redirect:</span> <span class="hljs-string">&quot;true&quot;</span><br>      <span class="hljs-attr">nginx.ingress.kubernetes.io/proxy-body-size:</span> <span class="hljs-string">&quot;0&quot;</span><br>    <span class="hljs-attr">harbor:</span><br>      <span class="hljs-comment"># harbor ingress-specific annotations</span><br>      <span class="hljs-attr">annotations:</span> &#123;&#125;<br>      <span class="hljs-comment"># harbor ingress-specific labels</span><br>      <span class="hljs-attr">labels:</span> &#123;&#125;<br>  <span class="hljs-attr">clusterIP:</span><br>    <span class="hljs-comment"># The name of ClusterIP service</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">harbor</span><br>    <span class="hljs-comment"># Annotations on the ClusterIP service</span><br>    <span class="hljs-attr">annotations:</span> &#123;&#125;<br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-comment"># The service port Harbor listens on when serving HTTP</span><br>      <span class="hljs-attr">httpPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-comment"># The service port Harbor listens on when serving HTTPS</span><br>  <span class="hljs-attr">nodePort:</span><br>    <span class="hljs-comment"># The name of NodePort service</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">harbor</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-attr">http:</span><br>        <span class="hljs-comment"># The service port Harbor listens on when serving HTTP</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>        <span class="hljs-comment"># The node port Harbor listens on when serving HTTP</span><br>        <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30002</span><br>      <span class="hljs-attr">https:</span><br>        <span class="hljs-comment"># The service port Harbor listens on when serving HTTPS</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">443</span><br>        <span class="hljs-comment"># The node port Harbor listens on when serving HTTPS</span><br>        <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30003</span><br>  <span class="hljs-attr">loadBalancer:</span><br>    <span class="hljs-comment"># The name of LoadBalancer service</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">harbor</span><br>    <span class="hljs-comment"># Set the IP if the LoadBalancer supports assigning IP</span><br>    <span class="hljs-attr">IP:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-comment"># The service port Harbor listens on when serving HTTP</span><br>      <span class="hljs-attr">httpPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-comment"># The service port Harbor listens on when serving HTTPS</span><br>      <span class="hljs-attr">httpsPort:</span> <span class="hljs-number">443</span><br>    <span class="hljs-attr">annotations:</span> &#123;&#125;<br>    <span class="hljs-attr">sourceRanges:</span> []<br><br><span class="hljs-comment"># The external URL for Harbor core service. It is used to</span><br><span class="hljs-comment"># 1) populate the docker/helm commands showed on portal</span><br><span class="hljs-comment"># 2) populate the token service URL returned to docker client</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Format: protocol://domain[:port]. Usually:</span><br><span class="hljs-comment"># 1) if &quot;expose.type&quot; is &quot;ingress&quot;, the &quot;domain&quot; should be</span><br><span class="hljs-comment"># the value of &quot;expose.ingress.hosts.core&quot;</span><br><span class="hljs-comment"># 2) if &quot;expose.type&quot; is &quot;clusterIP&quot;, the &quot;domain&quot; should be</span><br><span class="hljs-comment"># the value of &quot;expose.clusterIP.name&quot;</span><br><span class="hljs-comment"># 3) if &quot;expose.type&quot; is &quot;nodePort&quot;, the &quot;domain&quot; should be</span><br><span class="hljs-comment"># the IP address of k8s node</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If Harbor is deployed behind the proxy, set it as the URL of proxy</span><br><span class="hljs-attr">externalURL:</span> <span class="hljs-string">https://core.harbor.domain:30003</span><br><br><span class="hljs-comment"># The internal TLS used for harbor components secure communicating. In order to enable https</span><br><span class="hljs-comment"># in each components tls cert files need to provided in advance.</span><br><span class="hljs-attr">internalTLS:</span><br>  <span class="hljs-comment"># If internal TLS enabled</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># There are three ways to provide tls</span><br>  <span class="hljs-comment"># 1) &quot;auto&quot; will generate cert automatically</span><br>  <span class="hljs-comment"># 2) &quot;manual&quot; need provide cert file manually in following value</span><br>  <span class="hljs-comment"># 3) &quot;secret&quot; internal certificates from secret</span><br>  <span class="hljs-attr">certSource:</span> <span class="hljs-string">&quot;auto&quot;</span><br>  <span class="hljs-comment"># The content of trust ca, only available when `certSource` is &quot;manual&quot;</span><br>  <span class="hljs-attr">trustCa:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment"># core related cert configuration</span><br>  <span class="hljs-attr">core:</span><br>    <span class="hljs-comment"># secret name for core&#x27;s tls certs</span><br>    <span class="hljs-attr">secretName:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># Content of core&#x27;s TLS cert file, only available when `certSource` is &quot;manual&quot;</span><br>    <span class="hljs-attr">crt:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># Content of core&#x27;s TLS key file, only available when `certSource` is &quot;manual&quot;</span><br>    <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment"># jobservice related cert configuration</span><br>  <span class="hljs-attr">jobservice:</span><br>    <span class="hljs-comment"># secret name for jobservice&#x27;s tls certs</span><br>    <span class="hljs-attr">secretName:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># Content of jobservice&#x27;s TLS key file, only available when `certSource` is &quot;manual&quot;</span><br>    <span class="hljs-attr">crt:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># Content of jobservice&#x27;s TLS key file, only available when `certSource` is &quot;manual&quot;</span><br>    <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment"># registry related cert configuration</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-comment"># secret name for registry&#x27;s tls certs</span><br>    <span class="hljs-attr">secretName:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># Content of registry&#x27;s TLS key file, only available when `certSource` is &quot;manual&quot;</span><br>    <span class="hljs-attr">crt:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># Content of registry&#x27;s TLS key file, only available when `certSource` is &quot;manual&quot;</span><br>    <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment"># portal related cert configuration</span><br>  <span class="hljs-attr">portal:</span><br>    <span class="hljs-comment"># secret name for portal&#x27;s tls certs</span><br>    <span class="hljs-attr">secretName:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># Content of portal&#x27;s TLS key file, only available when `certSource` is &quot;manual&quot;</span><br>    <span class="hljs-attr">crt:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># Content of portal&#x27;s TLS key file, only available when `certSource` is &quot;manual&quot;</span><br>    <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment"># trivy related cert configuration</span><br>  <span class="hljs-attr">trivy:</span><br>    <span class="hljs-comment"># secret name for trivy&#x27;s tls certs</span><br>    <span class="hljs-attr">secretName:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># Content of trivy&#x27;s TLS key file, only available when `certSource` is &quot;manual&quot;</span><br>    <span class="hljs-attr">crt:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># Content of trivy&#x27;s TLS key file, only available when `certSource` is &quot;manual&quot;</span><br>    <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-attr">ipFamily:</span><br>  <span class="hljs-comment"># ipv6Enabled set to true if ipv6 is enabled in cluster, currently it affected the nginx related component</span><br>  <span class="hljs-attr">ipv6:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># ipv4Enabled set to true if ipv4 is enabled in cluster, currently it affected the nginx related component</span><br>  <span class="hljs-attr">ipv4:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># The persistence is enabled by default and a default StorageClass</span><br><span class="hljs-comment"># is needed in the k8s cluster to provision volumes dynamically.</span><br><span class="hljs-comment"># Specify another StorageClass in the &quot;storageClass&quot; or set &quot;existingClaim&quot;</span><br><span class="hljs-comment"># if you already have existing persistent volumes to use</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For storing images and charts, you can also use &quot;azure&quot;, &quot;gcs&quot;, &quot;s3&quot;,</span><br><span class="hljs-comment"># &quot;swift&quot; or &quot;oss&quot;. Set it in the &quot;imageChartStorage&quot; section</span><br><span class="hljs-attr">persistence:</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># Setting it to &quot;keep&quot; to avoid removing PVCs during a helm delete</span><br>  <span class="hljs-comment"># operation. Leaving it empty will delete PVCs after the chart deleted</span><br>  <span class="hljs-comment"># (this does not apply for PVCs that are created for internal database</span><br>  <span class="hljs-comment"># and redis components, i.e. they are never deleted automatically)</span><br>  <span class="hljs-attr">resourcePolicy:</span> <span class="hljs-string">&quot;keep&quot;</span><br>  <span class="hljs-attr">persistentVolumeClaim:</span><br>    <span class="hljs-attr">registry:</span><br>      <span class="hljs-comment"># Use the existing PVC which must be created manually before bound,</span><br>      <span class="hljs-comment"># and specify the &quot;subPath&quot; if the PVC is shared with other components</span><br>      <span class="hljs-attr">existingClaim:</span> <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-comment"># Specify the &quot;storageClass&quot; used to provision the volume. Or the default</span><br>      <span class="hljs-comment"># StorageClass will be used (the default).</span><br>      <span class="hljs-comment"># Set it to &quot;-&quot; to disable dynamic provisioning</span><br>      <span class="hljs-attr">storageClass:</span> <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">subPath:</span> <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">accessMode:</span> <span class="hljs-string">ReadWriteOnce</span><br>      <span class="hljs-attr">size:</span> <span class="hljs-string">5Gi</span><br>      <span class="hljs-attr">annotations:</span> &#123;&#125;<br>    <span class="hljs-attr">jobservice:</span><br>      <span class="hljs-attr">jobLog:</span><br>        <span class="hljs-attr">existingClaim:</span> <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-attr">storageClass:</span> <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-attr">subPath:</span> <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-attr">accessMode:</span> <span class="hljs-string">ReadWriteOnce</span><br>        <span class="hljs-attr">size:</span> <span class="hljs-string">1Gi</span><br>        <span class="hljs-attr">annotations:</span> &#123;&#125;<br>    <span class="hljs-comment"># If external database is used, the following settings for database will</span><br>    <span class="hljs-comment"># be ignored</span><br>    <span class="hljs-attr">database:</span><br>      <span class="hljs-attr">existingClaim:</span> <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">storageClass:</span> <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">subPath:</span> <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">accessMode:</span> <span class="hljs-string">ReadWriteOnce</span><br>      <span class="hljs-attr">size:</span> <span class="hljs-string">1Gi</span><br>      <span class="hljs-attr">annotations:</span> &#123;&#125;<br>    <span class="hljs-comment"># If external Redis is used, the following settings for Redis will</span><br>    <span class="hljs-comment"># be ignored</span><br>    <span class="hljs-attr">redis:</span><br>      <span class="hljs-attr">existingClaim:</span> <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">storageClass:</span> <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">subPath:</span> <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">accessMode:</span> <span class="hljs-string">ReadWriteOnce</span><br>      <span class="hljs-attr">size:</span> <span class="hljs-string">1Gi</span><br>      <span class="hljs-attr">annotations:</span> &#123;&#125;<br>    <span class="hljs-attr">trivy:</span><br>      <span class="hljs-attr">existingClaim:</span> <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">storageClass:</span> <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">subPath:</span> <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">accessMode:</span> <span class="hljs-string">ReadWriteOnce</span><br>      <span class="hljs-attr">size:</span> <span class="hljs-string">5Gi</span><br>      <span class="hljs-attr">annotations:</span> &#123;&#125;<br>  <span class="hljs-comment"># Define which storage backend is used for registry to store</span><br>  <span class="hljs-comment"># images and charts. Refer to</span><br>  <span class="hljs-comment"># https://github.com/docker/distribution/blob/master/docs/configuration.md#storage</span><br>  <span class="hljs-comment"># for the detail.</span><br>  <span class="hljs-attr">imageChartStorage:</span><br>    <span class="hljs-comment"># Specify whether to disable `redirect` for images and chart storage, for</span><br>    <span class="hljs-comment"># backends which not supported it (such as using minio for `s3` storage type), please disable</span><br>    <span class="hljs-comment"># it. To disable redirects, simply set `disableredirect` to `true` instead.</span><br>    <span class="hljs-comment"># Refer to</span><br>    <span class="hljs-comment"># https://github.com/docker/distribution/blob/master/docs/configuration.md#redirect</span><br>    <span class="hljs-comment"># for the detail.</span><br>    <span class="hljs-attr">disableredirect:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># Specify the &quot;caBundleSecretName&quot; if the storage service uses a self-signed certificate.</span><br>    <span class="hljs-comment"># The secret must contain keys named &quot;ca.crt&quot; which will be injected into the trust store</span><br>    <span class="hljs-comment"># of registry&#x27;s containers.</span><br>    <span class="hljs-comment"># caBundleSecretName:</span><br><br>    <span class="hljs-comment"># Specify the type of storage: &quot;filesystem&quot;, &quot;azure&quot;, &quot;gcs&quot;, &quot;s3&quot;, &quot;swift&quot;,</span><br>    <span class="hljs-comment"># &quot;oss&quot; and fill the information needed in the corresponding section. The type</span><br>    <span class="hljs-comment"># must be &quot;filesystem&quot; if you want to use persistent volumes for registry</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">filesystem</span><br>    <span class="hljs-attr">filesystem:</span><br>      <span class="hljs-attr">rootdirectory:</span> <span class="hljs-string">/storage</span><br>      <span class="hljs-comment">#maxthreads: 100</span><br>    <span class="hljs-attr">azure:</span><br>      <span class="hljs-attr">accountname:</span> <span class="hljs-string">accountname</span><br>      <span class="hljs-attr">accountkey:</span> <span class="hljs-string">base64encodedaccountkey</span><br>      <span class="hljs-attr">container:</span> <span class="hljs-string">containername</span><br>      <span class="hljs-comment">#realm: core.windows.net</span><br>      <span class="hljs-comment"># To use existing secret, the key must be AZURE_STORAGE_ACCESS_KEY</span><br>      <span class="hljs-attr">existingSecret:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">gcs:</span><br>      <span class="hljs-attr">bucket:</span> <span class="hljs-string">bucketname</span><br>      <span class="hljs-comment"># The base64 encoded json file which contains the key</span><br>      <span class="hljs-attr">encodedkey:</span> <span class="hljs-string">base64-encoded-json-key-file</span><br>      <span class="hljs-comment">#rootdirectory: /gcs/object/name/prefix</span><br>      <span class="hljs-comment">#chunksize: &quot;5242880&quot;</span><br>      <span class="hljs-comment"># To use existing secret, the key must be GCS_KEY_DATA</span><br>      <span class="hljs-attr">existingSecret:</span> <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">useWorkloadIdentity:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">s3:</span><br>      <span class="hljs-comment"># Set an existing secret for S3 accesskey and secretkey</span><br>      <span class="hljs-comment"># keys in the secret should be REGISTRY_STORAGE_S3_ACCESSKEY and REGISTRY_STORAGE_S3_SECRETKEY for registry</span><br>      <span class="hljs-comment">#existingSecret: &quot;&quot;</span><br>      <span class="hljs-attr">region:</span> <span class="hljs-string">us-west-1</span><br>      <span class="hljs-attr">bucket:</span> <span class="hljs-string">bucketname</span><br>      <span class="hljs-comment">#accesskey: awsaccesskey</span><br>      <span class="hljs-comment">#secretkey: awssecretkey</span><br>      <span class="hljs-comment">#regionendpoint: http://myobjects.local</span><br>      <span class="hljs-comment">#encrypt: false</span><br>      <span class="hljs-comment">#keyid: mykeyid</span><br>      <span class="hljs-comment">#secure: true</span><br>      <span class="hljs-comment">#skipverify: false</span><br>      <span class="hljs-comment">#v4auth: true</span><br>      <span class="hljs-comment">#chunksize: &quot;5242880&quot;</span><br>      <span class="hljs-comment">#rootdirectory: /s3/object/name/prefix</span><br>      <span class="hljs-comment">#storageclass: STANDARD</span><br>      <span class="hljs-comment">#multipartcopychunksize: &quot;33554432&quot;</span><br>      <span class="hljs-comment">#multipartcopymaxconcurrency: 100</span><br>      <span class="hljs-comment">#multipartcopythresholdsize: &quot;33554432&quot;</span><br>    <span class="hljs-attr">swift:</span><br>      <span class="hljs-attr">authurl:</span> <span class="hljs-string">https://storage.myprovider.com/v3/auth</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">username</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">password</span><br>      <span class="hljs-attr">container:</span> <span class="hljs-string">containername</span><br>      <span class="hljs-comment">#region: fr</span><br>      <span class="hljs-comment">#tenant: tenantname</span><br>      <span class="hljs-comment">#tenantid: tenantid</span><br>      <span class="hljs-comment">#domain: domainname</span><br>      <span class="hljs-comment">#domainid: domainid</span><br>      <span class="hljs-comment">#trustid: trustid</span><br>      <span class="hljs-comment">#insecureskipverify: false</span><br>      <span class="hljs-comment">#chunksize: 5M</span><br>      <span class="hljs-comment">#prefix:</span><br>      <span class="hljs-comment">#secretkey: secretkey</span><br>      <span class="hljs-comment">#accesskey: accesskey</span><br>      <span class="hljs-comment">#authversion: 3</span><br>      <span class="hljs-comment">#endpointtype: public</span><br>      <span class="hljs-comment">#tempurlcontainerkey: false</span><br>      <span class="hljs-comment">#tempurlmethods:</span><br>    <span class="hljs-attr">oss:</span><br>      <span class="hljs-attr">accesskeyid:</span> <span class="hljs-string">accesskeyid</span><br>      <span class="hljs-attr">accesskeysecret:</span> <span class="hljs-string">accesskeysecret</span><br>      <span class="hljs-attr">region:</span> <span class="hljs-string">regionname</span><br>      <span class="hljs-attr">bucket:</span> <span class="hljs-string">bucketname</span><br>      <span class="hljs-comment">#endpoint: endpoint</span><br>      <span class="hljs-comment">#internal: false</span><br>      <span class="hljs-comment">#encrypt: false</span><br>      <span class="hljs-comment">#secure: true</span><br>      <span class="hljs-comment">#chunksize: 10M</span><br>      <span class="hljs-comment">#rootdirectory: rootdirectory</span><br><br><span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br><br><span class="hljs-comment"># Use this set to assign a list of default pullSecrets</span><br><span class="hljs-attr">imagePullSecrets:</span><br><span class="hljs-comment">#  - name: docker-registry-secret</span><br><span class="hljs-comment">#  - name: internal-registry-secret</span><br><br><span class="hljs-comment"># The update strategy for deployments with persistent volumes(jobservice, registry): &quot;RollingUpdate&quot; or &quot;Recreate&quot;</span><br><span class="hljs-comment"># Set it as &quot;Recreate&quot; when &quot;RWM&quot; for volumes isn&#x27;t supported</span><br><span class="hljs-attr">updateStrategy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">RollingUpdate</span><br><br><span class="hljs-comment"># debug, info, warning, error or fatal</span><br><span class="hljs-attr">logLevel:</span> <span class="hljs-string">info</span><br><br><span class="hljs-comment"># The initial password of Harbor admin. Change it from portal after launching Harbor</span><br><span class="hljs-comment"># or give an existing secret for it</span><br><span class="hljs-comment"># key in secret is given via (default to HARBOR_ADMIN_PASSWORD)</span><br><span class="hljs-comment"># existingSecretAdminPassword:</span><br><span class="hljs-attr">existingSecretAdminPasswordKey:</span> <span class="hljs-string">HARBOR_ADMIN_PASSWORD</span><br><span class="hljs-attr">harborAdminPassword:</span> <span class="hljs-string">&quot;Harbor12345&quot;</span><br><br><span class="hljs-comment"># The name of the secret which contains key named &quot;ca.crt&quot;. Setting this enables the</span><br><span class="hljs-comment"># download link on portal to download the CA certificate when the certificate isn&#x27;t</span><br><span class="hljs-comment"># generated automatically</span><br><span class="hljs-attr">caSecretName:</span> <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment"># The secret key used for encryption. Must be a string of 16 chars.</span><br><span class="hljs-attr">secretKey:</span> <span class="hljs-string">&quot;not-a-secure-key&quot;</span><br><span class="hljs-comment"># If using existingSecretSecretKey, the key must be secretKey</span><br><span class="hljs-attr">existingSecretSecretKey:</span> <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment"># The proxy settings for updating trivy vulnerabilities from the Internet and replicating</span><br><span class="hljs-comment"># artifacts from/to the registries that cannot be reached directly</span><br><span class="hljs-attr">proxy:</span><br>  <span class="hljs-attr">httpProxy:</span><br>  <span class="hljs-attr">httpsProxy:</span><br>  <span class="hljs-attr">noProxy:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">,localhost,.local,.internal</span><br>  <span class="hljs-attr">components:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">core</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">jobservice</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">trivy</span><br><br><span class="hljs-comment"># Run the migration job via helm hook</span><br><span class="hljs-attr">enableMigrateHelmHook:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># The custom ca bundle secret, the secret must contain key named &quot;ca.crt&quot;</span><br><span class="hljs-comment"># which will be injected into the trust store for core, jobservice, registry, trivy components</span><br><span class="hljs-comment"># caBundleSecretName: &quot;&quot;</span><br><br><span class="hljs-comment">## UAA Authentication Options</span><br><span class="hljs-comment"># If you&#x27;re using UAA for authentication behind a self-signed</span><br><span class="hljs-comment"># certificate you will need to provide the CA Cert.</span><br><span class="hljs-comment"># Set uaaSecretName below to provide a pre-created secret that</span><br><span class="hljs-comment"># contains a base64 encoded CA Certificate named `ca.crt`.</span><br><span class="hljs-comment"># uaaSecretName:</span><br><br><span class="hljs-comment"># If service exposed via &quot;ingress&quot;, the Nginx will not be used</span><br><span class="hljs-attr">nginx:</span><br>  <span class="hljs-attr">image:</span><br>    <span class="hljs-attr">repository:</span> <span class="hljs-string">goharbor/nginx-photon</span><br>    <span class="hljs-attr">tag:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-comment"># set the service account to be used, default if left empty</span><br>  <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment"># mount the service account token</span><br>  <span class="hljs-attr">automountServiceAccountToken:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">revisionHistoryLimit:</span> <span class="hljs-number">10</span><br>  <span class="hljs-comment"># resources:</span><br>  <span class="hljs-comment">#  requests:</span><br>  <span class="hljs-comment">#    memory: 256Mi</span><br>  <span class="hljs-comment">#    cpu: 100m</span><br>  <span class="hljs-attr">extraEnvVars:</span> []<br>  <span class="hljs-attr">nodeSelector:</span> &#123;&#125;<br>  <span class="hljs-attr">tolerations:</span> []<br>  <span class="hljs-attr">affinity:</span> &#123;&#125;<br>  <span class="hljs-comment"># Spread Pods across failure-domains like regions, availability zones or nodes</span><br>  <span class="hljs-attr">topologySpreadConstraints:</span> []<br>  <span class="hljs-comment"># - maxSkew: 1</span><br>  <span class="hljs-comment">#   topologyKey: topology.kubernetes.io/zone</span><br>  <span class="hljs-comment">#   nodeTaintsPolicy: Honor</span><br>  <span class="hljs-comment">#   whenUnsatisfiable: DoNotSchedule</span><br>  <span class="hljs-comment">## Additional deployment annotations</span><br>  <span class="hljs-attr">podAnnotations:</span> &#123;&#125;<br>  <span class="hljs-comment">## Additional deployment labels</span><br>  <span class="hljs-attr">podLabels:</span> &#123;&#125;<br>  <span class="hljs-comment">## The priority class to run the pod as</span><br>  <span class="hljs-attr">priorityClassName:</span><br><br><span class="hljs-attr">portal:</span><br>  <span class="hljs-attr">image:</span><br>    <span class="hljs-attr">repository:</span> <span class="hljs-string">goharbor/harbor-portal</span><br>    <span class="hljs-attr">tag:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-comment"># set the service account to be used, default if left empty</span><br>  <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment"># mount the service account token</span><br>  <span class="hljs-attr">automountServiceAccountToken:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">revisionHistoryLimit:</span> <span class="hljs-number">10</span><br>  <span class="hljs-comment"># resources:</span><br>  <span class="hljs-comment">#  requests:</span><br>  <span class="hljs-comment">#    memory: 256Mi</span><br>  <span class="hljs-comment">#    cpu: 100m</span><br>  <span class="hljs-attr">extraEnvVars:</span> []<br>  <span class="hljs-attr">nodeSelector:</span> &#123;&#125;<br>  <span class="hljs-attr">tolerations:</span> []<br>  <span class="hljs-attr">affinity:</span> &#123;&#125;<br>  <span class="hljs-comment"># Spread Pods across failure-domains like regions, availability zones or nodes</span><br>  <span class="hljs-attr">topologySpreadConstraints:</span> []<br>  <span class="hljs-comment"># - maxSkew: 1</span><br>  <span class="hljs-comment">#   topologyKey: topology.kubernetes.io/zone</span><br>  <span class="hljs-comment">#   nodeTaintsPolicy: Honor</span><br>  <span class="hljs-comment">#   whenUnsatisfiable: DoNotSchedule</span><br>  <span class="hljs-comment">## Additional deployment annotations</span><br>  <span class="hljs-attr">podAnnotations:</span> &#123;&#125;<br>  <span class="hljs-comment">## Additional deployment labels</span><br>  <span class="hljs-attr">podLabels:</span> &#123;&#125;<br>  <span class="hljs-comment">## The priority class to run the pod as</span><br>  <span class="hljs-attr">priorityClassName:</span><br><br><span class="hljs-attr">core:</span><br>  <span class="hljs-attr">image:</span><br>    <span class="hljs-attr">repository:</span> <span class="hljs-string">goharbor/harbor-core</span><br>    <span class="hljs-attr">tag:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-comment"># set the service account to be used, default if left empty</span><br>  <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment"># mount the service account token</span><br>  <span class="hljs-attr">automountServiceAccountToken:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">revisionHistoryLimit:</span> <span class="hljs-number">10</span><br>  <span class="hljs-comment">## Startup probe values</span><br>  <span class="hljs-attr">startupProbe:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">10</span><br>  <span class="hljs-comment"># resources:</span><br>  <span class="hljs-comment">#  requests:</span><br>  <span class="hljs-comment">#    memory: 256Mi</span><br>  <span class="hljs-comment">#    cpu: 100m</span><br>  <span class="hljs-attr">extraEnvVars:</span> []<br>  <span class="hljs-attr">nodeSelector:</span> &#123;&#125;<br>  <span class="hljs-attr">tolerations:</span> []<br>  <span class="hljs-attr">affinity:</span> &#123;&#125;<br>  <span class="hljs-comment"># Spread Pods across failure-domains like regions, availability zones or nodes</span><br>  <span class="hljs-attr">topologySpreadConstraints:</span> []<br>  <span class="hljs-comment"># - maxSkew: 1</span><br>  <span class="hljs-comment">#   topologyKey: topology.kubernetes.io/zone</span><br>  <span class="hljs-comment">#   nodeTaintsPolicy: Honor</span><br>  <span class="hljs-comment">#   whenUnsatisfiable: DoNotSchedule</span><br>  <span class="hljs-comment">## Additional deployment annotations</span><br>  <span class="hljs-attr">podAnnotations:</span> &#123;&#125;<br>  <span class="hljs-comment">## Additional deployment labels</span><br>  <span class="hljs-attr">podLabels:</span> &#123;&#125;<br>  <span class="hljs-comment">## Additional service annotations</span><br>  <span class="hljs-attr">serviceAnnotations:</span> &#123;&#125;<br>  <span class="hljs-comment">## User settings configuration json string</span><br>  <span class="hljs-attr">configureUserSettings:</span><br>  <span class="hljs-comment"># Secret is used when core server communicates with other components.</span><br>  <span class="hljs-comment"># If a secret key is not specified, Helm will generate one.</span><br>  <span class="hljs-comment"># Must be a string of 16 chars.</span><br>  <span class="hljs-attr">secret:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment"># Fill the name of a kubernetes secret if you want to use your own</span><br>  <span class="hljs-comment"># TLS certificate and private key for token encryption/decryption.</span><br>  <span class="hljs-comment"># The secret must contain keys named:</span><br>  <span class="hljs-comment"># &quot;tls.key&quot; - the private key</span><br>  <span class="hljs-comment"># &quot;tls.crt&quot; - the certificate</span><br>  <span class="hljs-attr">secretName:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment"># If not specifying a preexisting secret, a secret can be created from tokenKey and tokenCert and used instead.</span><br>  <span class="hljs-comment"># If none of secretName, tokenKey, and tokenCert are specified, an ephemeral key and certificate will be autogenerated.</span><br>  <span class="hljs-comment"># tokenKey and tokenCert must BOTH be set or BOTH unset.</span><br>  <span class="hljs-comment"># The tokenKey value is formatted as a multiline string containing a PEM-encoded RSA key, indented one more than tokenKey on the following line.</span><br>  <span class="hljs-attr">tokenKey:</span> <span class="hljs-string">|</span><br><span class="hljs-string">  # If tokenKey is set, the value of tokenCert must be set as a PEM-encoded certificate signed by tokenKey, and supplied as a multiline string, indented one more than tokenCert on the following line.</span><br><span class="hljs-string">  tokenCert: |</span><br><span class="hljs-string">  # The XSRF key. Will be generated automatically if it isn&#x27;t specified</span><br><span class="hljs-string">  xsrfKey: &quot;&quot;</span><br><span class="hljs-string">  ## The priority class to run the pod as</span><br><span class="hljs-string">  priorityClassName:</span><br><span class="hljs-string">  # The time duration for async update artifact pull_time and repository</span><br><span class="hljs-string">  # pull_count, the unit is second. Will be 10 seconds if it isn&#x27;t set.</span><br><span class="hljs-string">  # eg. artifactPullAsyncFlushDuration: 10</span><br><span class="hljs-string">  artifactPullAsyncFlushDuration:</span><br><span class="hljs-string">  gdpr:</span><br><span class="hljs-string">    deleteUser: false</span><br><span class="hljs-string"></span><br><span class="hljs-attr">jobservice:</span><br>  <span class="hljs-attr">image:</span><br>    <span class="hljs-attr">repository:</span> <span class="hljs-string">goharbor/harbor-jobservice</span><br>    <span class="hljs-attr">tag:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">revisionHistoryLimit:</span> <span class="hljs-number">10</span><br>  <span class="hljs-comment"># set the service account to be used, default if left empty</span><br>  <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment"># mount the service account token</span><br>  <span class="hljs-attr">automountServiceAccountToken:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">maxJobWorkers:</span> <span class="hljs-number">10</span><br>  <span class="hljs-comment"># The logger for jobs: &quot;file&quot;, &quot;database&quot; or &quot;stdout&quot;</span><br>  <span class="hljs-attr">jobLoggers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">file</span><br>    <span class="hljs-comment"># - database</span><br>    <span class="hljs-comment"># - stdout</span><br>  <span class="hljs-comment"># The jobLogger sweeper duration (ignored if `jobLogger` is `stdout`)</span><br>  <span class="hljs-attr">loggerSweeperDuration:</span> <span class="hljs-number">14</span> <span class="hljs-comment">#days</span><br>  <span class="hljs-attr">notification:</span><br>    <span class="hljs-attr">webhook_job_max_retry:</span> <span class="hljs-number">3</span><br>    <span class="hljs-attr">webhook_job_http_client_timeout:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># in seconds</span><br>  <span class="hljs-attr">reaper:</span><br>    <span class="hljs-comment"># the max time to wait for a task to finish, if unfinished after max_update_hours, the task will be mark as error, but the task will continue to run, default value is 24</span><br>    <span class="hljs-attr">max_update_hours:</span> <span class="hljs-number">24</span><br>    <span class="hljs-comment"># the max time for execution in running state without new task created</span><br>    <span class="hljs-attr">max_dangling_hours:</span> <span class="hljs-number">168</span><br><br>  <span class="hljs-comment"># resources:</span><br>  <span class="hljs-comment">#   requests:</span><br>  <span class="hljs-comment">#     memory: 256Mi</span><br>  <span class="hljs-comment">#     cpu: 100m</span><br>  <span class="hljs-attr">extraEnvVars:</span> []<br>  <span class="hljs-attr">nodeSelector:</span> &#123;&#125;<br>  <span class="hljs-attr">tolerations:</span> []<br>  <span class="hljs-attr">affinity:</span> &#123;&#125;<br>  <span class="hljs-comment"># Spread Pods across failure-domains like regions, availability zones or nodes</span><br>  <span class="hljs-attr">topologySpreadConstraints:</span><br>  <span class="hljs-comment"># - maxSkew: 1</span><br>  <span class="hljs-comment">#   topologyKey: topology.kubernetes.io/zone</span><br>  <span class="hljs-comment">#   nodeTaintsPolicy: Honor</span><br>  <span class="hljs-comment">#   whenUnsatisfiable: DoNotSchedule</span><br>  <span class="hljs-comment">## Additional deployment annotations</span><br>  <span class="hljs-attr">podAnnotations:</span> &#123;&#125;<br>  <span class="hljs-comment">## Additional deployment labels</span><br>  <span class="hljs-attr">podLabels:</span> &#123;&#125;<br>  <span class="hljs-comment"># Secret is used when job service communicates with other components.</span><br>  <span class="hljs-comment"># If a secret key is not specified, Helm will generate one.</span><br>  <span class="hljs-comment"># Must be a string of 16 chars.</span><br>  <span class="hljs-attr">secret:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment">## The priority class to run the pod as</span><br>  <span class="hljs-attr">priorityClassName:</span><br><br><span class="hljs-attr">registry:</span><br>  <span class="hljs-comment"># set the service account to be used, default if left empty</span><br>  <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment"># mount the service account token</span><br>  <span class="hljs-attr">automountServiceAccountToken:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">image:</span><br>      <span class="hljs-attr">repository:</span> <span class="hljs-string">goharbor/registry-photon</span><br>      <span class="hljs-attr">tag:</span> <span class="hljs-string">dev</span><br>    <span class="hljs-comment"># resources:</span><br>    <span class="hljs-comment">#  requests:</span><br>    <span class="hljs-comment">#    memory: 256Mi</span><br>    <span class="hljs-comment">#    cpu: 100m</span><br>    <span class="hljs-attr">extraEnvVars:</span> []<br>  <span class="hljs-attr">controller:</span><br>    <span class="hljs-attr">image:</span><br>      <span class="hljs-attr">repository:</span> <span class="hljs-string">goharbor/harbor-registryctl</span><br>      <span class="hljs-attr">tag:</span> <span class="hljs-string">dev</span><br><br>    <span class="hljs-comment"># resources:</span><br>    <span class="hljs-comment">#  requests:</span><br>    <span class="hljs-comment">#    memory: 256Mi</span><br>    <span class="hljs-comment">#    cpu: 100m</span><br>    <span class="hljs-attr">extraEnvVars:</span> []<br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">revisionHistoryLimit:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">nodeSelector:</span> &#123;&#125;<br>  <span class="hljs-attr">tolerations:</span> []<br>  <span class="hljs-attr">affinity:</span> &#123;&#125;<br>  <span class="hljs-comment"># Spread Pods across failure-domains like regions, availability zones or nodes</span><br>  <span class="hljs-attr">topologySpreadConstraints:</span> []<br>  <span class="hljs-comment"># - maxSkew: 1</span><br>  <span class="hljs-comment">#   topologyKey: topology.kubernetes.io/zone</span><br>  <span class="hljs-comment">#   nodeTaintsPolicy: Honor</span><br>  <span class="hljs-comment">#   whenUnsatisfiable: DoNotSchedule</span><br>  <span class="hljs-comment">## Additional deployment annotations</span><br>  <span class="hljs-attr">podAnnotations:</span> &#123;&#125;<br>  <span class="hljs-comment">## Additional deployment labels</span><br>  <span class="hljs-attr">podLabels:</span> &#123;&#125;<br>  <span class="hljs-comment">## The priority class to run the pod as</span><br>  <span class="hljs-attr">priorityClassName:</span><br>  <span class="hljs-comment"># Secret is used to secure the upload state from client</span><br>  <span class="hljs-comment"># and registry storage backend.</span><br>  <span class="hljs-comment"># See: https://github.com/docker/distribution/blob/master/docs/configuration.md#http</span><br>  <span class="hljs-comment"># If a secret key is not specified, Helm will generate one.</span><br>  <span class="hljs-comment"># Must be a string of 16 chars.</span><br>  <span class="hljs-attr">secret:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment"># If true, the registry returns relative URLs in Location headers. The client is responsible for resolving the correct URL.</span><br>  <span class="hljs-attr">relativeurls:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">credentials:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">&quot;harbor_registry_user&quot;</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;harbor_registry_password&quot;</span><br>    <span class="hljs-comment"># If using existingSecret, the key must be REGISTRY_PASSWD and REGISTRY_HTPASSWD</span><br>    <span class="hljs-attr">existingSecret:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># Login and password in htpasswd string format. Excludes `registry.credentials.username`  and `registry.credentials.password`. May come in handy when integrating with tools like argocd or flux. This allows the same line to be generated each time the template is rendered, instead of the `htpasswd` function from helm, which generates different lines each time because of the salt.</span><br>    <span class="hljs-comment"># htpasswdString: $apr1$XLefHzeG$Xl4.s00sMSCCcMyJljSZb0 # example string</span><br>  <span class="hljs-attr">middleware:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">cloudFront</span><br>    <span class="hljs-attr">cloudFront:</span><br>      <span class="hljs-attr">baseurl:</span> <span class="hljs-string">example.cloudfront.net</span><br>      <span class="hljs-attr">keypairid:</span> <span class="hljs-string">KEYPAIRID</span><br>      <span class="hljs-attr">duration:</span> <span class="hljs-string">3000s</span><br>      <span class="hljs-attr">ipfilteredby:</span> <span class="hljs-string">none</span><br>      <span class="hljs-comment"># The secret key that should be present is CLOUDFRONT_KEY_DATA, which should be the encoded private key</span><br>      <span class="hljs-comment"># that allows access to CloudFront</span><br>      <span class="hljs-attr">privateKeySecret:</span> <span class="hljs-string">&quot;my-secret&quot;</span><br>  <span class="hljs-comment"># enable purge _upload directories</span><br>  <span class="hljs-attr">upload_purging:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># remove files in _upload directories which exist for a period of time, default is one week.</span><br>    <span class="hljs-attr">age:</span> <span class="hljs-string">168h</span><br>    <span class="hljs-comment"># the interval of the purge operations</span><br>    <span class="hljs-attr">interval:</span> <span class="hljs-string">24h</span><br>    <span class="hljs-attr">dryrun:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">trivy:</span><br>  <span class="hljs-comment"># enabled the flag to enable Trivy scanner</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">image:</span><br>    <span class="hljs-comment"># repository the repository for Trivy adapter image</span><br>    <span class="hljs-attr">repository:</span> <span class="hljs-string">goharbor/trivy-adapter-photon</span><br>    <span class="hljs-comment"># tag the tag for Trivy adapter image</span><br>    <span class="hljs-attr">tag:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-comment"># set the service account to be used, default if left empty</span><br>  <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment"># mount the service account token</span><br>  <span class="hljs-attr">automountServiceAccountToken:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># replicas the number of Pod replicas</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-comment"># debugMode the flag to enable Trivy debug mode with more verbose scanning log</span><br>  <span class="hljs-attr">debugMode:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># vulnType a comma-separated list of vulnerability types. Possible values are `os` and `library`.</span><br>  <span class="hljs-attr">vulnType:</span> <span class="hljs-string">&quot;os,library&quot;</span><br>  <span class="hljs-comment"># severity a comma-separated list of severities to be checked</span><br>  <span class="hljs-attr">severity:</span> <span class="hljs-string">&quot;UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL&quot;</span><br>  <span class="hljs-comment"># ignoreUnfixed the flag to display only fixed vulnerabilities</span><br>  <span class="hljs-attr">ignoreUnfixed:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># insecure the flag to skip verifying registry certificate</span><br>  <span class="hljs-attr">insecure:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># gitHubToken the GitHub access token to download Trivy DB</span><br>  <span class="hljs-comment">#</span><br>  <span class="hljs-comment"># Trivy DB contains vulnerability information from NVD, Red Hat, and many other upstream vulnerability databases.</span><br>  <span class="hljs-comment"># It is downloaded by Trivy from the GitHub release page https://github.com/aquasecurity/trivy-db/releases and cached</span><br>  <span class="hljs-comment"># in the local file system (`/home/scanner/.cache/trivy/db/trivy.db`). In addition, the database contains the update</span><br>  <span class="hljs-comment"># timestamp so Trivy can detect whether it should download a newer version from the Internet or use the cached one.</span><br>  <span class="hljs-comment"># Currently, the database is updated every 12 hours and published as a new release to GitHub.</span><br>  <span class="hljs-comment">#</span><br>  <span class="hljs-comment"># Anonymous downloads from GitHub are subject to the limit of 60 requests per hour. Normally such rate limit is enough</span><br>  <span class="hljs-comment"># for production operations. If, for any reason, it&#x27;s not enough, you could increase the rate limit to 5000</span><br>  <span class="hljs-comment"># requests per hour by specifying the GitHub access token. For more details on GitHub rate limiting please consult</span><br>  <span class="hljs-comment"># https://developer.github.com/v3/#rate-limiting</span><br>  <span class="hljs-comment">#</span><br>  <span class="hljs-comment"># You can create a GitHub token by following the instructions in</span><br>  <span class="hljs-comment"># https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line</span><br>  <span class="hljs-attr">gitHubToken:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment"># skipUpdate the flag to disable Trivy DB downloads from GitHub</span><br>  <span class="hljs-comment">#</span><br>  <span class="hljs-comment"># You might want to set the value of this flag to `true` in test or CI/CD environments to avoid GitHub rate limiting issues.</span><br>  <span class="hljs-comment"># If the value is set to `true` you have to manually download the `trivy.db` file and mount it in the</span><br>  <span class="hljs-comment"># `/home/scanner/.cache/trivy/db/trivy.db` path.</span><br>  <span class="hljs-attr">skipUpdate:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># The offlineScan option prevents Trivy from sending API requests to identify dependencies.</span><br>  <span class="hljs-comment">#</span><br>  <span class="hljs-comment"># Scanning JAR files and pom.xml may require Internet access for better detection, but this option tries to avoid it.</span><br>  <span class="hljs-comment"># For example, the offline mode will not try to resolve transitive dependencies in pom.xml when the dependency doesn&#x27;t</span><br>  <span class="hljs-comment"># exist in the local repositories. It means a number of detected vulnerabilities might be fewer in offline mode.</span><br>  <span class="hljs-comment"># It would work if all the dependencies are in local.</span><br>  <span class="hljs-comment"># This option doesn’t affect DB download. You need to specify skipUpdate as well as offlineScan in an air-gapped environment.</span><br>  <span class="hljs-attr">offlineScan:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># Comma-separated list of what security issues to detect. Possible values are `vuln`, `config` and `secret`. Defaults to `vuln`.</span><br>  <span class="hljs-attr">securityCheck:</span> <span class="hljs-string">&quot;vuln&quot;</span><br>  <span class="hljs-comment"># The duration to wait for scan completion</span><br>  <span class="hljs-attr">timeout:</span> <span class="hljs-string">5m0s</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">cpu:</span> <span class="hljs-string">200m</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-string">512Mi</span><br>    <span class="hljs-attr">limits:</span><br>      <span class="hljs-attr">cpu:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-string">1Gi</span><br>  <span class="hljs-attr">extraEnvVars:</span> []<br>  <span class="hljs-attr">nodeSelector:</span> &#123;&#125;<br>  <span class="hljs-attr">tolerations:</span> []<br>  <span class="hljs-attr">affinity:</span> &#123;&#125;<br>  <span class="hljs-comment"># Spread Pods across failure-domains like regions, availability zones or nodes</span><br>  <span class="hljs-attr">topologySpreadConstraints:</span> []<br>  <span class="hljs-comment"># - maxSkew: 1</span><br>  <span class="hljs-comment">#   topologyKey: topology.kubernetes.io/zone</span><br>  <span class="hljs-comment">#   nodeTaintsPolicy: Honor</span><br>  <span class="hljs-comment">#   whenUnsatisfiable: DoNotSchedule</span><br>  <span class="hljs-comment">## Additional deployment annotations</span><br>  <span class="hljs-attr">podAnnotations:</span> &#123;&#125;<br>  <span class="hljs-comment">## Additional deployment labels</span><br>  <span class="hljs-attr">podLabels:</span> &#123;&#125;<br>  <span class="hljs-comment">## The priority class to run the pod as</span><br>  <span class="hljs-attr">priorityClassName:</span><br><br><span class="hljs-attr">database:</span><br>  <span class="hljs-comment"># if external database is used, set &quot;type&quot; to &quot;external&quot;</span><br>  <span class="hljs-comment"># and fill the connection information in &quot;external&quot; section</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">internal</span><br>  <span class="hljs-attr">internal:</span><br>    <span class="hljs-comment"># set the service account to be used, default if left empty</span><br>    <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># mount the service account token</span><br>    <span class="hljs-attr">automountServiceAccountToken:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">image:</span><br>      <span class="hljs-attr">repository:</span> <span class="hljs-string">goharbor/harbor-db</span><br>      <span class="hljs-attr">tag:</span> <span class="hljs-string">dev</span><br>    <span class="hljs-comment"># The initial superuser password for internal database</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;changeit&quot;</span><br>    <span class="hljs-comment"># The size limit for Shared memory, pgSQL use it for shared_buffer</span><br>    <span class="hljs-comment"># More details see:</span><br>    <span class="hljs-comment"># https://github.com/goharbor/harbor/issues/15034</span><br>    <span class="hljs-attr">shmSizeLimit:</span> <span class="hljs-string">512Mi</span><br>    <span class="hljs-comment"># resources:</span><br>    <span class="hljs-comment">#  requests:</span><br>    <span class="hljs-comment">#    memory: 256Mi</span><br>    <span class="hljs-comment">#    cpu: 100m</span><br>    <span class="hljs-comment"># The timeout used in livenessProbe; 1 to 5 seconds</span><br>    <span class="hljs-attr">livenessProbe:</span><br>      <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span><br>    <span class="hljs-comment"># The timeout used in readinessProbe; 1 to 5 seconds</span><br>    <span class="hljs-attr">readinessProbe:</span><br>      <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">extraEnvVars:</span> []<br>    <span class="hljs-attr">nodeSelector:</span> &#123;&#125;<br>    <span class="hljs-attr">tolerations:</span> []<br>    <span class="hljs-attr">affinity:</span> &#123;&#125;<br>    <span class="hljs-comment">## The priority class to run the pod as</span><br>    <span class="hljs-attr">priorityClassName:</span><br>    <span class="hljs-attr">initContainer:</span><br>      <span class="hljs-attr">migrator:</span> &#123;&#125;<br>      <span class="hljs-comment"># resources:</span><br>      <span class="hljs-comment">#  requests:</span><br>      <span class="hljs-comment">#    memory: 128Mi</span><br>      <span class="hljs-comment">#    cpu: 100m</span><br>      <span class="hljs-attr">permissions:</span> &#123;&#125;<br>      <span class="hljs-comment"># resources:</span><br>      <span class="hljs-comment">#  requests:</span><br>      <span class="hljs-comment">#    memory: 128Mi</span><br>      <span class="hljs-comment">#    cpu: 100m</span><br>  <span class="hljs-attr">external:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">&quot;192.168.0.1&quot;</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-string">&quot;5432&quot;</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">&quot;user&quot;</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;password&quot;</span><br>    <span class="hljs-attr">coreDatabase:</span> <span class="hljs-string">&quot;registry&quot;</span><br>    <span class="hljs-comment"># if using existing secret, the key must be &quot;password&quot;</span><br>    <span class="hljs-attr">existingSecret:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># &quot;disable&quot; - No SSL</span><br>    <span class="hljs-comment"># &quot;require&quot; - Always SSL (skip verification)</span><br>    <span class="hljs-comment"># &quot;verify-ca&quot; - Always SSL (verify that the certificate presented by the</span><br>    <span class="hljs-comment"># server was signed by a trusted CA)</span><br>    <span class="hljs-comment"># &quot;verify-full&quot; - Always SSL (verify that the certification presented by the</span><br>    <span class="hljs-comment"># server was signed by a trusted CA and the server host name matches the one</span><br>    <span class="hljs-comment"># in the certificate)</span><br>    <span class="hljs-attr">sslmode:</span> <span class="hljs-string">&quot;disable&quot;</span><br>  <span class="hljs-comment"># The maximum number of connections in the idle connection pool per pod (core+exporter).</span><br>  <span class="hljs-comment"># If it &lt;=0, no idle connections are retained.</span><br>  <span class="hljs-attr">maxIdleConns:</span> <span class="hljs-number">100</span><br>  <span class="hljs-comment"># The maximum number of open connections to the database per pod (core+exporter).</span><br>  <span class="hljs-comment"># If it &lt;= 0, then there is no limit on the number of open connections.</span><br>  <span class="hljs-comment"># <span class="hljs-doctag">Note:</span> the default number of connections is 1024 for postgre of harbor.</span><br>  <span class="hljs-attr">maxOpenConns:</span> <span class="hljs-number">900</span><br>  <span class="hljs-comment">## Additional deployment annotations</span><br>  <span class="hljs-attr">podAnnotations:</span> &#123;&#125;<br>  <span class="hljs-comment">## Additional deployment labels</span><br>  <span class="hljs-attr">podLabels:</span> &#123;&#125;<br><br><span class="hljs-attr">redis:</span><br>  <span class="hljs-comment"># if external Redis is used, set &quot;type&quot; to &quot;external&quot;</span><br>  <span class="hljs-comment"># and fill the connection information in &quot;external&quot; section</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">internal</span><br>  <span class="hljs-attr">internal:</span><br>    <span class="hljs-comment"># set the service account to be used, default if left empty</span><br>    <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># mount the service account token</span><br>    <span class="hljs-attr">automountServiceAccountToken:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">image:</span><br>      <span class="hljs-attr">repository:</span> <span class="hljs-string">goharbor/redis-photon</span><br>      <span class="hljs-attr">tag:</span> <span class="hljs-string">dev</span><br>    <span class="hljs-comment"># resources:</span><br>    <span class="hljs-comment">#  requests:</span><br>    <span class="hljs-comment">#    memory: 256Mi</span><br>    <span class="hljs-comment">#    cpu: 100m</span><br>    <span class="hljs-attr">extraEnvVars:</span> []<br>    <span class="hljs-attr">nodeSelector:</span> &#123;&#125;<br>    <span class="hljs-attr">tolerations:</span> []<br>    <span class="hljs-attr">affinity:</span> &#123;&#125;<br>    <span class="hljs-comment">## The priority class to run the pod as</span><br>    <span class="hljs-attr">priorityClassName:</span><br>  <span class="hljs-attr">external:</span><br>    <span class="hljs-comment"># support redis, redis+sentinel</span><br>    <span class="hljs-comment"># addr for redis: &lt;host_redis&gt;:&lt;port_redis&gt;</span><br>    <span class="hljs-comment"># addr for redis+sentinel: &lt;host_sentinel1&gt;:&lt;port_sentinel1&gt;,&lt;host_sentinel2&gt;:&lt;port_sentinel2&gt;,&lt;host_sentinel3&gt;:&lt;port_sentinel3&gt;</span><br>    <span class="hljs-attr">addr:</span> <span class="hljs-string">&quot;192.168.0.2:6379&quot;</span><br>    <span class="hljs-comment"># The name of the set of Redis instances to monitor, it must be set to support redis+sentinel</span><br>    <span class="hljs-attr">sentinelMasterSet:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># The &quot;coreDatabaseIndex&quot; must be &quot;0&quot; as the library Harbor</span><br>    <span class="hljs-comment"># used doesn&#x27;t support configuring it</span><br>    <span class="hljs-attr">coreDatabaseIndex:</span> <span class="hljs-string">&quot;0&quot;</span><br>    <span class="hljs-attr">jobserviceDatabaseIndex:</span> <span class="hljs-string">&quot;1&quot;</span><br>    <span class="hljs-attr">registryDatabaseIndex:</span> <span class="hljs-string">&quot;2&quot;</span><br>    <span class="hljs-attr">trivyAdapterIndex:</span> <span class="hljs-string">&quot;5&quot;</span><br>    <span class="hljs-comment"># username field can be an empty string and it will be authenticated against the default user</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># If using existingSecret, the key must be REDIS_PASSWORD</span><br>    <span class="hljs-attr">existingSecret:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment">## Additional deployment annotations</span><br>  <span class="hljs-attr">podAnnotations:</span> &#123;&#125;<br>  <span class="hljs-comment">## Additional deployment labels</span><br>  <span class="hljs-attr">podLabels:</span> &#123;&#125;<br><br><span class="hljs-attr">exporter:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">revisionHistoryLimit:</span> <span class="hljs-number">10</span><br>  <span class="hljs-comment"># resources:</span><br>  <span class="hljs-comment">#  requests:</span><br>  <span class="hljs-comment">#    memory: 256Mi</span><br>  <span class="hljs-comment">#    cpu: 100m</span><br>  <span class="hljs-attr">extraEnvVars:</span> []<br>  <span class="hljs-attr">podAnnotations:</span> &#123;&#125;<br>  <span class="hljs-comment">## Additional deployment labels</span><br>  <span class="hljs-attr">podLabels:</span> &#123;&#125;<br>  <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment"># mount the service account token</span><br>  <span class="hljs-attr">automountServiceAccountToken:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">image:</span><br>    <span class="hljs-attr">repository:</span> <span class="hljs-string">goharbor/harbor-exporter</span><br>    <span class="hljs-attr">tag:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">nodeSelector:</span> &#123;&#125;<br>  <span class="hljs-attr">tolerations:</span> []<br>  <span class="hljs-attr">affinity:</span> &#123;&#125;<br>  <span class="hljs-comment"># Spread Pods across failure-domains like regions, availability zones or nodes</span><br>  <span class="hljs-attr">topologySpreadConstraints:</span> []<br>  <span class="hljs-comment"># - maxSkew: 1</span><br>  <span class="hljs-comment">#   topologyKey: topology.kubernetes.io/zone</span><br>  <span class="hljs-comment">#   nodeTaintsPolicy: Honor</span><br>  <span class="hljs-comment">#   whenUnsatisfiable: DoNotSchedule</span><br>  <span class="hljs-attr">cacheDuration:</span> <span class="hljs-number">23</span><br>  <span class="hljs-attr">cacheCleanInterval:</span> <span class="hljs-number">14400</span><br>  <span class="hljs-comment">## The priority class to run the pod as</span><br>  <span class="hljs-attr">priorityClassName:</span><br><br><span class="hljs-attr">metrics:</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">core:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/metrics</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8001</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/metrics</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8001</span><br>  <span class="hljs-attr">jobservice:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/metrics</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8001</span><br>  <span class="hljs-attr">exporter:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/metrics</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8001</span><br>  <span class="hljs-comment">## Create prometheus serviceMonitor to scrape harbor metrics.</span><br>  <span class="hljs-comment">## This requires the monitoring.coreos.com/v1 CRD. Please see</span><br>  <span class="hljs-comment">## https://github.com/prometheus-operator/prometheus-operator/blob/master/Documentation/user-guides/getting-started.md</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-attr">serviceMonitor:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">additionalLabels:</span> &#123;&#125;<br>    <span class="hljs-comment"># Scrape interval. If not set, the Prometheus default scrape interval is used.</span><br>    <span class="hljs-attr">interval:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># Metric relabel configs to apply to samples before ingestion.</span><br>    <span class="hljs-attr">metricRelabelings:</span><br>      []<br>      <span class="hljs-comment"># - action: keep</span><br>      <span class="hljs-comment">#   regex: &#x27;kube_(daemonset|deployment|pod|namespace|node|statefulset).+&#x27;</span><br>      <span class="hljs-comment">#   sourceLabels: [__name__]</span><br>    <span class="hljs-comment"># Relabel configs to apply to samples before ingestion.</span><br>    <span class="hljs-attr">relabelings:</span><br>      []<br>      <span class="hljs-comment"># - sourceLabels: [__meta_kubernetes_pod_node_name]</span><br>      <span class="hljs-comment">#   separator: ;</span><br>      <span class="hljs-comment">#   regex: ^(.*)$</span><br>      <span class="hljs-comment">#   targetLabel: nodename</span><br>      <span class="hljs-comment">#   replacement: $1</span><br>      <span class="hljs-comment">#   action: replace</span><br><br><span class="hljs-attr">trace:</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># trace provider: jaeger or otel</span><br>  <span class="hljs-comment"># jaeger should be 1.26+</span><br>  <span class="hljs-attr">provider:</span> <span class="hljs-string">jaeger</span><br>  <span class="hljs-comment"># set sample_rate to 1 if you wanna sampling 100% of trace data; set 0.5 if you wanna sampling 50% of trace data, and so forth</span><br>  <span class="hljs-attr">sample_rate:</span> <span class="hljs-number">1</span><br>  <span class="hljs-comment"># namespace used to differentiate different harbor services</span><br>  <span class="hljs-comment"># namespace:</span><br>  <span class="hljs-comment"># attributes is a key value dict contains user defined attributes used to initialize trace provider</span><br>  <span class="hljs-comment"># attributes:</span><br>  <span class="hljs-comment">#   application: harbor</span><br>  <span class="hljs-attr">jaeger:</span><br>    <span class="hljs-comment"># jaeger supports two modes:</span><br>    <span class="hljs-comment">#   collector mode(uncomment endpoint and uncomment username, password if needed)</span><br>    <span class="hljs-comment">#   agent mode(uncomment agent_host and agent_port)</span><br>    <span class="hljs-attr">endpoint:</span> <span class="hljs-string">http://hostname:14268/api/traces</span><br>    <span class="hljs-comment"># username:</span><br>    <span class="hljs-comment"># password:</span><br>    <span class="hljs-comment"># agent_host: hostname</span><br>    <span class="hljs-comment"># export trace data by jaeger.thrift in compact mode</span><br>    <span class="hljs-comment"># agent_port: 6831</span><br>  <span class="hljs-attr">otel:</span><br>    <span class="hljs-attr">endpoint:</span> <span class="hljs-string">hostname:4318</span><br>    <span class="hljs-attr">url_path:</span> <span class="hljs-string">/v1/traces</span><br>    <span class="hljs-attr">compression:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">insecure:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># timeout is in seconds</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">10</span><br><br><span class="hljs-comment"># cache layer configurations</span><br><span class="hljs-comment"># if this feature enabled, harbor will cache the resource</span><br><span class="hljs-comment"># `project/project_metadata/repository/artifact/manifest` in the redis</span><br><span class="hljs-comment"># which help to improve the performance of high concurrent pulling manifest.</span><br><span class="hljs-attr">cache:</span><br>  <span class="hljs-comment"># default is not enabled.</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># default keep cache for one day.</span><br>  <span class="hljs-attr">expireHours:</span> <span class="hljs-number">24</span><br><br></code></pre></td></tr></table></figure><p>准备好 values.yaml 以后，就可以开始部署了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">helm repo add harbor https://helm.goharbor.io<br>helm fetch harbor/harbor --untar<br>kubectl create ns harbor<br>helm install harbor harbor/harbor -f values.yaml -n harbor<br></code></pre></td></tr></table></figure><p>然后等待所有的 pod 成功运行即可。</p><blockquote><p>我部署完有两个 pod 死活起不来，看了下 describe 是因为探针探活失败：<code>Readiness probe failed: Get &quot;http://10.233.103.29:4443/_notary_server/health&quot;: dial tcp 10.233.103.29:4443: connect: connection refuse </code>，不知道啥原因，不过目前用起来貌似还没啥影响，暂时就先不管了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">k get po -n harbor -owide<br><br>NAME                                    READY   STATUS             RESTARTS         AGE     IP              NODE      NOMINATED NODE   READINESS GATES<br>harbor-core-59996c5bd-snkpr             1/1     Running            0                148m    10.233.116.38   worker3   &lt;none&gt;           &lt;none&gt;<br>harbor-database-0                       1/1     Running            0                4h46m   10.233.103.26   worker2   &lt;none&gt;           &lt;none&gt;<br>harbor-jobservice-76dc8fd6b9-7jgjs      1/1     Running            2 (148m ago)     148m    10.233.116.37   worker3   &lt;none&gt;           &lt;none&gt;<br>harbor-nginx-b8fddd6c8-sczxb            1/1     Running            0                148m    10.233.110.39   worker1   &lt;none&gt;           &lt;none&gt;<br>harbor-notary-server-549547797f-rjmmq   0/1     CrashLoopBackOff   30 (3m58s ago)   148m    10.233.116.39   worker3   &lt;none&gt;           &lt;none&gt;<br>harbor-notary-server-78976f954d-njwtp   0/1     CrashLoopBackOff   31 (41s ago)     150m    10.233.103.29   worker2   &lt;none&gt;           &lt;none&gt;<br>harbor-notary-signer-56fdb7f6b7-vwg2r   0/1     CrashLoopBackOff   30 (4m8s ago)    148m    10.233.110.40   worker1   &lt;none&gt;           &lt;none&gt;<br>harbor-notary-signer-7bb68698d9-2bggx   0/1     CrashLoopBackOff   31 (95s ago)     150m    10.233.110.38   worker1   &lt;none&gt;           &lt;none&gt;<br>harbor-portal-7f48c7b98d-l2m64          1/1     Running            0                4h46m   10.233.110.32   worker1   &lt;none&gt;           &lt;none&gt;<br>harbor-redis-0                          1/1     Running            0                4h46m   10.233.110.34   worker1   &lt;none&gt;           &lt;none&gt;<br>harbor-registry-6c7d666d67-hs9kr        2/2     Running            0                148m    10.233.103.31   worker2   &lt;none&gt;           &lt;none&gt;<br>harbor-trivy-0                          1/1     Running            0                4h46m   10.233.103.27   worker2   &lt;none&gt;           &lt;none&gt;<br></code></pre></td></tr></table></figure><p>（就是 harbor-notary-server 和 harbor-notary-signer 这两个 pod）</p></blockquote><p>等 pod 都起来后，看一下 harbor 的 service：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">k get svc -n harbor<br>NAME                   TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                                     AGE<br>harbor                 NodePort    10.233.57.147   &lt;none&gt;        80:30002/TCP,443:30003/TCP,4443:30004/TCP   4h58m<br></code></pre></td></tr></table></figure><p>然后就可以用集群内任意一台主机的 IP + 30002&#x2F;30003 端口访问了，这里不知道是不是因为 values.yaml 指定了开启 tls 的原因，我用 30002 （即 http 的端口）是无法访问的，必须要用 30003 （https 端口）访问，当然还要记得指定 scheme 为 https，比如 <code>https://192.168.31.244:30003/</code> 这样。</p><p>成功访问，进入到登录页，然后就可以登录了，用户名是 admin，密码是 values.yaml 中指定的。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/harbor1.jpg"></p><p>进入到主页，我们点到项目，发现这里已经有一个默认的项目了，我们就直接使用这个。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/harbor2.jpg"></p><p>点进去以后，发现里面有一个 <strong>镜像仓库</strong> 子菜单，这正是我们想要的，点一下右边的 <strong>推送命令</strong>，里面列出了一些工具推送镜像到该 repo 的命令。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/harbor3.jpg"></p><h1 id="使用-Docker-推送镜像"><a href="#使用-Docker-推送镜像" class="headerlink" title="使用 Docker 推送镜像"></a>使用 Docker 推送镜像</h1><p>首先执行 <code>docker login</code> 命令，登录到 harbor：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker login -u admin -p Harbor12345 core.harbor.domain:30003<br></code></pre></td></tr></table></figure><blockquote><p>如果这一步遇到了 <code>x509: certificate signed by unknown authority</code> 错误，那么你需要在 <code>/etc/docker/daemon.json</code> 里加入一条 <code>&quot;insecure-registries&quot;: [&quot;core.harbor.domain:30003&quot;]</code>，然后执行 <code>sudo systemctl restart docker</code> 重启 docker 让其生效。</p></blockquote><p>如果执行后输出 <code>Login Succeeded</code> ，那么恭喜你，登录成功了。</p><p>然后我们可以先 docker pull 一个 image 用于后续的测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull nginx<br></code></pre></td></tr></table></figure><p>然后我们给这个 image 打一个 tag，tag 的格式是 <code>&lt;harbor-url:harbor-port&gt;/&lt;project-name&gt;/&lt;image&gt;:&lt;tag&gt;</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker tag nginx core.harbor.domain:30003/library/nginx:latest<br></code></pre></td></tr></table></figure><p>然后就可以往 harbor push 了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker push core.harbor.domain:30003/library/nginx:latest<br></code></pre></td></tr></table></figure><p>我前面截的第 3 张图的镜像仓库里面有一个 library&#x2F;nginx 镜像，正是上面 push 的这个镜像，说明已经 push 成功了，也说明我们搭建的 harbor 已经可以正常工作了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>harbor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Prometheus try 1：初识 Prometheus [draft]</title>
    <link href="/2023/06/26/prometheus-shijian/"/>
    <url>/2023/06/26/prometheus-shijian/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Prometheus"><a href="#什么是-Prometheus" class="headerlink" title="什么是 Prometheus"></a>什么是 Prometheus</h1><p>让我们先跳过那些繁杂而枯燥的理论知识，你暂时只需要知道这是一个用来 <strong>监控</strong> 的组件就 OK 了，我们会通过实践来逐渐拨开 Prometheus 的神秘面纱。</p><h1 id="实践-1：搭建"><a href="#实践-1：搭建" class="headerlink" title="实践 1：搭建"></a>实践 1：搭建</h1><p>想快速了解一个系统&#x2F;软件，最好的方法就是将其搭建出来，实际使用一下，所以我们的第一个实践就是搭建出 Prometheus，简单起见，我们先使用 Docker 而不是 K8s 来搭建。</p><h2 id="使用-docker-compose-搭建-prometheus-和-grafana"><a href="#使用-docker-compose-搭建-prometheus-和-grafana" class="headerlink" title="使用 docker-compose 搭建  prometheus 和 grafana"></a>使用 docker-compose 搭建  prometheus 和 grafana</h2><p>首先我们需要先准备两个文件，一个 docker-compose 文件以及一个 prometheus 的配置文件。</p><p>使用下面的 docker-compose 来运行 prometheus，grafana，nodeExporter。</p><p>其中，grafana 提供 <strong>可视化界面</strong>，nodeExporter 提供 <strong>数据源</strong>。</p><blockquote><p>这里简单介绍一下 <strong>可视化界面</strong> 和 <strong>数据源</strong></p><p>顾名思义，可视化界面就是以一种更直观，更美观的方式观察我们监控的数据指标，这个比较好理解。</p><p>而数据源就是提供我们关注的监控数据的来源，一般数据源是一个 http server，然后它会提供一些接口，Prometheus 通过这些接口从数据源中获取监控数据，并存储起来。这里的 nodeExporter 会提供节点的 CPU 使用率、内存使用情况、磁盘空间等监控信息，后面就可以看到效果。</p></blockquote><p>docker-compose 文件如下，可以看到跑了 3 个容器：prometheus，grafana，nodeExporter，其他参数我们先不关注。</p><p><code>docker-compose.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;2&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">prometheus:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">prom/prometheus:latest</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./prometheus.yml:/etc/prometheus/prometheus.yml</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">prometheus_data:/prometheus</span><br>    <span class="hljs-attr">command:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;--config.file=/etc/prometheus/prometheus.yml&#x27;</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;9090:9090&#x27;</span><br>  <span class="hljs-attr">grafana:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">grafana/grafana:latest</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">grafana_data:/var/lib/grafana</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">GF_SECURITY_ADMIN_PASSWORD=admin</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">prometheus</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;3000:3000&#x27;</span><br>  <span class="hljs-attr">node_exporter:</span> <span class="hljs-comment"># 通过 9100 端口访问</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">quay.io/prometheus/node-exporter:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">node_exporter</span><br>    <span class="hljs-attr">command:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;--path.procfs=/host/proc&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;--path.rootfs=/rootfs&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;--path.sysfs=/host/sys&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;--collector.filesystem.mount-points-exclude=^/(sys|proc|dev|host|etc)($$|/)&#x27;</span><br>    <span class="hljs-attr">pid:</span> <span class="hljs-string">host</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/proc:/host/proc:ro</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/sys:/host/sys:ro</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/:/rootfs:ro</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;9100:9100&#x27;</span><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">grafana_data:</span> &#123;&#125;<br>  <span class="hljs-attr">prometheus_data:</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>Prometheus 的配置文件如下，注意文件名必须是 prometheus.yml，因为在上面的 <code>docker-compose.yml</code> 中，我们指定了挂载的配置文件名为 <code>./prometheus.yml</code>。</p><p>在上面的 docker-compose 中，我们启动了 node_exporter 这个数据源，它的访问端口是 9100，根据这些信息，我们就可以写出下面的 job 参数，<strong>你只需要修改 static_configs 中的 IP 为你的机器的 IP 地址即可</strong>。</p><blockquote><p>这里的其他配置我们先忽略，只需要需要简单关注一下 scrape_configs 这个配置，可以看到该配置下有一个 job_name，每个 job 其实就是一个监控作业（也就是前面提到的数据源），然后每个 job 下又指定了 metrics_path 和 targets，前面提到过，数据源一般都是一个 http server，所以 targets 就是 server 的 addr，而 metrics_path 就是接口的访问路径，Prometheus 通过这些信息就可以访问数据源，抓取监控数据。</p></blockquote><p><code>prometheus.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># my global config</span><br><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">15s</span> <span class="hljs-comment"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span><br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">15s</span> <span class="hljs-comment"># Evaluate rules every 15 seconds. The default is every 1 minute.</span><br>  <span class="hljs-comment"># scrape_timeout is set to the global default (10s).</span><br><br><span class="hljs-comment"># Alertmanager configuration</span><br><span class="hljs-attr">alerting:</span><br>  <span class="hljs-attr">alertmanagers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">static_configs:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span><br>          <span class="hljs-comment"># - alertmanager:9093</span><br><br><span class="hljs-comment"># Load rules once and periodically evaluate them according to the global &#x27;evaluation_interval&#x27;.</span><br><span class="hljs-attr">rule_files:</span><br>  <span class="hljs-comment"># - &quot;first_rules.yml&quot;</span><br>  <span class="hljs-comment"># - &quot;second_rules.yml&quot;</span><br><br><span class="hljs-comment"># A scrape configuration containing exactly one endpoint to scrape:</span><br><span class="hljs-comment"># Here it&#x27;s Prometheus itself.</span><br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;node&quot;</span><br><br>    <span class="hljs-comment"># metrics_path defaults to &#x27;/metrics&#x27;</span><br>    <span class="hljs-comment"># scheme defaults to &#x27;http&#x27;.</span><br>    <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">1s</span><br>    <span class="hljs-attr">metrics_path:</span> <span class="hljs-string">/metrics</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;$宿主机ip:9100&#x27;</span>]<br></code></pre></td></tr></table></figure><p>然后执行 <code>docker-compose up</code> 将这些镜像部署起来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up<br></code></pre></td></tr></table></figure><p>然后访问 <a href="http://localhost:9090/graph">http://localhost:9090/graph</a>, 在查询框中输入 up 并回车，查看添加的 job 是否已存在且可访问：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-string">up&#123;instance=&quot;10.71.104.120:9100&quot;,</span> <span class="hljs-string">job=&quot;node&quot;&#125;</span>   <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>右边这个数字 value 代表该 job 是否可达，如果是 1 则代表可达。</p><p>也可以在 Status&#x2F;Targets 里面查询所有的 job，并且这里可以看到每个 job 更详细的信息：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/prom_targets.jpg"></p><p>然后就可以访问 <a href="http://localhost:3000/">http://localhost:3000</a> 进入 Grafana ，进行可视化操作了。</p><p>进入以后，首先需要登录，账号和密码都是 admin：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/grafana_login.jpg"></p><p>登录成功后会让你设置新密码，因为我们只是实践，所以直接 Skip。</p><p>我们先添加数据源，将 Prometheus 添加进去：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/grafana_add_data_source.jpg"></p><p>这里填写 Prometheus 的地址（这里的端口应该是 9090，我写错了，懒得重新截图了）：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/grafana_prom_addr.jpg"></p><p>填写完毕后，点一下最下面的 Save &amp; test，看看能不能成功访问到 Prometheus：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/grafana_save_test.jpg"></p><p>然后看一下 Data sources，就可以看到我们刚才添加的 Prometheus 数据源：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/grafana_datasource_list.jpg"></p><p>然后我们再添加一个 Dashboard 用于展示数据，点击左上角的三条杠，选择 Dashboards 进入下面的界面：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/prom1.png"></p><p>导入一个 Dashboards 主题，点击右边的 Load：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/prom2.png"></p><p>导入数据源，选择 Prometheus：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/prom3.png"></p><p>查看效果，看起来还挺高大上的：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/prom4.png"></p><p>至此，我们成功搭建了 Prometheus。</p><h1 id="实践-2：实现一个简单的自定义监控"><a href="#实践-2：实现一个简单的自定义监控" class="headerlink" title="实践 2：实现一个简单的自定义监控"></a>实践 2：实现一个简单的自定义监控</h1><p>基本流程：</p><ol><li><p>创建一个 metrics ，同时指定该 metrics 的查询名，以及可以通过哪些 label 来进行数据查询。metrics 有以下几种类型：</p><blockquote><p><strong>Counter</strong></p><p>可以理解为只增不减的计数器，典型的应用如：请求的个数，结束的任务数， 出现的错误数等等；</p><p>对应 gopkg&#x2F;metrics 的 EmitStore。</p><p><strong>Gauge</strong></p><p>一种常规的 metric，典型的应用如：goroutines 的数量；</p><p>可以任意加减；</p><p>对应 gopkg&#x2F;metrics 的 EmitCounter。</p><p><strong>Histogram</strong></p><p>生成直方图数据，用于统计和分析样本的分布情况，典型的应用如：pct99，CPU 的平均使用率等；</p><p>可以对观察结果采样，分组及统计。</p><p>对应 gopkg&#x2F;metrics 的 EmitTimer。</p><p><strong>Summary</strong></p><p>类似于 Histogram，提供观测值的 count 和 sum 功能；</p><p>提供百分位的功能，即可以按百分比划分跟踪结果；</p><p> Summary 的分位数是直接在客户端计算完成，因此对于分位数的计算而言，Summary 在通过 PromQL 进行查询时有更好的性能表现，而 Histogram 则会消耗更多的资源，对于客户端而言 Histogram 消耗的资源更少。</p></blockquote></li><li><p>创建一个 prometheu registry，将你定义的这些 metrics 注册进来。</p></li><li><p>创建一个 http server 用来对外提供 metrics 信息，其中 path 和 addr 自行指定，然后使用 promhttp.HandlerFor() 将上一步的 registry 作为 handle 对外提供。</p></li><li><p>在对应的代码处对之前定义的 metrics 进行操作，也就是生产监控数据。比如定义了一个 Counter 类型的 metrics 用来统计 http server 某个路由的被访问次数，那么就可以在该路由的 handle 里编写对应的代码来操作该 Counter，让其值 + 1。</p></li></ol><p>下面这段代码是一个简单的 http server，其中有 2 个路由 &#x2F;foo 和 &#x2F;bar，同时又提供了 2 个用于统计路由被访问次数的指标：route_foo_visits_num 和 route_bar_visits_num，分别对应 &#x2F;foo 和 &#x2F;bar。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/cloudwego/hertz/pkg/app&quot;</span><br>    <span class="hljs-string">&quot;github.com/cloudwego/hertz/pkg/app/server&quot;</span><br>    <span class="hljs-string">&quot;github.com/cloudwego/hertz/pkg/common/hlog&quot;</span><br>    prom <span class="hljs-string">&quot;github.com/prometheus/client_golang/prometheus&quot;</span><br>    <span class="hljs-string">&quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>    routePathFoo = <span class="hljs-string">&quot;/foo&quot;</span><br>    routePathBar = <span class="hljs-string">&quot;/bar&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>    LabelName = <span class="hljs-string">&quot;name&quot;</span><br>    LabelAge  = <span class="hljs-string">&quot;age&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> trace <span class="hljs-keyword">interface</span> &#123;<br>    Record(context.Context, *app.RequestContext) <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-keyword">type</span> httpRouteTrace <span class="hljs-keyword">struct</span> &#123;<br>    fooCount *prom.CounterVec<br>    barCount *prom.CounterVec<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *httpRouteTrace)</span></span> Record(ctx context.Context, c *app.RequestContext) <span class="hljs-type">error</span> &#123;<br>    labels := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">if</span> v := c.Query(LabelName); v != <span class="hljs-string">&quot;&quot;</span> &#123;<br>       labels[LabelName] = v<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;must provide name param&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> v := c.Query(LabelAge); v != <span class="hljs-string">&quot;&quot;</span> &#123;<br>       labels[LabelAge] = v<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;must provide age param&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span> <span class="hljs-type">string</span>(c.Path()) &#123;<br>    <span class="hljs-keyword">case</span> routePathFoo:<br>       <span class="hljs-keyword">if</span> err := countAdd(f.fooCount, labels); err != <span class="hljs-literal">nil</span> &#123;<br>          <span class="hljs-keyword">return</span> err<br>       &#125;<br>    <span class="hljs-keyword">case</span> routePathBar:<br>       <span class="hljs-keyword">if</span> err := countAdd(f.barCount, labels); err != <span class="hljs-literal">nil</span> &#123;<br>          <span class="hljs-keyword">return</span> err<br>       &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countAdd</span><span class="hljs-params">(vec *prom.CounterVec, labels prom.Labels)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 这里的 labels 数量必须要与 NewCounterVec 时指定的 label 数量相同</span><br>    counter, err := vec.GetMetricWith(labels)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       <span class="hljs-keyword">return</span> err<br>    &#125;<br>    counter.Inc()<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newHttpRouteTrace</span><span class="hljs-params">(addr, path <span class="hljs-type">string</span>)</span></span> trace &#123;<br>    <span class="hljs-comment">// 形如 NewXxxVec 的函数代表提供了 label 选项，可以通过 label 对数据进行过滤筛选</span><br>    fooCounter := prom.NewCounterVec(<br>       prom.CounterOpts&#123;<br>          Name: <span class="hljs-string">&quot;route_foo_visits_num&quot;</span>,<br>          Help: <span class="hljs-string">&quot;Total visits number of route path /foo&quot;</span>,<br>       &#125;,<br>       []<span class="hljs-type">string</span>&#123;LabelName, LabelAge&#125;, <span class="hljs-comment">// 这里定义了两个 label</span><br>    )<br><br>    barCounter := prom.NewCounterVec(<br>       prom.CounterOpts&#123;<br>          Name: <span class="hljs-string">&quot;route_bar_visits_num&quot;</span>,<br>          Help: <span class="hljs-string">&quot;Total visits number of route path /bar&quot;</span>,<br>       &#125;,<br>       []<span class="hljs-type">string</span>&#123;LabelName, LabelAge&#125;,<br>    )<br><br>    registry := prom.NewRegistry()<br>    registry.MustRegister(fooCounter)<br>    registry.MustRegister(barCounter)<br><br>    f := &amp;httpRouteTrace&#123;fooCount: fooCounter, barCount: barCounter&#125;<br><br>    <span class="hljs-comment">// start server for prometheus</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>       http.Handle(path, promhttp.HandlerFor(registry, promhttp.HandlerOpts&#123;ErrorHandling: promhttp.ContinueOnError&#125;))<br>       log.Fatalln(http.ListenAndServe(addr, <span class="hljs-literal">nil</span>))<br>    &#125;()<br><br>    <span class="hljs-keyword">return</span> f<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    f := newHttpRouteTrace(<span class="hljs-string">&quot;:9300&quot;</span>, <span class="hljs-string">&quot;/metrics&quot;</span>)<br>    h := server.Default(server.WithHostPorts(<span class="hljs-string">&quot;:8887&quot;</span>))<br>    h.GET(routePathFoo, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, c *app.RequestContext)</span></span> &#123;<br>       <span class="hljs-keyword">if</span> err := f.Record(ctx, c); err != <span class="hljs-literal">nil</span> &#123;<br>          hlog.Error(err)<br>          c.Error(err)<br>          <span class="hljs-keyword">return</span><br>       &#125;<br>       c.WriteString(<span class="hljs-string">&quot;foo&quot;</span>)<br>    &#125;)<br>    h.GET(routePathBar, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, c *app.RequestContext)</span></span> &#123;<br>       <span class="hljs-keyword">if</span> err := f.Record(ctx, c); err != <span class="hljs-literal">nil</span> &#123;<br>          hlog.Error(err)<br>          c.Error(err)<br>          <span class="hljs-keyword">return</span><br>       &#125;<br>       c.WriteString(<span class="hljs-string">&quot;bar&quot;</span>)<br>    &#125;)<br>    h.Spin()<br>&#125;<br></code></pre></td></tr></table></figure><p>编写完成后，编辑 Prometheus 的 配置文件，将上面的监控作为一个 job 添加进来，并定义相关信息，比如提供 metrics 信息的 http server 的 addr 和 path，然后重启 prom，重启后在 prometheus web 中执行 up 命令，看这个 job 是否添加进来了，并且确保存活。</p><h1 id="实践-3：告警"><a href="#实践-3：告警" class="headerlink" title="实践 3：告警"></a>实践 3：告警</h1><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-built_in">(sum</span> <span class="hljs-keyword">by</span>(<span class="hljs-keyword">instance</span>) (irate(node_cpu_seconds_total&#123;<span class="hljs-keyword">instance</span>=<span class="hljs-string">&quot;$node&quot;</span>,job=<span class="hljs-string">&quot;$job&quot;</span>, mode!=<span class="hljs-string">&quot;idle&quot;</span>&#125;[<span class="hljs-variable">$__rate_interval</span>])) / on(<span class="hljs-keyword">instance</span>) group_left<span class="hljs-built_in"> sum</span> <span class="hljs-keyword">by</span> (<span class="hljs-keyword">instance</span>)((irate(node_cpu_seconds_total&#123;<span class="hljs-keyword">instance</span>=<span class="hljs-string">&quot;$node&quot;</span>,job=<span class="hljs-string">&quot;$job&quot;</span>&#125;[<span class="hljs-variable">$__rate_interval</span>])))) * <span class="hljs-number">100</span><br><br><span class="hljs-built_in"></span><br><span class="hljs-built_in">sum</span><span class="hljs-built_in">(avg</span> without (cpu)(irate(node_cpu_seconds_total&#123;mode!=<span class="hljs-string">&#x27;idle&#x27;</span>&#125;[<span class="hljs-number">5</span>m]))) <span class="hljs-keyword">by</span> (<span class="hljs-keyword">instance</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>prometheus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K8s 控制节点高可用实践</title>
    <link href="/2023/06/18/k8s-master-ha/"/>
    <url>/2023/06/18/k8s-master-ha/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是控制节点高可用"><a href="#什么是控制节点高可用" class="headerlink" title="什么是控制节点高可用"></a>什么是控制节点高可用</h1><p>控制节点，也可以叫做 k8s master 节点，负责管理和控制整个集群的运行。控制节点上运行着 k8s 控制平面组件，其中包括了负责集群内外通信的超核心的组件  —— api-server，这代表着如果控制节点挂掉了，那么整个集群都会因为 ”群龙无首“ 而不可用，所以在实际的生产环境中，k8s 集群一定会部署多个控制节点，这样可以保证某个节点挂掉后，其他节点还能继续提供服务，即 ”高可用“。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>在本文中，为了实现高可用，使用了 <code>HAproxy</code> 和 <code>Keepalived</code> 这两个组件，其中：</p><ul><li><code>HAproxy</code> 负责反向代理和负载均衡，有点类似 <code>Nginx</code>，其代理实际的 k8s master 节点地址，当用户访问 HAproxy 时，HAproxy 会通过负载均衡的方式，将用户的请求转发给 k8s master 节点。</li><li>Keepalived 为 <code>HAproxy</code> 提供高可用。HAproxy 提供了反向代理服务，如果 HAproxy 挂掉了，那么用户的请求就到不了 master 节点，一样会导致服务不可用，所以同样也需要为 HAproxy 提供高可用保证。Keepalived 会先创建一个固定的 VIP（VIP，即虚拟 IP），并将其绑定到某个运行了 HAproxy 的节点（也可以称之为 LB 节点）的某张网卡上，用户只需要访问这个 VIP，即可访问到这个 VIP 绑定的节点的 HAproxy，如果这个节点的 HAproxy 挂掉了，或者干脆这个节点都挂掉了，那么 Keepalived 检测到后，会进行 VIP 漂移的操作，将这个 VIP 绑定到另一个 LB 节点的某个网卡上，用户依然访问这个 VIP 即可，完全不受任何影响。</li></ul><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>在本次实践中，我们使用的是外部负载均衡器的方式，即 HAproxy 单独部署在非 k8s 集群的机器上。</p><ul><li>两台主机，用来作为负载均衡服务器，其中一台为 master（主），另一台 backup（备），正常情况下会由 master 提供负载均衡服务，如果 master 挂掉了，则转而由 backup 提供。</li></ul><h2 id="安装-haproxy-和-keepalived"><a href="#安装-haproxy-和-keepalived" class="headerlink" title="安装 haproxy 和 keepalived"></a>安装 haproxy 和 keepalived</h2><p>分别在两台负载均衡主机上安装 haproxy 和 keepalived：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install haproxy keepalived -y<br></code></pre></td></tr></table></figure><h2 id="配置-Keepalived"><a href="#配置-Keepalived" class="headerlink" title="配置 Keepalived"></a>配置 Keepalived</h2><p>然后，分别给两台主机配置 keepalived 配置文件，该配置文件位于 <code>/etc/keepalived/keepalived.conf</code>，下面是模版：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs awk">! <span class="hljs-regexp">/etc/</span>keepalived/keepalived.conf<br>! Configuration File <span class="hljs-keyword">for</span> keepalived<br>global_defs &#123;<br>    router_id LVS_DEVEL<br>    script_user root<br>    enable_script_security<br>&#125;<br><br>vrrp_script chk_haproxy &#123;<br>    script  <span class="hljs-string">&quot;killall -0 haproxy&quot;</span><br>    interval  <span class="hljs-number">2</span><br>    weight  <span class="hljs-number">2</span><br>&#125;<br><br>vrrp_instance VI_1 &#123;<br>    state  <span class="hljs-variable">$&#123;STATE&#125;</span> <br>    interface <span class="hljs-variable">$&#123;INTERFACE&#125;</span><br>    virtual_router_id  <span class="hljs-variable">$&#123;ROUTER_ID&#125;</span><br>    priority <span class="hljs-variable">$&#123;PRIORITY&#125;</span><br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass <span class="hljs-variable">$&#123;AUTH_PASS&#125;</span><br>    &#125;<br>    virtual_ipaddress &#123;<br>        <span class="hljs-variable">$&#123;APISERVER_VIP&#125;</span><br>    &#125;<br>    track_script &#123;<br>        chk_haproxy<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面的模板文件中有部分内容（用 ${} 包裹的一些变量）需要替换为自己相应的内容，详细如下：</p><table><thead><tr><th>需要替换的变量</th><th align="left">替换内容</th></tr></thead><tbody><tr><td>${STATE}</td><td align="left">如果是主节点 则为 MASTER 其他则为 BACKUP。我这里选择 lb1 这台主机 为 MASTER；lb2 为 BACKUP</td></tr><tr><td>${INTERFACE}</td><td align="left">网络接口，即服务器网卡，我的服务器均为 eth1；</td></tr><tr><td>${ROUTER_ID}</td><td align="left">这个值只要在 keepalived 集群中保持一致即可，我使用的是默认值 51；</td></tr><tr><td>${PRIORITY}</td><td align="left">优先级，优先级高的会拿到 VIP。这里需要保证 master 节点的高于 backup 节点。</td></tr><tr><td>${AUTH_PASS}</td><td align="left">这个值只要在 keepalived 集群中保持一致即可；</td></tr><tr><td>${APISERVER_VIP}</td><td align="left">就是 VIP 的地址，我的为 192.168.31.110</td></tr></tbody></table><blockquote><p>简单说明一下这段配置文件：</p><p>global_defs 块中的  <code>script_user root</code> 和 <code>enable_script_security</code> 用于解决 Keepalived 执行脚本时报错 <code>scripts are being executed but script_security not enabled.</code> 的问题，不用过多关注。</p><p>vrrp_script chk_haproxy 块有一个 script 字段，可以指定为一个 shell 文件所在路径，或者一条命令。这个块还拥有一个 weight 字段，表示脚本执行结果对当前节点优先级的影响。具体来说，Keepalived 会 <strong>定期执行这个脚本</strong>，如果脚本执行成功了，那么当前节点的优先级会增加 weight 对应的值，如果执行失败了，则会减掉相应的值，而每个节点的优先级又决定了 VIP 会绑定到谁（VIP 会绑定到优先级最高的那个节点），所以可以说，<strong>这个块可以用来作为 Keepalived 判断是否需要进行 VIP 漂移的依据</strong>。</p><p>vrrp_instance 块则代表 Keepalived 中一个具体实例，主要用来定义实例相关的配置，包括该实例是主还是备、对应网络接口、优先级、认证方式和 VIP 等信息，这个块里面还有一个 track_script 块，其指定的正是上面我们定义的 vrrp_script 的名字。</p></blockquote><div class="note note-warning">            <p>注意，master 和 backup 的配置文件会有所不同，不能直接把 master 节点的 keepalived 配置文件拷贝给 backup 节点。</p>          </div><div class="note note-warning">            <p>${PRIORITY} 这个值的设置有点名堂，不是简单的 master 大于 backup 即可，否则可能会出现 VIP 无法正确漂移的情况。简单的说，你需要确保 master 大于 backup，且二者的差值小于 vrrp_script 中的 weight。比如如果 weight 为 2，那么你需要分别设置 master 和 backup 的 priority 为 50 和 49（其他数字也行，只要二者差值小于 2 即可）。你可以阅读文章中 <strong>验证 VIP 漂移&#x2F;验证不通过</strong> 开始的章节来了解原因。</p>          </div><p><del>此外，上面的配置文件中还有一个需要注意的地方，即 vrrp_script check_apiserver 块的 script 字段，需要指定健康检查脚本的所在路径，监控检查脚本的内容如下：</del></p><p><del>保存在 <code>/etc/keepalived/check_apiserver.sh</code></del></p><p><del>#bin&#x2F;sh</del></p><p><del>errorExit() {</del><br>    <del>echo “*** $*” 1&gt;&amp;2</del><br>    <del>exit 1</del><br><del>}</del></p><p><del>APISERVER_VIP&#x3D;192.168.31.110</del><br><del>APISERVER_DEST_PORT&#x3D;6443</del></p><p><del>curl –silent –max-time 2 –insecure <a href="https://localhost:${APISERVER_DEST_PORT}/">https://localhost:${APISERVER_DEST_PORT}/</a> -o &#x2F;dev&#x2F;null || errorExit “Error GET <a href="https://localhost:${APISERVER_DEST_PORT}/">https://localhost:${APISERVER_DEST_PORT}/</a>“</del><br><del>if ip addr | grep -q ${APISERVER_VIP}; then</del><br>    <del>curl –silent –max-time 2 –insecure https:&#x2F;&#x2F;${APISERVER_VIP}:${APISERVER_DEST_PORT}&#x2F; -o &#x2F;dev&#x2F;null || errorExit “Error GET https:&#x2F;&#x2F;${APISERVER_VIP}:${APISERVER_DEST_PORT}&#x2F;“</del><br><del>fi</del></p><table><thead><tr><th><del>需要替换的变量</del></th><th><del>替换内容</del></th></tr></thead><tbody><tr><td><del>${APISERVER_VIP}</del></td><td><del>VIP 的地址</del></td></tr><tr><td><del>${APISERVER_DEST_PORT}</del></td><td><del>定义 API Server 交互的负载均衡端口，其实就是 HAProxy 绑定前端负载均衡的端口号</del></td></tr></tbody></table><p>下面是我配置好的 master 和 backup 的配置文件，可以参考一下：</p><p><strong>master</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">&quot;keepalived.conf&quot;</span> <span class="hljs-number">27</span>L, <span class="hljs-number">485</span>B                                                  <span class="hljs-number">22</span>,<span class="hljs-number">24</span>         All<br>! /etc/keepalived/keepalived.conf<br>! Configuration File <span class="hljs-keyword">for</span> keepalived<br>global_defs &#123;<br>    router_id LVS_DEVEL<br>    script_user root<br>    enable_script_security<br>&#125;<br>vrrp_script chk_haproxy &#123;<br>    script  <span class="hljs-string">&quot;killall -0 haproxy&quot;</span><br>    <span class="hljs-built_in">int</span>erval  <span class="hljs-number">2</span><br>    weight  <span class="hljs-number">2</span><br>&#125;<br><br>vrrp_instance VI_1 &#123;<br>    state MASTER<br>    <span class="hljs-keyword">interface</span> <span class="hljs-symbol">eth1</span><br>    <span class="hljs-symbol">virtual_router_id</span> <span class="hljs-symbol">51</span><br>    <span class="hljs-symbol">priority</span> <span class="hljs-symbol">50</span><br>    <span class="hljs-symbol">authentication</span> &#123;<br>        auth_type PASS<br>        auth_pass pwd12345<br>    &#125;<br>    virtual_ipaddress &#123;<br>       <span class="hljs-number">192.168</span><span class="hljs-number">.31</span><span class="hljs-number">.110</span>/<span class="hljs-number">24</span><br>    &#125;<br>    track_script &#123;<br>        chk_haproxy<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>backup</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">! /etc/keepalived/keepalived.conf<br>! Configuration File <span class="hljs-keyword">for</span> keepalived<br>global_defs &#123;<br>    router_id LVS_DEVEL<br>    script_user root<br>    enable_script_security<br>&#125;<br>vrrp_script chk_haproxy &#123;<br>    script  <span class="hljs-string">&quot;killall -0 haproxy&quot;</span><br>    <span class="hljs-built_in">int</span>erval  <span class="hljs-number">2</span><br>    weight  <span class="hljs-number">2</span><br>&#125;<br><br>vrrp_instance VI_1 &#123;<br>    state BACKUP<br>    <span class="hljs-keyword">interface</span> <span class="hljs-symbol">eth1</span><br>    <span class="hljs-symbol">virtual_router_id</span> <span class="hljs-symbol">51</span><br>    <span class="hljs-symbol">priority</span> <span class="hljs-symbol">49</span><br>    <span class="hljs-symbol">authentication</span> &#123;<br>        auth_type PASS<br>        auth_pass pwd12345<br>    &#125;<br>    virtual_ipaddress &#123;<br>       <span class="hljs-number">192.168</span><span class="hljs-number">.31</span><span class="hljs-number">.110</span>/<span class="hljs-number">24</span><br>    &#125;<br>    track_script &#123;<br>        chk_haproxy<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="配置-HAproxy"><a href="#配置-HAproxy" class="headerlink" title="配置 HAproxy"></a>配置 HAproxy</h2><p>接下来继续配置 HAproxy：</p><p>该文件位于 <code>/etc/haproxy/haproxy.cfg</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#---------------------------------------------------------------------</span><br><span class="hljs-comment"># Example configuration for a possible web application.  See the</span><br><span class="hljs-comment"># full configuration options online.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   http://haproxy.1wt.eu/download/1.4/doc/configuration.txt</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#---------------------------------------------------------------------</span><br><br><span class="hljs-comment">#---------------------------------------------------------------------</span><br><span class="hljs-comment"># Global settings</span><br><span class="hljs-comment">#---------------------------------------------------------------------</span><br><span class="hljs-attribute">global</span><br>    <span class="hljs-comment"># to have these messages end up in /var/log/haproxy.log you will</span><br>    <span class="hljs-comment"># need to:</span><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment"># 1) configure syslog to accept network log events.  This is done</span><br>    <span class="hljs-comment">#    by adding the &#x27;-r&#x27; option to the SYSLOGD_OPTIONS in</span><br>    <span class="hljs-comment">#    /etc/sysconfig/syslog</span><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment"># 2) configure local2 events to go to the /var/log/haproxy.log</span><br>    <span class="hljs-comment">#   file. A line like the following can be added to</span><br>    <span class="hljs-comment">#   /etc/sysconfig/syslog</span><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment">#    local2.*                       /var/log/haproxy.log</span><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-attribute">log</span>         <span class="hljs-number">127.0.0.1</span> local2<br><br>    <span class="hljs-attribute">chroot</span>      /var/lib/haproxy<br>    <span class="hljs-attribute">pidfile</span>     /var/run/haproxy.pid<br>    <span class="hljs-attribute">maxconn</span>     <span class="hljs-number">4000</span><br>    <span class="hljs-attribute">user</span>        haproxy<br>    <span class="hljs-attribute">group</span>       haproxy<br>    <span class="hljs-attribute">daemon</span><br><br>    <span class="hljs-comment"># turn on stats unix socket</span><br>    <span class="hljs-attribute">stats</span> socket /var/lib/haproxy/stats<br><br><span class="hljs-comment">#---------------------------------------------------------------------</span><br><span class="hljs-comment"># common defaults that all the &#x27;listen&#x27; and &#x27;backend&#x27; sections will</span><br><span class="hljs-comment"># use if not designated in their block</span><br><span class="hljs-comment">#---------------------------------------------------------------------</span><br><span class="hljs-attribute">defaults</span><br>    <span class="hljs-attribute">mode</span>                    http<br>    <span class="hljs-attribute">log</span>                     global<br>    <span class="hljs-attribute">option</span>                  httplog<br>    <span class="hljs-attribute">option</span>                  dontlognull<br>    <span class="hljs-attribute">option</span> http-server-close<br>    <span class="hljs-attribute">option</span> forwardfor       except <span class="hljs-number">127.0.0.0</span>/<span class="hljs-number">8</span><br>    <span class="hljs-attribute">option</span>                  redispatch<br>    <span class="hljs-attribute">retries</span>                 <span class="hljs-number">3</span><br>    <span class="hljs-attribute">timeout</span> http-request    <span class="hljs-number">10</span>s<br>    <span class="hljs-attribute">timeout</span> queue           <span class="hljs-number">1</span>m<br>    <span class="hljs-attribute">timeout</span> connect         <span class="hljs-number">10</span>s<br>    <span class="hljs-attribute">timeout</span> client          <span class="hljs-number">1</span>m<br>    <span class="hljs-attribute">timeout</span> server          <span class="hljs-number">1</span>m<br>    <span class="hljs-attribute">timeout</span> http-keep-alive <span class="hljs-number">10</span>s<br>    <span class="hljs-attribute">timeout</span> check           <span class="hljs-number">10</span>s<br>    <span class="hljs-attribute">maxconn</span>                 <span class="hljs-number">3000</span><br><br><span class="hljs-comment">#---------------------------------------------------------------------</span><br><span class="hljs-comment"># apiserver frontend which proxys to the masters</span><br><span class="hljs-comment">#---------------------------------------------------------------------</span><br><span class="hljs-attribute">frontend</span> apiserver<br>    <span class="hljs-attribute">bind</span> *:<span class="hljs-number">6443</span>   ## 注意这里的端口，其实就是 haproxy 的端口，后面加入集群的时候需要用到<br>    <span class="hljs-attribute">mode</span> tcp<br>    <span class="hljs-attribute">option</span> tcplog<br>    <span class="hljs-attribute">default_backend</span> apiserver<br><br><span class="hljs-comment">#---------------------------------------------------------------------</span><br><span class="hljs-comment"># round robin balancing for apiserver</span><br><span class="hljs-comment">#---------------------------------------------------------------------</span><br><span class="hljs-attribute">backend</span> apiserver<br>    <span class="hljs-attribute">option</span> httpchk GET /healthz<br>    <span class="hljs-attribute">http</span>-check expect status <span class="hljs-number">200</span><br>    <span class="hljs-attribute">mode</span> tcp<br>    <span class="hljs-attribute">option</span> ssl-hello-chk<br>    <span class="hljs-attribute">balance</span>     roundrobin<br>        <span class="hljs-attribute">server</span> k8s-master1 <span class="hljs-number">192.168.31.86:6443</span> check<br>        <span class="hljs-attribute">server</span> k8s-master2 <span class="hljs-number">192.168.31.82:6443</span> check<br>        <span class="hljs-attribute">server</span> k8s-master3 <span class="hljs-number">192.168.31.83:6443</span> check<br></code></pre></td></tr></table></figure><p>这里主要关注两个地方，一个是 frontend apiserver 下的 bind，该字段用于定义 HAproxy 监听的地址；另一个是 backend apiserver 下的 balance     roundrobin 字段，这里指定为你的 k8s master 节点的 IP 地址。</p><p>HAproxy 的配置文件是通用的，所以可以直接拷贝到另一台 LB 主机（当然手动复制粘贴问题也不大，毕竟只有 2 个节点）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp /etc/haproxy/haproxy.cfg  root@192.168.31.91:/etc/haproxy<br></code></pre></td></tr></table></figure><h2 id="启动服务并配置开机自启"><a href="#启动服务并配置开机自启" class="headerlink" title="启动服务并配置开机自启"></a>启动服务并配置开机自启</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable haproxy --now<br>systemctl enable keepalived --now<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>我在执行这一步时，遇到了 haproxy 进程已经启动（ps -rf | grep haproxy），但却没有监听对应端口的情况（lsof -i :6443），最终通过 <code>systemctl restart haproxy</code> 重启 HAproxy 解决了。</p>          </div><h2 id="验证-VIP-漂移"><a href="#验证-VIP-漂移" class="headerlink" title="验证 VIP 漂移"></a>验证 VIP 漂移</h2><p>看一下这两台主机的网卡情况，首先看一下 lb1 这台作为 master 节点的主机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip addr<br>// .... 省略其他网卡，我在配置文件里指定的是 eth1 这种网卡<br>3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000<br>    link/ether 52:54:00:47:ec:3f brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.31.90/24 brd 192.168.31.255 scope global eth1<br>       valid_lft forever preferred_lft forever<br>    inet 192.168.31.110/32 scope global eth1<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::5054:ff:fe47:ec3f/64 scope link<br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>可以看到这张网卡有两个 IPv4 地址，其中 192.168.31.110&#x2F;32 就是我们定义的 keepalived VIP。</p><p>再看一下作为备节点的这台主机的网卡情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip addr<br>// .... 省略其他网卡<br>3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000<br>    link/ether 52:54:00:56:20:5e brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.31.91/24 brd 192.168.31.255 scope global eth1<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::5054:ff:fe56:205e/64 scope link<br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>这台主机的 eth1 网卡并没有绑定 VIP</p><p>然后我停掉 master 节点的 HAproxy 进程，看看 VIP 会不会漂移到 backup 节点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在 master 节点上执行，停止这台机器上的 haproxy 进程</span><br>systemctl stop haproxy<br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查一下</span><br>ps -ef | grep haproxy<br>root       12382   11336  0 22:34 pts/1    00:00:00 grep --color=auto haproxy # 这个进程是 grep 的，与 haproxy 本身无关<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后看一下 IP：</span><br>ip addr<br>3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000<br>    link/ether 52:54:00:47:ec:3f brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.31.90/24 brd 192.168.31.255 scope global eth1<br>       valid_lft forever preferred_lft forever<br>    inet 192.168.31.110/24 scope global secondary eth1<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::5054:ff:fe47:ec3f/64 scope link<br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><h3 id="验证不通过"><a href="#验证不通过" class="headerlink" title="验证不通过"></a>验证不通过</h3><p>发现 VIP 并没有漂移！并且我已经检查过，backup 节点的 HAproxy 是正常运行的，然后我又试了下 stop master 节点的 keepalived 进程，发现此时 VIP 会漂移到 backup 节点，但是一旦重新启动 master 节点上的 keepalived，那么 VIP 又会重新漂移到 master 节点，这显然不符预期啊？我们期望的是用 keepalived 对 HAproxy 做高可用，如果某个节点上的 HAproxy 都已经挂掉了，VIP 却还停留在该节点上，那到时候 k8s 还是会请求到这个节点，但是又无法转发给实际的 k8s 控制节点，导致无法工作。不知道为啥会出现这种情况</p><p>我在 <a href="https://serverfault.com/questions/764557/keepalived-registers-failure-but-wont-failover">serverfault </a>上找到了一个情况相同的问题，但是并没有人给出靠谱的解决方法</p><h3 id="终于解决了"><a href="#终于解决了" class="headerlink" title="终于解决了"></a>终于解决了</h3><p>我尝试使用英文，在谷歌上搜索 <a href="https://serverfault.com/questions/718132/keepalived-vrrp-script-not-failing-over">keepalived VRRP_script not failing over</a>，最终找到了这个靠谱的回答。</p><p>原因出在 keepalived 配置中的 priority，即优先级，貌似 keepalived 是严格按照 priority 来决定谁拥有 VIP 的，也就是说，只有在 <strong>另一台主机的 priority 高于当前拥有 VIP 的主机的 priority 的情况下，VIP 才会进行漂移</strong>。在上面的配置中，我们给 master 节点的 priority 设置成了 100，而 backup 节点的 priority 设置为了 50，两者相差 50！而我们在 <code>vrrp_script chk_haproxy</code> 中定义的 <code>weight</code> 值为 2，也就是当前节点如果成功执行脚本且没有返回错误，则给当前节点的 priority + 2（这里貌似是只有第一次执行成功会 +2，之后再执行成功就不会 +2 了？不太确定），然后现在的情况是：master 执行失败，priority 保持原样 &#x3D; 100，backup 执行成功，priority + 2 &#x3D; 52，backup 的 priority 依然远小于 master，所以 VIP 依然保持在 master 节点，不会漂移到  backup 节点。</p><p><strong>解决这个问题的方法也很简单，我修改了一下 master 节点的 priority，将其改为 50，而 backup 的 priority 我改成了 49，这样二者只相差 1</strong>，如果 backup 执行脚本成功，则其 priority 变为 51，master 执行失败，则依然为 50，这样就可以保证 backup 的优先级大于 master，从而实现 VIP 的漂移。而如果 master 上的 haproxy 恢复正常了，则脚本执行成功， priority 又会变成 50 + 2 &#x3D; 52，大于 backup 的 priority，所以 VIP 的掌控权又会回到 master 手中，符合我们的需求。</p><div class="note note-success">            <p>经过我的测试，发现 priority 的增减逻辑是这样的：</p><ul><li><p>如果 <code>vrrp_script</code> 执行成功，且是第一次执行成功，则 priority + 2</p></li><li><p>如果 <code>vrrp_script</code> 执行失败，且是第一次执行失败，则 priority - 2</p><p>可以通过日志佐证这一点，这是 master 节点的日志，可以通过 <code>journalctl -u keepalived.service</code> 查看：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Jun</span> <span class="hljs-number">23</span> <span class="hljs-number">23</span>:<span class="hljs-number">56</span>:<span class="hljs-number">55</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: Script `chk_haproxy` now returning <span class="hljs-number">0</span><br><span class="hljs-attribute">Jun</span> <span class="hljs-number">23</span> <span class="hljs-number">23</span>:<span class="hljs-number">56</span>:<span class="hljs-number">55</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: VRRP_Script(chk_haproxy) succeeded<br><span class="hljs-attribute">Jun</span> <span class="hljs-number">23</span> <span class="hljs-number">23</span>:<span class="hljs-number">56</span>:<span class="hljs-number">55</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: (VI_1) Changing effective priority from <span class="hljs-number">50</span> to <span class="hljs-number">52</span><br><span class="hljs-attribute">Jun</span> <span class="hljs-number">23</span> <span class="hljs-number">23</span>:<span class="hljs-number">56</span>:<span class="hljs-number">55</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: (VI_1) received lower priority (<span class="hljs-number">51</span>) advert from <span class="hljs-number">19</span>&gt;<br><span class="hljs-attribute">Jun</span> <span class="hljs-number">23</span> <span class="hljs-number">23</span>:<span class="hljs-number">56</span>:<span class="hljs-number">56</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: (VI_1) received lower priority (<span class="hljs-number">51</span>) advert from <span class="hljs-number">19</span>&gt;<br><span class="hljs-attribute">Jun</span> <span class="hljs-number">23</span> <span class="hljs-number">23</span>:<span class="hljs-number">56</span>:<span class="hljs-number">57</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: (VI_1) received lower priority (<span class="hljs-number">51</span>) advert from <span class="hljs-number">19</span>&gt;<br><span class="hljs-attribute">Jun</span> <span class="hljs-number">23</span> <span class="hljs-number">23</span>:<span class="hljs-number">56</span>:<span class="hljs-number">58</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: (VI_1) Entering MASTER STATE<br><span class="hljs-attribute">Jun</span> <span class="hljs-number">24</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">33</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: Script `chk_haproxy` now returning <span class="hljs-number">1</span><br><span class="hljs-attribute">Jun</span> <span class="hljs-number">24</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">33</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: VRRP_Script(chk_haproxy) failed (exited with statu&gt;<br><span class="hljs-attribute">Jun</span> <span class="hljs-number">24</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">33</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: (VI_1) Changing effective priority from <span class="hljs-number">52</span> to <span class="hljs-number">50</span><br><span class="hljs-attribute">Jun</span> <span class="hljs-number">24</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">36</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: (VI_1) Master received advert from <span class="hljs-number">192.168.31.91</span> w&gt;<br><span class="hljs-attribute">Jun</span> <span class="hljs-number">24</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">36</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: (VI_1) Entering BACKUP STATE<br></code></pre></td></tr></table></figure><p>23:56:57 时，我重启了 master 节点的 haproxy ，所以脚本执行成功，日志输出 <code>VRRP_Script(chk_haproxy) succeeded</code> ，对应的会 <code>Changing effective priority from 52 to 50</code>，并且只 + 2 了一次，之后都没有变化了，这代表只有第一次成功时会增加。在 00:00:33 的时候，我 stop 了 master 节点的 haproxy，导致脚本执行失败，日志输出 <code>VRRP_Script(chk_haproxy) failed (exited with statu&gt;</code>，然后 <code>(VI_1) Changing effective priority from 52 to 50</code>。</p></li></ul>          </div><p>除此之外，好像也可以修改 <code>vrrp_script</code> 的 weight 为负数，这样执行失败就会扣除对应节点的优先级？这种方法我这里就先不尝试了。</p><div class="note note-success">            <p>Tips：<br>可以使用 <code>kill -HUP $(cat /var/run/keepalived.pid)</code> 命令，让 keepalived 重载配置文件。<br>使用 <code>journalctl -u keepalived.service</code> 查看 keepalived 的日志。</p>          </div><h2 id="部署-K8s"><a href="#部署-K8s" class="headerlink" title="部署 K8s"></a>部署 K8s</h2><p>至此已经部署好了 Keepalived 和 HAproxy 这两个高可用相关的组件，接下来就可以部署 k8s 集群了，因为部署 k8s 不是本文的重点，所以这里不会详细记录部署过程，只简单记录一下如何部署高可用。</p><p>网上查了一下，似乎大部分工具部署高可用集群，都是通过一个名为 controlPlaneEndpoint 的参数实现的，比如我使用的部署工具 kubesphere，其部署高可用集群只需要在部署配置文件中提供 controlPlaneEndpoint 下的相关信息即可，类似这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">controlPlaneEndpoint:</span><br>    <span class="hljs-attr">domain:</span> <span class="hljs-string">lb.kubesphere.local</span><br>    <span class="hljs-attr">address:</span> <span class="hljs-number">172.16</span><span class="hljs-number">.0</span><span class="hljs-number">.10</span>   <span class="hljs-comment"># The VIP address</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6443</span><br></code></pre></td></tr></table></figure><p>然后我又看了一下 kubeadm 的高可用部署，貌似也是在 kubeadm-config.yaml 配置文件中指定 controlPlaneEndpoint 的值，不过我这边就没有实践了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kubeadm.k8s.io/v1beta3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterConfiguration</span><br><span class="hljs-attr">kubernetesVersion:</span> <span class="hljs-string">&quot;v1.21.0&quot;</span><br><span class="hljs-attr">controlPlaneEndpoint:</span> <span class="hljs-string">&quot;master.k8s.io:16443&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>🤔 k8s controlPlaneEndpoint 是什么？</p><p>🤖 <code>controlPlaneEndpoint</code> 是 Kubernetes 高可用集群配置中的一个参数，用于指定集群的控制平面终结点。它通常用于指定 Kubernetes API 服务器的地址，以及外部可以访问该 API 服务器的端点。</p><p>在一个高可用的 Kubernetes 集群中，通常会有多个 Master 节点，它们共同组成控制平面。这些 Master 节点之间需要进行通信，并在需要时进行故障转移。<code>controlPlaneEndpoint</code> 提供了一个统一的访问点，用于访问控制平面的各个组件，以确保集群的稳定性和高可用性。</p><p><code>controlPlaneEndpoint</code> 参数包括以下信息：</p><ul><li><code>host</code>：指定控制平面终结点的主机名或 IP 地址。</li><li><code>port</code>：指定 Kubernetes API 服务器的端口号。</li></ul><p>通过指定 <code>controlPlaneEndpoint</code>，集群中的各个组件（如 kubelet、kube-proxy 等）以及外部用户或工具可以通过该终结点与集群的控制平面进行通信和交互。</p><p>需要注意的是，<code>controlPlaneEndpoint</code> 的配置取决于您的具体集群环境和部署方式。在不同的部署方案中，可能会有不同的配置方式和要求。</p></blockquote><p>我使用 kubesphere 成功搭建好了高可用集群，过程也非常简单，只要按照官方提供的文档，填写 controlPlaneEndpoint 下的相关配置，然后正常安装集群即可。</p><div class="note note-success">            <p>🤔 如果我现在有一个之前部署好的，非高可用的集群，现在想把它改造成高可用，可行吗？应该怎么做？</p>          </div><h2 id="验证高可用（存疑）"><a href="#验证高可用（存疑）" class="headerlink" title="验证高可用（存疑）"></a>验证高可用（存疑）</h2><p>搭建完高可用集群后，我进行了测试，但是在测试过程中我发现一个现象：我的集群拥有 3 个控制节点，当我停掉其中 1 个节点后，集群不受影响；但是当我停掉 2 个节点后，集群就无法正常工作了，我不太明白这是不是一种正常现象，在 google 上找到了 <a href="https://github.com/lentil1016/kubeadm-ha/issues/21">一个类似的问题</a>，里面有个回答如下：</p><blockquote><p>查了一下，ETCD挂掉是一个正常现象，<a href="https://coreos.com/etcd/docs/latest/v2/admin_guide.html#optimal-cluster-size">3节点的ETCD集群失去两个节点即为majority loss</a>，将导致ETCD停止服务，直到另两个节点中的某一个恢复连接。如果不想经历该问题，请保证始终只有单点故障，或增加HA集群中的主机数量。</p></blockquote><p>不知道是不是问题的原因所在，暂时先记录为 <strong>存疑</strong>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP 滑动窗口与流量控制</title>
    <link href="/2023/06/06/tcp-liu-liang-kong-zhi/"/>
    <url>/2023/06/06/tcp-liu-liang-kong-zhi/</url>
    
    <content type="html"><![CDATA[<h1 id="流量控制与滑动窗口图解"><a href="#流量控制与滑动窗口图解" class="headerlink" title="流量控制与滑动窗口图解"></a>流量控制与滑动窗口图解</h1><blockquote><p>ps: 下面的图片皆源自 B 站课程 <a href="https://www.bilibili.com/video/BV1c4411d7jb?p=60&vd_source=2ff613424b86c58a71ba91b7304ffe9b">计算机网络微课堂（有字幕无背景音乐版）</a></p></blockquote><p>当主机 A 与 B 建立 TCP 连接时，B（接收方）告诉 A（发送方），自己的接收窗口大小为 400。</p><p>这意味着主机 A 就可以一口气发送 400 字节的数据，而无需等待 B 确认。</p><p>如下图所示，A 的发送窗口为 400，这表示在窗口填满以前，A 都可以直接发送报文，而无需等待 B 的确认，所以 A 将 1-100，101-200，201-300 以及 301-400 的数据都发送出去了。</p><p>但不巧的是，201-300 的报文丢失了，所以 B 的响应 ack 值的 201，<strong>表示我现在期望收到从 201 开始的报文，即：201 以前的报文我都已经收到了</strong>，这便是 TCP 的 <strong>累计确认</strong>。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/tcp_liu_liang_kong_zhi1.jpg"></p><p>主机 A 知道这个消息以后，就可以开始 <strong>滑动窗口</strong> 了，滑动的正是已经被主机 B 接收到的报文，即 1-200，这部分既然已经被对方成功接收到了，自然就可以从窗口中移除了，如下图所示，1-100 和 101-200 这两部分已经从窗口滑出了。</p><p>同时，B 还通知 A，我的接收窗口有变，之前能接受 400 字节的数据，但是现在只能接收 300 字节了，主机 A 收到这个消息后，也会同样调整自己的发送窗口大小，使其与主机 B 的接收窗口大小相同。<strong>这便是主机 B 对主机 A 的流量控制</strong>。</p><p>所以现在，窗口还剩 200 字节的空位，这意味着 A 还能继续发送 301-400 和 401-500 两个报文，而 201-300 这个报文因为还未被对方接收到，所以依然停留在窗口内。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/tcp_llkz2.jpg"></p><p>现在，A 一共发送了序号 201-500 一共 3 个报文，但是这其中的 201-300 的报文在发送后的一段时间内，没有收到对方的 ack 回复，因此会触发超时重传，A 会判定该报文可能已丢失，重新发送。</p><p>这次 B 成功收到 201-300 这个报文了，此外，先前发送的 301-400 和 401-500 这两个报文，也被 B 成功接收了，所以 B 回复的 ack 值就会是 501，表示 501 以前的包我都已经收到了，现在我期望收到的下一个包从序号 501 开始。</p><p>此外，B 在响应内容中，又对自己的接收窗口进行了调整，调整为了 100，这是 B 对 A 的 <strong>第二次流量控制</strong>。如下图所示。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/tcp_llkz3.jpg"></p><p>现在，A 可以将序号为 201-500 这几个已经被 B 接收到的报文，从自己的发送窗口中滑出了，同时对自己的窗口进行调整，使其大小为 100。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/tcp_llkz4.jpg"></p><p>通过上面的演示，应该对滑动窗口和流量控制有了比较清晰的认识了。</p><h1 id="TODO-窗口死锁"><a href="#TODO-窗口死锁" class="headerlink" title="TODO 窗口死锁"></a>TODO 窗口死锁</h1>]]></content>
    
    
    
    <tags>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Istio Bookinfo</title>
    <link href="/2023/05/27/istio-bookinfo/"/>
    <url>/2023/05/27/istio-bookinfo/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Bookinfo 是 istio 官方提供的一个演示应用，并且官方也给出了详细的功能描述：</p><blockquote><p>这个应用模仿在线书店的一个分类，显示一本书的信息。 页面上会显示一本书的描述，书籍的细节（ISBN、页数等），以及关于这本书的一些评论。</p><p>Bookinfo 应用分为四个单独的微服务：</p><ul><li><code>productpage</code>. 这个微服务会调用 <code>details</code> 和 <code>reviews</code> 两个微服务，用来生成页面。</li><li><code>details</code>. 这个微服务中包含了书籍的信息。</li><li><code>reviews</code>. 这个微服务中包含了书籍相关的评论。它还会调用 <code>ratings</code> 微服务。</li><li><code>ratings</code>. 这个微服务中包含了由书籍评价组成的评级信息。</li></ul><p><code>reviews</code> 微服务有 3 个版本：</p><ul><li>v1 版本不会调用 <code>ratings</code> 服务。</li><li>v2 版本会调用 <code>ratings</code> 服务，并使用 1 到 5 个黑色星形图标来显示评分信息。</li><li>v3 版本会调用 <code>ratings</code> 服务，并使用 1 到 5 个红色星形图标来显示评分信息。</li></ul></blockquote><p>我们可以通过 bookinfo 了解到 istio 的</p><p>首先看看创建 bookinfo 用到的几个 yaml 文件。</p><h2 id="bookinfo-yaml"><a href="#bookinfo-yaml" class="headerlink" title="bookinfo.yaml"></a>bookinfo.yaml</h2><p>这个 yaml 定义了一些 bookinfo 微服务相关的 Deploy，Service，ServiceAccount，没什么好说的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Copyright Istio Authors</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="hljs-comment">#   you may not use this file except in compliance with the License.</span><br><span class="hljs-comment">#   You may obtain a copy of the License at</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#       http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   Unless required by applicable law or agreed to in writing, software</span><br><span class="hljs-comment">#   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="hljs-comment">#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="hljs-comment">#   See the License for the specific language governing permissions and</span><br><span class="hljs-comment">#   limitations under the License.</span><br><br><span class="hljs-comment">##################################################################################################</span><br><span class="hljs-comment"># This file defines the services, service accounts, and deployments for the Bookinfo sample.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># To apply all 4 Bookinfo services, their corresponding service accounts, and deployments:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Alternatively, you can deploy any resource separately:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml -l service=reviews # reviews Service</span><br><span class="hljs-comment">#   kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml -l account=reviews # reviews ServiceAccount</span><br><span class="hljs-comment">#   kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml -l app=reviews,version=v3 # reviews-v3 Deployment</span><br><span class="hljs-comment">##################################################################################################</span><br><br><span class="hljs-comment">##################################################################################################</span><br><span class="hljs-comment"># Details service</span><br><span class="hljs-comment">##################################################################################################</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">details</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">details</span><br>    <span class="hljs-attr">service:</span> <span class="hljs-string">details</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">9080</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">details</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">bookinfo-details</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">account:</span> <span class="hljs-string">details</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">details-v1</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">details</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">details</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">details</span><br>        <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">bookinfo-details</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">details</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/istio/examples-bookinfo-details-v1:1.17.0</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9080</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">1000</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment">##################################################################################################</span><br><span class="hljs-comment"># Ratings service</span><br><span class="hljs-comment">##################################################################################################</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ratings</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">ratings</span><br>    <span class="hljs-attr">service:</span> <span class="hljs-string">ratings</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">9080</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">ratings</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">bookinfo-ratings</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">account:</span> <span class="hljs-string">ratings</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ratings-v1</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">ratings</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">ratings</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">ratings</span><br>        <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">bookinfo-ratings</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ratings</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/istio/examples-bookinfo-ratings-v1:1.17.0</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9080</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">1000</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment">##################################################################################################</span><br><span class="hljs-comment"># Reviews service</span><br><span class="hljs-comment">##################################################################################################</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">reviews</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>    <span class="hljs-attr">service:</span> <span class="hljs-string">reviews</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">9080</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">bookinfo-reviews</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">account:</span> <span class="hljs-string">reviews</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">reviews-v1</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>        <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">bookinfo-reviews</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">reviews</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/istio/examples-bookinfo-reviews-v1:1.17.0</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">LOG_DIR</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;/tmp/logs&quot;</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9080</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/tmp</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">wlp-output</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/opt/ibm/wlp/output</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">1000</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">wlp-output</span><br>        <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp</span><br>        <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">reviews-v2</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">v2</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v2</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>        <span class="hljs-attr">version:</span> <span class="hljs-string">v2</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">bookinfo-reviews</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">reviews</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/istio/examples-bookinfo-reviews-v2:1.17.0</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">LOG_DIR</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;/tmp/logs&quot;</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9080</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/tmp</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">wlp-output</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/opt/ibm/wlp/output</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">1000</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">wlp-output</span><br>        <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp</span><br>        <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">reviews-v3</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">v3</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v3</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>        <span class="hljs-attr">version:</span> <span class="hljs-string">v3</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">bookinfo-reviews</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">reviews</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/istio/examples-bookinfo-reviews-v3:1.17.0</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">LOG_DIR</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;/tmp/logs&quot;</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9080</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/tmp</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">wlp-output</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/opt/ibm/wlp/output</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">1000</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">wlp-output</span><br>        <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp</span><br>        <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br><span class="hljs-meta">---</span><br><span class="hljs-comment">##################################################################################################</span><br><span class="hljs-comment"># Productpage services</span><br><span class="hljs-comment">##################################################################################################</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">productpage</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">productpage</span><br>    <span class="hljs-attr">service:</span> <span class="hljs-string">productpage</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">9080</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">productpage</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">bookinfo-productpage</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">account:</span> <span class="hljs-string">productpage</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">productpage-v1</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">productpage</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">productpage</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">productpage</span><br>        <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">bookinfo-productpage</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">productpage</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/istio/examples-bookinfo-productpage-v1:1.17.0</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9080</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/tmp</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">1000</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp</span><br>        <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br></code></pre></td></tr></table></figure><h2 id="bookinfo-gateway-yaml"><a href="#bookinfo-gateway-yaml" class="headerlink" title="bookinfo-gateway.yaml"></a>bookinfo-gateway.yaml</h2><p>这个 yaml 里面包括了<code>Gateway</code> （需要注意的是它的 apiVersion 是 istio，不是 k8s 原生的 Gateway 资源 ）和 <code>VirtualService</code> 两种资源，下面来简单说明一下这两个资源。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Gateway</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">bookinfo-gateway</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">istio:</span> <span class="hljs-string">ingressgateway</span> <span class="hljs-comment"># use istio default controller</span><br>  <span class="hljs-attr">servers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span><br>      <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">HTTP</span><br>    <span class="hljs-attr">hosts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;*&quot;</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">VirtualService</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">bookinfo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hosts:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;*&quot;</span><br>  <span class="hljs-attr">gateways:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">bookinfo-gateway</span><br>  <span class="hljs-attr">http:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">match:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">exact:</span> <span class="hljs-string">/productpage</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">prefix:</span> <span class="hljs-string">/static</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">exact:</span> <span class="hljs-string">/login</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">exact:</span> <span class="hljs-string">/logout</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">prefix:</span> <span class="hljs-string">/api/v1/products</span><br>    <span class="hljs-attr">route:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span><br>        <span class="hljs-attr">host:</span> <span class="hljs-string">productpage</span><br>        <span class="hljs-attr">port:</span><br>          <span class="hljs-attr">number:</span> <span class="hljs-number">9080</span><br><br></code></pre></td></tr></table></figure><h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><p><code>Gateway</code> 在网格边缘接收外部访问，并将流量转发到网格内的服务。<code>Gateway</code> 一般需要和 <code>VirtualService</code> 配合使用，其中 <code>Gateway</code> 定义了服务怎样从外面访问，而 <code>VirtualService</code> 定义了请求进入到内部后，其流量如何流转。</p><p>在这个 yaml 里，<code>Gateway</code> 包含了 <code>selector</code> 和 <code>servers</code> 两个字段，下面对这两个字段的作用进行一下记录。</p><h4 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h4><p>Gateway 的  <code>spec.selector</code> 字段用于指定入口处运行了 Envoy 的 Pod，这些 Pod 会执行 Gateway 定义的规则。在 bookinfo 里指定的是 <code>istio: ingressgateway</code> ，即所有拥有 <code>istio: ingressgateway</code> label 的 Pod。这些 Pod 由 istio-system namespace 下的名为  istio-ingressgateway 的 Deploy 创建，可以看一下这个 Deploy 的定义：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">k describe -n istio-system deploy istio-ingressgateway<br><br>spec:<br>  template:<br>    metadata:<br>    # .... 省略<br>      labels:<br>        app: istio-ingressgateway<br>        istio: ingressgateway # 这里<br>    spec:<br>      image: docker.io/istio/proxyv2:1.17.2<br>      imagePullPolicy: IfNotPresent<br>      name: istio-proxy<br></code></pre></td></tr></table></figure><p>可以看到在 label 这里定义了这个 <code>istio: ingressgateway</code> label，同时还注意到其使用的镜像是 <code>docker.io/istio/proxyv2:1.17.2</code>，<code>docker.io/istio/proxyv2</code> 是 Istio 中的 Envoy 代理镜像，表明其创建的 Pod 运行的都是 Envoy，用于接收外部请求并将其转发到 Istio 网格中的适当服务。</p><h4 id="servers"><a href="#servers" class="headerlink" title="servers"></a>servers</h4><p>TODO：spec.servers</p><p>TODO：Gateway 貌似需要通过定义一个 service 来进行访问，验证这个猜想</p><p>发现在 istio-system 命名空间下有一个 istio-ingressgateway service，貌似是安装 istio 后自动创建的？不太清楚，并且监听了这些端口</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">15021</span>/TCP,<span class="hljs-number">80</span>/TCP,<span class="hljs-number">443</span>/TCP,<span class="hljs-number">31400</span>/TCP,<span class="hljs-number">15443</span>/TCP<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">k</span> <span class="hljs-string">describe</span> <span class="hljs-string">svc</span> <span class="hljs-string">-n</span> <span class="hljs-string">istio-system</span>                   <span class="hljs-string">istio-ingressgateway</span><br><span class="hljs-attr">Name:</span>                     <span class="hljs-string">istio-ingressgateway</span><br><span class="hljs-attr">Namespace:</span>                <span class="hljs-string">istio-system</span><br><span class="hljs-attr">Labels:</span>                   <span class="hljs-string">app=istio-ingressgateway</span><br>                          <span class="hljs-string">install.operator.istio.io/owning-resource=unknown</span><br>                          <span class="hljs-string">install.operator.istio.io/owning-resource-namespace=istio-system</span><br>                          <span class="hljs-string">istio=ingressgateway</span> <span class="hljs-comment"># 注意这里？代理了 ingress Envoy pod ？</span><br></code></pre></td></tr></table></figure><h3 id="VirtualService"><a href="#VirtualService" class="headerlink" title="VirtualService"></a>VirtualService</h3><p><code>VirtualService</code> 定义了对特定目标服务的一组流量规则，即满足什么条件的流量被哪个后端处理。</p><p>先来看看 <code>VirtualService</code> 有哪些字段</p><h4 id="hosts"><a href="#hosts" class="headerlink" title="hosts"></a>hosts</h4><p>这里的 hosts 定义貌似和 Gateway 中某个 servers 中定义的 Host 有关系，会判断二者的 hosts 是否匹配，如果匹配，则代表当你访问该 Gateway servers 时，会进一步走 VirtualService 定义的流量规则，为了验证这个猜想是否正确，可以手动实践一下：</p><p>首先需要在 &#x2F;etc&#x2F;hosts 中配置一下我们将要添加的域名，其中 IP 从 istio-ingressgateway 这个 service 中获得，因为我使用的是 NodePort 类型的，所以这里的 IP 可以设置为集群内任意一个节点的 IP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo 192.168.31.108 test.com &gt;&gt; /etc/hosts<br></code></pre></td></tr></table></figure><p>修改 Gateway Resource 的声明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">k edit gw -n meshapp bookinfo-gateway<br></code></pre></td></tr></table></figure><p>添加一个 server，声明如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">istio:</span> <span class="hljs-string">ingressgateway</span><br>  <span class="hljs-attr">servers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;*&#x27;</span><br>    <span class="hljs-attr">port:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>      <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">HTTP</span><br>  <span class="hljs-comment"># 新添加的 server</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">test.com</span><br>    <span class="hljs-attr">port:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">http1</span><br>      <span class="hljs-attr">number:</span> <span class="hljs-number">9527</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">HTTP</span><br></code></pre></td></tr></table></figure><p>这里我添加的新的 server 将通过 test.com 作为 host 来访问（似乎必须这样，如果用 IP 访问会 404），当然还要加上对应的端口号（比如 <a href="http://test.com:31225/login%EF%BC%89%EF%BC%8C%E8%BF%99%E9%87%8C%E6%88%91%E5%AE%9A%E4%B9%89%E4%B8%BA">http://test.com:31225/login），这里我定义为</a> 9527 这个端口。</p><p>然后我们再添加一个新的 VirtualService ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">VirtualService</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">bookinfo1</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hosts:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">test.com</span> <span class="hljs-comment"># 与 gateway 新添加的 server 的 hosts 相匹配</span><br>  <span class="hljs-attr">gateways:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">bookinfo-gateway</span><br>  <span class="hljs-attr">http:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">match:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">exact:</span> <span class="hljs-string">/productpage</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">prefix:</span> <span class="hljs-string">/static</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">exact:</span> <span class="hljs-string">/login</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">exact:</span> <span class="hljs-string">/logout</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">prefix:</span> <span class="hljs-string">/api/v1/products</span><br>    <span class="hljs-attr">route:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span><br>        <span class="hljs-attr">host:</span> <span class="hljs-string">productpage</span><br>        <span class="hljs-attr">port:</span><br>          <span class="hljs-attr">number:</span> <span class="hljs-number">9080</span><br></code></pre></td></tr></table></figure><p>修改 service，新暴露一个端口，让其指向我们新创建的 Gateway server 的 port（即 targetPort），也就是 9527，并且该 server 也监听在 9527 端口，然后通过 NodePort 31225 暴露给外界。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http3</span><br>  <span class="hljs-attr">nodePort:</span> <span class="hljs-number">31225</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9527</span><br>  <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9527</span><br></code></pre></td></tr></table></figure><p>现在我们就可以尝试通过 serviceIP + nodePort 来访问这个新定义的服务了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl http://test.com:31225/productpage<br><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;Simple Bookstore App&lt;/title&gt;<br></code></pre></td></tr></table></figure><p>可以看到我们可以成功访问这个 server。</p><blockquote><p>❓为什么明明是一样的 URL，但是通过 curl 可以访问，chrome 访问却会报错 404？</p><p>好吧，发现是开了代理的原因，把 clash 关了就好了</p><p>如果你尝试使用 Postman 访问，哪些需要取消勾选请求头中默认的 Host，然后自己创建一个 Host，指定值为 <code>test.com</code> 或者 <code>test.com:31225</code>，似乎 curl 和 chrome 访问时都会默认加上这个请求头</p></blockquote><h2 id="destination-rule-all-yaml"><a href="#destination-rule-all-yaml" class="headerlink" title="destination-rule-all.yaml"></a>destination-rule-all.yaml</h2><p>这个 yaml 定义的是 DestinationRule（目标规则），这个资源定义了一些 subsets（子集），subset 需要指定一些 labels，这些 labels 实际对应的是 Pod 的 label，类似 Deployment 的 Selector，最终它会请求到匹配 label 的 Pod</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DestinationRule</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">productpage</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-string">productpage</span><br>  <span class="hljs-attr">subsets:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DestinationRule</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">reviews</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-string">reviews</span><br>  <span class="hljs-attr">subsets:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v2</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v2</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v3</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v3</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DestinationRule</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ratings</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-string">ratings</span><br>  <span class="hljs-attr">subsets:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v2</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v2</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v2-mysql</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v2-mysql</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v2-mysql-vm</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v2-mysql-vm</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DestinationRule</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">details</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-string">details</span><br>  <span class="hljs-attr">subsets:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v2</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v2</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br></code></pre></td></tr></table></figure><h3 id="DestinationRule"><a href="#DestinationRule" class="headerlink" title="DestinationRule"></a>DestinationRule</h3><p>DestinationRule 需要配合 VirtualService 使用，看一下前面的 VirtualService 的定义，你会发现里面有这样一段代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">route:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span><br>        <span class="hljs-attr">host:</span> <span class="hljs-string">productpage</span><br>        <span class="hljs-attr">port:</span><br>          <span class="hljs-attr">number:</span> <span class="hljs-number">9080</span><br></code></pre></td></tr></table></figure><p>这里的 destination 正是 DestinationRule。</p><p>DestinationRule 可以配置一些流量策略，比如使用哪种负责均衡策略，TCP 最大连接数等等</p><p><code>VirtualService</code> 和 <code>DestinationRule</code> 有什么区别？</p><p>VirtualService 负责把流量路由到指定的某个实例，但是具体要对流量做一些什么策略，则由 DestinationRule 处理。</p>]]></content>
    
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Multipass 快速搭建虚拟机</title>
    <link href="/2023/05/19/multipass-create-vm-so-easy/"/>
    <url>/2023/05/19/multipass-create-vm-so-easy/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前搭建 k8s 集群一直使用的是 Vmware，虽然总的来说用起来还算 OK，但是总感觉比较重，安装系统什么的也比较耗时（后来发现可以先创建好一台，然后克隆），加上 k8s 老被我搞坏，每次搞坏又都要重新创建集群，每台虚机又要重新配置 root 用户、root ssh 连接之类的（后来也发现貌似可以做一个快照），搞得有点烦，就想看看有没有什么别的虚机工具，能够方便且快速的搭建虚机，最好能支持命令行操作，只要输入一条命令，就可以定制化创建一个虚拟机，找来找去，最终还是找到了之前用过的老朋友 multipass。</p><h1 id="创建一个标准虚机"><a href="#创建一个标准虚机" class="headerlink" title="创建一个标准虚机"></a>创建一个标准虚机</h1><p>只需要使用一行命令即可快速搭建一台虚机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">multipass launch --name vm<br></code></pre></td></tr></table></figure><blockquote><p> PS：如果是第一次创建需要拉取镜像，会稍微慢一些，之后创建就很快了。</p></blockquote><h1 id="创建时指定配置"><a href="#创建时指定配置" class="headerlink" title="创建时指定配置"></a>创建时指定配置</h1><p>此外，你还可以在创建时指定虚机的配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">multipass launch --name vm --cpus 4 --disk 150G --memory 8G<br></code></pre></td></tr></table></figure><h1 id="创建桥接模式的虚机"><a href="#创建桥接模式的虚机" class="headerlink" title="创建桥接模式的虚机"></a>创建桥接模式的虚机</h1><p>默认情况下，使用 multipass 创建出来的虚机只能被宿主机访问，同局域网的其他机器无法访问，如果你想创建类似 Vmware 桥接模式的虚机，让同局域网任意机器访问，可以在创建时指定 <code>--network</code> 参数实现。</p><p>首先执行 <code>multipass networks</code> 查看一下宿主机的网卡：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">multipass networks<br>Name              Type      Description<br>Default Switch    switch    Virtual Switch with internal networking<br>ExtSwitch (WLAN)  switch    Virtual Switch with external networking via &quot;WLAN&quot; (Created by Multipass)<br>WLAN              wifi      Intel(R) Wi-Fi 6E AX210 160MHz<br>��̫��             ethernet  Intel(R) Ethernet Connection (17) I219-V<br></code></pre></td></tr></table></figure><p>然后选择一张物理网卡作为 –network 的值，这里我选择 WLAN 这张网卡：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">multipass launch --name vm --network WLAN --cpus 4 --disk 150G --memory 8G<br></code></pre></td></tr></table></figure><p>然后创建出来的虚拟机会分配一个局域网 IP，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">multipass list<br>Name                    State             IPv4             Image<br>kmaster1                Running           172.21.137.51    Ubuntu 22.04 LTS<br>                                          192.168.31.108<br>kmaster2                Running           172.21.135.58    Ubuntu 22.04 LTS<br>                                          192.168.31.63<br>kmaster3                Running           172.21.129.190   Ubuntu 22.04 LTS<br>                                          192.168.31.125<br>kworker1                Running           172.21.130.113   Ubuntu 22.04 LTS<br>                                          192.168.31.171<br>kworker2                Running           172.21.131.101   Ubuntu 22.04 LTS<br>                                          192.168.31.73<br>kworker3                Running           172.21.137.108   Ubuntu 22.04 LTS<br>                                          192.168.31.253<br></code></pre></td></tr></table></figure><p>可以看到，每台虚机都分配了一个 192.168.31.0 网段的 IP，现在你就可以使用同局域网的任意一台机器，对这些虚机进行访问了。</p><p>而且这个东西最 NB 的是，宿主机的 clash tun 模式对这些虚机也有效，我之前使用 Vmware 桥接模式搭建的虚机是无效的，不知道怎么做到的</p><h1 id="固定-IP"><a href="#固定-IP" class="headerlink" title="固定 IP"></a>固定 IP</h1><p>固定 IP 是一个比较常见的需求，比如搭建 K8s 集群就一定要固定每个节点的 IP，否则如果节点的 IP 发生了变化，会导致集群无法访问。</p><blockquote><p><strong>题外话</strong></p><p>虚机的 IP 是会变化的，不过并不像网上一些文章所说的是只要重启就会变化，至少在我的机器上不是这样，我测试过很多次，不管是重启宿主机，还是重启虚机，最后虚机的 IP 都不会变化，非常稳定，这给了我一种错觉，以为是 multipass 的某些 “神秘魔法”，直到后来我的宿主机莫名其妙关机了好几天，我也一直没注意到，等注意到重新开机以后，才发现虚机的 IP 基本全变了，导致我的 k8s 集群又给坏掉了。。。看来还是必须要执行固定 IP 的操作。。。</p></blockquote><div class="note note-info">            <p>🤔 为什么虚拟机的 IP 会发生变化？</p><p>网上找到一个回答：</p><blockquote><p>因为虚拟机在 NAT 模式下由 Vmware8 虚拟网卡提供虚拟机的 IP 分配，网桥模式下由 Vmware1 来提供 IP 分配。它们都相当于一个小型的 DHCP 服务器，除非改动虚拟机的网络连接方式，或动了虚拟网卡服务属性，那么虚拟机的 IP 租约过期后，IP 就会自动重新分配，从而造成 IP 地址自行变化。</p></blockquote><p>他这里说的是 Vmware，不过其他类型的虚拟化软件应该也差不多是这个原因。</p>          </div><p>使用 multipass 创建的桥接模式的虚拟机，其网络配置文件定义在 <code>/etc/netplan/50-cloud-init.yaml</code>，默认内容大致如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">network:</span><br>    <span class="hljs-attr">ethernets:</span><br>        <span class="hljs-attr">default:</span><br>            <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">true</span><br>            <span class="hljs-attr">match:</span><br>                <span class="hljs-attr">macaddress:</span> <span class="hljs-number">52</span><span class="hljs-string">:54:00:65:36:49</span><br>        <span class="hljs-attr">extra0:</span><br>            <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">true</span><br>            <span class="hljs-attr">dhcp4-overrides:</span><br>                <span class="hljs-attr">route-metric:</span> <span class="hljs-number">200</span><br>            <span class="hljs-attr">match:</span><br>                <span class="hljs-attr">macaddress:</span> <span class="hljs-number">52</span><span class="hljs-string">:54:00:95:0f:24</span><br>            <span class="hljs-attr">optional:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>除了网卡的 MAC 地址以外，其他内容基本在每台虚机上都相同，我们只需要关注 extra0 这段配置即可。extra0 这段配置对应的正是桥接模式的网卡（可以使用 ip addr 看一下这张网卡的 MAC 地址，发现和 extra0.macaddress 是一样的），可以看到 extra0 下的 dhcp4 被配置为了 true，并且没有指定静态 IP，所以我们需要修改的只有两块：</p><ol><li>extra0.dhcp4 修改为 no</li><li>extra0 下增加一条 addresses 配置，指定静态 IP，比如： <code>addresses: [192.168.31.244/24]</code></li></ol><p>修改完后的文件类似这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">network:</span><br>    <span class="hljs-attr">ethernets:</span><br>        <span class="hljs-attr">default:</span><br>            <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">true</span><br>            <span class="hljs-attr">match:</span><br>                <span class="hljs-attr">macaddress:</span> <span class="hljs-number">52</span><span class="hljs-string">:54:00:ee:75:da</span><br>        <span class="hljs-attr">extra0:</span><br>            <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span><span class="hljs-comment"># 这里</span><br>            <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.31</span><span class="hljs-number">.244</span><span class="hljs-string">/24</span>]<span class="hljs-comment"># 这里</span><br>            <span class="hljs-attr">dhcp4-overrides:</span><br>                <span class="hljs-attr">route-metric:</span> <span class="hljs-number">200</span><br>            <span class="hljs-attr">match:</span><br>                <span class="hljs-attr">macaddress:</span> <span class="hljs-number">52</span><span class="hljs-string">:54:00:05:2f:b8</span><br>            <span class="hljs-attr">optional:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>修改完后，执行 <code>netplan apply</code> 命令，即可让配置生效。</p><h2 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h2><p>手动用 vim 修改配置感觉还是有点麻烦，只改那么一两台还好，要是需要改 6,7 台，那这个操作还是有点蛋疼的，有没有什么办法可以用命令行的方式进行配置呢？网上查了下，可以用下面的方式：</p><p>首先安装 yq 这个库，这是一个专门用来修改 yaml 文件的命令行工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">snap install yq<br></code></pre></td></tr></table></figure><p>然后就可以使用这个工具修改 50-cloud-init.yaml 了，类似下面这样，你可以直接粘过去用，只需要改一下 IP 即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cat /etc/netplan/50-cloud-init.yaml | yq &#x27;.network.ethernets.extra0.dhcp4 = &quot;no&quot; | .network.ethernets.extra0.addresses = [&quot;192.168.31.201/24&quot;]&#x27; | sudo tee /etc/netplan/50-cloud-init.yaml.tmp<br>sudo mv /etc/netplan/50-cloud-init.yaml.tmp /etc/netplan/50-cloud-init.yaml<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>🤔 为什么不直接修改 &#x2F;etc&#x2F;netplan&#x2F;50-cloud-init.yaml，而是先拷贝一个 tmp 文件，再用 tmp 覆盖 50-cloud-init.yaml？</p><p>参见 <a href="https://github.com/mikefarah/yq/blob/master/README.md">这个库</a> 的 README，里面说明了原因：</p><blockquote><p><code>yq</code> installs with <a href="https://docs.snapcraft.io/snap-confinement/6233"><em>strict confinement</em></a> in snap, this means it doesn’t have direct access to root files. </p></blockquote><p>大致意思是使用 snap 安装的 yq 被限制了权限，无法访问根目录下的文件，所以只能这么搞了</p>          </div><h1 id="创建时指定配置-1"><a href="#创建时指定配置-1" class="headerlink" title="创建时指定配置"></a>创建时指定配置</h1><p>我们创建虚机后，往往都需要做一些配置，比如设置 root 用户，配置 ssh 允许以 root 身份登录，安装一些包等等，有点麻烦，更麻烦的是如果要搭建的是集群，那么就要在每台虚拟机上都执行这一系列操作，想想就蛋疼，有没有一种可能，通过配置文件定义好这些配置行为，然后创建时通过指定配置文件的方式，自动执行这一系列行为呢？看了一下官方文档，发现 multipass 还真支持。</p><p>根据我的要求，我的配置文件定义如下（配置文件的具体参数，可以查阅官方文档）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#cloud-config</span><br><span class="hljs-attr">users:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">lock_passwd:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">plain_text_passwd:</span> <span class="hljs-string">&quot;root&quot;</span><br>    <span class="hljs-attr">sudo:</span> <span class="hljs-string">ALL=(ALL)</span> <span class="hljs-string">NOPASSWD:ALL</span><br>    <span class="hljs-attr">shell:</span> <span class="hljs-string">/bin/bash</span><br><br><span class="hljs-attr">ssh_pwauth:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-attr">write_files:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/etc/ssh/sshd_config.d/99-allow-root-login.conf</span><br>    <span class="hljs-attr">content:</span> <span class="hljs-string">|</span><br><span class="hljs-string">      PermitRootLogin yes</span><br><span class="hljs-string"></span><br><span class="hljs-attr">packages:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">socat</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">conntrack</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ebtables</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ipset</span><br><br></code></pre></td></tr></table></figure><blockquote><p><strong>&#x2F;etc&#x2F;ssh&#x2F;sshd_config.d&#x2F;99-allow-root-login.conf 是什么文件？和 &#x2F;etc&#x2F;ssh&#x2F;sshd_config 有什么区别 ?</strong></p><p>文件 <code>/etc/ssh/sshd_config.d/99-allow-root-login.conf</code> 是 OpenSSH 服务器配置文件的一个片段文件，它用于存储自定义的配置选项，以覆盖主配置文件 <code>/etc/ssh/sshd_config</code> 中的默认选项。这种分离的配置文件结构使得管理和组织配置更加灵活和可扩展。</p><p>主配置文件 <code>/etc/ssh/sshd_config</code> 包含了 OpenSSH 服务器的所有配置选项。它是一个全局配置文件，影响整个服务器的行为。您可以在此文件中设置各种选项，例如监听端口、允许的认证方式、访问控制规则等。</p><p>而 <code>/etc/ssh/sshd_config.d/</code> 目录是用于存放额外的配置文件片段的目录。这些配置文件片段以 <code>.conf</code> 扩展名结尾，并按照一定的顺序加载到主配置文件中。每个片段文件包含一组相关的配置选项，可以根据需要进行添加、修改或删除。这样的分离配置文件的机制使得配置管理更加方便，可以避免直接修改主配置文件，而是通过添加或修改相应的片段文件来实现自定义配置。</p><p>例如，<code>/etc/ssh/sshd_config.d/99-allow-root-login.conf</code> 文件可以包含一条配置选项 <code>PermitRootLogin yes</code>，用于允许 root 用户通过 SSH 登录。这样的自定义配置片段文件可以方便地管理和维护，而不必直接修改主配置文件。</p></blockquote><p>然后在创建虚机时，通过 –cloud-init [filepath.yaml] 的方式，指定要应用的配置文件，非常的方便：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">multipass launch --cloud-init cloud-config.yaml --name vm --network WLAN --cpus 4 --disk 150G --memory 8G<br></code></pre></td></tr></table></figure><p>现在想搭建一个集群就非常容易了，比如下面的命令就可以创建 6 台虚机，组成一个集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">multipass launch --cloud-init cloud-config.yaml --name kmaster1 --network WLAN --cpus 4 --disk 150G --memory 8G<br>multipass launch --cloud-init cloud-config.yaml --name kmaster2 --network WLAN --cpus 4 --disk 150G --memory 8G<br>multipass launch --cloud-init cloud-config.yaml --name kmaster3 --network WLAN --cpus 4 --disk 150G --memory 8G<br>multipass launch --cloud-init cloud-config.yaml --name kworker1 --network WLAN --cpus 4 --disk 150G --memory 8G<br>multipass launch --cloud-init cloud-config.yaml --name kworker2 --network WLAN --cpus 4 --disk 150G --memory 8G<br>multipass launch --cloud-init cloud-config.yaml --name kworker3 --network WLAN --cpus 4 --disk 150G --memory 8G<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>multipass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s loadbalancer —— Metallb [draft] </title>
    <link href="/2023/05/08/metallb/"/>
    <url>/2023/05/08/metallb/</url>
    
    <content type="html"><![CDATA[<h1 id="安装（Layer2-模式）"><a href="#安装（Layer2-模式）" class="headerlink" title="安装（Layer2 模式）"></a>安装（Layer2 模式）</h1><p>首先需要查看你的 kube-proxy 使用的是不是 ipvs 模式，执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl edit configmap -n kube-system kube-proxy<br></code></pre></td></tr></table></figure><p>其中有一个配置项 mode，如果它的值是 ipvs，则表示使用的 ipvs 模式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">config.conf:</span> <span class="hljs-string">|-</span><br><span class="hljs-string">    apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class="hljs-string">    mode: ipvs # 这里</span><br></code></pre></td></tr></table></figure><p>这种情况下，你需要修改 ipvs 的配置，启用严格的 ARP，将 strictARP 设置为 true，这样 k8s 集群中的<code>kube-proxy</code> 就会停止响应<code>kube-ipvs0</code> 网卡之外的其他网卡的 arp 请求，进而让 MetalLB 接手处理。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ipvs:</span><br>  <span class="hljs-attr">strictARP:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>然后执行下面的命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.13.9/config/manifests/metallb-native.yaml<br></code></pre></td></tr></table></figure><p>安装完成后，为了让 metallb 能够给 service 分配 IP，还需要创建一个 <code>IPAddressPool</code>CR ，并在该 CR 中定义 IP 池的范围，这样 metallb 才能知道有哪些 IP 可以分配。</p><p><strong>注意：指定的 IP 池需要和集群节点在同一网段，也就是同一局域网内。</strong></p><p>如果指定了非同一局域网的 IP 池地址，那么将收不到 ARP 响应报文，导致无法通过 EXTERNAL-IP 访问（这里还没太搞懂）</p><blockquote><p>我指定的 IP 池是 192.168.31.0&#x2F;24，结果这货直接给我的 service 分配了 192.168.31.0，有点离谱，不知道为啥</p><p>更新：</p><p>需要指定 <code>avoidBuggyIPs: true</code> 来避免分配网络地址和广播地址。</p><p>而且我不能同时指定 CIDR 和具体的 IP 范围，比如我下面指定的 192.168.31.0&#x2F;24 和 192.168.31.150-192.168.31.160，会报错</p><p>Error from server (CIDR “192.168.31.150&#x2F;31” in pool “first-pool” overlaps with already defined CIDR “192.168.31.0&#x2F;24”): error when creating “IPAddressPool.yaml”: admission webhook “ipaddresspoolvalidationwebhook.metallb.io” denied the request: CIDR “192.168.31.150&#x2F;31” in pool “first-pool” overlaps with already defined CIDR “192.168.31.0&#x2F;24”</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &lt;&lt;EOF &gt; IPAddressPool.yaml<br>apiVersion: metallb.io/v1beta1<br>kind: IPAddressPool<br>metadata:<br>  name: first-pool<br>  namespace: metallb-system<br>spec:<br>  addresses:<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">可分配的 IP 地址,可以指定多个，包括 ipv4、ipv6</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">- 192.168.31.0/24</span><br>  - 192.168.31.150-192.168.31.160<br>  avoidBuggyIPs: true # 避免分配网络地址和广播地址<br>EOF<br><br>kubectl apply -f IPAddressPool.yaml<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>创建一个 nginx deploy 以及一个 loadbalance 类型的 svc 来测试。</p><p>使用以下命令创建 nginx deploy：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt; nginx-dp.yaml</span><br><span class="hljs-string">apiVersion: apps/v1</span><br><span class="hljs-string">kind: Deployment</span><br><span class="hljs-string">metadata:</span><br><span class="hljs-string">  name: nginx-deployment</span><br><span class="hljs-string">  labels:</span><br><span class="hljs-string">    app: nginx</span><br><span class="hljs-string">spec:</span><br><span class="hljs-string">  replicas: 3</span><br><span class="hljs-string">  selector:</span><br><span class="hljs-string">    matchLabels:</span><br><span class="hljs-string">      app: nginx</span><br><span class="hljs-string">  template:</span><br><span class="hljs-string">    metadata:</span><br><span class="hljs-string">      labels:</span><br><span class="hljs-string">        app: nginx</span><br><span class="hljs-string">    spec:</span><br><span class="hljs-string">      containers:</span><br><span class="hljs-string">      - name: nginx</span><br><span class="hljs-string">        image: docker.io/nginx:latest</span><br><span class="hljs-string">        ports:</span><br><span class="hljs-string">        - containerPort: 80</span><br><span class="hljs-string">EOF</span><br><br>kubectl apply -f nginx-dp.yaml<br></code></pre></td></tr></table></figure><p>使用以下命令创建 nginx-svc：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt; nginx-svc.yaml</span><br><span class="hljs-string">apiVersion: v1</span><br><span class="hljs-string">kind: Service</span><br><span class="hljs-string">metadata:</span><br><span class="hljs-string">  name: nginx</span><br><span class="hljs-string">  labels:</span><br><span class="hljs-string">    app: nginx</span><br><span class="hljs-string">spec:</span><br><span class="hljs-string">  selector:</span><br><span class="hljs-string">    app: nginx</span><br><span class="hljs-string">  ports:</span><br><span class="hljs-string">  - name: nginx-port</span><br><span class="hljs-string">    protocol: TCP</span><br><span class="hljs-string">    port: 80</span><br><span class="hljs-string">    targetPort: 80</span><br><span class="hljs-string">  type: LoadBalancer</span><br><span class="hljs-string">EOF</span><br><br>kubectl apply -f nginx-svc.yaml<br></code></pre></td></tr></table></figure><p>然后查看 svc，看看是不是真的分配了 ExternalIP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl get svc<br>NAME         TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)        AGE<br>kubernetes   ClusterIP      10.233.0.1      &lt;none&gt;           443/TCP        3h31m<br>nginx2       LoadBalancer   10.233.61.237   192.168.31.150   80:31724/TCP   8s<br></code></pre></td></tr></table></figure><p>访问对应的 EXTERNAL-IP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Bash">curl 192.168.31.150<br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;<span class="hljs-built_in">head</span>&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br>&lt;style&gt;<br>html &#123; color-scheme: light dark; &#125;<br>body &#123; width: 35em; margin: 0 auto;<br>font-family: Tahoma, Verdana, Arial, sans-serif; &#125;<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br>&lt;p&gt;If you see this page, the nginx web server is successfully installed and<br>working. Further configuration is required.&lt;/p&gt;<br><br>&lt;p&gt;For online documentation and support please refer to<br>&lt;a href=<span class="hljs-string">&quot;http://nginx.org/&quot;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;<br>Commercial support is available at<br>&lt;a href=<span class="hljs-string">&quot;http://nginx.com/&quot;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;<br><br>&lt;p&gt;&lt;em&gt;Thank you <span class="hljs-keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>能够访问，说明 LB 正常工作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>loadbalancer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Controller-Runtime 之 Source </title>
    <link href="/2023/04/20/controller-runtime-source/"/>
    <url>/2023/04/20/controller-runtime-source/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><code>Source</code> 是 <code>Watches()</code> 的第一个参数，代表一种事件源，实际类型是一个 interface，原型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Source <span class="hljs-keyword">interface</span> &#123;<br>Start(context.Context, handler.EventHandler, workqueue.RateLimitingInterface, ...predicate.Predicate) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只有一个 Start 方法</p><p>TODO: Start 方法参数的作用，在哪里被调用，如何工作</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>老实说光看注释说明还是挺懵逼的，在网上也找不到太多相关的内容，不少博客讲的都是偏概念性质的，对 Source 这个东西还是一头雾水，不知道到底是干嘛的，实际该怎么使用。感觉想要快速了解一个功能的用途，还是想办法做一个 demo 最靠谱，下面我就做了一个 demo，通过自定义一个 Source 事件源，来达到监听文件的目的，当监听的文件内容发生变动时，就会触发一次 Reconcile。</p><p>首先先定义一个 struct 来实现 Source 接口，完整代码如下：</p><h2 id="source-go"><a href="#source-go" class="headerlink" title="source.go"></a><strong>source.go</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;k8s.io/apimachinery/pkg/types&quot;</span><br><span class="hljs-string">&quot;k8s.io/client-go/util/workqueue&quot;</span><br><span class="hljs-string">&quot;k8s.io/klog/v2&quot;</span><br>ctrl <span class="hljs-string">&quot;sigs.k8s.io/controller-runtime&quot;</span><br><span class="hljs-string">&quot;sigs.k8s.io/controller-runtime/pkg/handler&quot;</span><br><span class="hljs-string">&quot;sigs.k8s.io/controller-runtime/pkg/predicate&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> FileWatch <span class="hljs-keyword">struct</span> &#123;<br>p           <span class="hljs-type">string</span><br>f           *os.File<br>q           workqueue.RateLimitingInterface<br>lastModTime time.Time<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewFileWatch</span><span class="hljs-params">(filepath <span class="hljs-type">string</span>)</span></span> *FileWatch &#123;<br>fw := <span class="hljs-built_in">new</span>(FileWatch)<br>fw.p = filepath<br><br>f, err := os.Open(filepath)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fw.f = f<br><br>stat, err := f.Stat()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fw.lastModTime = stat.ModTime()<br><br><span class="hljs-keyword">return</span> fw<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *FileWatch)</span></span> Sync() &#123;<br>ticket := time.NewTicker(time.Second * <span class="hljs-number">3</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ticket.C:<br>modify, modTime, err := f.FileIsModify()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> modify &#123;<br><span class="hljs-comment">// Add 的参数必须是 ctrl.Request 类型的，其他类型会直接被 controller 丢弃</span><br>f.q.Add(ctrl.Request&#123;NamespacedName: types.NamespacedName&#123;Name: f.p&#125;&#125;)<br>f.lastModTime = modTime<br>&#125;<br>&#125;<br>&#125;<br>&#125;()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *FileWatch)</span></span> FileIsModify() (<span class="hljs-type">bool</span>, time.Time, <span class="hljs-type">error</span>) &#123;<br>stat, err := os.Stat(f.p)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, time.Time&#123;&#125;, err<br>&#125;<br><span class="hljs-keyword">if</span> stat.ModTime().After(f.lastModTime) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, stat.ModTime(), <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, stat.ModTime(), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *FileWatch)</span></span> Start(ctx context.Context, h handler.EventHandler, queue workqueue.RateLimitingInterface, p ...predicate.Predicate) <span class="hljs-type">error</span> &#123;<br>klog.Info(<span class="hljs-string">&quot;fileWatch start...&quot;</span>)<br>f.q = queue<br><span class="hljs-keyword">go</span> f.Sync()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>文件监听相关的代码比较简单，这里就不说明了，也不是本文的重点，这里主要需要关注的是 Sync() 里的 <code>f.q.Add(ctrl.Request&#123;NamespacedName: types.NamespacedName&#123;Name: f.p&#125;&#125;)</code> 这一行，表示当文件发生修改时，添加一个 ctrl.Request 到队列中，Request 的 Name 是该文件的路径，然后在 Start() 里，我们运行了 Sync() 这个函数。</p><p>需要注意的是，队列里添加的对象一定要是 ctrl.Request 类型的，如果是其他类型，会直接被内部 controller 丢弃，具体的代码在 <code>controller-runtime/pkg/internal/controller/controller.go</code> 的 reconcileHandler 函数，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> reconcileHandler(ctx context.Context, obj <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-comment">//....</span><br><br><span class="hljs-comment">// Make sure that the object is a valid request.</span><br>  <span class="hljs-comment">// 在这里进行了判断，如果不是 Request 类型会直接丢弃</span><br>req, ok := obj.(reconcile.Request)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-comment">// As the item in the workqueue is actually invalid, we call</span><br><span class="hljs-comment">// Forget here else we&#x27;d go into a loop of attempting to</span><br><span class="hljs-comment">// process a work item that is invalid.</span><br>c.Queue.Forget(obj)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来编写调协相关的代码：</p><h2 id="ctrl-go"><a href="#ctrl-go" class="headerlink" title="ctrl.go"></a>ctrl.go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><br>corev1 <span class="hljs-string">&quot;k8s.io/api/core/v1&quot;</span><br><span class="hljs-string">&quot;k8s.io/klog/v2&quot;</span><br>ctrl <span class="hljs-string">&quot;sigs.k8s.io/controller-runtime&quot;</span><br><span class="hljs-string">&quot;sigs.k8s.io/controller-runtime/pkg/event&quot;</span><br><span class="hljs-string">&quot;sigs.k8s.io/controller-runtime/pkg/handler&quot;</span><br><span class="hljs-string">&quot;sigs.k8s.io/controller-runtime/pkg/predicate&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Ctrl <span class="hljs-keyword">struct</span> &#123;<br>fw *FileWatch<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Ctrl)</span></span> Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, <span class="hljs-type">error</span>) &#123;<br>klog.Info(<span class="hljs-string">&quot;new modify event, file path: &quot;</span>, req.String())<br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Ctrl)</span></span> SetupWithManager(mgr ctrl.Manager) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> ctrl.NewControllerManagedBy(mgr).<br><span class="hljs-comment">// controller-runtime 必须要指定一种监听的资源，否则无法启动，这里设置为 Pod</span><br>For(&amp;corev1.Pod&#123;&#125;).<br>Watches(c.fw, &amp;handler.EnqueueRequestForObject&#123;&#125;).<br>WithEventFilter(&amp;predicate.Funcs&#123;<br><span class="hljs-comment">// 在这里设置过滤事件，只监听指定 namespace 的 pod 的创建事件，</span><br><span class="hljs-comment">// 这里的 namespace 我随便设置了一个，进而可以达到忽略 Pod 事件的目的，</span><br>      <span class="hljs-comment">// 因为我们的主要目的是观察自定义 Source 的效果，所以尽量避免其他资源的干扰</span><br>CreateFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(e event.CreateEvent)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> e.Object.GetNamespace() == <span class="hljs-string">&quot;UNKNOWN_NAMESPACE&quot;</span><br>&#125;,<br>&#125;).<br>Complete(c)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>Reconcile</code> 中，我们只会简单输出一条日志，表示发生了文件修改事件，在 <code>SetupWithManager</code> 中，我们指定了 <code>Watches</code> 的第一个参数为 fw，也就是我们自定义的 Source。</p><p>最后是主函数 main.go。</p><h2 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;os&quot;</span><br><br><span class="hljs-string">&quot;k8s.io/klog/v2&quot;</span><br>ctrl <span class="hljs-string">&quot;sigs.k8s.io/controller-runtime&quot;</span><br><span class="hljs-string">&quot;sigs.k8s.io/controller-runtime/pkg/client/config&quot;</span><br><span class="hljs-string">&quot;sigs.k8s.io/controller-runtime/pkg/manager&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>filepath := os.Getenv(<span class="hljs-string">&quot;FILE_PATH&quot;</span>)<br><span class="hljs-keyword">if</span> filepath == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;file path can&#x27;t be nil&quot;</span>)<br>&#125;<br><br>cfg, err := config.GetConfig()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>klog.Error(err, <span class="hljs-string">&quot;unable to get kubeconfig&quot;</span>)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><br>mgr, err := manager.New(cfg, manager.Options&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>klog.Error(err, <span class="hljs-string">&quot;unable to set up manager&quot;</span>)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">if</span> err := (&amp;Ctrl&#123;<br>fw: NewFileWatch(filepath),<br>&#125;).SetupWithManager(mgr); err != <span class="hljs-literal">nil</span> &#123;<br>klog.Error(err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>klog.Info(<span class="hljs-string">&quot;starting manager&quot;</span>)<br><span class="hljs-keyword">if</span> err := mgr.Start(ctrl.SetupSignalHandler()); err != <span class="hljs-literal">nil</span> &#123;<br>klog.Error(err, <span class="hljs-string">&quot;problem running manager&quot;</span>)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后我们启动整个程序，你需要通过环境变量 <code>FILE_PATH</code> 来指定你要监听的文件路径，比如像下面这样。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">FILE_PATH=testdata/test.txt  go run .<br></code></pre></td></tr></table></figure><p>运行后，对你监听的文件进行修改，观察 terminal 的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">I0420 16:47:42.610297 3741467 main.go:35] starting manager<br>I0420 16:47:42.610718 3741467 source.go:74] fileWatch start...<br>I0420 16:48:00.611223 3741467 ctrl.go:19] new modify event, file path: /testdata/test.txt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>controller-runtime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K8s Storageclass</title>
    <link href="/2023/04/18/k8s-storageclass/"/>
    <url>/2023/04/18/k8s-storageclass/</url>
    
    <content type="html"><![CDATA[<h1 id="搭建-NFS-StorageClass"><a href="#搭建-NFS-StorageClass" class="headerlink" title="搭建 NFS StorageClass"></a>搭建 NFS StorageClass</h1><h2 id="搭建-NFS-Server"><a href="#搭建-NFS-Server" class="headerlink" title="搭建 NFS Server"></a>搭建 NFS Server</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 NFS 服务端</span><br>sudo apt-get install nfs-kernel-server  <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建一个 <span class="hljs-built_in">dir</span> 作为 NFS 共享目录</span><br>mkdir /share<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑配置</span><br>sudo vim /etc/exports<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在最后一行添加</span><br>/share *(rw,sync,no_root_squash,no_subtree_check)<br></code></pre></td></tr></table></figure><p>修改完成后，:wq 保存，然后执行 <code>exportfs -rav</code> 命令使配置生效，不然客户端挂载 NFS 会报错无权限。</p><p><code>/share *(rw,sync,no_root_squash,no_subtree_check)</code></p><p>其中 &#x2F;share 就是我们的 NFS 共享目录</p><p>*(rw,sync,no_root_squash,no_subtree_check) 是一条配置行，用于指定 NFS 共享目录的权限设置</p><p>具体解释如下：</p><ul><li><code>*</code>: 表示允许任何客户端访问该共享目录。也可以指定特定的 IP 地址、IP 地址范围或域名等来限制客户端的访问。</li><li><code>(rw)</code>: 表示共享目录以读写 (read-write) 模式共享，客户端可以对共享目录进行读取和写入操作。也可以使用 <code>(ro)</code> 表示只读 (read-only) 模式共享，客户端只能对共享目录进行读取操作。</li><li><code>(sync)</code>: 表示使用同步 (synchronous) 模式，NFS 服务器在客户端请求完成之前会等待写入操作同步到磁盘上。这样可以保证数据的一致性，但可能会影响性能。</li><li><code>(no_root_squash)</code>: 表示允许客户端使用 root 权限访问共享目录。默认情况下，NFS 服务器会将客户端使用 root 权限的请求映射为使用匿名用户 (nobody) 权限，这样可以提高安全性。使用 <code>(no_root_squash)</code> 参数可以禁用这种映射，允许客户端使用 root 权限访问共享目录。</li><li><code>(no_subtree_check)</code>: 表示禁用子树检查，这样可以加快目录共享的速度。子树检查是一种安全特性，用于检查共享目录的父目录和祖先目录的权限，但在某些情况下可能会影响性能。使用 <code>(no_subtree_check)</code> 参数可以禁用这种检查。</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>首先在共享目录 &#x2F;share 下创建一个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> 123 &gt; /share/123.txt</span><br></code></pre></td></tr></table></figure><p>在另一台主机上，挂载该共享目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo mount -t nfs 192.168.223.129:/share /mnt</span><br></code></pre></td></tr></table></figure><p>其中，192.168.223.129 是 NFS Server 的 IP，&#x2F;share 是该 server 的共享目录，&#x2F;mnt 是客户端要挂载到本机的目的目录。</p><blockquote><p>如果执行后报错</p><p>mount: &#x2F;mnt: bad option; for several filesystems (e.g. nfs, cifs) you might need a &#x2F;sbin&#x2F;mount.<type> helper program.</p><p>表示你没有安装 NFS 客户端，执行下面的命令进行安装 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install -y nfs-common<br></code></pre></td></tr></table></figure></blockquote><p>执行完成后如果没有任何错误信息则代表成功，查看当前主机的 &#x2F;mnt 目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /mnt</span><br>123.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /mnt/123.txt</span><br>123<br></code></pre></td></tr></table></figure><p>发现之前在 NFS Server 的 &#x2F;share 里创建的文件，出现在了客户端主机的 &#x2F;mnt 目录下，代表 NFS Server 搭建成功。</p><h1 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner</span><br>  <span class="hljs-comment"># replace with namespace where provisioner is deployed</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span>        <span class="hljs-comment">#根据实际环境设定namespace,下面类同</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner-runner</span><br><span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>    <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;persistentvolumes&quot;</span>]<br>    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>, <span class="hljs-string">&quot;create&quot;</span>, <span class="hljs-string">&quot;delete&quot;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>    <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;persistentvolumeclaims&quot;</span>]<br>    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>, <span class="hljs-string">&quot;update&quot;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;storage.k8s.io&quot;</span>]<br>    <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;storageclasses&quot;</span>]<br>    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>    <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;events&quot;</span>]<br>    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;create&quot;</span>, <span class="hljs-string">&quot;update&quot;</span>, <span class="hljs-string">&quot;patch&quot;</span>]<br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">run-nfs-client-provisioner</span><br><span class="hljs-attr">subjects:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner</span><br>    <span class="hljs-comment"># replace with namespace where provisioner is deployed</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner-runner</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">leader-locking-nfs-client-provisioner</span><br>    <span class="hljs-comment"># replace with namespace where provisioner is deployed</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>    <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;endpoints&quot;</span>]<br>    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>, <span class="hljs-string">&quot;create&quot;</span>, <span class="hljs-string">&quot;update&quot;</span>, <span class="hljs-string">&quot;patch&quot;</span>]<br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">RoleBinding</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">leader-locking-nfs-client-provisioner</span><br><span class="hljs-attr">subjects:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner</span><br>    <span class="hljs-comment"># replace with namespace where provisioner is deployed</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">leader-locking-nfs-client-provisioner</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br></code></pre></td></tr></table></figure><h1 id="部署-provisioner-deployment"><a href="#部署-provisioner-deployment" class="headerlink" title="部署 provisioner-deployment"></a>部署 provisioner-deployment</h1><blockquote><p>⚠️  如果你的 k8s 版本和我一样是 v1.25.6，那么需要使用下面这个镜像：</p><p>gcr.io&#x2F;k8s-staging-sig-storage&#x2F;nfs-subdir-external-provisioner:v4.0.0</p><p>否则 pvc 无法 bound，报错 selfLink was empty, can’t make reference</p><p>下面这个镜像无法正常工作</p><p>quay.io&#x2F;external_storage&#x2F;nfs-client-provisioner:latest</p><p>此外还需要注意的是，你需要确保所有节点上都已经安装好了 NFS 客户端，因为 pod 可能被调度到任何一个 worker 节点。如果没有，你可以执行下面的命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install -y nfs-common<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># nft-provisioner-deployment.yaml</span><br><span class="hljs-comment"># kubectl apply -f nft-provisioner-deployment.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nfs-client-provisioner</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nfs-client-provisioner</span><br>  <span class="hljs-attr">strategy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">Recreate</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nfs-client-provisioner</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nfs-client-provisioner</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">nfs-client-provisioner</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner</span><br>          <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">gcr.io/k8s-staging-sig-storage/nfs-subdir-external-provisioner:v4.0.0</span><br>          <span class="hljs-attr">volumeMounts:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-root</span><br>              <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/persistentvolumes</span><br>          <span class="hljs-attr">env:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">PROVISIONER_NAME</span><br>              <span class="hljs-comment"># 自定义 provisioner 名称</span><br>              <span class="hljs-attr">value:</span> <span class="hljs-string">nfs-provisioner</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">NFS_SERVER</span><br>              <span class="hljs-comment"># 替换为 nfs 服务器地址</span><br>              <span class="hljs-attr">value:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.223</span><span class="hljs-number">.129</span> <br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">NFS_PATH</span><br>              <span class="hljs-comment"># 替换为 NFS 共享文件路径</span><br>              <span class="hljs-attr">value:</span> <span class="hljs-string">/share</span> <br>      <span class="hljs-attr">volumes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-root</span><br>          <span class="hljs-attr">nfs:</span><br>            <span class="hljs-comment"># 替换为 nfs 服务器地址</span><br>            <span class="hljs-attr">server:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.223</span><span class="hljs-number">.129</span><br>            <span class="hljs-comment"># 替换为 NFS 共享文件路径</span><br>            <span class="hljs-attr">path:</span> <span class="hljs-string">/share</span><br></code></pre></td></tr></table></figure><h3 id="StorageClass"><a href="#StorageClass" class="headerlink" title="StorageClass"></a>StorageClass</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># nfs-storage.yaml</span><br><span class="hljs-comment"># kubectl apply -f nfs-storage.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-storage</span><br><span class="hljs-comment"># 使用上面的自定义 provisioner 名称</span><br><span class="hljs-attr">provisioner:</span> <span class="hljs-string">nfs-provisioner</span><br><span class="hljs-attr">parameters:</span><br>  <span class="hljs-comment"># archiveOnDelete 指定为 false 表示删除 PVC 后 PV 也会被删除。</span><br>  <span class="hljs-comment"># 如果想在 PVC 被删除后仍旧保留数据的，可指定为 true</span><br>  <span class="hljs-attr">archiveOnDelete:</span> <span class="hljs-string">&quot;false&quot;</span><br></code></pre></td></tr></table></figure><p>验证：</p><p>创建 pvc</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-claim</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-comment"># 与 nfs-StorageClass.yaml metadata.name 保持一致</span><br>    <span class="hljs-attr">volume.beta.kubernetes.io/storage-class:</span> <span class="hljs-string">&quot;nfs-storage&quot;</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">1Mi</span><br></code></pre></td></tr></table></figure><p>查看是否 Bound：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">k get pvc</span><br>NAME           STATUS    VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE<br>test-claim     Bound     pvc-969d9309-4510-46ac-90c1-8e9cc1d8f2ec   1Mi        RWX            nfs-storage    22m<br></code></pre></td></tr></table></figure><p>TODO 测试 pod 能否挂载上这个 pvc</p><h1 id="设置默认-StorageClass"><a href="#设置默认-StorageClass" class="headerlink" title="设置默认 StorageClass"></a>设置默认 StorageClass</h1><p>执行下面的命令将某个 sc 设置为默认：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl patch storageclass &lt;storageclass-name&gt; -p <span class="hljs-string">&#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27;</span></span><br></code></pre></td></tr></table></figure><p>比如现在有一个名为 nfs-storage 的 sc，要将其设置为默认 sc：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">k get sc</span><br>NAME          PROVISIONER       RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE<br>nfs-storage   nfs-provisioner   Delete          Immediate           false                  41m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl patch storageclass nfs-storage -p <span class="hljs-string">&#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27;</span></span><br></code></pre></td></tr></table></figure><p>执行后，发现名字后面多了一个 (default)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">k get sc</span><br>NAME                    PROVISIONER       RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE<br>nfs-storage (default)   nfs-provisioner   Delete          Immediate           false                  46m<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Kubespray 搭建 k8s 集群</title>
    <link href="/2023/04/16/Kubespray-install/"/>
    <url>/2023/04/16/Kubespray-install/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>⚠️  安装前最好确保你的主机够干净，我的虚拟机就因为之前自行用二进制搭建过，导致使用 kubespray 安装出现各种奇奇怪怪的错误，最后删除重新创建了一台，一次就安装成功了</p>          </div><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install pip<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ssh 登录要用，不然报错 <span class="hljs-string">&quot;to use the &#x27;ssh&#x27; connection type with passwords or pkcs11_provider, you must install the sshpass program</span></span><br>apt install sshpass<br><br>pip install netaddr # 不确定这玩意的必要性，最好还是装了吧<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">不要手动安装下面这些东西，手动安装的 ansible 可能与 Kubespray 要求的版本不匹配</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">pip install --upgrade jinja2</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">apt install ansible</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">不要 clone 这个，可能有问题</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">git clone https://github.com/kubernetes-incubator/kubespray.git</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">从 kubespray github release 里下载，版本任意选择</span></span><br>wget https://github.com/kubernetes-sigs/kubespray/archive/refs/tags/v2.21.0.tar.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">解压上面下载下来的压缩包</span></span><br>tar -C . -xvf v2.21.0.tar.gz<br><br>cd kubespray-2.21.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">安装符合版本的依赖，这里会安装对应版本的 ansible</span></span><br>pip install -U -r requirements.txt<br></code></pre></td></tr></table></figure><h1 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd kubespray-2.21.0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">复制一份配置进行修改</span><br>cp -rfp inventory/sample inventory/k8s<br>vim inventory/k8s/inventory.ini<br></code></pre></td></tr></table></figure><p>配置如下，注意要确保 IP 正确，另外如果是 master 节点要额外指定 <code>etcd_member_name</code> 参数。</p><p>同理，[kube_control_plane] 和 [etcd] 里填写 master 节点，[kube_node] 里填写 worker 节点。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-comment"># ## Configure &#x27;ip&#x27; variable to bind kubernetes services on a</span><br><span class="hljs-comment"># ## different ip than the default iface</span><br><span class="hljs-section">[all]</span><br>k8s-master <span class="hljs-attr">ansible_host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">223.128</span> ip=<span class="hljs-number">192.168</span>.<span class="hljs-number">223.128</span> ansible_ssh_user=root ansible_ssh_pass=root etcd_member_name=k8s-master<br>k8s-worker1 <span class="hljs-attr">ansible_host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">223.129</span> ip=<span class="hljs-number">192.168</span>.<span class="hljs-number">223.129</span> etcd_member_name=<span class="hljs-string">&quot;&quot;</span><br>k8s-worker2 <span class="hljs-attr">ansible_host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">223.130</span> ip=<span class="hljs-number">192.168</span>.<span class="hljs-number">223.130</span> etcd_member_name=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-comment"># node1 ansible_host=95.54.0.12  # ip=10.3.0.1 etcd_member_name=etcd1</span><br><span class="hljs-comment"># node2 ansible_host=95.54.0.13  # ip=10.3.0.2 etcd_member_name=etcd2</span><br><span class="hljs-comment"># node3 ansible_host=95.54.0.14  # ip=10.3.0.3 etcd_member_name=etcd3</span><br><span class="hljs-comment"># node4 ansible_host=95.54.0.15  # ip=10.3.0.4 etcd_member_name=etcd4</span><br><span class="hljs-comment"># node5 ansible_host=95.54.0.16  # ip=10.3.0.5 etcd_member_name=etcd5</span><br><span class="hljs-comment"># node6 ansible_host=95.54.0.17  # ip=10.3.0.6 etcd_member_name=etcd6</span><br><br><span class="hljs-comment"># ## configure a bastion host if your nodes are not directly reachable</span><br><span class="hljs-comment"># [bastion]</span><br><span class="hljs-comment"># bastion ansible_host=x.x.x.x ansible_user=some_user</span><br><br><span class="hljs-section">[kube_control_plane]</span><br>k8s-master<br><span class="hljs-comment"># node1</span><br><span class="hljs-comment"># node2</span><br><span class="hljs-comment"># node3</span><br><br><span class="hljs-section">[etcd]</span><br>k8s-master<br><span class="hljs-comment"># node1</span><br><span class="hljs-comment"># node2</span><br><span class="hljs-comment"># node3</span><br><br><span class="hljs-section">[kube_node]</span><br>k8s-worker1<br>k8s-worker2<br><span class="hljs-comment"># node2</span><br><span class="hljs-comment"># node3</span><br><span class="hljs-comment"># node4</span><br><span class="hljs-comment"># node5</span><br><span class="hljs-comment"># node6</span><br><br><span class="hljs-section">[calico_rr]</span><br><br><span class="hljs-section">[k8s_cluster:children]</span><br>kube_control_plane<br>kube_node<br>calico_rr<br></code></pre></td></tr></table></figure><h1 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h1><p>执行下面的命令进行部署，中间可能需要等待 10 分钟左右。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible-playbook -i inventory/k8s/inventory.ini cluster.yml -b -vvv <br></code></pre></td></tr></table></figure><p>最终如果执行结果如下，即所有节点 failed&#x3D;0，代表安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">PLAY RECAP ****************************************************************************************************<br>k8s-master                 : ok=728  changed=141  unreachable=0    failed=0    skipped=1260 rescued=0    ignored=8<br>k8s-worker1                : ok=479  changed=28   unreachable=0    failed=0    skipped=776  rescued=0    ignored=1<br>k8s-worker2                : ok=479  changed=28   unreachable=0    failed=0    skipped=775  rescued=0    ignored=1<br>localhost                  : ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0<br></code></pre></td></tr></table></figure><h1 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p><del>报错 Ansible must be between 2.11.0 and 2.13.0 exclusive</del></p><p><del>执行 python3 -m pip install –upgrade –user ansible 后还是报错，发现是版本又太高了：</del></p><p><del>ansible –version</del><br><del>ansible [core 2.14.4]</del></p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>报错 the output has been hidden due to the fact that ‘no_log: true’ was specified for this result</p><p><code>vim inventory/k8s/group_vars/all/all.yml</code></p><p>修改下面这行为 true</p><p><code>unsafe_show_logs: true</code></p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>报错：</p><p>The checksum for &#x2F;tmp&#x2F;releases&#x2F;calico-v3.25.1-kdd-crds&#x2F;v3.25.1.tar.gz did not match 361b0e0e6d64156f0e1b2fbfd18d13217d188eee614eec5de6b05ac0deaab372; it was 4d6b6653499f24f80a85a0a7dac28d9571cabfa25356b08f3b438fd97e322e2d.</p><p>尝试手动下载</p><p>cd &#x2F;tmp&#x2F;releases&#x2F;calico-v3.25.1-kdd-crds</p><p>wget <a href="https://github.com/projectcalico/calico/archive/v3.25.1.tar.gz">https://github.com/projectcalico/calico/archive/v3.25.1.tar.gz</a></p><p>不行，执行部署命令会清空该目录</p><p>解决：</p><p>不要 clone 下面这个 master 分支，可能有问题</p><p>git clone <a href="https://github.com/kubernetes-incubator/kubespray.git">https://github.com/kubernetes-incubator/kubespray.git</a></p><p>从 release 里下载</p><p>wget <a href="https://github.com/kubernetes-sigs/kubespray/archive/refs/tags/v2.21.0.tar.gz">https://github.com/kubernetes-sigs/kubespray/archive/refs/tags/v2.21.0.tar.gz</a></p><p>后安装就没有这个问题了</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>W0416 11:04:23.183824  468870 utils.go:69] The recommended value for &quot;clusterDNS&quot; in &quot;KubeletConfiguration&quot; is: [10.233.0.10]; the provided value is: [169.254.25.10]\nerror execution phase certs&#x2F;apiserver: couldn’t load CA certificate ca: couldn’t load ca certificate authority from &#x2F;etc&#x2F;kubernetes&#x2F;ssl\nTo see the stack trace of this error execute with –v&#x3D;5 or higher</p><p>不知道啥原因，可能是因为之前机器装过二进制 k8s 导致一些莫名其妙的冲突</p><h1 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h1><p>安装完只有 master 节点安装好了 kubectl，worker 节点都没有安装，这个正常吗？</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装机记录</title>
    <link href="/2023/04/14/zhuangji-jilu/"/>
    <url>/2023/04/14/zhuangji-jilu/</url>
    
    <content type="html"><![CDATA[<p>最近组了台台式，用来当做迷你服务器使用，因为是自己第一次独立装机，所以特此记录一下期间的心路历程。</p><h1 id="坑爹-1：CPU"><a href="#坑爹-1：CPU" class="headerlink" title="坑爹 1：CPU"></a>坑爹 1：CPU</h1><p>坑爹指数：⭐️</p><p>老实说这玩意安装还是非常简单的，主要是包装和说明书上各种警告，还有网上各种压弯针脚的帖子，搞得人心惶惶的，其实感觉问题不大，按照说明书的步骤来，稍微小心一点，很容易就安装好了。</p><h1 id="坑爹-2：-主板"><a href="#坑爹-2：-主板" class="headerlink" title="坑爹 2： 主板"></a>坑爹 2： 主板</h1><p>坑爹指数：⭐️⭐️⭐️⭐️</p><p>主板本身的安装没什么难的，对准螺丝柱，拧上螺丝就 OK 了，蛋疼的是这玩意不能太早安装，作为初次装机的练习生，在这点上就踩了大坑了，前前后后装了拆拆了装了好几次，印象如下：</p><p>第一次：主板电源插线，发现需要用点力才能插进去，但是因为已经固定在螺丝柱上了，而有一部分线又需要插在主板角落，害怕把持不住把主板搞弯了，保险起见只能把主板拆掉再插线</p><p>第二次：安装散热，发现散热底座螺丝柱需要从主板背面安装，没办法又得拆下主板</p><p>第三次：安装机箱挡板，这玩意要安装在机箱内部，然后再用力往外压才能完成安装，我一开始还以为是从外到内安装。。。没办法只能拆掉主板</p><p>第四次：安装网卡 wifi-go 盒子，同样也是要从主板背面安装螺丝，没办法又得拆下主板</p><h1 id="坑爹-3：主板跳线"><a href="#坑爹-3：主板跳线" class="headerlink" title="坑爹 3：主板跳线"></a>坑爹 3：主板跳线</h1><p>坑爹指数：⭐️⭐️</p><p>这个乍一看挺复杂的，其实对着网上的视频教学，还是不难的，不过话虽这么说，但我还是没有一次成功，装好后电源键没反应，当时吓了我一跳，还以为硬件有问题，还好把跳线全部拔掉再照着视频插了一遍后成功解决了，总的来说还是不难的</p><h1 id="坑爹-4：主板电源线"><a href="#坑爹-4：主板电源线" class="headerlink" title="坑爹 4：主板电源线"></a>坑爹 4：主板电源线</h1><p>坑爹指数：⭐️⭐️⭐️⭐️⭐️</p><p>插这破玩意的时候直接让我破防，主要是太紧了，看视频要全部插到底才算 OK，否则有烧主板的风险，但是想插到底真的是费劲的一批，而且用太大劲又怕把针脚给搞弯，搞的是用劲不是，不用劲也不是，最后磨了半天最后才完全插进去，属实是恶心</p><h1 id="坑爹-5：网卡"><a href="#坑爹-5：网卡" class="headerlink" title="坑爹 5：网卡"></a>坑爹 5：网卡</h1><p>坑爹指数：⭐️⭐️⭐️⭐️⭐️</p><p>千算万算没想到，这个 jb 玩意是我安装过程中最恶心的一个部位，首先是那两根破线，就是连接天线和网卡的那根线，连接纽扣处太小了，难装的一批，后来看视频里的是斜着装的，然后调整了半天角度才扣上去，装好后又发现一个问题：我不知道如何将天线固定在机箱，虽然包装里给了两个带洞的铁片，好像是什么挡板，但是我不知道装在机箱的哪里，网上找到的视频也都是 wifi-go 盒子安装的，折腾了半天也没头绪，浪费了好多时间，最后没办法只能再买一个 wifi-go 盒子了，不过我发现单网卡不插天线，其实也是可以使用的，网速也有个 4 5M 每秒。</p><h1 id="坑爹-6：机箱挡板"><a href="#坑爹-6：机箱挡板" class="headerlink" title="坑爹 6：机箱挡板"></a>坑爹 6：机箱挡板</h1><p>坑爹指数：⭐️</p><p>这玩意其实没啥坑爹的，就是按压的时候要用点力，听见咔嚓的声音就可以了</p><h1 id="傻瓜级：内存，固态，电源"><a href="#傻瓜级：内存，固态，电源" class="headerlink" title="傻瓜级：内存，固态，电源"></a>傻瓜级：内存，固态，电源</h1><p>这三玩意基本都是简单无脑，也无需担心不小心装坏了什么的，像内存和电源都有防呆缺口，然后插进去就 OK 了，电源也是直接对准机箱屁股拧上螺丝就好了，主要是电源接线麻烦一些，电源本身安装非常简单</p>]]></content>
    
    
    
    <tags>
      
      <tag>misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K8s 二进制安装</title>
    <link href="/2023/04/13/k8s-binray-install/"/>
    <url>/2023/04/13/k8s-binray-install/</url>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>主机系统为 win11，通过 vmware 创建了 3 台虚拟机，详情如下：</p><table><thead><tr><th>hostname</th><th>os</th><th>ip</th><th>cpu</th><th>mem</th><th>disk</th></tr></thead><tbody><tr><td>k8s-master</td><td>Ubuntu 22.04.2 LTS</td><td>192.168.223.128</td><td>4c</td><td>8g</td><td>50g</td></tr><tr><td>k8s-worker1</td><td>Ubuntu 22.04.2 LTS</td><td>192.168.223.129</td><td>4c</td><td>8g</td><td>50g</td></tr><tr><td>k8s-worker2</td><td>Ubuntu 22.04.2 LTS</td><td>192.168.223.130</td><td>4c</td><td>8g</td><td>50g</td></tr></tbody></table><h1 id="基础环境准备"><a href="#基础环境准备" class="headerlink" title="基础环境准备"></a>基础环境准备</h1><h2 id="配置-hosts"><a href="#配置-hosts" class="headerlink" title="配置 hosts"></a>配置 hosts</h2><p>在 3 台主机的 &#x2F;etc&#x2F;hosts 文件中加入以下内容：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.223.128</span> k8s-master<br><span class="hljs-number">192.168.223.129</span> k8s-worker1<br><span class="hljs-number">192.168.223.130</span> k8s-worker2<br></code></pre></td></tr></table></figure><h2 id="配置免密登录"><a href="#配置免密登录" class="headerlink" title="配置免密登录"></a>配置免密登录</h2><p>首先在每台机器上执行下面的命令来生成 ssh 秘钥，直接回车到底：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa</span><br></code></pre></td></tr></table></figure><p>继续执行 <code>ssh-copy-id -i .ssh/id_rsa.pub &lt;hostname&gt;</code> 命令，其中 hostname 填写 <strong>另外两台主机的主机名</strong>，这里以 <code>k8s-worker1</code> 为例。 按照提示输入 yes，最后输入目标主机的密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh-copy-id -i .ssh/id_rsa.pub k8s-worker1</span><br></code></pre></td></tr></table></figure><p>输入密码后，如果提示下面内容，说明配置免密成功，执行 <code>ssh &#39;k8s-worker1&#39;</code>，发现无需输入密码即可直接 ssh 到目标主机。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Number of key(s) added: 1<br><br>Now try logging into the machine, with:   &quot;ssh &#x27;k8s-worker1&#x27;&quot;<br>and check to make sure that only the key(s) you wanted were added.<br></code></pre></td></tr></table></figure><p>按照上面的流程对每台主机执行相同操作，完成 3 台主机相互之间的免密登录，这里不再赘述。</p><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><p>在每台主机上执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl <span class="hljs-built_in">disable</span> --now ufw</span><br></code></pre></td></tr></table></figure><p>查看效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ufw status</span><br>Status: inactive<br></code></pre></td></tr></table></figure><h2 id="关闭交换分区"><a href="#关闭交换分区" class="headerlink" title="关闭交换分区"></a>关闭交换分区</h2><p>执行下面的命令关闭 swap：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab<br>swapoff -a &amp;&amp; sysctl -w vm.swappiness=0<br></code></pre></td></tr></table></figure><p>查看效果，Swap 这栏的 total 为 0，表示关闭成功。上面的命令会永久禁用 Swap，即使重启后也会生效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">free -h</span><br>               total        used        free      shared  buff/cache   available<br>Mem:           7.7Gi       415Mi       6.5Gi       1.0Mi       851Mi       7.1Gi<br>Swap:             0B          0B          0B<br></code></pre></td></tr></table></figure><blockquote><p>🤔️ 为什么安装 k8s 要需要关闭 Swap？</p><p>在安装 Kubernetes 集群时，需要关闭 swap。原因是 Kubernetes 通过 cgroup 来对容器进行资源限制，而 cgroup 只能控制实际内存，无法控制 swap，因此开启 swap 后可能会导致资源不受限制，进而导致容器运行不稳定或者宕机。因此关闭 swap 可以提高 Kubernetes 集群的稳定性和安全性。</p></blockquote><h2 id="设置时间同步"><a href="#设置时间同步" class="headerlink" title="设置时间同步"></a>设置时间同步</h2><p>在所有主机上执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打开终端输入以下命令安装ntpdate工具。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">apt install ntpdate</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再输入命令设置系统时间与网络时间同步。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ntpdate cn.pool.ntp.org</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后输入命令将时间更新到硬件上即可。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hwclock --systohc</span><br></code></pre></td></tr></table></figure><blockquote><p>🤔️ 安装 k8s 为什么需要设置时间同步？</p><p>在 Kubernetes 集群中，各个节点之间需要进行协调和通信，如果各个节点的时间不同步，将会导致一些问题，例如：</p><ol><li>证书问题：Kubernetes 使用 TLS 证书进行节点间的认证和通信，如果各个节点的时间不同步，可能导致证书过期或者无法验证等问题。</li><li>日志问题：各个节点的日志需要进行时间戳的记录，如果各个节点的时间不同步，可能导致日志顺序错乱或者无法定位问题。</li></ol><p>因此，在安装 Kubernetes 时需要设置时间同步，保证各个节点之间的时间是一致的，从而避免出现以上问题。</p></blockquote><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a><del>安装 Docker</del></h2><p><del>因为我在安装 Ubuntu 时勾选了 Docker，所以系统已经默认安装好了 Docker。</del></p><h2 id="所有节点安装-Containerd"><a href="#所有节点安装-Containerd" class="headerlink" title="所有节点安装 Containerd"></a>所有节点安装 Containerd</h2><p>在所有节点执行，master 节点和 worker 节点都需要</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://github.com/containernetworking/plugins/releases/download/v1.1.1/cni-plugins-linux-amd64-v1.1.1.tgz</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 cni 插件所需目录</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> -p /etc/cni/net.d /opt/cni/bin</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压 cni 二进制包</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar xf cni-plugins-linux-amd64-v1.1.1.tgz -C /opt/cni/bin/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://github.com/containerd/containerd/releases/download/v1.6.4/cri-containerd-cni-1.6.4-linux-amd64.tar.gz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar -C / -xzf cri-containerd-cni-1.6.4-linux-amd64.tar.gz</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建服务启动文件</span><br>cat &gt; /etc/systemd/system/containerd.service &lt;&lt;EOF<br>[Unit]<br>Description=containerd container runtime<br>Documentation=https://containerd.io<br>After=network.target local-fs.target<br>[Service]<br>ExecStartPre=-/sbin/modprobe overlay<br>ExecStart=/usr/local/bin/containerd<br>Type=notify<br>Delegate=yes<br>KillMode=process<br>Restart=always<br>RestartSec=5<br>LimitNPROC=infinity<br>LimitCORE=infinity<br>LimitNOFILE=infinity<br>TasksMax=infinity<br>OOMScoreAdjust=-999<br>[Install]<br>WantedBy=multi-user.target<br>EOF<br></code></pre></td></tr></table></figure><p>配置 Containerd 所需的模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/containerd.conf<br>overlay<br>br_netfilter<br>EOF<br></code></pre></td></tr></table></figure><p>加载模块，设置开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl restart systemd-modules-load.service</span><br></code></pre></td></tr></table></figure><p>配置Containerd所需的内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf<br>net.bridge.bridge-nf-call-iptables  = 1<br>net.ipv4.ip_forward                 = 1<br>net.bridge.bridge-nf-call-ip6tables = 1<br>EOF<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">加载内核</span> <br>sysctl --system<br></code></pre></td></tr></table></figure><p>创建 Containerd 的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建配置文件</span><br>mkdir -p /etc/containerd<br>containerd config default | tee /etc/containerd/config.toml<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改 Containerd 的配置文件</span><br>sed -i &quot;s#SystemdCgroup\ \=\ false#SystemdCgroup\ \=\ true#g&quot; /etc/containerd/config.toml<br><br>cat /etc/containerd/config.toml | grep SystemdCgroup<br><br>sed -i &quot;s#k8s.gcr.io#registry.cn-hangzhou.aliyuncs.com/abcdocker#g&quot; /etc/containerd/config.toml<br><br>cat /etc/containerd/config.toml | grep sandbox_image<br></code></pre></td></tr></table></figure><p>手动删除 <code>/etc/containerd/config.toml</code> 中的 <code>systemd_cgroup = false</code> 这一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/containerd/config.toml<br></code></pre></td></tr></table></figure><p>设置开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl daemon-reload<br>systemctl enable --now containerd<br></code></pre></td></tr></table></figure><p>验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ctr version</span><br>Client:<br>  Version:  v1.6.4<br>  Revision: 212e8b6fa2f44b9c21b2798135fc6fb7c53efc16<br>  Go version: go1.17.9<br>Server:<br>  Version:  v1.6.4<br>  Revision: 212e8b6fa2f44b9c21b2798135fc6fb7c53efc16<br>  UUID: f3171aee-67b0-4e01-871b-2e93674af2ad<br></code></pre></td></tr></table></figure><h1 id="k8s-环境部署"><a href="#k8s-环境部署" class="headerlink" title="k8s 环境部署"></a>k8s 环境部署</h1><h2 id="下载相关二进制文件"><a href="#下载相关二进制文件" class="headerlink" title="下载相关二进制文件"></a>下载相关二进制文件</h2><p>在 master 节点执行下面的命令，下载 k8s 相关的可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://dl.k8s.io/v1.24.3/kubernetes-server-linux-amd64.tar.gz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://github.com/etcd-io/etcd/releases/download/v3.5.4/etcd-v3.5.4-linux-amd64.tar.gz</span><br></code></pre></td></tr></table></figure><p>解压获得可执行文件，将解压到 <code>/usr/local/bin</code> 目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar -xf kubernetes-server-linux-amd64.tar.gz  --strip-components=3 -C /usr/local/bin kubernetes/server/bin/kube&#123;<span class="hljs-built_in">let</span>,ctl,-apiserver,-controller-manager,-scheduler,-proxy&#125;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar -xf etcd-v3.5.4-linux-amd64.tar.gz --strip-components=1 -C /usr/local/bin etcd-v3.5.4-linux-amd64/etcd&#123;,ctl&#125;</span><br></code></pre></td></tr></table></figure><p>检查<code>/usr/local/bin</code>下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /usr/local/bin/</span><br>cfssl      etcd     kube-apiserver           kubectl  kube-proxy<br>cfssljson  etcdctl  kube-controller-manager  kubelet  kube-scheduler<br></code></pre></td></tr></table></figure><p>验证二进制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubelet --version</span><br>Kubernetes v1.24.3<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcdctl version</span><br>etcdctl version: 3.5.4<br>API version: 3.5<br></code></pre></td></tr></table></figure><p>将刚刚解压的二进制文件拷贝到其它节点上（另外两个节点都是计算节点，所以其实不用拷贝 etcd 相关的可执行文件，但是 kubectl 什么的还是需要的，所以影响不大）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for i in k8s-worker1 k8s-worker2;do   <br>scp /usr/local/bin/kube* root@$i:/usr/local/bin/    <br>scp /usr/local/bin/&#123;etcd,etcdctl&#125;   root@$i:/usr/local/bin/<br>done<br></code></pre></td></tr></table></figure><h2 id="准备一个目录用来存放证书配置文件"><a href="#准备一个目录用来存放证书配置文件" class="headerlink" title="准备一个目录用来存放证书配置文件"></a>准备一个目录用来存放证书配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> pki</span><br></code></pre></td></tr></table></figure><h2 id="下载配置-cfssl-证书"><a href="#下载配置-cfssl-证书" class="headerlink" title="下载配置 cfssl 证书"></a>下载配置 cfssl 证书</h2><blockquote><p>⚠️ 只需在控制节点 k8s-master 上执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget <span class="hljs-string">&quot;https://github.com/cloudflare/cfssl/releases/download/v1.6.1/cfssl_1.6.1_linux_amd64&quot;</span> -O /usr/local/bin/cfssl</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget <span class="hljs-string">&quot;https://github.com/cloudflare/cfssl/releases/download/v1.6.1/cfssljson_1.6.1_linux_amd64&quot;</span> -O /usr/local/bin/cfssljson</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> +x /usr/local/bin/cfssl /usr/local/bin/cfssljson</span><br></code></pre></td></tr></table></figure><h2 id="创建证书配置文件"><a href="#创建证书配置文件" class="headerlink" title="创建证书配置文件"></a>创建证书配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> pki</span><br></code></pre></td></tr></table></figure><p>下面这段 shell 是用来创建一个 admin 用户的证书签发请求文件 <code>admin-csr.json</code>，其中包含了以下信息：</p><ul><li><code>CN</code>：Common Name，即证书的名称，这里是 <code>admin</code>。</li><li><code>key</code>：用于指定生成密钥的算法及长度，这里是 <code>rsa</code> 算法，长度是 <code>2048</code> 位。</li><li><code>names</code>：用于指定证书中的主题（Subject）信息，包括国家（C）、省（ST）、城市（L）、组织（O）和组织单位（OU），这里主要指定了组织为 <code>system:masters</code>，也就是 Kubernetes 的管理员。</li></ul><p>该证书用于验证用户 <code>admin</code> 对 Kubernetes API Server 的访问权限，由 Kubernetes 的证书管理工具 <code>cfssl</code> 根据此文件生成证书。</p><p>（以上内容来自 ChatGPT。。。）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> &gt; admin-csr.json &lt;&lt; <span class="hljs-string">EOF</span></span> <br>&#123;<br>  &quot;CN&quot;: &quot;admin&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;system:masters&quot;,<br>      &quot;OU&quot;: &quot;Kubernetes-manual&quot;<br>    &#125;<br>  ]<br>&#125;<br>EOF<br></code></pre></td></tr></table></figure><p>下面这段 shell 是定义 CA 的配置文件，主要包含两个部分，”signing” 和 “profiles”。</p><p>其中，”signing” 部分定义了默认的证书过期时间，这里设置为 876000 小时，也就是 100 年。这个时间可以根据实际情况进行调整。</p><p>“profiles” 部分定义了不同 profile 的配置信息。这里只定义了一个叫做 “kubernetes” 的 profile，该 profile 的用途包括 “signing”、”key encipherment”、”server auth” 和 “client auth”，也就是该 profile 适用于用于签发和验证服务器和客户端证书，同时也能用于加密传输数据。该 profile 的证书过期时间也设置为 876000 小时，与默认的证书过期时间相同。</p><blockquote><p>CA，即证书授权中心（Certificate Authority），是指负责签发、管理和吊销数字证书的可信机构。在网络通信中，数字证书起到验证通信双方身份的作用，CA 则是负责颁发数字证书，以及验证证书的真实性和有效性。</p><p>CA 通常由政府、军队、金融机构等具有一定信誉和安全保障能力的机构所担任，以确保数字证书的安全性和可靠性。通过使用CA，数字证书的颁发和验证得以形成一个闭环，使得网络通信过程更加安全和可靠。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> &gt; ca-config.json &lt;&lt; <span class="hljs-string">EOF</span></span> <br>&#123;<br>  &quot;signing&quot;: &#123;<br>    &quot;default&quot;: &#123;<br>      &quot;expiry&quot;: &quot;876000h&quot;<br>    &#125;,<br>    &quot;profiles&quot;: &#123;<br>      &quot;kubernetes&quot;: &#123;<br>        &quot;usages&quot;: [<br>            &quot;signing&quot;,<br>            &quot;key encipherment&quot;,<br>            &quot;server auth&quot;,<br>            &quot;client auth&quot;<br>        ],<br>        &quot;expiry&quot;: &quot;876000h&quot;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>EOF<br></code></pre></td></tr></table></figure><p>下面这段 shell 是用于创建 etcd CA 证书签名请求文件的 JSON 配置文件。其中，”CN” 是证书的通用名称，”key” 定义了加密算法和密钥长度，”names” 列出了证书的主题，”ca” 定义了证书颁发机构的过期时间。该文件会被用于生成 etcd CA 证书，用于签发和管理 etcd 集群中的其他证书，保证集群通信的安全性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> &gt; etcd-ca-csr.json  &lt;&lt; <span class="hljs-string">EOF</span></span> <br>&#123;<br>  &quot;CN&quot;: &quot;etcd&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;etcd&quot;,<br>      &quot;OU&quot;: &quot;Etcd Security&quot;<br>    &#125;<br>  ],<br>  &quot;ca&quot;: &#123;<br>    &quot;expiry&quot;: &quot;876000h&quot;<br>  &#125;<br>&#125;<br>EOF<br></code></pre></td></tr></table></figure><h3 id="这部分直接看这里"><a href="#这部分直接看这里" class="headerlink" title="这部分直接看这里"></a>这部分直接看这里</h3><blockquote><p>发现这部分 shell 有点多，懒得一个一个问 ChatGPT 什么意思了，暂时也不关注这些证书相关的东西了。。。</p></blockquote><p>直接将下面这些命令复制到 terminal 回车即可，会一并创建这些文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; admin-csr.json &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;admin&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;system:masters&quot;,<br>      &quot;OU&quot;: &quot;Kubernetes-manual&quot;<br>    &#125;<br>  ]<br>&#125;<br>EOF<br>cat &gt; ca-config.json &lt;&lt; EOF <br>&#123;<br>  &quot;signing&quot;: &#123;<br>    &quot;default&quot;: &#123;<br>      &quot;expiry&quot;: &quot;876000h&quot;<br>    &#125;,<br>    &quot;profiles&quot;: &#123;<br>      &quot;kubernetes&quot;: &#123;<br>        &quot;usages&quot;: [<br>            &quot;signing&quot;,<br>            &quot;key encipherment&quot;,<br>            &quot;server auth&quot;,<br>            &quot;client auth&quot;<br>        ],<br>        &quot;expiry&quot;: &quot;876000h&quot;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>EOF<br>cat &gt; etcd-ca-csr.json  &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;etcd&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;etcd&quot;,<br>      &quot;OU&quot;: &quot;Etcd Security&quot;<br>    &#125;<br>  ],<br>  &quot;ca&quot;: &#123;<br>    &quot;expiry&quot;: &quot;876000h&quot;<br>  &#125;<br>&#125;<br>EOF<br>cat &gt; front-proxy-ca-csr.json  &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;kubernetes&quot;,<br>  &quot;key&quot;: &#123;<br>     &quot;algo&quot;: &quot;rsa&quot;,<br>     &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;ca&quot;: &#123;<br>    &quot;expiry&quot;: &quot;876000h&quot;<br>  &#125;<br>&#125;<br>EOF<br>cat &gt; kubelet-csr.json  &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;system:node:\$NODE&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;system:nodes&quot;,<br>      &quot;OU&quot;: &quot;Kubernetes-manual&quot;<br>    &#125;<br>  ]<br>&#125;<br>EOF<br>cat &gt; manager-csr.json &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;system:kube-controller-manager&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;system:kube-controller-manager&quot;,<br>      &quot;OU&quot;: &quot;Kubernetes-manual&quot;<br>    &#125;<br>  ]<br>&#125;<br>EOF<br>cat &gt; apiserver-csr.json &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;kube-apiserver&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;Kubernetes&quot;,<br>      &quot;OU&quot;: &quot;Kubernetes-manual&quot;<br>    &#125;<br>  ]<br>&#125;<br>EOF<br>cat &gt; ca-csr.json   &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;kubernetes&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;Kubernetes&quot;,<br>      &quot;OU&quot;: &quot;Kubernetes-manual&quot;<br>    &#125;<br>  ],<br>  &quot;ca&quot;: &#123;<br>    &quot;expiry&quot;: &quot;876000h&quot;<br>  &#125;<br>&#125;<br>EOF<br>cat &gt; etcd-csr.json &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;etcd&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;etcd&quot;,<br>      &quot;OU&quot;: &quot;Etcd Security&quot;<br>    &#125;<br>  ]<br>&#125;<br>EOF<br>cat &gt; front-proxy-client-csr.json  &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;front-proxy-client&quot;,<br>  &quot;key&quot;: &#123;<br>     &quot;algo&quot;: &quot;rsa&quot;,<br>     &quot;size&quot;: 2048<br>  &#125;<br>&#125;<br>EOF<br>cat &gt; kube-proxy-csr.json  &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;system:kube-proxy&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;system:kube-proxy&quot;,<br>      &quot;OU&quot;: &quot;Kubernetes-manual&quot;<br>    &#125;<br>  ]<br>&#125;<br>EOF<br>cat &gt; scheduler-csr.json &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;system:kube-scheduler&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;system:kube-scheduler&quot;,<br>      &quot;OU&quot;: &quot;Kubernetes-manual&quot;<br>    &#125;<br>  ]<br>&#125;<br>EOF<br></code></pre></td></tr></table></figure><p>继续复制执行下面的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ..<br>mkdir bootstrap<br>cd bootstrap<br>cat &gt; bootstrap.secret.yaml &lt;&lt; EOF <br>apiVersion: v1<br>kind: Secret<br>metadata:<br>  name: bootstrap-token-c8ad9c<br>  namespace: kube-system<br>type: bootstrap.kubernetes.io/token<br>stringData:<br>  description: &quot;The default bootstrap token generated by &#x27;kubelet &#x27;.&quot;<br>  token-id: c8ad9c<br>  token-secret: 2e4d610cf3e7426e<br>  usage-bootstrap-authentication: &quot;true&quot;<br>  usage-bootstrap-signing: &quot;true&quot;<br>  auth-extra-groups:  system:bootstrappers:default-node-token,system:bootstrappers:worker,system:bootstrappers:ingress<br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRoleBinding<br>metadata:<br>  name: kubelet-bootstrap<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: ClusterRole<br>  name: system:node-bootstrapper<br>subjects:<br>- apiGroup: rbac.authorization.k8s.io<br>  kind: Group<br>  name: system:bootstrappers:default-node-token<br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRoleBinding<br>metadata:<br>  name: node-autoapprove-bootstrap<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: ClusterRole<br>  name: system:certificates.k8s.io:certificatesigningrequests:nodeclient<br>subjects:<br>- apiGroup: rbac.authorization.k8s.io<br>  kind: Group<br>  name: system:bootstrappers:default-node-token<br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRoleBinding<br>metadata:<br>  name: node-autoapprove-certificate-rotation<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: ClusterRole<br>  name: system:certificates.k8s.io:certificatesigningrequests:selfnodeclient<br>subjects:<br>- apiGroup: rbac.authorization.k8s.io<br>  kind: Group<br>  name: system:nodes<br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRole<br>metadata:<br>  annotations:<br>    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;<br>  labels:<br>    kubernetes.io/bootstrapping: rbac-defaults<br>  name: system:kube-apiserver-to-kubelet<br>rules:<br>  - apiGroups:<br>      - &quot;&quot;<br>    resources:<br>      - nodes/proxy<br>      - nodes/stats<br>      - nodes/log<br>      - nodes/spec<br>      - nodes/metrics<br>    verbs:<br>      - &quot;*&quot;<br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRoleBinding<br>metadata:<br>  name: system:kube-apiserver<br>  namespace: &quot;&quot;<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: ClusterRole<br>  name: system:kube-apiserver-to-kubelet<br>subjects:<br>  - apiGroup: rbac.authorization.k8s.io<br>    kind: User<br>    name: kube-apiserver<br>EOF<br></code></pre></td></tr></table></figure><p>这些 Kubernetes 配置包含以下内容：</p><ol><li><code>bootstrap-token-c8ad9c</code>: 用于启动 Kubernetes 集群的默认引导令牌及其相关权限信息，包括描述信息、令牌 ID、令牌密钥以及用于启动认证和签名等权限的标志。</li><li><code>kubelet-bootstrap</code> ClusterRoleBinding：将 <code>system:node-bootstrapper</code> ClusterRole 分配给 <code>system:bootstrappers:default-node-token</code> 组，以便允许节点使用引导令牌进行身份验证和授权。</li><li><code>node-autoapprove-bootstrap</code> ClusterRoleBinding：自动批准使用引导令牌发出的节点客户端证书签名请求。</li><li><code>node-autoapprove-certificate-rotation</code> ClusterRoleBinding：自动批准用于自签名节点证书轮换的签名请求。</li><li><code>system:kube-apiserver-to-kubelet</code> ClusterRole：定义了一个角色，该角色允许 kube-apiserver 访问 kubelet API，以便可以从 kube-apiserver 发送请求到节点的 kubelet API，以获取节点信息和执行操作。</li><li><code>system:kube-apiserver</code> ClusterRoleBinding：将 <code>system:kube-apiserver-to-kubelet</code> ClusterRole 分配给 kube-apiserver 用户，以便在整个 Kubernetes 集群范围内允许 kube-apiserver 访问 kubelet API。</li></ol><h2 id="ETCD-证书"><a href="#ETCD-证书" class="headerlink" title="ETCD 证书"></a>ETCD 证书</h2><blockquote><p>本节操作只需要 master 节点执行即可。</p></blockquote><h3 id="创建证书文件"><a href="#创建证书文件" class="headerlink" title="创建证书文件"></a>创建证书文件</h3><p>创建用于存放证书的文件夹</p><p>PS：因为我只有一个控制面节点 k8s-master，而 etcd 只需要部署在控制面即可，所以不需要在其他节点执行同样的操作，直接在本节点创建</p><p><del>for i in k8s-master k8s-worker1 k8s-worker2;do</del><br>   <del>ssh root@$i mkdir &#x2F;etc&#x2F;etcd&#x2F;ssl -p</del><br>   <del>echo $i create done</del><br><del>done</del></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /etc/etcd/ssl -p<br></code></pre></td></tr></table></figure><h3 id="生成-etcd-证书和-etcd-证书的-key"><a href="#生成-etcd-证书和-etcd-证书的-key" class="headerlink" title="生成 etcd 证书和 etcd 证书的 key"></a>生成 etcd 证书和 etcd 证书的 key</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> pki</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cfssl gencert -initca etcd-ca-csr.json | cfssljson -bare /etc/etcd/ssl/etcd-ca</span><br></code></pre></td></tr></table></figure><p>注意 <code>-hostname</code> 这里的参数，改成你对应 master 节点的 hostname 和 IP，别直接 cv 过来就执行，如果你不小心执行错了（和我一样没注意，直接 cv 过来就执行，导致后续 etcd 不认这个节点），直接修改下面的 shell 后再重新执行一遍即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cfssl gencert \</span><br><span class="language-bash">   -ca=/etc/etcd/ssl/etcd-ca.pem \</span><br><span class="language-bash">   -ca-key=/etc/etcd/ssl/etcd-ca-key.pem \</span><br><span class="language-bash">   -config=ca-config.json \</span><br><span class="language-bash">   -hostname=k8s-master,192.168.223.128 \</span><br><span class="language-bash">   -profile=kubernetes \</span><br><span class="language-bash">   etcd-csr.json | cfssljson -bare /etc/etcd/ssl/etcd</span><br></code></pre></td></tr></table></figure><p>执行完成后，将会在 <code>/etc/etcd/ssl</code> 目录下生成这些证书文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /etc/etcd/ssl</span><br>etcd-ca.csr  etcd-ca-key.pem  etcd-ca.pem  etcd.csr  etcd-key.pem  etcd.pem<br></code></pre></td></tr></table></figure><h3 id="将证书复制到其他节点"><a href="#将证书复制到其他节点" class="headerlink" title="将证书复制到其他节点"></a>将证书复制到其他节点</h3><p>我的单节点控制面用不上了</p><p><del>for i in k8s-worker1 k8s-worker2;do</del><br>    <del>ssh $i “mkdir -p &#x2F;etc&#x2F;etcd&#x2F;ssl”</del><br>    <del>scp &#x2F;etc&#x2F;etcd&#x2F;ssl&#x2F;* $i:&#x2F;etc&#x2F;etcd&#x2F;ssl&#x2F;</del><br><del>done</del></p><h2 id="k8s-集群证书"><a href="#k8s-集群证书" class="headerlink" title="k8s 集群证书"></a>k8s 集群证书</h2><blockquote><p>本节操作只需要 master 节点执行即可。</p></blockquote><h3 id="创建所有证书的存放目录"><a href="#创建所有证书的存放目录" class="headerlink" title="创建所有证书的存放目录"></a>创建所有证书的存放目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> -p /etc/kubernetes/pki</span><br></code></pre></td></tr></table></figure><h3 id="生成一个根证书"><a href="#生成一个根证书" class="headerlink" title="生成一个根证书"></a>生成一个根证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cfssl gencert -initca ca-csr.json | cfssljson -bare /etc/kubernetes/pki/ca</span><br></code></pre></td></tr></table></figure><h3 id="创建-API-Server-凭证与私钥"><a href="#创建-API-Server-凭证与私钥" class="headerlink" title="创建 API Server 凭证与私钥"></a>创建 API Server 凭证与私钥</h3><p>10.96.0.1 是 service 网段的第一个地址，hostname 中指定了生成的证书的 Subject Alternative Names (SANs)，即证书允许被使用的主机名或 IP 地址，这里我填写了 3 台虚拟机的 hostname 和 IP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cfssl gencert   \</span><br><span class="language-bash">-ca=/etc/kubernetes/pki/ca.pem   \</span><br><span class="language-bash">-ca-key=/etc/kubernetes/pki/ca-key.pem   \</span><br><span class="language-bash">-config=ca-config.json   \</span><br><span class="language-bash">-hostname=10.96.0.1,127.0.0.1,kubernetes,kubernetes.default,kubernetes.default.svc,kubernetes.default.svc.cluster,kubernetes.default.svc.cluster.local,k8s-master,k8s-worker1,k8s-worker2,192.168.223.128,192.168.223.129,192.168.223.130   \</span><br><span class="language-bash">-profile=kubernetes   apiserver-csr.json | cfssljson -bare /etc/kubernetes/pki/apiserver</span><br></code></pre></td></tr></table></figure><h3 id="生成-apiserver"><a href="#生成-apiserver" class="headerlink" title="生成 apiserver"></a>生成 apiserver</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cfssl gencert   -initca front-proxy-ca-csr.json | cfssljson -bare /etc/kubernetes/pki/front-proxy-ca</span> <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cfssl gencert  \</span><br><span class="language-bash">-ca=/etc/kubernetes/pki/front-proxy-ca.pem   \</span><br><span class="language-bash">-ca-key=/etc/kubernetes/pki/front-proxy-ca-key.pem   \</span><br><span class="language-bash">-config=ca-config.json   \</span><br><span class="language-bash">-profile=kubernetes   front-proxy-client-csr.json | cfssljson -bare /etc/kubernetes/pki/front-proxy-client</span><br></code></pre></td></tr></table></figure><h3 id="生成-controller-manage-证书"><a href="#生成-controller-manage-证书" class="headerlink" title="生成 controller-manage 证书"></a>生成 controller-manage 证书</h3><p>注意替换下面命令中的 –server，IP 填写 api-server 的 IP，在我这里是 master 节点的 IP，端口填写 api-server 的 port，这个值在 api server 配置中的 –secure-port&#x3D;6443 指定</p><blockquote><p>疑问：</p><p>我这里只有一个 master 节点，所以 api-server 的 IP 就是该 master 节点的 IP，那如果部署方式是多个 master 节点，此时 api-server 的 IP 又该如何填写呢？</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cfssl gencert \</span><br><span class="language-bash">   -ca=/etc/kubernetes/pki/ca.pem \</span><br><span class="language-bash">   -ca-key=/etc/kubernetes/pki/ca-key.pem \</span><br><span class="language-bash">   -config=ca-config.json \</span><br><span class="language-bash">   -profile=kubernetes \</span><br><span class="language-bash">   manager-csr.json | cfssljson -bare /etc/kubernetes/pki/controller-manager</span><br>   <br>   <br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置一个集群项</span><br>kubectl config set-cluster kubernetes \<br>     --certificate-authority=/etc/kubernetes/pki/ca.pem \<br>     --embed-certs=true \<br>     --server=https://192.168.223.128:6443 \<br>     --kubeconfig=/etc/kubernetes/controller-manager.kubeconfig<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置一个环境项，一个上下文</span><br>kubectl config set-context system:kube-controller-manager@kubernetes \<br>    --cluster=kubernetes \<br>    --user=system:kube-controller-manager \<br>    --kubeconfig=/etc/kubernetes/controller-manager.kubeconfig<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置一个用户项</span><br>kubectl config set-credentials system:kube-controller-manager \<br>     --client-certificate=/etc/kubernetes/pki/controller-manager.pem \<br>     --client-key=/etc/kubernetes/pki/controller-manager-key.pem \<br>     --embed-certs=true \<br>     --kubeconfig=/etc/kubernetes/controller-manager.kubeconfig<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置默认环境</span><br>kubectl config use-context system:kube-controller-manager@kubernetes \<br>     --kubeconfig=/etc/kubernetes/controller-manager.kubeconfig<br>cfssl gencert \<br>   -ca=/etc/kubernetes/pki/ca.pem \<br>   -ca-key=/etc/kubernetes/pki/ca-key.pem \<br>   -config=ca-config.json \<br>   -profile=kubernetes \<br>   scheduler-csr.json | cfssljson -bare /etc/kubernetes/pki/scheduler<br>kubectl config set-cluster kubernetes \<br>     --certificate-authority=/etc/kubernetes/pki/ca.pem \<br>     --embed-certs=true \<br>     --server=https://192.168.223.128:6443 \<br>     --kubeconfig=/etc/kubernetes/scheduler.kubeconfig<br>kubectl config set-credentials system:kube-scheduler \<br>     --client-certificate=/etc/kubernetes/pki/scheduler.pem \<br>     --client-key=/etc/kubernetes/pki/scheduler-key.pem \<br>     --embed-certs=true \<br>     --kubeconfig=/etc/kubernetes/scheduler.kubeconfig<br>kubectl config set-context system:kube-scheduler@kubernetes \<br>     --cluster=kubernetes \<br>     --user=system:kube-scheduler \<br>     --kubeconfig=/etc/kubernetes/scheduler.kubeconfig<br>kubectl config use-context system:kube-scheduler@kubernetes \<br>     --kubeconfig=/etc/kubernetes/scheduler.kubeconfig<br>cfssl gencert \<br>   -ca=/etc/kubernetes/pki/ca.pem \<br>   -ca-key=/etc/kubernetes/pki/ca-key.pem \<br>   -config=ca-config.json \<br>   -profile=kubernetes \<br>   admin-csr.json | cfssljson -bare /etc/kubernetes/pki/admin<br>kubectl config set-cluster kubernetes     \<br>  --certificate-authority=/etc/kubernetes/pki/ca.pem     \<br>  --embed-certs=true     \<br>  --server=https://192.168.223.128:6443     \<br>  --kubeconfig=/etc/kubernetes/admin.kubeconfig<br>kubectl config set-credentials kubernetes-admin  \<br>  --client-certificate=/etc/kubernetes/pki/admin.pem     \<br>  --client-key=/etc/kubernetes/pki/admin-key.pem     \<br>  --embed-certs=true     \<br>  --kubeconfig=/etc/kubernetes/admin.kubeconfig<br>kubectl config set-context kubernetes-admin@kubernetes    \<br>  --cluster=kubernetes     \<br>  --user=kubernetes-admin     \<br>  --kubeconfig=/etc/kubernetes/admin.kubeconfig<br>kubectl config use-context kubernetes-admin@kubernetes  --kubeconfig=/etc/kubernetes/admin.kubeconfig<br></code></pre></td></tr></table></figure><h3 id="生成-kube-proxy-证书"><a href="#生成-kube-proxy-证书" class="headerlink" title="生成 kube-proxy 证书"></a>生成 kube-proxy 证书</h3><p>注意替换下面命令中的 –server</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">cfssl gencert \<br>   -ca=/etc/kubernetes/pki/ca.pem \<br>   -ca-key=/etc/kubernetes/pki/ca-key.pem \<br>   -config=ca-config.json \<br>   -profile=kubernetes \<br>   kube-proxy-csr.json | cfssljson -bare /etc/kubernetes/pki/kube-proxy<br>kubectl config set-cluster kubernetes     \<br>  --certificate-authority=/etc/kubernetes/pki/ca.pem     \<br>  --embed-certs=true     \<br>  --server=https://192.168.223.128:6443     \<br>  --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig<br>kubectl config set-credentials kube-proxy  \<br>  --client-certificate=/etc/kubernetes/pki/kube-proxy.pem     \<br>  --client-key=/etc/kubernetes/pki/kube-proxy-key.pem     \<br>  --embed-certs=true     \<br>  --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig<br>kubectl config set-context kube-proxy@kubernetes    \<br>  --cluster=kubernetes     \<br>  --user=kube-proxy     \<br>  --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig<br>kubectl config use-context kube-proxy@kubernetes  --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig<br></code></pre></td></tr></table></figure><h3 id="创建-ServiceAccount-Key"><a href="#创建-ServiceAccount-Key" class="headerlink" title="创建 ServiceAccount Key"></a>创建 ServiceAccount Key</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">openssl genrsa -out /etc/kubernetes/pki/sa.key 2048</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">openssl rsa -<span class="hljs-keyword">in</span> /etc/kubernetes/pki/sa.key -pubout -out /etc/kubernetes/pki/sa.pub</span><br></code></pre></td></tr></table></figure><p>其他节点创建目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for i in k8s-worker1 k8s-worker2;do    <br>ssh $i &quot;mkdir  /etc/kubernetes/pki/ -p&quot;    <br>scp -r /etc/kubernetes/pki $i:/etc/kubernetes/<br>done<br></code></pre></td></tr></table></figure><h3 id="查看各个节点的证书"><a href="#查看各个节点的证书" class="headerlink" title="查看各个节点的证书"></a>查看各个节点的证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /etc/kubernetes/pki/</span><br>admin.csr          ca.csr                      front-proxy-ca.csr          kube-proxy.csr      scheduler-key.pem<br>admin-key.pem      ca-key.pem                  front-proxy-ca-key.pem      kube-proxy-key.pem  scheduler.pem<br>admin.pem          ca.pem                      front-proxy-ca.pem          kube-proxy.pem<br>apiserver.csr      controller-manager.csr      front-proxy-client.csr      sa.key<br>apiserver-key.pem  controller-manager-key.pem  front-proxy-client-key.pem  sa.pub<br>apiserver.pem      controller-manager.pem      front-proxy-client.pem      scheduler.csr<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">一共 26 个就对了</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /etc/kubernetes/pki/ |<span class="hljs-built_in">wc</span> -l</span><br>26<br></code></pre></td></tr></table></figure><h2 id="配置-ETCD"><a href="#配置-ETCD" class="headerlink" title="配置 ETCD"></a>配置 ETCD</h2><h3 id="master-节点"><a href="#master-节点" class="headerlink" title="master 节点"></a>master 节点</h3><p>在 master 节点执行下面的 shell，注意将配置里的 IP 改为 master 节点的 IP，hostname 也要修改成对应的，initial-cluster 修改成对应的几个节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">如果要用 IPv6 那么把 IPv4 地址修改为 IPv6 即可</span><br>cat &gt; /etc/etcd/etcd.config.yml &lt;&lt; EOF <br>name: &#x27;k8s-master&#x27;<br>data-dir: /var/lib/etcd<br>wal-dir: /var/lib/etcd/wal<br>snapshot-count: 5000<br>heartbeat-interval: 100<br>election-timeout: 1000<br>quota-backend-bytes: 0<br>listen-peer-urls: &#x27;https://192.168.223.128:2380&#x27;<br>listen-client-urls: &#x27;https://192.168.223.128:2379,http://127.0.0.1:2379&#x27;<br>max-snapshots: 3<br>max-wals: 5<br>cors:<br>initial-advertise-peer-urls: &#x27;https://192.168.223.128:2380&#x27;<br>advertise-client-urls: &#x27;https://192.168.223.128:2379&#x27;<br>discovery:<br>discovery-fallback: &#x27;proxy&#x27;<br>discovery-proxy:<br>discovery-srv:<br>initial-cluster: &#x27;k8s-master=https://192.168.223.128:2380&#x27;<br>initial-cluster-token: &#x27;etcd-k8s-cluster&#x27;<br>initial-cluster-state: &#x27;new&#x27;<br>strict-reconfig-check: false<br>enable-v2: true<br>enable-pprof: true<br>proxy: &#x27;off&#x27;<br>proxy-failure-wait: 5000<br>proxy-refresh-interval: 30000<br>proxy-dial-timeout: 1000<br>proxy-write-timeout: 5000<br>proxy-read-timeout: 0<br>client-transport-security:<br>  cert-file: &#x27;/etc/kubernetes/pki/etcd/etcd.pem&#x27;<br>  key-file: &#x27;/etc/kubernetes/pki/etcd/etcd-key.pem&#x27;<br>  client-cert-auth: true<br>  trusted-ca-file: &#x27;/etc/kubernetes/pki/etcd/etcd-ca.pem&#x27;<br>  auto-tls: true<br>peer-transport-security:<br>  cert-file: &#x27;/etc/kubernetes/pki/etcd/etcd.pem&#x27;<br>  key-file: &#x27;/etc/kubernetes/pki/etcd/etcd-key.pem&#x27;<br>  peer-client-cert-auth: true<br>  trusted-ca-file: &#x27;/etc/kubernetes/pki/etcd/etcd-ca.pem&#x27;<br>  auto-tls: true<br>debug: false<br>log-package-levels:<br>log-outputs: [default]<br>force-new-cluster: false<br>EOF<br></code></pre></td></tr></table></figure><h3 id="k8s-worker1-节点"><a href="#k8s-worker1-节点" class="headerlink" title="k8s-worker1 节点"></a><del>k8s-worker1 节点</del></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">如果要用 IPv6 那么把 IPv4 地址修改为 IPv6 即可</span><br>cat &gt; /etc/etcd/etcd.config.yml &lt;&lt; EOF <br>name: &#x27;k8s-worker1&#x27;<br>data-dir: /var/lib/etcd<br>wal-dir: /var/lib/etcd/wal<br>snapshot-count: 5000<br>heartbeat-interval: 100<br>election-timeout: 1000<br>quota-backend-bytes: 0<br>listen-peer-urls: &#x27;https://192.168.223.129:2380&#x27;<br>listen-client-urls: &#x27;https://192.168.223.129:2379,http://127.0.0.1:2379&#x27;<br>max-snapshots: 3<br>max-wals: 5<br>cors:<br>initial-advertise-peer-urls: &#x27;https://192.168.223.129:2380&#x27;<br>advertise-client-urls: &#x27;https://192.168.223.129:2379&#x27;<br>discovery:<br>discovery-fallback: &#x27;proxy&#x27;<br>discovery-proxy:<br>discovery-srv:<br>initial-cluster: &#x27;k8s-master=https://192.168.223.128:2380,k8s-worker1=https://192.168.223.129:2380,k8s-worker2=https://192.168.223.130:2380&#x27;<br>initial-cluster-token: &#x27;etcd-k8s-cluster&#x27;<br>initial-cluster-state: &#x27;new&#x27;<br>strict-reconfig-check: false<br>enable-v2: true<br>enable-pprof: true<br>proxy: &#x27;off&#x27;<br>proxy-failure-wait: 5000<br>proxy-refresh-interval: 30000<br>proxy-dial-timeout: 1000<br>proxy-write-timeout: 5000<br>proxy-read-timeout: 0<br>client-transport-security:<br>  cert-file: &#x27;/etc/kubernetes/pki/etcd/etcd.pem&#x27;<br>  key-file: &#x27;/etc/kubernetes/pki/etcd/etcd-key.pem&#x27;<br>  client-cert-auth: true<br>  trusted-ca-file: &#x27;/etc/kubernetes/pki/etcd/etcd-ca.pem&#x27;<br>  auto-tls: true<br>peer-transport-security:<br>  cert-file: &#x27;/etc/kubernetes/pki/etcd/etcd.pem&#x27;<br>  key-file: &#x27;/etc/kubernetes/pki/etcd/etcd-key.pem&#x27;<br>  peer-client-cert-auth: true<br>  trusted-ca-file: &#x27;/etc/kubernetes/pki/etcd/etcd-ca.pem&#x27;<br>  auto-tls: true<br>debug: false<br>log-package-levels:<br>log-outputs: [default]<br>force-new-cluster: false<br>EOF<br></code></pre></td></tr></table></figure><h3 id="k8s-worker2-节点"><a href="#k8s-worker2-节点" class="headerlink" title="k8s-worker2 节点"></a><del>k8s-worker2 节点</del></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">如果要用 IPv6 那么把 IPv4 地址修改为 IPv6 即可</span><br>cat &gt; /etc/etcd/etcd.config.yml &lt;&lt; EOF <br>name: &#x27;k8s-worker2&#x27;<br>data-dir: /var/lib/etcd<br>wal-dir: /var/lib/etcd/wal<br>snapshot-count: 5000<br>heartbeat-interval: 100<br>election-timeout: 1000<br>quota-backend-bytes: 0<br>listen-peer-urls: &#x27;https://192.168.223.130:2380&#x27;<br>listen-client-urls: &#x27;https://192.168.223.130:2379,http://127.0.0.1:2379&#x27;<br>max-snapshots: 3<br>max-wals: 5<br>cors:<br>initial-advertise-peer-urls: &#x27;https://192.168.223.130:2380&#x27;<br>advertise-client-urls: &#x27;https://192.168.223.130:2379&#x27;<br>discovery:<br>discovery-fallback: &#x27;proxy&#x27;<br>discovery-proxy:<br>discovery-srv:<br>initial-cluster: &#x27;k8s-master=https://192.168.223.128:2380,k8s-worker1=https://192.168.223.129:2380,k8s-worker2=https://192.168.223.130:2380&#x27;<br>initial-cluster-token: &#x27;etcd-k8s-cluster&#x27;<br>initial-cluster-state: &#x27;new&#x27;<br>strict-reconfig-check: false<br>enable-v2: true<br>enable-pprof: true<br>proxy: &#x27;off&#x27;<br>proxy-failure-wait: 5000<br>proxy-refresh-interval: 30000<br>proxy-dial-timeout: 1000<br>proxy-write-timeout: 5000<br>proxy-read-timeout: 0<br>client-transport-security:<br>  cert-file: &#x27;/etc/kubernetes/pki/etcd/etcd.pem&#x27;<br>  key-file: &#x27;/etc/kubernetes/pki/etcd/etcd-key.pem&#x27;<br>  client-cert-auth: true<br>  trusted-ca-file: &#x27;/etc/kubernetes/pki/etcd/etcd-ca.pem&#x27;<br>  auto-tls: true<br>peer-transport-security:<br>  cert-file: &#x27;/etc/kubernetes/pki/etcd/etcd.pem&#x27;<br>  key-file: &#x27;/etc/kubernetes/pki/etcd/etcd-key.pem&#x27;<br>  peer-client-cert-auth: true<br>  trusted-ca-file: &#x27;/etc/kubernetes/pki/etcd/etcd-ca.pem&#x27;<br>  auto-tls: true<br>debug: false<br>log-package-levels:<br>log-outputs: [default]<br>force-new-cluster: false<br>EOF<br></code></pre></td></tr></table></figure><p>创建 etcd 启动服务（需要在所有 master 节点操作）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; /usr/lib/systemd/system/etcd.service &lt;&lt; EOF<br>[Unit]<br>Description=Etcd Service<br>Documentation=https://coreos.com/etcd/docs/latest/<br>After=network.target<br>[Service]<br>Type=notify<br>ExecStart=/usr/local/bin/etcd --config-file=/etc/etcd/etcd.config.yml<br>Restart=on-failure<br>RestartSec=10<br>LimitNOFILE=65536<br>[Install]<br>WantedBy=multi-user.target<br>Alias=etcd3.service<br>EOF<br></code></pre></td></tr></table></figure><p>拷贝 ETCD 证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /etc/kubernetes/pki/etcd<br>ln -s /etc/etcd/ssl/* /etc/kubernetes/pki/etcd/<br>systemctl daemon-reload<br>systemctl enable --now etcd<br></code></pre></td></tr></table></figure><p>查看 etcd 状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcdctl --endpoints=<span class="hljs-string">&quot;k8s-master:2379&quot;</span> --cacert=/etc/kubernetes/pki/etcd/etcd-ca.pem --cert=/etc/kubernetes/pki/etcd/etcd.pem --key=/etc/kubernetes/pki/etcd/etcd-key.pem  endpoint status --write-out=table</span><br></code></pre></td></tr></table></figure><blockquote><p>之前的配置文件写错了，应该只有 master 节点需要运行 etcd，所以配置文件中的 initial-cluster 需要改为 k8s-master&#x3D;<a href="https://192.168.223.128:2380'，也就是只添加">https://192.168.223.128:2380&#39;，也就是只添加</a> master 本身即可，删掉之前加入的两个 worker 节点，修改为：</p><p><code>initial-cluster: &#39;k8s-master=https://192.168.223.128:2380&#39;</code></p><p>然后执行 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl daemon-reload</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl restart etcd</span><br></code></pre></td></tr></table></figure><p>重新运行 etcd，但是发现无法运行，手动执行 etcd –config-file&#x3D;&#x2F;etc&#x2F;etcd&#x2F;etcd.config.yml（也可以使用 <code>sudo journalctl -u etcd</code>），发现日志里输出 “error”:”dial tcp 192.168.223.129:2380: connect: connection refused”，这表示 etcd 依旧在尝试连接 worker1 的 etcd，明明改了 initial-cluster，为什么没有生效呢？</p><p>我重新排查日志，发现有这么一行有点可疑：</p><p>{“level”:”info”,”ts”:”2023-04-15T16:58:41.252Z”,”caller”:”etcdmain&#x2F;etcd.go:116”,”msg”:”server has been already initialized”,”data-dir”:”&#x2F;var&#x2F;lib&#x2F;etcd”,”dir-type”:”member”}</p><p>尝试删掉 &#x2F;var&#x2F;lib&#x2F;etcd&#x2F;member，再次执行 sudo systemctl restart etcd，发现命令不会阻塞了，etcd 成功运行。（此时我只想夸自己一句牛逼 plus）</p></blockquote><p>如果输出下面这些内容，说明你搞对了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">+-----------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+<br>|    ENDPOINT     |        ID        | VERSION | DB SIZE | IS LEADER | IS LEARNER | RAFT TERM | RAFT INDEX | RAFT APPLIED INDEX | ERRORS |<br>+-----------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+<br>| k8s-master:2379 | 2918d818e481030f |   3.5.4 |   20 kB |      true |      false |         5 |         10 |                 10 |        |<br>+-----------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+<br></code></pre></td></tr></table></figure><h2 id="ApiServer-配置"><a href="#ApiServer-配置" class="headerlink" title="ApiServer 配置"></a>ApiServer 配置</h2><p>创建 apiserver 服务启动文件</p><p>需要在每台节点自行修改对应的信息</p><ul><li>–advertise-address 当前节点 IP</li><li>–etcd-servers ETCD 节点信息</li><li>–secure-port apiserver 端口号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; /usr/lib/systemd/system/kube-apiserver.service &lt;&lt; EOF<br>[Unit]<br>Description=Kubernetes API Server<br>Documentation=https://github.com/kubernetes/kubernetes<br>After=network.target<br>[Service]<br>ExecStart=/usr/local/bin/kube-apiserver \<br>      --v=2  \<br>      --logtostderr=true  \<br>      --allow-privileged=true  \<br>      --bind-address=0.0.0.0  \<br>      --secure-port=6443  \<br>      --advertise-address=192.168.223.128 \<br>      --service-cluster-ip-range=10.96.0.0/12,fd00::/108  \<br>      --feature-gates=IPv6DualStack=true  \<br>      --service-node-port-range=30000-32767  \<br>      --etcd-servers=https://k8s-master:2379 \<br>      --etcd-cafile=/etc/etcd/ssl/etcd-ca.pem  \<br>      --etcd-certfile=/etc/etcd/ssl/etcd.pem  \<br>      --etcd-keyfile=/etc/etcd/ssl/etcd-key.pem  \<br>      --client-ca-file=/etc/kubernetes/pki/ca.pem  \<br>      --tls-cert-file=/etc/kubernetes/pki/apiserver.pem  \<br>      --tls-private-key-file=/etc/kubernetes/pki/apiserver-key.pem  \<br>      --kubelet-client-certificate=/etc/kubernetes/pki/apiserver.pem  \<br>      --kubelet-client-key=/etc/kubernetes/pki/apiserver-key.pem  \<br>      --service-account-key-file=/etc/kubernetes/pki/sa.pub  \<br>      --service-account-signing-key-file=/etc/kubernetes/pki/sa.key  \<br>      --service-account-issuer=https://kubernetes.default.svc.cluster.local \<br>      --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname  \<br>      --enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota  \<br>      --authorization-mode=Node,RBAC  \<br>      --enable-bootstrap-token-auth=true  \<br>      --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.pem  \<br>      --proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-client.pem  \<br>      --proxy-client-key-file=/etc/kubernetes/pki/front-proxy-client-key.pem  \<br>      --requestheader-allowed-names=aggregator  \<br>      --requestheader-group-headers=X-Remote-Group  \<br>      --requestheader-extra-headers-prefix=X-Remote-Extra-  \<br>      --requestheader-username-headers=X-Remote-User \<br>      --enable-aggregator-routing=true<br>      # --token-auth-file=/etc/kubernetes/token.csv<br>Restart=on-failure<br>RestartSec=10s<br>LimitNOFILE=65535<br>[Install]<br>WantedBy=multi-user.target<br>EOF<br></code></pre></td></tr></table></figure><p>启动 apiserver（所有 master 节点）</p><p><del>for i in k8s-01 k8s-02 k8s-03;do</del><br>    <del>ssh $i “systemctl daemon-reload &amp;&amp; systemctl enable –now kube-apiserver”</del><br>    <del>echo “$i”</del><br>    <del>sleep 5</del><br>    <del>ssh $i “systemctl status kube-apiserver”</del><br><del>done</del></p><p>单 master 节点只需要执行下面的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl daemon-reload &amp;&amp; systemctl <span class="hljs-built_in">enable</span> --now kube-apiserver</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sleep</span> 5</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl status kube-apiserver</span><br></code></pre></td></tr></table></figure><p>如果输出类似这样，即 Active: active (running)，则代表成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">● kube-apiserver.service - Kubernetes API Server<br>     Loaded: loaded (/lib/systemd/system/kube-apiserver.service; enabled; vendor preset: enabled)<br>     Active: active (running) since Sat 2023-04-15 18:01:27 UTC; 6s ago<br>       Docs: https://github.com/kubernetes/kubernetes<br>   Main PID: 54969 (kube-apiserver)<br>      Tasks: 15 (limit: 9362)<br>     Memory: 290.8M<br>        CPU: 3.201s<br></code></pre></td></tr></table></figure><h2 id="Controller-Manage-配置"><a href="#Controller-Manage-配置" class="headerlink" title="Controller-Manage 配置"></a>Controller-Manage 配置</h2><p>172.16.0.0&#x2F;12 为 pod 网段，按需求设置你自己的网段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; /usr/lib/systemd/system/kube-controller-manager.service &lt;&lt; EOF<br>[Unit]<br>Description=Kubernetes Controller Manager<br>Documentation=https://github.com/kubernetes/kubernetes<br>After=network.target<br>[Service]<br>ExecStart=/usr/local/bin/kube-controller-manager \<br>      --v=2 \<br>      --logtostderr=true \<br>      --bind-address=127.0.0.1 \<br>      --root-ca-file=/etc/kubernetes/pki/ca.pem \<br>      --cluster-signing-cert-file=/etc/kubernetes/pki/ca.pem \<br>      --cluster-signing-key-file=/etc/kubernetes/pki/ca-key.pem \<br>      --service-account-private-key-file=/etc/kubernetes/pki/sa.key \<br>      --kubeconfig=/etc/kubernetes/controller-manager.kubeconfig \<br>      --leader-elect=true \<br>      --use-service-account-credentials=true \<br>      --node-monitor-grace-period=40s \<br>      --node-monitor-period=5s \<br>      --pod-eviction-timeout=2m0s \<br>      --controllers=*,bootstrapsigner,tokencleaner \<br>      --allocate-node-cidrs=true \<br>      --feature-gates=IPv6DualStack=true \<br>      --service-cluster-ip-range=10.96.0.0/12,fd00::/108 \<br>      --cluster-cidr=172.16.0.0/12,fc00::/48 \<br>      --node-cidr-mask-size-ipv4=24 \<br>      --node-cidr-mask-size-ipv6=64 \<br>      --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.pem <br>Restart=always<br>RestartSec=10s<br>[Install]<br>WantedBy=multi-user.target<br>EOF<br></code></pre></td></tr></table></figure><p><strong>配置文件拷贝到其它节点</strong></p><p><del>for i in k8s-02 k8s-03;do<br>    scp &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;kube-controller-manager.service  $i:&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;    scp &#x2F;etc&#x2F;kubernetes&#x2F;controller-manager.kubeconfig  $i:&#x2F;etc&#x2F;kubernetes&#x2F;</del><br><del>done</del></p><p>我这边就用不着了</p><p><strong>启动所有节点服务</strong></p><p><del>for i in k8s-01 k8s-02 k8s-03;do</del><br>      <del>ssh $i “systemctl daemon-reload &amp;&amp; systemctl enable –now kube-controller-manager &amp;&amp; systemctl  status kube-controller-manager”</del><br><del>done</del></p><p>我这里也用不着了，只需要执行下面这段即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl daemon-reload &amp;&amp; systemctl <span class="hljs-built_in">enable</span> --now kube-controller-manager &amp;&amp; systemctl  status kube-controller-manager</span><br></code></pre></td></tr></table></figure><p>输出类似下面这样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">Created symlink /etc/systemd/system/multi-user.target.wants/kube-controller-manager.service → /lib/systemd/system/kube-controller-manager.service.<br>● kube-controller-manager.service - Kubernetes Controller Manager<br>     Loaded: loaded (/lib/systemd/system/kube-controller-manager.service; enabled; vendor preset: enabled)<br>     Active: active (running) since Sat 2023-04-15 18:14:05 UTC; 5ms ago<br>       Docs: https://github.com/kubernetes/kubernetes<br>   Main PID: 55081 (kube-controller)<br>      Tasks: 6 (limit: 9362)<br>     Memory: 1.6M<br>        CPU: 3ms<br></code></pre></td></tr></table></figure><h2 id="Scheduler-配置"><a href="#Scheduler-配置" class="headerlink" title="Scheduler 配置"></a>Scheduler 配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; /usr/lib/systemd/system/kube-scheduler.service &lt;&lt; EOF<br>[Unit]<br>Description=Kubernetes Scheduler<br>Documentation=https://github.com/kubernetes/kubernetes<br>After=network.target<br>[Service]<br>ExecStart=/usr/local/bin/kube-scheduler \<br>      --v=2 \<br>      --logtostderr=true \<br>      --bind-address=127.0.0.1 \<br>      --leader-elect=true \<br>      --kubeconfig=/etc/kubernetes/scheduler.kubeconfig<br>Restart=always<br>RestartSec=10s<br>[Install]<br>WantedBy=multi-user.target<br>EOF<br></code></pre></td></tr></table></figure><p><del>配置文件拷贝到其它节点</del></p><p><del>for i in k8s-02 k8s-03;do<br>    scp &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;kube-scheduler.service  $i:&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;<br>    scp &#x2F;etc&#x2F;kubernetes&#x2F;scheduler.kubeconfig $i:&#x2F;etc&#x2F;kubernetes&#x2F;</del><br><del>done</del></p><p>启动所有节点服务</p><p><del>for i in k8s-01 k8s-02 k8s-03;do<br>    ssh $i “systemctl daemon-reload &amp;&amp; systemctl enable –now kube-scheduler &amp;&amp; systemctl  status kube-scheduler”</del><br><del>done</del></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl daemon-reload &amp;&amp; systemctl <span class="hljs-built_in">enable</span> --now kube-scheduler &amp;&amp; systemctl  status kube-scheduler</span><br></code></pre></td></tr></table></figure><h2 id="上下文配置"><a href="#上下文配置" class="headerlink" title="上下文配置"></a>上下文配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /root/bootstrap<br>kubectl config set-cluster kubernetes     \<br>--certificate-authority=/etc/kubernetes/pki/ca.pem     \<br>--embed-certs=true     <br>--server=https://192.168.223.128:6443     \<br>--kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig<br>kubectl config set-credentials tls-bootstrap-token-user     \<br>--token=c8ad9c.2e4d610cf3e7426e \<br>--kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig<br>kubectl config set-context tls-bootstrap-token-user@kubernetes     \<br>--cluster=kubernetes     \<br>--user=tls-bootstrap-token-user     \<br>--kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig<br>kubectl config use-context tls-bootstrap-token-user@kubernetes     \<br>--kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig<br><span class="hljs-meta prompt_"># </span><span class="language-bash">token的位置在bootstrap.secret.yaml，如果修改的话到这个文件修改</span><br>mkdir -p /root/.kube ; cp /etc/kubernetes/admin.kubeconfig /root/.kube/config<br></code></pre></td></tr></table></figure><p>查看集群状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get cs</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这样就对了</span><br>Warning: v1 ComponentStatus is deprecated in v1.19+<br>NAME                 STATUS    MESSAGE                         ERROR<br>scheduler            Healthy   ok<br>controller-manager   Healthy   ok<br>etcd-0               Healthy   &#123;&quot;health&quot;:&quot;true&quot;,&quot;reason&quot;:&quot;&quot;&#125;<br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f bootstrap.secret.yaml</span><br></code></pre></td></tr></table></figure><h2 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h2><h3 id="创建-kubelet-启动文件"><a href="#创建-kubelet-启动文件" class="headerlink" title="创建 kubelet 启动文件"></a>创建 kubelet 启动文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; /usr/lib/systemd/system/kubelet.service &lt;&lt; EOF<br>[Unit]<br>Description=Kubernetes Kubelet<br>Documentation=https://github.com/kubernetes/kubernetes<br>After=containerd.service<br>Requires=containerd.service<br>[Service]<br>ExecStart=/usr/local/bin/kubelet \<br>    --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig  \<br>    --kubeconfig=/etc/kubernetes/kubelet.kubeconfig \<br>    --config=/etc/kubernetes/kubelet-conf.yml \<br>    --container-runtime=remote  \<br>    --runtime-request-timeout=15m  \<br>    --container-runtime-endpoint=unix:///run/containerd/containerd.sock  \<br>    --cgroup-driver=systemd \<br>    --node-labels=node.kubernetes.io/node=&#x27;&#x27; \<br>    --feature-gates=IPv6DualStack=true<br>[Install]<br>WantedBy=multi-user.target<br>EOF<br></code></pre></td></tr></table></figure><h3 id="创建-kubelet-配置文件"><a href="#创建-kubelet-配置文件" class="headerlink" title="创建 kubelet 配置文件"></a>创建 kubelet 配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; /etc/kubernetes/kubelet-conf.yml &lt;&lt;EOF<br>apiVersion: kubelet.config.k8s.io/v1beta1<br>kind: KubeletConfiguration<br>address: 0.0.0.0<br>port: 10250<br>readOnlyPort: 10255<br>authentication:<br>  anonymous:<br>    enabled: false<br>  webhook:<br>    cacheTTL: 2m0s<br>    enabled: true<br>  x509:<br>    clientCAFile: /etc/kubernetes/pki/ca.pem<br>authorization:<br>  mode: Webhook<br>  webhook:<br>    cacheAuthorizedTTL: 5m0s<br>    cacheUnauthorizedTTL: 30s<br>cgroupDriver: systemd<br>cgroupsPerQOS: true<br>clusterDNS:<br>- 10.96.0.10<br>clusterDomain: cluster.local<br>containerLogMaxFiles: 5<br>containerLogMaxSize: 10Mi<br>contentType: application/vnd.kubernetes.protobuf<br>cpuCFSQuota: true<br>cpuManagerPolicy: none<br>cpuManagerReconcilePeriod: 10s<br>enableControllerAttachDetach: true<br>enableDebuggingHandlers: true<br>enforceNodeAllocatable:<br>- pods<br>eventBurst: 10<br>eventRecordQPS: 5<br>evictionHard:<br>  imagefs.available: 15%<br>  memory.available: 100Mi<br>  nodefs.available: 10%<br>  nodefs.inodesFree: 5%<br>evictionPressureTransitionPeriod: 5m0s<br>failSwapOn: true<br>fileCheckFrequency: 20s<br>hairpinMode: promiscuous-bridge<br>healthzBindAddress: 127.0.0.1<br>healthzPort: 10248<br>httpCheckFrequency: 20s<br>imageGCHighThresholdPercent: 85<br>imageGCLowThresholdPercent: 80<br>imageMinimumGCAge: 2m0s<br>iptablesDropBit: 15<br>iptablesMasqueradeBit: 14<br>kubeAPIBurst: 10<br>kubeAPIQPS: 5<br>makeIPTablesUtilChains: true<br>maxOpenFiles: 1000000<br>maxPods: 110<br>nodeStatusUpdateFrequency: 10s<br>oomScoreAdj: -999<br>podPidsLimit: -1<br>registryBurst: 10<br>registryPullQPS: 5<br>resolvConf: /etc/resolv.conf<br>rotateCertificates: true<br>runtimeRequestTimeout: 2m0s<br>serializeImagePulls: true<br>staticPodPath: /etc/kubernetes/manifests<br>streamingConnectionIdleTimeout: 4h0m0s<br>syncFrequency: 1m0s<br>volumeStatsAggPeriod: 1m0s<br>EOF<br></code></pre></td></tr></table></figure><h3 id="拷贝证书到其它节点"><a href="#拷贝证书到其它节点" class="headerlink" title="拷贝证书到其它节点"></a><del>拷贝证书到其它节点</del></h3><p><del>for i in k8s-01 k8s-02 k8s-03;do<br>    ssh $i “mkdir -p &#x2F;var&#x2F;lib&#x2F;kubelet &#x2F;var&#x2F;log&#x2F;kubernetes  &#x2F;etc&#x2F;kubernetes&#x2F;manifests&#x2F;“   scp &#x2F;etc&#x2F;kubernetes&#x2F;kubelet-conf.yml $i:&#x2F;etc&#x2F;kubernetes&#x2F;<br>    scp &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;kubelet.service  $i:&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;<br>    scp &#x2F;etc&#x2F;kubernetes&#x2F;bootstrap-kubelet.kubeconfig $i:&#x2F;etc&#x2F;kubernetes&#x2F;</del><br><del>done</del></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> -p /var/lib/kubelet /var/log/kubernetes  /etc/kubernetes/manifests/</span><br></code></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl daemon-reload<br>systemctl enable --now kubelet<br>systemctl status kubelet<br></code></pre></td></tr></table></figure><h3 id="查看集群"><a href="#查看集群" class="headerlink" title="查看集群"></a>查看集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get node</span><br><br>No resources found<br></code></pre></td></tr></table></figure><p>失败了。。。没有任何节点</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://i4t.com/5636.html">https://i4t.com/5636.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过实践学习 Nginx [draft]</title>
    <link href="/2023/04/06/nginx-practice/"/>
    <url>/2023/04/06/nginx-practice/</url>
    
    <content type="html"><![CDATA[<h1 id="代理静态文件-x2F-虚拟主机"><a href="#代理静态文件-x2F-虚拟主机" class="headerlink" title="代理静态文件&#x2F;虚拟主机"></a>代理静态文件&#x2F;虚拟主机</h1><p>在 <code>/usr/share/nginx/html</code> 目录下新建两个文件夹 <code>a</code> 和 <code>b</code>，分别存放 a.html 和 b.html，两个 html 的内容如下：</p><p><code>a.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>b.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello2<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后修改 nginx 的配置文件，在 http 块中添加如下内容：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span> www.testweb1.com;<br><br>        <span class="hljs-section">location</span> / &#123;<br>           <span class="hljs-attribute">root</span> /usr/share/nginx/html/a;<br>        &#125;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span> www.testweb2.com;<br><br>        <span class="hljs-section">location</span> / &#123;<br>           <span class="hljs-attribute">root</span> /usr/share/nginx/html/b;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们两个 server 监听了同一个端口，但是 server_name 不同，在这种情况下，将会根据 HTTP 请求头中的 HOST 来决定走哪个 server，首先为了能解析出域名，我们需要修改一下 &#x2F;etc&#x2F;hosts 文件，添加如下内容：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span>   www.testweb1.com<br><span class="hljs-number">127.0.0.1</span>   www.testweb2.com<br></code></pre></td></tr></table></figure><p>然后我们尝试访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl http://www.testweb1.com/a.html<br>&lt;h1&gt;Hello1&lt;/h1&gt;<br><br>curl http://www.testweb2.com/b.html<br>&lt;h1&gt;Hello2&lt;/h1&gt;<br></code></pre></td></tr></table></figure><p>也就是说，我们通过 <a href="http://www.testweb1.com/">www.testweb1.com</a> 访问，等同于访问 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;a 这个文件夹，但是我们必须还拼接上要访问的文件名，比如 <a href="http://www.testweb1.com/a.html">www.testweb1.com/a.html</a> 这样。</p><p>你还可以通过设置 index 来指定一个默认文件，这样的话如果访问路径没有指定文件名，那么就会去访问这个文件，我们修改一下上面的 nginx.conf，为其添加一个 index：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span> www.testweb1.com;<br><br>        <span class="hljs-section">location</span> / &#123;<br>           <span class="hljs-attribute">root</span> /usr/share/nginx/html/a;<br>         <span class="hljs-attribute">index</span> a.html;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时就可以不携带文件名访问了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl http://www.testweb1.com<br>&lt;h1&gt;Hello1&lt;/h1&gt;<br></code></pre></td></tr></table></figure><h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><p>这里顺带提一下 HTTP 请求头 Host 的概念，当我们请求域名时，会自动加上 Host，比如如果我们执行 <code>curl http://www.testweb1.com/a.html</code> 时，会自动给请求添加一个这样的请求头： <code>Host: www.testweb1.com</code>（当然你也可以手动指定这个请求头），然后 nginx 会根据这个 Host 来选择对应的 server，这样就可以用同一个 IP + 端口提供不同的服务，这就是这个请求头的作用。</p><p>比如在上面的例子中，我们的 <a href="http://www.testweb1.com/">www.testweb1.com</a> 和 <a href="http://www.testweb2.com/">www.testweb2.com</a> 都指向了 127.0.0.1，并且我们 <code>curl http://www.testweb1.com/a.html</code> 和 <code>curl http://www.testweb2.com/b.html</code> 这两个域名时走的都是 80 端口（没有指定端口，则 http 默认走 80），相当于我们实际访问的都是 127.0.0.1:80，但是却能返回不同的页面，正是因为我们请求的 Host 不同所导致的，当我们请求 <a href="http://www.testweb1.com/a.html">http://www.testweb1.com/a.html</a> 时，Host 是 <a href="http://www.testweb1.com,这就匹配到/">www.testweb1.com，这就匹配到</a> <code>server_name www.testweb1.com</code> 这个 server 块，从而显示出 a.html；同理，另一个请求也一样。</p><p>（参考 Nginx 虚拟主机的概念）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.v2ex.com/t/662419">http 报文的 host 字段是干啥用的</a></p><h1 id="Nginx-反代"><a href="#Nginx-反代" class="headerlink" title="Nginx 反代"></a>Nginx 反代</h1><p>准备下面的程序，用来运行 N 个 http server，每个 http server 会输出不同的内容，用来标识自身，方便我们测试反代负载均衡的效果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>n <span class="hljs-type">int</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.IntVar(&amp;n, <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;run N http server&quot;</span>)<br>flag.Parse()<br><br>ip := <span class="hljs-string">&quot;0.0.0.0&quot;</span><br>firstPort := <span class="hljs-string">&quot;10000&quot;</span><br><br>wg := sync.WaitGroup&#123;&#125;<br>mu := sync.Mutex&#123;&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>mu.Lock()<br>firstPortInt, _ := strconv.Atoi(firstPort)<br>portInt := firstPortInt + <span class="hljs-number">1</span><br>firstPort = strconv.Itoa(portInt)<br><br><span class="hljs-keyword">defer</span> wg.Done()<br>mux := http.NewServeMux()<br>mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>w.Write([]<span class="hljs-type">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;You visited %v\n&quot;</span>, i)))<br>&#125;)<br><br>fmt.Printf(<span class="hljs-string">&quot;listen in %v:%v\n&quot;</span>, ip, firstPort)<br><span class="hljs-comment">// 把锁的范围扩大一些，保证多个 goroutine 不会用到同一个 port</span><br><span class="hljs-comment">// 如果锁的范围过小，比如写在 firstPort = strconv.Itoa(portInt) 后面</span><br><span class="hljs-comment">// 会导致不同 goroutine 拿到的 firstPort 相同从而 panic</span><br>mu.Unlock()<br><span class="hljs-keyword">if</span> err := http.ListenAndServe(fmt.Sprintf(<span class="hljs-string">&quot;%s:%s&quot;</span>, ip, firstPort), mux); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>然后运行它，通过 -n 来指定要运行几个 http server：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">go run run_n_server.go -n 3<br>listen in 0.0.0.0:10001<br>listen in 0.0.0.0:10002<br>listen in 0.0.0.0:10003<br></code></pre></td></tr></table></figure><p>（下面还有一个之前写的程序，也是类似的效果，但是用起来要麻烦一些，所以废弃了，只做保留）</p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">&quot;flag&quot;</span><br>        <span class="hljs-string">&quot;fmt&quot;</span><br>        <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>        mark <span class="hljs-type">string</span><br>        ip   <span class="hljs-type">string</span><br>        port <span class="hljs-type">string</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        flag.StringVar(&amp;mark, <span class="hljs-string">&quot;m&quot;</span>, <span class="hljs-string">&quot;001&quot;</span>, <span class="hljs-string">&quot;mark&quot;</span>)<br>        flag.StringVar(&amp;ip, <span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-string">&quot;ip&quot;</span>)<br>        flag.StringVar(&amp;port, <span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>)<br>        flag.Parse()<br><br>        fmt.Printf(<span class="hljs-string">&quot;listen in %v:%v, mark: %v\n&quot;</span>, ip, port, mark)<br><br>        http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>                w.Write([]<span class="hljs-type">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;You visited %s&quot;</span>, mark)))<br>        &#125;)<br><br>        <span class="hljs-keyword">if</span> err := http.ListenAndServe(fmt.Sprintf(<span class="hljs-string">&quot;%s:%s&quot;</span>, ip, port), <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">go run http_server.go -m 001 -p 8081 &amp;<br>go run http_server.go -m 002 -p 8082 &amp;<br>go run http_server.go -m 003 -p 8083 &amp;<br></code></pre></td></tr></table></figure></blockquote><p>在 nginx.conf  中，修改 http 代码块如下（你也可以把这个块里面的内容粘贴到现有的 http 块中，但是需要注意的是整个配置文件中只能有一个 http 块）：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-section">upstream</span> myapp &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8081</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8082</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8083</span>;<br>    &#125;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">8000</span>;<br>        <span class="hljs-attribute">server_name</span> localhost;<br>        <br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">proxy_pass</span> http://myapp;<br>            <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后执行 <code>nginx -t</code> 检查一下配置文件是否有误。</p><p>最后执行 <code>nginx -s reload</code> 重载配置文件。</p><p>访问 localhost:8000，会随机显示 You visited 001, You visited 002, You visited 003</p><p>TODO：观察 8080 的响应头</p><h1 id="配置-HTTPS"><a href="#配置-HTTPS" class="headerlink" title="配置 HTTPS"></a>配置 HTTPS</h1><p>生成证书和私钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /usr/local/nginx/cert<br>cd /usr/local/nginx/cert<br>openssl genrsa -out server.key 4096<br>openssl req -new -key server.key -out server.csr<br>openssl x509 -req -in server.csr -out server.crt -signkey server.key -days 3650<br></code></pre></td></tr></table></figure><p>注意生成的私钥长度要大于 2048（我也不确定是不是这个数，反正之前我指定的长度为 2048 会报错），不然 nginx 会报错：<code>[emerg] 313#313: SSL_CTX_use_certificate(&quot;/usr/local/nginx/cert/server.crt&quot;) failed (SSL: error:0A00018F:SSL routines::ee key too small)</code>，这里我把它指定为 4096。</p><p>然后配置 nginx.conf：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<br>        <span class="hljs-attribute">server_name</span> localhost;<br><br>        <span class="hljs-attribute">ssl_certificate</span> /usr/local/nginx/cert/server.crt;<br>        <span class="hljs-attribute">ssl_certificate_key</span> /usr/local/nginx/cert/server.key;<br><br>        <span class="hljs-section">location</span> / &#123;<br>           <span class="hljs-attribute">root</span> /usr/share/nginx/html/;<br>           <span class="hljs-attribute">index</span> index.html;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>测试访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -k https://localhost<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">....</span><br>&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">....</span><br></code></pre></td></tr></table></figure><h1 id="修改响应体"><a href="#修改响应体" class="headerlink" title="修改响应体"></a>修改响应体</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">&quot;encoding/json&quot;</span><br>        <span class="hljs-string">&quot;flag&quot;</span><br>        <span class="hljs-string">&quot;fmt&quot;</span><br>        <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>        ip   <span class="hljs-type">string</span><br>        port <span class="hljs-type">string</span><br>)<br><br><span class="hljs-keyword">type</span> Resp <span class="hljs-keyword">struct</span> &#123;<br>        HTTPCode <span class="hljs-type">string</span><br>        Code     <span class="hljs-type">string</span><br>        Msg      <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        flag.StringVar(&amp;ip, <span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-string">&quot;ip&quot;</span>)<br>        flag.StringVar(&amp;port, <span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>)<br>        flag.Parse()<br><br>        fmt.Printf(<span class="hljs-string">&quot;listen in %v:%v\n&quot;</span>, ip, port)<br><br>        http.HandleFunc(<span class="hljs-string">&quot;/suc&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>                b, err := json.Marshal(&amp;Resp&#123;HTTPCode: <span class="hljs-string">&quot;200&quot;</span>, Code: <span class="hljs-string">&quot;10000&quot;</span>, Msg: <span class="hljs-string">&quot;success.&quot;</span>&#125;)<br>                <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                        w.WriteHeader(http.StatusInternalServerError)<br>                        w.Write([]<span class="hljs-type">byte</span>(err.Error()))<br>                        <span class="hljs-keyword">return</span><br>                &#125;<br>                w.WriteHeader(http.StatusOK)<br>                w.Write(b)<br>        &#125;)<br><br>        http.HandleFunc(<span class="hljs-string">&quot;/err&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>                b, err := json.Marshal(&amp;Resp&#123;HTTPCode: <span class="hljs-string">&quot;500&quot;</span>, Code: <span class="hljs-string">&quot;20000&quot;</span>, Msg: <span class="hljs-string">&quot;error.&quot;</span>&#125;)<br>                <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                        w.WriteHeader(http.StatusInternalServerError)<br>                        w.Write([]<span class="hljs-type">byte</span>(err.Error()))<br>                        <span class="hljs-keyword">return</span><br>                &#125;<br>                w.WriteHeader(http.StatusInternalServerError)<br>                w.Write(b)<br>        &#125;)<br><br>        <span class="hljs-keyword">if</span> err := http.ListenAndServe(fmt.Sprintf(<span class="hljs-string">&quot;%s:%s&quot;</span>, ip, port), <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>&#125;<br>http &#123;<br>    gzip              on;<br>    gzip_types        text/plain text/css application/json application/javascript;<br>    gzip_min_length   <span class="hljs-number">1000</span>;<br>    gzip_proxied      any;<br><br>    server &#123;<br>        listen <span class="hljs-number">80</span>;<br>        server_name example.com;<br><br>        location /api &#123;<br>            proxy_pass http:<span class="hljs-comment">//backend;</span><br>            sub_filter_types application/json;<br>            sub_filter <span class="hljs-string">&#x27;foo&#x27;</span>: <span class="hljs-string">&#x27;bar&#x27;</span>;<br>            sub_filter_last_modified on;<br>            sub_filter_once off;<br>            proxy_set_header Accept-Encoding <span class="hljs-string">&quot;&quot;</span>;<br>            proxy_set_header Connection <span class="hljs-string">&quot;&quot;</span>;<br>            proxy_http_version <span class="hljs-number">1.1</span>;<br>            proxy_set_header Host $host;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s Secret</title>
    <link href="/2022/10/10/k8s-secret/"/>
    <url>/2022/10/10/k8s-secret/</url>
    
    <content type="html"><![CDATA[<h2 id="Opaque-Secret"><a href="#Opaque-Secret" class="headerlink" title="Opaque Secret"></a>Opaque Secret</h2><p>要求 value 必须是 base64 编码的</p><h3 id="测试：如果-value-不是-base64-呢？"><a href="#测试：如果-value-不是-base64-呢？" class="headerlink" title="测试：如果 value 不是 base64 呢？"></a>测试：如果 value 不是 base64 呢？</h3><p>准备如下 yaml 用来创建 secret，其中 value 不是 base64 格式的：</p><p><strong>secret_not_base64.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret-not-base64</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">Opaque</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">user:</span> <span class="hljs-string">root</span><br>  <span class="hljs-attr">pass:</span> <span class="hljs-string">123r</span> <br></code></pre></td></tr></table></figure><p>运行并查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f secret_not_base64.yaml</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get secret</span>                           <br>NAME                  TYPE                                  DATA   AGE<br>mysecret-not-base64   Opaque                                2      42m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get secret mysecret-not-base64 -oyaml</span><br>apiVersion: v1<br>data:<br>  pass: 123r<br>  user: root<br>kind: Secret<br>metadata:<br>  annotations:<br>    kubectl.kubernetes.io/last-applied-configuration: |<br>      &#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;data&quot;:&#123;&quot;pass&quot;:&quot;123r&quot;,&quot;user&quot;:&quot;root&quot;&#125;,&quot;kind&quot;:&quot;Secret&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&#125;,&quot;name&quot;:&quot;mysecret-not-base64&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;,&quot;type&quot;:&quot;Opaque&quot;&#125;<br>  creationTimestamp: &quot;2022-10-10T14:25:30Z&quot;<br>  name: mysecret-not-base64<br>  namespace: default<br>  resourceVersion: &quot;158457&quot;<br>  uid: 44ae7fda-3f7f-4da3-95b1-c3068727d765<br>type: Opaque<br></code></pre></td></tr></table></figure><p>貌似没什么影响啊？可以正常创建，也可以查看其中的值，继续测试看看</p><p>该 yaml 从名为 mysecret-not-base64 的 secret 中引用值，并将其设置为环境变量，然后会执行 env 命令查看当前系统里的所有环境变量（busybox 是一个集成了一些 linux 同样命令的镜像）</p><p><strong>secret_not_base64_pod.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">secret-not-base64-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">secret1</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">command:</span> [ <span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;env&quot;</span> ]<br>    <span class="hljs-attr">env:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">USERNAME</span> <span class="hljs-comment"># 设置名为 USERNAME 的环境变量，其值引用 mysecret-not-base64 中的 user 字段</span><br>      <span class="hljs-attr">valueFrom:</span><br>        <span class="hljs-attr">secretKeyRef:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret-not-base64</span> <br>          <span class="hljs-attr">key:</span> <span class="hljs-string">user</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">PASSWORD</span><br>      <span class="hljs-attr">valueFrom:</span><br>        <span class="hljs-attr">secretKeyRef:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret-not-base64</span> <br>          <span class="hljs-attr">key:</span> <span class="hljs-string">pass</span><br></code></pre></td></tr></table></figure><p>运行并查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f secret_not_base64_pod.yaml</span> <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl logs  secret-not-base64-pod</span>        <br>KUBERNETES_SERVICE_PORT=443<br>KUBERNETES_PORT=tcp://10.96.0.1:443<br>HOSTNAME=secret-not-base64-pod<br>SHLVL=1<br>HOME=/root<br>USERNAME=��-<br>KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1<br>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br>KUBERNETES_PORT_443_TCP_PORT=443<br>KUBERNETES_PORT_443_TCP_PROTO=tcp<br>KUBERNETES_SERVICE_PORT_HTTPS=443<br>KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443<br>KUBERNETES_SERVICE_HOST=10.96.0.1<br>PWD=/<br>PASSWORD=�m�<br></code></pre></td></tr></table></figure><p>发现我们设置的两个环境变量 USERNAME 和 PASSWORD 的值都显示为乱码，莫非如果引用了Opaque 类型的 secret 中的字段，会执行解码操作，将解码出来的值作为 value 进行设置吗？</p><p>为了搞清楚这个问题，我们可以再尝试做一个 value 是 base64 编码过的 secret：</p><p><strong>secret.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">Opaque</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">user:</span> <span class="hljs-string">YWRtaW4=</span><br>  <span class="hljs-attr">pass:</span> <span class="hljs-string">MWYyZDFlMmU2N2Rm</span><br></code></pre></td></tr></table></figure><p>tips：linux&#x2F;mac 自带了 base64 命令，可以方便的获取值的 base64:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;admin&quot;</span> | <span class="hljs-built_in">base64</span></span><br>YWRtaW4=<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;admin321&quot;</span> | <span class="hljs-built_in">base64</span></span><br>YWRtaW4zMjE=<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;YWRtaW4=&quot;</span> | <span class="hljs-built_in">base64</span> -d</span>    <br>admin<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解密</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;MWYyZDFlMmU2N2Rm&quot;</span> | <span class="hljs-built_in">base64</span> -d</span><br>1f2d1e2e67df<br></code></pre></td></tr></table></figure><p><strong>secret_base64_pod.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">secret-base64-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">secret1</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">command:</span> [ <span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;env&quot;</span> ]<br>    <span class="hljs-attr">env:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">USERNAME</span><br>      <span class="hljs-attr">valueFrom:</span><br>        <span class="hljs-attr">secretKeyRef:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret</span> <br>          <span class="hljs-attr">key:</span> <span class="hljs-string">user</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">PASSWORD</span><br>      <span class="hljs-attr">valueFrom:</span><br>        <span class="hljs-attr">secretKeyRef:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret</span> <br>          <span class="hljs-attr">key:</span> <span class="hljs-string">pass</span><br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f secret_base64_pod.yaml</span>  <br>pod/secret-base64-pod created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl logs secret-base64-pod</span><br>KUBERNETES_SERVICE_PORT=443<br>KUBERNETES_PORT=tcp://10.96.0.1:443<br>HOSTNAME=secret-base64-pod<br>SHLVL=1<br>HOME=/root<br>USERNAME=admin<br>KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1<br>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br>KUBERNETES_PORT_443_TCP_PORT=443<br>KUBERNETES_PORT_443_TCP_PROTO=tcp<br>KUBERNETES_SERVICE_PORT_HTTPS=443<br>KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443<br>KUBERNETES_SERVICE_HOST=10.96.0.1<br>PWD=/<br>PASSWORD=1f2d1e2e67df<br></code></pre></td></tr></table></figure><p>发现环境变量 USERNAME 和 PASSWORD 的值都正常显示了，看来确实是这样，当引用Opaque 类型的 secret 中的值时，会自动做 base64 解码操作</p><p>再试试用挂载的方式：</p><p>这里将 mysecret 这个 secret 下的所有条目挂载到了容器内的 &#x2F;projected-volume 目录下，mysecret 就是上面定义的 secret.yaml：</p><p><strong>secret-test-pod.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-projected-volume</span> <br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">test-secret-volume</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">args:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">sleep</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;86400&quot;</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-cred</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">&quot;/projected-volume&quot;</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-cred</span><br>    <span class="hljs-attr">projected:</span><br>      <span class="hljs-attr">sources:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">secret:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret</span><br></code></pre></td></tr></table></figure><p>运行并查看效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f secret-test-pod.yaml</span>  <br>pod/test-projected-volume created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span>                         <br>NAME                                READY   STATUS    RESTARTS   AGE<br>test-projected-volume               1/1     Running   0          7s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it test-projected-volume -- <span class="hljs-built_in">cat</span> /projected-volume/pass</span>                              <br><span class="hljs-meta prompt_">1f2d1e2e67df% </span><span class="language-bash">                                                                                                                                                            $ kubectl <span class="hljs-built_in">exec</span> -it test-projected-volume -- <span class="hljs-built_in">cat</span> /projected-volume/user</span><br><span class="hljs-meta prompt_">admin% </span><br></code></pre></td></tr></table></figure><p>发现这里将 secret 中的每个条目都单独做成了一个文件，并且文件内容都是已经解码过的值</p><p>再试试挂载引用之前那个 value 不是 base64 的 secret：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-projected-volume-not-base64</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">test-secret-volume</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">args:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">sleep</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;86400&quot;</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-cred</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">&quot;/projected-volume&quot;</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-cred</span><br>    <span class="hljs-attr">projected:</span><br>      <span class="hljs-attr">sources:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">secret:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret-not-base64</span> <span class="hljs-comment"># 修改这里</span><br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it test-projected-volume-not-base64 -- <span class="hljs-built_in">cat</span> /projected-volume/user</span><br>??-%                                                                                                                                                                      $ kubectl exec -it test-projected-volume-not-base64 -- cat /projected-volume/pass<br>?m?% <br></code></pre></td></tr></table></figure><p>发现乱码了</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s client-go informer 源码阅读 [draft]</title>
    <link href="/2022/10/07/client-go-yuan-ma/"/>
    <url>/2022/10/07/client-go-yuan-ma/</url>
    
    <content type="html"><![CDATA[<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/K8s-informer.png"></p><p>Informers 由几个核心的组件构成：</p><ul><li><p>Reflector：负责从 api-server List（全量拉取数据） and Watch（监听数据变更），然后扔到 DeltaFIFO 里面</p></li><li><p>DeltaFIFO：一个存储事件的队列，里面记录了事件的类型以及对象</p></li><li><p>Indexer：就是 Informer 的本地 cache，缓存的是 apiserver 中的对象，这样当调用者请求获取数据时，就不再需要去访问 apiserver 了，从而减轻 apiserver的压力。Indexer 只会被 Lister 的 List&#x2F;Get 方法访问。</p><p>Informer 的数据来源是从 DeltaFIFO 中 pop 出来的，然后会根据事件类型进行对应的操作，比如如果 pop 出来的是添加事件，那么就将该事件对应的 obj 添加进来；如果是删除事件，就把该 obj 从自身删除。。。</p></li><li><p>sharedProcessor：用于运行用户设置的事件回调函数，里面用 map 存储了所有的 listener，每次调用 AddEventHandler 都会创建一个 listener，同时这个函数可以调用多次，也就是创建多个 listener，当发送事件时，会调用所有的 listener 的对应回调函数</p></li><li><p>controller：上面提到的 Reflector、DeltaFIFO、Indexer 各自有各自的作用，但是它们彼此之间还没有关联起来，而 controller 就是负责这件事的，它是这 3 个组件的协调者，让它们可以协同运作，大致流程是：Reflector 执行 ListAndWatch 将事件 push 到 DeltaFIFO 中，controller 这边会持续从 DeltaFIFO 中 pop 元素，然后根据事件类型对 indexer 进行相应操作（add、update、delete），使得 indexer 中的数据和 api-server 中的保持一致，同时还会调用 sharedProcessor 的对应回调，来完成用户设置的对应事件操作。</p></li></ul><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="Reflector"><a href="#Reflector" class="headerlink" title="Reflector"></a>Reflector</h2><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>下面是一个 reflector 的基本使用示例，大致流程就是编写一个实现了 ListerWatcher 接口的 struct，然后 new 一个 reflector 和 store，最后再启动 reflector 即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// LW 实现了 ListerWatcher 接口</span><br><span class="hljs-keyword">var</span> _ cache.ListerWatcher = &amp;LW&#123;&#125;<br><br><span class="hljs-keyword">type</span> LW <span class="hljs-keyword">struct</span> &#123;<br>ListFunc  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(options metav1.ListOptions)</span></span> (runtime.Object, <span class="hljs-type">error</span>)<br>WatchFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(options metav1.ListOptions)</span></span> (watch.Interface, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LW)</span></span> List(options metav1.ListOptions) (runtime.Object, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> l.ListFunc(options)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LW)</span></span> Watch(options metav1.ListOptions) (watch.Interface, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> l.WatchFunc(options)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ctx := context.TODO()<br>cfg, err := clientcmd.BuildConfigFromFlags(<span class="hljs-string">&quot;&quot;</span>, clientcmd.RecommendedHomeFile)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>cli, err := kubernetes.NewForConfig(cfg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>lw := &amp;LW&#123;<br>    <span class="hljs-comment">// List 具体的实现</span><br>ListFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(opt metav1.ListOptions)</span></span> (runtime.Object, <span class="hljs-type">error</span>) &#123;<br>klog.Info(<span class="hljs-string">&quot;start list...&quot;</span>)<br>      <span class="hljs-comment">// 获取 default namespace 下的所有 pod</span><br><span class="hljs-keyword">return</span> cli.CoreV1().Pods(metav1.NamespaceDefault).List(ctx, opt)<br>&#125;,<br>WatchFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(opt metav1.ListOptions)</span></span> (watch.Interface, <span class="hljs-type">error</span>) &#123;<br>klog.Info(<span class="hljs-string">&quot;start watch...&quot;</span>)<br><span class="hljs-keyword">return</span> cli.CoreV1().Pods(metav1.NamespaceDefault).Watch(ctx, opt)<br>&#125;,<br>&#125;<br><br>  <span class="hljs-comment">// 创建一个 store</span><br>s := cache.NewStore(cache.MetaNamespaceKeyFunc)<br>  <span class="hljs-comment">// 创建一个 reflector</span><br>r := cache.NewReflector(lw, &amp;corev1.Pod&#123;&#125;, s, <span class="hljs-number">0</span>)<br>  <span class="hljs-comment">// 启动 reflector</span><br><span class="hljs-keyword">go</span> r.Run(wait.NeverStop)<br>  <br>  <span class="hljs-comment">// 之后就可以观察 store 的状态了，比如下面这样。。。</span><br>  <span class="hljs-comment">// 可以手动使用 kubectl 对 pod 执行操作，看看这里输出的变化。。。</span><br>  <span class="hljs-keyword">for</span> &#123;<br>  klog.Info(s.ListKeys())<br>    time.Sleep(time.Second*<span class="hljs-number">3</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="types-x2F-Reflector"><a href="#types-x2F-Reflector" class="headerlink" title="types&#x2F;Reflector"></a>types&#x2F;Reflector</h4><p>Reflector struct 有非常多的字段，这里对其进行了截取，只保留了部分与本文相关的关键字段。</p><ul><li>store：在 Informer 中，会由 controller 来创建 Reflector，其提供的 store 实际是 deltaFIFO</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reflector <span class="hljs-keyword">struct</span> &#123;<br>  <span class="hljs-comment">// The destination to sync up with the watch source</span><br>store Store<br><span class="hljs-comment">// listerWatcher is used to perform lists and watches.</span><br>listerWatcher ListerWatcher<br>&#125;<br></code></pre></td></tr></table></figure><p>ListerWatcher 接口定义如下，实际就是组合了 Lister 和 Watcher 两个接口，这个接口分别对应 List 和 Watch 操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ListerWatcher <span class="hljs-keyword">interface</span> &#123;<br>Lister<br>Watcher<br>&#125;<br><br><span class="hljs-comment">// Lister is any object that knows how to perform an initial list.</span><br><span class="hljs-keyword">type</span> Lister <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// List should return a list type object; the Items field will be extracted, and the</span><br><span class="hljs-comment">// ResourceVersion field will be used to start the watch in the right place.</span><br>List(options metav1.ListOptions) (runtime.Object, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-comment">// Watcher is any object that knows how to start a watch on a resource.</span><br><span class="hljs-keyword">type</span> Watcher <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Watch should begin a watch at the specified version.</span><br>Watch(options metav1.ListOptions) (watch.Interface, <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="function-x2F-Run"><a href="#function-x2F-Run" class="headerlink" title="function&#x2F;Run"></a>function&#x2F;Run</h4><p>reflector 的入口函数，用来启动 reflector，其实主要就是调用了 ListAndWatch 这个方法，不过是用 wait.BackoffUntil 又包了一层，<del>这个函数会让其包裹的函数定期执行，所以这里会定期执行  <code>r.ListAndWatch()</code></del> ，直到 stopCh 关闭。</p><div class="note note-warning">            <p>🤔 这里的定期执行 <code>ListAndWatch</code> 有点疑问，定期执行 Watch 操作可以理解，但是定期执行 List 是什么意思？ListAndWatch 不应该是只 List 一次，之后都只执行 Watch 吗？</p><p><code>ListAndWatch</code> 内部会先调用 list() 获取一次全量数据，之后在一个死循环里不断调用 Watch()，所以正常情况下，ListAndWatch 这个方法是不会返回的，所以也不存在定期执行这种说法，用 wait.BackoffUntil 包裹起来，可能是为了发生错误时进行重试。</p>          </div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Run repeatedly uses the reflector&#x27;s ListAndWatch to fetch all the</span><br><span class="hljs-comment">// objects and subsequent deltas.</span><br><span class="hljs-comment">// Run will exit when stopCh is closed.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reflector)</span></span> Run(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>wait.BackoffUntil(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := r.ListAndWatch(stopCh); err != <span class="hljs-literal">nil</span> &#123;<br>r.watchErrorHandler(r, err)<br>&#125;<br>&#125;, r.backoffManager, <span class="hljs-literal">true</span>, stopCh)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="function-x2F-ListAndWatch"><a href="#function-x2F-ListAndWatch" class="headerlink" title="function&#x2F;ListAndWatch"></a>function&#x2F;ListAndWatch</h4><p>该方法会执行以下操作：</p><ol><li>调用 list 拉取数据，list 的具体说明在后面会提到</li><li>开启一个 goroutine，定期执行 resync 操作，所谓的 resync，指的是将 cache 中存在，但是 deltaFIFO 中不存在的元素重新 push 到 deltaFIFO，（前面提到过，r.store 实际是一个 deltaFIFO，然后 deltaFIFO 又有一个 knownObjects 字段用于从本地缓存中获取值，这样就可以比较二者的差异了），具体的内容可以参见 DeltaFIFO 这一节的源码部分的 function&#x2F;Resync 部分。</li><li>之后在一个死循环中不断调用 watch 获取增量数据，然后会调用 watchHandler 对 watch 到的数据进行处理，主要就是根据 watch 到的事件类型去操作 deltaFIFO，比如如果是 Added 事件，那么就将其添加到队列中，然后这些 watch 相关的操作还用 cache.RetryWithDeadline 包了一层，貌似是可以在发生错误时提供一些重试机制。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reflector)</span></span> ListAndWatch(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>klog.V(<span class="hljs-number">3</span>).Infof(<span class="hljs-string">&quot;Listing and watching %v from %s&quot;</span>, r.expectedTypeName, r.name)<br><br>err := r.list(stopCh)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>resyncerrc := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, <span class="hljs-number">1</span>)<br>cancelCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(cancelCh)<br>  <span class="hljs-comment">// 定期 resync</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>resyncCh, cleanup := r.resyncChan()<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>cleanup() <span class="hljs-comment">// Call the last one written into cleanup</span><br>&#125;()<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-resyncCh:<br><span class="hljs-keyword">case</span> &lt;-stopCh:<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> &lt;-cancelCh:<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> r.ShouldResync == <span class="hljs-literal">nil</span> || r.ShouldResync() &#123;<br>klog.V(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">&quot;%s: forcing resync&quot;</span>, r.name)<br><span class="hljs-keyword">if</span> err := r.store.Resync(); err != <span class="hljs-literal">nil</span> &#123;<br>resyncerrc &lt;- err<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>cleanup()<br>resyncCh, cleanup = r.resyncChan()<br>&#125;<br>&#125;()<br><br>retry := NewRetryWithDeadline(r.MaxInternalErrorRetryDuration, time.Minute, apierrors.IsInternalError, r.clock)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// give the stopCh a chance to stop the loop, even in case of continue statements further down on errors</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-stopCh:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br><br>timeoutSeconds := <span class="hljs-type">int64</span>(minWatchTimeout.Seconds() * (rand.Float64() + <span class="hljs-number">1.0</span>))<br>options := metav1.ListOptions&#123;<br>ResourceVersion: r.LastSyncResourceVersion(),<br><span class="hljs-comment">// We want to avoid situations of hanging watchers. Stop any watchers that do not</span><br><span class="hljs-comment">// receive any events within the timeout window.</span><br>TimeoutSeconds: &amp;timeoutSeconds,<br><span class="hljs-comment">// To reduce load on kube-apiserver on watch restarts, you may enable watch bookmarks.</span><br><span class="hljs-comment">// Reflector doesn&#x27;t assume bookmarks are returned at all (if the server do not support</span><br><span class="hljs-comment">// watch bookmarks, it will ignore this field).</span><br>AllowWatchBookmarks: <span class="hljs-literal">true</span>,<br>&#125;<br><br><span class="hljs-comment">// start the clock before sending the request, since some proxies won&#x27;t flush headers until after the first watch event is sent</span><br>start := r.clock.Now()<br>w, err := r.listerWatcher.Watch(options)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// If this is &quot;connection refused&quot; error, it means that most likely apiserver is not responsive.</span><br><span class="hljs-comment">// It doesn&#x27;t make sense to re-list all objects because most likely we will be able to restart</span><br><span class="hljs-comment">// watch where we ended.</span><br><span class="hljs-comment">// If that&#x27;s the case begin exponentially backing off and resend watch request.</span><br><span class="hljs-comment">// Do the same for &quot;429&quot; errors.</span><br><span class="hljs-keyword">if</span> utilnet.IsConnectionRefused(err) || apierrors.IsTooManyRequests(err) &#123;<br>&lt;-r.initConnBackoffManager.Backoff().C()<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>err = watchHandler(start, w, r.store, r.expectedType, r.expectedGVK, r.name, r.expectedTypeName, r.setLastSyncResourceVersion, r.clock, resyncerrc, stopCh)<br>retry.After(err)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err != errorStopRequested &#123;<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> isExpiredError(err):<br><span class="hljs-comment">// Don&#x27;t set LastSyncResourceVersionUnavailable - LIST call with ResourceVersion=RV already</span><br><span class="hljs-comment">// has a semantic that it returns data at least as fresh as provided RV.</span><br><span class="hljs-comment">// So first try to LIST with setting RV to resource version of last observed object.</span><br>klog.V(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">&quot;%s: watch of %v closed with: %v&quot;</span>, r.name, r.expectedTypeName, err)<br><span class="hljs-keyword">case</span> apierrors.IsTooManyRequests(err):<br>klog.V(<span class="hljs-number">2</span>).Infof(<span class="hljs-string">&quot;%s: watch of %v returned 429 - backing off&quot;</span>, r.name, r.expectedTypeName)<br>&lt;-r.initConnBackoffManager.Backoff().C()<br><span class="hljs-keyword">continue</span><br><span class="hljs-keyword">case</span> apierrors.IsInternalError(err) &amp;&amp; retry.ShouldRetry():<br>klog.V(<span class="hljs-number">2</span>).Infof(<span class="hljs-string">&quot;%s: retrying watch of %v internal error: %v&quot;</span>, r.name, r.expectedTypeName, err)<br><span class="hljs-keyword">continue</span><br><span class="hljs-keyword">default</span>:<br>klog.Warningf(<span class="hljs-string">&quot;%s: watch of %v ended with: %v&quot;</span>, r.name, r.expectedTypeName, err)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ListAndWatch 被 BackoffUntil 包裹， BackoffUntil 会定期执行指定的函数，在这里实际是重试操作，因为正常情况下，ListAndWatch 是会在一个死循环中持续处理 watch 事件的，并不会返回，只有当 </p><ol><li>List 发生 err 时 </li><li>初始化 Watch 发生 err 时 </li><li>handle watch 发生部分 err 时（比如网络中断）<br>这个函数才会结束，此时会由 BackoffUntil 重新执行，重新执行意味着会做一次全量的 List 操作。这也意味着如果我们在 watch 过程中发生网络中断等问题，会重新 List 一次全量数据，来弥补这段时间遗漏的事件</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">wait.BackoffUntil(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>klog.Info(<span class="hljs-string">&quot;wait.BackoffUntil callback&quot;</span>)<br><span class="hljs-keyword">if</span> err := r.ListAndWatch(stopCh); err != <span class="hljs-literal">nil</span> &#123;<br>r.watchErrorHandler(r, err)<br>&#125;<br>&#125;, r.backoffManager, <span class="hljs-literal">true</span>, stopCh)<br></code></pre></td></tr></table></figure><h4 id="function-x2F-list"><a href="#function-x2F-list" class="headerlink" title="function&#x2F;list"></a>function&#x2F;list</h4><blockquote><p>TODO: resourceVersion 的作用</p></blockquote><p>这个方法看起来代码量不少，不过感觉核心的其实就是两步：</p><ol><li>调用用户自行实现的 List 方法，获取数据。</li><li>用获取到的数据更新 store。</li></ol><p>其他都是一些繁枝缛节的处理，大部分都是和 List 的行为相关的，比如是分页批量拉取数据，还是全量拉取，还有就是 resourceVersion 这个字段的相关处理，比如拉取后更新已被处理的最新资源对象的 resourceVersion 值之类的。。。这里面最关键的还是 resourceVersion 这个东西，感觉如果想要吃透 list，这个东西必须得好好研究一下，这里暂时先不展开了。。。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// list simply lists all items and records a resource version obtained from the server at the moment of the call.</span><br><span class="hljs-comment">// the resource version can be used for further progress notification (aka. watch).</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reflector)</span></span> list(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">var</span> resourceVersion <span class="hljs-type">string</span><br><span class="hljs-comment">// 设置 ListOptions 的 ResourceVersion，这个字段非常重要，会影响 List 的一些行为，比如是否从 etcd 获取，是否让 limit 生效等等</span><br><span class="hljs-comment">// 这里不会详细阐述该字段的作用了</span><br>options := metav1.ListOptions&#123;ResourceVersion: r.relistResourceVersion()&#125;<br><br><span class="hljs-comment">// 这里删掉了 trace 相关的代码</span><br><span class="hljs-comment">// ...</span><br>  <br><span class="hljs-keyword">var</span> list runtime.Object<br><span class="hljs-keyword">var</span> paginatedResult <span class="hljs-type">bool</span><br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-comment">// 这个 chan 貌似是为了等待执行 list 操作的 goroutine（就是下面的下面这一行开启的）完成？</span><br>listCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br>panicCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>panicCh &lt;- r<br>&#125;<br>&#125;()<br><span class="hljs-comment">// Attempt to gather list in chunks, if supported by listerWatcher, if not, the first</span><br><span class="hljs-comment">// list request will return the full response.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 用 pager 包裹了 r.listerWatcher.List，pager 将尝试以分块的方式批量拉取数据，否则会全量获取</span><br><span class="hljs-comment">//（这里我还没太搞懂如何判断是全量拉取还是分块获取，貌似也是和 ResourceVersion 这个字段有关）</span><br>pager := pager.New(pager.SimplePageFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(opts metav1.ListOptions)</span></span> (runtime.Object, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> r.listerWatcher.List(opts)<br>&#125;))<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> r.WatchListPageSize != <span class="hljs-number">0</span>:<br>pager.PageSize = r.WatchListPageSize<br><span class="hljs-keyword">case</span> r.paginatedResult:<br><span class="hljs-comment">// We got a paginated result initially. Assume this resource and server honor</span><br><span class="hljs-comment">// paging requests (i.e. watch cache is probably disabled) and leave the default</span><br><span class="hljs-comment">// pager size set.</span><br><span class="hljs-keyword">case</span> options.ResourceVersion != <span class="hljs-string">&quot;&quot;</span> &amp;&amp; options.ResourceVersion != <span class="hljs-string">&quot;0&quot;</span>:<br><span class="hljs-comment">// User didn&#x27;t explicitly request pagination.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// With ResourceVersion != &quot;&quot;, we have a possibility to list from watch cache,</span><br><span class="hljs-comment">// but we do that (for ResourceVersion != &quot;0&quot;) only if Limit is unset.</span><br><span class="hljs-comment">// To avoid thundering herd on etcd (e.g. on master upgrades), we explicitly</span><br><span class="hljs-comment">// switch off pagination to force listing from watch cache (if enabled).</span><br><span class="hljs-comment">// With the existing semantic of RV (result is at least as fresh as provided RV),</span><br><span class="hljs-comment">// this is correct and doesn&#x27;t lead to going back in time.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// We also don&#x27;t turn off pagination for ResourceVersion=&quot;0&quot;, since watch cache</span><br><span class="hljs-comment">// is ignoring Limit in that case anyway, and if watch cache is not enabled</span><br><span class="hljs-comment">// we don&#x27;t introduce regression.</span><br>pager.PageSize = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// pager.List 将尝试以分块的方式批量拉取数据</span><br>list, paginatedResult, err = pager.List(context.Background(), options)<br><span class="hljs-keyword">if</span> isExpiredError(err) || isTooLargeResourceVersionError(err) &#123;<br>r.setIsLastSyncResourceVersionUnavailable(<span class="hljs-literal">true</span>)<br><span class="hljs-comment">// Retry immediately if the resource version used to list is unavailable.</span><br><span class="hljs-comment">// The pager already falls back to full list if paginated list calls fail due to an &quot;Expired&quot; error on</span><br><span class="hljs-comment">// continuation pages, but the pager might not be enabled, the full list might fail because the</span><br><span class="hljs-comment">// resource version it is listing at is expired or the cache may not yet be synced to the provided</span><br><span class="hljs-comment">// resource version. So we need to fallback to resourceVersion=&quot;&quot; in all to recover and ensure</span><br><span class="hljs-comment">// the reflector makes forward progress.</span><br>list, paginatedResult, err = pager.List(context.Background(), metav1.ListOptions&#123;ResourceVersion: r.relistResourceVersion()&#125;)<br>&#125;<br><span class="hljs-comment">// 走到这里说明这个 goroutine 执行完成了，关闭 listCh，这样就可以起到通知</span><br><span class="hljs-comment">// 的作用，让下面的 select 得以从阻塞中恢复（其他 case 不满足的情况）</span><br><span class="hljs-built_in">close</span>(listCh)<br>&#125;()<br><span class="hljs-comment">// 这个 select 用于等待上面的 list goroutine 执行完成，然后根据执行结果进行对应的操作，</span><br><span class="hljs-comment">// 除此之外还会监听 stopCh 的状态，如果收到了 stopCh 的信号则直接 return</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-stopCh:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> r := &lt;-panicCh:<span class="hljs-comment">// list goroutine 发生了 panic</span><br><span class="hljs-built_in">panic</span>(r)<br><span class="hljs-keyword">case</span> &lt;-listCh:<span class="hljs-comment">// 等待 list goroutine 执行完成，因为</span><br>&#125;<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>klog.Warningf(<span class="hljs-string">&quot;%s: failed to list %v: %v&quot;</span>, r.name, r.expectedTypeName, err)<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;failed to list %v: %w&quot;</span>, r.expectedTypeName, err)<br>&#125;<br><br><span class="hljs-comment">// We check if the list was paginated and if so set the paginatedResult based on that.</span><br><span class="hljs-comment">// However, we want to do that only for the initial list (which is the only case</span><br><span class="hljs-comment">// when we set ResourceVersion=&quot;0&quot;). The reasoning behind it is that later, in some</span><br><span class="hljs-comment">// situations we may force listing directly from etcd (by setting ResourceVersion=&quot;&quot;)</span><br><span class="hljs-comment">// which will return paginated result, even if watch cache is enabled. However, in</span><br><span class="hljs-comment">// that case, we still want to prefer sending requests to watch cache if possible.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Paginated result returned for request with ResourceVersion=&quot;0&quot; mean that watch</span><br><span class="hljs-comment">// cache is disabled and there are a lot of objects of a given type. In such case,</span><br><span class="hljs-comment">// there is no need to prefer listing from watch cache.</span><br><span class="hljs-keyword">if</span> options.ResourceVersion == <span class="hljs-string">&quot;0&quot;</span> &amp;&amp; paginatedResult &#123;<br>r.paginatedResult = <span class="hljs-literal">true</span><br>&#125;<br>  <br><span class="hljs-comment">// 下面的代码有很多都是和更新 resourceVersion 有关的</span><br><br>r.setIsLastSyncResourceVersionUnavailable(<span class="hljs-literal">false</span>) <span class="hljs-comment">// list was successful</span><br>listMetaInterface, err := meta.ListAccessor(list)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unable to understand list result %#v: %v&quot;</span>, list, err)<br>&#125;<br>resourceVersion = listMetaInterface.GetResourceVersion()<br><br><span class="hljs-comment">// ExtractList 将 obj 的 Items 元素作为 []runtime.Object 返回。如果 obj 不是 List 类型（没有 Items 成员），则返回错误。</span><br>items, err := meta.ExtractList(list)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unable to understand list result %#v (%v)&quot;</span>, list, err)<br>&#125;<br><br><span class="hljs-comment">// 用 list 拿到的 items 更新 store </span><br><span class="hljs-keyword">if</span> err := r.syncWith(items, resourceVersion); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unable to sync list result: %v&quot;</span>, err)<br>&#125;<br><br>r.setLastSyncResourceVersion(resourceVersion)<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="function-x2F-watchHandler"><a href="#function-x2F-watchHandler" class="headerlink" title="function&#x2F;watchHandler"></a>function&#x2F;watchHandler</h4><p>当 watch 到有事件产生时，会执行该函数对事件进行相应的处理，主要就是根据 watch 到的事件类型，对应的去操作 DeltaFIFO 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// watchHandler watches w and sets setLastSyncResourceVersion</span><br><span class="hljs-comment">// 这里省略了一些参数...</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">watchHandler</span><span class="hljs-params">(start time.Time, w watch.Interface, store Store)</span></span> <span class="hljs-type">error</span> &#123;<br>  eventCount := <span class="hljs-number">0</span><br><br><span class="hljs-comment">// Stopping the watcher should be idempotent and if we return from this function there&#x27;s no way</span><br><span class="hljs-comment">// we&#x27;re coming back in with the same watch interface.</span><br><span class="hljs-keyword">defer</span> w.Stop()<br><br>loop:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-comment">// 省略部分代码...</span><br><span class="hljs-comment">// 有事件产生了  </span><br><span class="hljs-keyword">case</span> event, ok := &lt;-w.ResultChan():<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">break</span> loop<br>&#125;<br><span class="hljs-keyword">if</span> event.Type == watch.Error &#123;<br><span class="hljs-keyword">return</span> apierrors.FromObject(event.Object)<br>&#125;<br><span class="hljs-comment">// 省略部分代码...</span><br><span class="hljs-comment">// 判断事件类型，进行相应的处理</span><br><span class="hljs-comment">// 比如如果当前事件是 Added，那么就调用 Add 往 store 中添加一条新数据；</span><br><span class="hljs-comment">// 如果是 Modified 事件，就更新 store 中对应的这条数据；</span><br><span class="hljs-keyword">switch</span> event.Type &#123;<br><span class="hljs-keyword">case</span> watch.Added:<br><span class="hljs-comment">// 这里的 store 实际是 DeltaFIFO，调用的是 DeltaFIFO.Add()</span><br>err := store.Add(event.Object)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to add watch event object (%#v) to store: %v&quot;</span>, name, event.Object, err))<br>&#125;<br><span class="hljs-keyword">case</span> watch.Modified:<br>err := store.Update(event.Object)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to update watch event object (%#v) to store: %v&quot;</span>, name, event.Object, err))<br>&#125;<br><span class="hljs-keyword">case</span> watch.Deleted:<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Will any consumers need access to the &quot;last known</span><br><span class="hljs-comment">// state&quot;, which is passed in event.Object? If so, may need</span><br><span class="hljs-comment">// to change this.</span><br>err := store.Delete(event.Object)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to delete watch event object (%#v) from store: %v&quot;</span>, name, event.Object, err))<br>&#125;<br><span class="hljs-keyword">case</span> watch.Bookmark:<br><span class="hljs-comment">// A `Bookmark` means watch has synced here, just update the resourceVersion</span><br><span class="hljs-keyword">default</span>:<br>utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to understand watch event %#v&quot;</span>, name, event))<br>&#125;<br>setLastSyncResourceVersion(resourceVersion)<br><span class="hljs-keyword">if</span> rvu, ok := store.(ResourceVersionUpdater); ok &#123;<br>rvu.UpdateResourceVersion(resourceVersion)<br>&#125;<br>eventCount++<br>&#125;<br>&#125;<br><span class="hljs-comment">// 省略...</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="Informer"><a href="#Informer" class="headerlink" title="Informer"></a>Informer</h2><h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><h2 id="SharedInformer"><a href="#SharedInformer" class="headerlink" title="SharedInformer"></a>SharedInformer</h2><h3 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h3><h4 id="types-x2F-sharedInformerFactory"><a href="#types-x2F-sharedInformerFactory" class="headerlink" title="types&#x2F;sharedInformerFactory"></a>types&#x2F;sharedInformerFactory</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> sharedInformerFactory <span class="hljs-keyword">struct</span> &#123;<br>   client           kubernetes.Interface<br>   namespace        <span class="hljs-type">string</span><br>   tweakListOptions internalinterfaces.TweakListOptionsFunc<br>   lock             sync.Mutex<br>   defaultResync    time.Duration<br>   customResync     <span class="hljs-keyword">map</span>[reflect.Type]time.Duration<br><br>   informers <span class="hljs-keyword">map</span>[reflect.Type]cache.SharedIndexInformer<br>   <span class="hljs-comment">// startedInformers is used for tracking which informers have been started.</span><br>   <span class="hljs-comment">// This allows Start() to be called multiple times safely.</span><br>   startedInformers <span class="hljs-keyword">map</span>[reflect.Type]<span class="hljs-type">bool</span><br>   <span class="hljs-comment">// wg tracks how many goroutines were started.</span><br>   wg sync.WaitGroup<br>   <span class="hljs-comment">// shuttingDown is true when Shutdown has been called. It may still be running</span><br>   <span class="hljs-comment">// because it needs to wait for goroutines.</span><br>   shuttingDown <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="function-x2F-Start"><a href="#function-x2F-Start" class="headerlink" title="function&#x2F;Start"></a>function&#x2F;Start</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Start initializes all requested informers.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *sharedInformerFactory)</span></span> Start(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>f.lock.Lock()<br><span class="hljs-keyword">defer</span> f.lock.Unlock()<br><br>  <span class="hljs-comment">// 遍历 factory 中已注册的 informer，如果该 informer 还未运行过，则运行它</span><br><span class="hljs-keyword">for</span> informerType, informer := <span class="hljs-keyword">range</span> f.informers &#123;<br><span class="hljs-keyword">if</span> !f.startedInformers[informerType] &#123;<span class="hljs-comment">// 还未运行过</span><br><span class="hljs-keyword">go</span> informer.Run(stopCh)<span class="hljs-comment">// 运行该 informer</span><br>f.startedInformers[informerType] = <span class="hljs-literal">true</span><span class="hljs-comment">// 标记为已运行</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DeltaFIFO"><a href="#DeltaFIFO" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h2><p>DeltaFIFO 是增量队列，主要用来存储 ListAndWatch 发生的事件。</p><p>感觉这块的源码有的地方有点迷，比如有一个 dedupDelats 函数。。。<a href="https://github.com/k8s-club/k8s-club/blob/main/articles/Informer%E6%9C%BA%E5%88%B6%20-%20DeltaFIFO.md">这里</a> 有一些解释，不过老实说我看不太懂。。。</p><h3 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h3><h4 id="types-x2F-DeltaFIFO"><a href="#types-x2F-DeltaFIFO" class="headerlink" title="types&#x2F;DeltaFIFO"></a>types&#x2F;DeltaFIFO</h4><p>主要关注 queue 和 ltems 这两个字段，实际的元素都是存储在这两个字段里面的，其中 queue 只保存了元素的 key，而 items 是一个 map，其存储了 key 到 deltas 的映射，至于为什么要用两个字段去存储，可以参考一下 function&#x2F;Pop 这部分。deltas 是一个切片，存储了该 key 发生的所有事件，每个事件都拥有一个事件类型字段，一些组件会根据事件类型执行不同的操作，比如 controller。</p><p>除此以外还有一个 knownObjects 字段，这是一个接口类型，用于获取本地存储 cache 的一些信息，可以用于 resync 等操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> DeltaFIFO <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// lock/cond protects access to &#x27;items&#x27; and &#x27;queue&#x27;.</span><br>lock sync.RWMutex<br>cond sync.Cond<br><br><span class="hljs-comment">// `items` 将 key 映射到 Delta。</span><br><span class="hljs-comment">// 每个这样的 Deltas 至少有一个 Delta。</span><br>items <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Deltas<br><br><span class="hljs-comment">// `queue` 维护 FIFO 顺序的键以便在 Pop() 中使用。</span><br><span class="hljs-comment">// `queue` 中没有重复项。</span><br><span class="hljs-comment">// 当且仅当键位于 `items` 中时，该 key 才位于 `queue`</span><br>queue []<span class="hljs-type">string</span><br><br><span class="hljs-comment">// populated is true if the first batch of items inserted by Replace() has been populated</span><br><span class="hljs-comment">// or Delete/Add/Update/AddIfNotPresent was called first.</span><br>populated <span class="hljs-type">bool</span><br><span class="hljs-comment">// initialPopulationCount is the number of items inserted by the first call of Replace()</span><br>initialPopulationCount <span class="hljs-type">int</span><br><br><span class="hljs-comment">// keyFunc is used to make the key used for queued item</span><br><span class="hljs-comment">// insertion and retrieval, and should be deterministic.</span><br>keyFunc KeyFunc<br><br><span class="hljs-comment">// knownObjects list keys that are &quot;known&quot; --- affecting Delete(),</span><br><span class="hljs-comment">// Replace(), and Resync()</span><br>knownObjects KeyListerGetter<br><br><span class="hljs-comment">// Used to indicate a queue is closed so a control loop can exit when a queue is empty.</span><br><span class="hljs-comment">// Currently, not used to gate any of CRUD operations.</span><br>closed <span class="hljs-type">bool</span><br><br><span class="hljs-comment">// emitDeltaTypeReplaced is whether to emit the Replaced or Sync</span><br><span class="hljs-comment">// DeltaType when Replace() is called (to preserve backwards compat).</span><br>emitDeltaTypeReplaced <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="type-x2F-Deltas"><a href="#type-x2F-Deltas" class="headerlink" title="type&#x2F;Deltas"></a>type&#x2F;Deltas</h4><p>Deltas 是 DeltaFIFO.items 中存储的 value 类型，实际的底层类型是一个 Delta 切片， </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Deltas []Delta<br><br><span class="hljs-keyword">type</span> Delta <span class="hljs-keyword">struct</span> &#123;<br>Type   DeltaType<br>Object <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// DeltaType is the type of a change (addition, deletion, etc)</span><br><span class="hljs-keyword">type</span> DeltaType <span class="hljs-type">string</span><br><br><span class="hljs-comment">// Change type definition</span><br><span class="hljs-keyword">const</span> (<br>Added   DeltaType = <span class="hljs-string">&quot;Added&quot;</span><br>Updated DeltaType = <span class="hljs-string">&quot;Updated&quot;</span><br>Deleted DeltaType = <span class="hljs-string">&quot;Deleted&quot;</span><br><span class="hljs-comment">// Replaced is emitted when we encountered watch errors and had to do a</span><br><span class="hljs-comment">// relist. We don&#x27;t know if the replaced object has changed.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Previous versions of DeltaFIFO would use Sync for Replace events</span><br><span class="hljs-comment">// as well. Hence, Replaced is only emitted when the option</span><br><span class="hljs-comment">// EmitDeltaTypeReplaced is true.</span><br>Replaced DeltaType = <span class="hljs-string">&quot;Replaced&quot;</span><br><span class="hljs-comment">// Sync is for synthetic events during a periodic resync.</span><br>Sync DeltaType = <span class="hljs-string">&quot;Sync&quot;</span><br>)<br></code></pre></td></tr></table></figure><h4 id="types-x2F-DeltaFIFOOptions"><a href="#types-x2F-DeltaFIFOOptions" class="headerlink" title="types&#x2F;DeltaFIFOOptions"></a>types&#x2F;DeltaFIFOOptions</h4><p>DeltaFIFOOptions 是 DeltaFIFO 的配置参数，所有参数都是可选的。</p><ul><li><p>KeyFunction 实际是  func(obj interface{}) (string, error) 类型，由调用者自行实现，返回可以唯一标识 obj 的，string 类型的 key。</p><p>比如 client-go 中提供了一个 <code>MetaNamespaceKeyFunc</code>，其实现如下：</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MetaNamespaceKeyFunc</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> key, ok := obj.(ExplicitKey); ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(key), <span class="hljs-literal">nil</span><br>&#125;<br>meta, err := meta.Accessor(obj)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;object has no meta: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(meta.GetNamespace()) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> meta.GetNamespace() + <span class="hljs-string">&quot;/&quot;</span> + meta.GetName(), <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> meta.GetName(), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它会用 obj 的 namespace + name 来组成一个 key，形式为 “namespace&#x2F;name”，如果 obj 的 namespace 为空，则返回 name。</p><ul><li>KnownObjects 指定当前 “已知” 的 keys，实际上，在 Informer 中（包括 SharedInformer），创建的 DeltaFIFO 的 KnownObjects 指定的都是 cache.cache 这个 struct（即通过 ListAndWatch 获取的，存储在本地的缓存 cache）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// DeltaFIFOOptions is the configuration parameters for DeltaFIFO. All are</span><br><span class="hljs-comment">// optional.</span><br><span class="hljs-keyword">type</span> DeltaFIFOOptions <span class="hljs-keyword">struct</span> &#123;<br><br><span class="hljs-comment">// KeyFunction is used to figure out what key an object should have. (It&#x27;s</span><br><span class="hljs-comment">// exposed in the returned DeltaFIFO&#x27;s KeyOf() method, with additional</span><br><span class="hljs-comment">// handling around deleted objects and queue state).</span><br><span class="hljs-comment">// Optional, the default is MetaNamespaceKeyFunc.</span><br>KeyFunction KeyFunc<br><br><span class="hljs-comment">// KnownObjects is expected to return a list of keys that the consumer of</span><br><span class="hljs-comment">// this queue &quot;knows about&quot;. It is used to decide which items are missing</span><br><span class="hljs-comment">// when Replace() is called; &#x27;Deleted&#x27; deltas are produced for the missing items.</span><br><span class="hljs-comment">// KnownObjects may be nil if you can tolerate missing deletions on Replace().</span><br>KnownObjects KeyListerGetter<br><br><span class="hljs-comment">// EmitDeltaTypeReplaced indicates that the queue consumer</span><br><span class="hljs-comment">// understands the Replaced DeltaType. Before the `Replaced` event type was</span><br><span class="hljs-comment">// added, calls to Replace() were handled the same as Sync(). For</span><br><span class="hljs-comment">// backwards-compatibility purposes, this is false by default.</span><br><span class="hljs-comment">// When true, `Replaced` events will be sent for items passed to a Replace() call.</span><br><span class="hljs-comment">// When false, `Sync` events will be sent instead.</span><br>EmitDeltaTypeReplaced <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="function-x2F-Resync"><a href="#function-x2F-Resync" class="headerlink" title="function&#x2F;Resync"></a>function&#x2F;Resync</h4><p>比较重要的一个方法，Reflector 的定期 resync 实际调用的就是这个方法，deltaFIFO 会通过 Resync 检查 knownObjects（knownObjects 其实就是本地的缓存 cache），看看和自己当前存储的元素有什么差别，主要是看少了哪些元素，然后把少的这部分 push 到自己的队列中。</p><p>为什么需要 Resync 机制呢？因为在处理 SharedInformer 事件回调时，可能存在处理失败的情况，定时的 Resync 让这些处理失败的事件有了重新 onUpdate 处理的机会。</p><p>比如 Reflector watch 到了一个新事件 A，然后添加到 deltaFIFO，然后 controller 从 deltaFIFO pop 出 A ，传递给用户设置的回调函数，但是很不幸，该回调函数执行失败了，又因为 A 又已经从队列中 pop 出去了，导致无法被再次消费到，从而造成了漏消费。但是有了 Resync 机制后，就可以做一些补偿操作，将遗漏的 delta 重新扔到队列中，得以让回调函数重新消费到。</p><blockquote><p>Resync 的原因，可以参考这个 Issue 里面的回答，感觉写的很不错：[<a href="https://github.com/cloudnativeto/sig-kubernetes/issues/11#top">提问]Informer 中为什么需要引入 Resync 机制？</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *DeltaFIFO)</span></span> Resync() <span class="hljs-type">error</span> &#123;<br>f.lock.Lock()<br><span class="hljs-keyword">defer</span> f.lock.Unlock()<br><br><span class="hljs-keyword">if</span> f.knownObjects == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br>keys := f.knownObjects.ListKeys()<br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> keys &#123;<br><span class="hljs-keyword">if</span> err := f.syncKeyLocked(k); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>会继续调用 syncKeyLocked：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *DeltaFIFO)</span></span> syncKeyLocked(key <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>obj, exists, err := f.knownObjects.GetByKey(key)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>klog.Errorf(<span class="hljs-string">&quot;Unexpected error %v during lookup of key %v, unable to queue object for sync&quot;</span>, err, key)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> !exists &#123;<br>klog.Infof(<span class="hljs-string">&quot;Key %v does not exist in known objects store, unable to queue object for sync&quot;</span>, key)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// If we are doing Resync() and there is already an event queued for that object,</span><br><span class="hljs-comment">// we ignore the Resync for it. This is to avoid the race, in which the resync</span><br><span class="hljs-comment">// comes with the previous value of object (since queueing an event for the object</span><br><span class="hljs-comment">// doesn&#x27;t trigger changing the underlying store &lt;knownObjects&gt;.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果发现 FIFO 队列中已经有相同 key 的 event 进来了，说明该资源对象有了新的 event，</span><br><span class="hljs-comment">// 在 Indexer 中旧的缓存应该失效，因此不做 Resync 处理直接返回 nil</span><br>id, err := f.KeyOf(obj)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> KeyError&#123;obj, err&#125;<br>&#125;<br><span class="hljs-comment">// 如果 f.items 即 deltaFIFO 中已经有这个 key 了，就忽略掉这个 key，不做任何处理？</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(f.items[id]) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 否则重新 push 到 FIFO，并且标记该事件的类型为 Sync</span><br><span class="hljs-keyword">if</span> err := f.queueActionLocked(Sync, obj); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;couldn&#x27;t queue object: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="function-x2F-Replace"><a href="#function-x2F-Replace" class="headerlink" title="function&#x2F;Replace"></a>function&#x2F;Replace</h4><p>这个方法被 Reflector.syncWith() 调用，而 syncWith 又被 Reflector.list() 调用，前面已经提到过，Reflector.list() 的作用是从 api-server 拉取数据，所以传递给 Replace 的 list 参数的内容，就是当前 k8s 的最新数据，Replace 将用最新的数据去更新自己的 item，保证自身数据与远端一致。</p><blockquote><p>TODO：未完成</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *DeltaFIFO)</span></span> Replace(list []<span class="hljs-keyword">interface</span>&#123;&#125;, _ <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>f.lock.Lock()<br><span class="hljs-keyword">defer</span> f.lock.Unlock()<br>keys := <span class="hljs-built_in">make</span>(sets.String, <span class="hljs-built_in">len</span>(list))<br><br><span class="hljs-comment">// keep backwards compat for old clients</span><br>action := Sync<br><span class="hljs-keyword">if</span> f.emitDeltaTypeReplaced &#123;<br>action = Replaced<br>&#125;<br><br><span class="hljs-comment">// Add Sync/Replaced action for each new item.</span><br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> list &#123;<br>key, err := f.KeyOf(item)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> KeyError&#123;item, err&#125;<br>&#125;<br><span class="hljs-comment">// 去重</span><br>keys.Insert(key)<br><span class="hljs-keyword">if</span> err := f.queueActionLocked(action, item); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;couldn&#x27;t enqueue object: %v&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> f.knownObjects == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// Do deletion detection against our own list.</span><br>queuedDeletions := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> k, oldItem := <span class="hljs-keyword">range</span> f.items &#123;<br><span class="hljs-keyword">if</span> keys.Has(k) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// Delete pre-existing items not in the new list.</span><br><span class="hljs-comment">// This could happen if watch deletion event was missed while</span><br><span class="hljs-comment">// disconnected from apiserver.</span><br><span class="hljs-keyword">var</span> deletedObj <span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-keyword">if</span> n := oldItem.Newest(); n != <span class="hljs-literal">nil</span> &#123;<br>deletedObj = n.Object<br>&#125;<br>queuedDeletions++<br><span class="hljs-keyword">if</span> err := f.queueActionLocked(Deleted, DeletedFinalStateUnknown&#123;k, deletedObj&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> !f.populated &#123;<br>f.populated = <span class="hljs-literal">true</span><br><span class="hljs-comment">// While there shouldn&#x27;t be any queued deletions in the initial</span><br><span class="hljs-comment">// population of the queue, it&#x27;s better to be on the safe side.</span><br>f.initialPopulationCount = keys.Len() + queuedDeletions<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Detect deletions not already in the queue.</span><br>knownKeys := f.knownObjects.ListKeys()<br>queuedDeletions := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> knownKeys &#123;<br><span class="hljs-keyword">if</span> keys.Has(k) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>deletedObj, exists, err := f.knownObjects.GetByKey(k)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>deletedObj = <span class="hljs-literal">nil</span><br>klog.Errorf(<span class="hljs-string">&quot;Unexpected error %v during lookup of key %v, placing DeleteFinalStateUnknown marker without object&quot;</span>, err, k)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> !exists &#123;<br>deletedObj = <span class="hljs-literal">nil</span><br>klog.Infof(<span class="hljs-string">&quot;Key %v does not exist in known objects store, placing DeleteFinalStateUnknown marker without object&quot;</span>, k)<br>&#125;<br>queuedDeletions++<br><span class="hljs-keyword">if</span> err := f.queueActionLocked(Deleted, DeletedFinalStateUnknown&#123;k, deletedObj&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> !f.populated &#123;<br>f.populated = <span class="hljs-literal">true</span><br>f.initialPopulationCount = keys.Len() + queuedDeletions<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="function-x2F-Pop"><a href="#function-x2F-Pop" class="headerlink" title="function&#x2F;Pop"></a>function&#x2F;Pop</h4><p>Pop 从 queue 中弹出元素，并调用传入的回调函数 process 对弹出的元素进行处理，如果 queue 中没有元素，则会阻塞等待。</p><div class="note note-warning">            <p>🤔 这里为啥要用 queue 和 items 两个变量来存储？queue 是一个 slice，只存储了 key，然后 item 是一个 map，存储的是 key 到 Deltas 的映射，相当于同一个 key 既存在于 queue 中，也存在于 item 中，然后 pop 会先从 queue 中移除，再从 items 中移除，那为啥不能只用 items 存储？直接遍历 items 然后依次 pop 不就好了吗？难道是因为 pop 对元素的顺序性有要求，所以要额外用一个 queue 来存储？因为 map 遍历是无序的（看起来好像就是这个原因）</p>          </div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *DeltaFIFO)</span></span> Pop(process PopProcessFunc) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>f.lock.Lock()<br><span class="hljs-keyword">defer</span> f.lock.Unlock()<br><span class="hljs-comment">// 没搞懂这个 for 循环是为了啥，好像是为了应对这种情况：一个 key 在 queue 中有，但是 items 中没有，</span><br><span class="hljs-comment">// 如果出现这种情况就会 continue，跳过这个 key，继续从 queue 中 pop 下一个 key，</span><br><span class="hljs-comment">// 直到遇到一个既存在于 queue 中也存在 items 中的 key</span><br><span class="hljs-comment">// 但是什么情况下会出现 &quot;一个 key 在 queue 中有，但是 items 中没有&quot; 这种情况？</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(f.queue) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.</span><br><span class="hljs-comment">// When Close() is called, the f.closed is set and the condition is broadcasted.</span><br><span class="hljs-comment">// Which causes this loop to continue and return from the Pop().</span><br><span class="hljs-keyword">if</span> f.closed &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrFIFOClosed<br>&#125;<br><span class="hljs-comment">// 如果 queue 中没有元素，则 block</span><br>f.cond.Wait()<br>&#125;<br><br><span class="hljs-comment">// 这里为啥要用 queue 和 items 两个变量来存储？</span><br><span class="hljs-comment">// queue 是一个 slice，只存储了 key，然后 item 是一个 map，存储的是 key 到 Deltas 的映射</span><br><span class="hljs-comment">// 相当于同一个 key 既存在于 queue 中，也存在于 item 中</span><br><span class="hljs-comment">// 然后 pop 会先从 queue 中移除，再从 items 中移除</span><br><span class="hljs-comment">// 那为啥不能只用 items 存储？直接遍历 items 然后依次 pop 不就好了吗？</span><br><span class="hljs-comment">// 难道是因为 pop 对元素的顺序性有要求，所以要额外用一个 queue 来存储？因为 map 遍历是无序的（看起来好像就是这个原因）</span><br>id := f.queue[<span class="hljs-number">0</span>]<br>f.queue = f.queue[<span class="hljs-number">1</span>:]<br>depth := <span class="hljs-built_in">len</span>(f.queue)<span class="hljs-comment">// 用于判断是否继续 trace</span><br><span class="hljs-keyword">if</span> f.initialPopulationCount &gt; <span class="hljs-number">0</span> &#123;<br>f.initialPopulationCount--<br>&#125;<br>item, ok := f.items[id]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-comment">// This should never happen</span><br>klog.Errorf(<span class="hljs-string">&quot;Inconceivable! %q was in f.queue but not f.items; ignoring.&quot;</span>, id)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-built_in">delete</span>(f.items, id)<br><span class="hljs-comment">// 删掉了一段 trace depth 的代码，应该不是重点</span><br>    <br><span class="hljs-comment">// 调用传进来的回调函数，对 pop 出来的元素进行处理</span><br>err := process(item)<br><span class="hljs-comment">// 如果执行失败了，重新将 item 添加到 queue 和 items</span><br><span class="hljs-keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;<br>f.addIfNotPresent(id, item)<br>err = e.Err<br>&#125;<br><span class="hljs-comment">// Don&#x27;t need to copyDeltas here, because we&#x27;re transferring</span><br><span class="hljs-comment">// ownership to the caller.</span><br><span class="hljs-keyword">return</span> item, err<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="function-x2F-Add"><a href="#function-x2F-Add" class="headerlink" title="function&#x2F;Add"></a>function&#x2F;Add</h4><p>实际调用的是 queueActionLocked 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Add inserts an item, and puts it in the queue. The item is only enqueued</span><br><span class="hljs-comment">// if it doesn&#x27;t already exist in the set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *DeltaFIFO)</span></span> Add(obj <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>   f.lock.Lock()<br>   <span class="hljs-keyword">defer</span> f.lock.Unlock()<br>   f.populated = <span class="hljs-literal">true</span><br>   <span class="hljs-keyword">return</span> f.queueActionLocked(Added, obj)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="function-x2F-queueActionLocked"><a href="#function-x2F-queueActionLocked" class="headerlink" title="function&#x2F;queueActionLocked()"></a>function&#x2F;queueActionLocked()</h4><p>queueActionLocked 会将 actionType 和 obj 封装为一个 Delta 对象，并 push 到 DeltaFIFO</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// queueActionLocked appends to the delta list for the object.</span><br><span class="hljs-comment">// Caller must lock first.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *DeltaFIFO)</span></span> queueActionLocked(actionType DeltaType, obj <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>id, err := f.KeyOf(obj)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> KeyError&#123;obj, err&#125;<br>&#125;<br>oldDeltas := f.items[id]<br>newDeltas := <span class="hljs-built_in">append</span>(oldDeltas, Delta&#123;actionType, obj&#125;)<br>newDeltas = dedupDeltas(newDeltas)<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(newDeltas) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> _, exists := f.items[id]; !exists &#123;<br>f.queue = <span class="hljs-built_in">append</span>(f.queue, id)<br>&#125;<br>f.items[id] = newDeltas<br>f.cond.Broadcast()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// This never happens, because dedupDeltas never returns an empty list</span><br><span class="hljs-comment">// when given a non-empty list (as it is here).</span><br><span class="hljs-comment">// If somehow it happens anyway, deal with it but complain.</span><br><span class="hljs-keyword">if</span> oldDeltas == <span class="hljs-literal">nil</span> &#123;<br>klog.Errorf(<span class="hljs-string">&quot;Impossible dedupDeltas for id=%q: oldDeltas=%#+v, obj=%#+v; ignoring&quot;</span>, id, oldDeltas, obj)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>klog.Errorf(<span class="hljs-string">&quot;Impossible dedupDeltas for id=%q: oldDeltas=%#+v, obj=%#+v; breaking invariant by storing empty Deltas&quot;</span>, id, oldDeltas, obj)<br>f.items[id] = newDeltas<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Impossible dedupDeltas for id=%q: oldDeltas=%#+v, obj=%#+v; broke DeltaFIFO invariant by storing empty Deltas&quot;</span>, id, oldDeltas, obj)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>🤔 注意这个方法里面调用了一个 <code>dedupDeltas</code> 函数，看了不少博客，都只是简单的解释了一下该函数，说是用来合并相同事件的，但是我看了一下源码却发现这个函数有点迷，它会尝试合并 deltas 中的最后两个 delta，合并条件是如果这两个 delta 都是 delete 事件，但是为啥只合并最后两个？为啥只有两个都是 delete 事件才合并？（源码粘到下面了）</p>          </div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// re-listing and watching can deliver the same update multiple times in any</span><br><span class="hljs-comment">// order. This will combine the most recent two deltas if they are the same.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//尝试合并最后两个 delta，如果这两个 delta 都是 delete 事件的话</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 有点迷的一个函数，为啥只合并最后两个？为啥只有两个都是 delete 事件才合并？</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dedupDeltas</span><span class="hljs-params">(deltas Deltas)</span></span> Deltas &#123;<br>n := <span class="hljs-built_in">len</span>(deltas)<br><span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> deltas<br>&#125;<br>a := &amp;deltas[n<span class="hljs-number">-1</span>]<br>b := &amp;deltas[n<span class="hljs-number">-2</span>]<br><span class="hljs-keyword">if</span> out := isDup(a, b); out != <span class="hljs-literal">nil</span> &#123;<br>deltas[n<span class="hljs-number">-2</span>] = *out<br><span class="hljs-keyword">return</span> deltas[:n<span class="hljs-number">-1</span>]<br>&#125;<br><span class="hljs-keyword">return</span> deltas<br>&#125;<br><br><span class="hljs-comment">// If a &amp; b represent the same event, returns the delta that ought to be kept.</span><br><span class="hljs-comment">// Otherwise, returns nil.</span><br><span class="hljs-comment">// 如果 a &amp; b 表示相同的事件，则返回应保留的增量。否则，返回 nil。</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> is there anything other than deletions that need deduping?</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isDup</span><span class="hljs-params">(a, b *Delta)</span></span> *Delta &#123;<br><span class="hljs-keyword">if</span> out := isDeletionDup(a, b); out != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> out<br>&#125;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Detect other duplicate situations? Are there any?</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// keep the one with the most information if both are deletions.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isDeletionDup</span><span class="hljs-params">(a, b *Delta)</span></span> *Delta &#123;<br><span class="hljs-keyword">if</span> b.Type != Deleted || a.Type != Deleted &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// Do more sophisticated checks, or is this sufficient?</span><br><span class="hljs-keyword">if</span> _, ok := b.Object.(DeletedFinalStateUnknown); ok &#123;<br><span class="hljs-keyword">return</span> a<br>&#125;<br><span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><h3 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h3><h4 id="types-x2F-controller"><a href="#types-x2F-controller" class="headerlink" title="types&#x2F;controller"></a>types&#x2F;controller</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// `*controller` implements Controller</span><br><span class="hljs-keyword">type</span> controller <span class="hljs-keyword">struct</span> &#123;<br>config         Config<br>reflector      *Reflector<br>reflectorMutex sync.RWMutex<br>clock          clock.Clock<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="function-x2F-processLoop"><a href="#function-x2F-processLoop" class="headerlink" title="function&#x2F;processLoop"></a>function&#x2F;processLoop</h4><p>processLoop 会不断从 DeltaFIFO 中 pop 元素（元素实际是 <code>type Deltas []Delta</code> 类型的），并调用 c.config.Process 对 pop 出来的元素进行处理，这个 Process 实际是 sharedIndexInformer.HandleDeltas（如果是 sharedIndexInformer.Run 调用），或者是一个匿名函数（如果是 newInformer 调用），不过这两个函数内部都会进一步调用 processDelta 函数，所以我们只需要重点关注 processDelta 即可，这个函数马上就会提到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// processLoop drains the work queue.</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Consider doing the processing in parallel. This will require a little thought</span><br><span class="hljs-comment">// to make sure that we don&#x27;t end up processing the same object multiple times</span><br><span class="hljs-comment">// concurrently.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Plumb through the stopCh here (and down to the queue) so that this can</span><br><span class="hljs-comment">// actually exit when the controller is stopped. Or just give up on this stuff</span><br><span class="hljs-comment">// ever being stoppable. Converting this whole package to use Context would</span><br><span class="hljs-comment">// also be helpful.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *controller)</span></span> processLoop() &#123;<br>   <span class="hljs-keyword">for</span> &#123;<br>      obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         <span class="hljs-keyword">if</span> err == ErrFIFOClosed &#123;<br>            <span class="hljs-keyword">return</span><br>         &#125;<br>         <span class="hljs-keyword">if</span> c.config.RetryOnError &#123;<br>            <span class="hljs-comment">// This is the safe way to re-enqueue.</span><br>            c.config.Queue.AddIfNotPresent(obj)<br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="function-x2F-processDeltas"><a href="#function-x2F-processDeltas" class="headerlink" title="function&#x2F;processDeltas"></a>function&#x2F;processDeltas</h4><p>processDeltas 用来处理从 DeltaFIFO pop 出来的元素。</p><p>部分参数的作用：</p><ul><li>handler：这是一个接口类型，需要实现 OnAdd、OnUpdate、OnDelete 三个方法，sharedIndexInformer 实现了这个接口，实际会调用 sharedProcessor 的 OnAdd 等方法，而这些方法实际上又是用户自己设置的回调函数</li><li>clientState：不论是 <code>sharedIndexInformer.HandleDeltas</code> 调用还是 <code>newInformer</code> 调用，这个参数实际传递的都是一个 cache.cache。</li><li>deltas：就是从 deltaFIFO 中 pop 出来的元素，Deltas 是 []Delta 的别名类型。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Multiplexes updates in the form of a list of Deltas into a Store, and informs</span><br><span class="hljs-comment">// a given handler of events OnUpdate, OnAdd, OnDelete</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processDeltas</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">// Object which receives event notifications from the given deltas</span></span><br><span class="hljs-params"><span class="hljs-function">handler ResourceEventHandler,</span></span><br><span class="hljs-params"><span class="hljs-function">clientState Store,</span></span><br><span class="hljs-params"><span class="hljs-function">transformer TransformFunc,</span></span><br><span class="hljs-params"><span class="hljs-function">deltas Deltas,</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// from oldest to newest</span><br><span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> deltas &#123;<br>obj := d.Object<br><span class="hljs-keyword">if</span> transformer != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>obj, err = transformer(obj)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">switch</span> d.Type &#123;<br><span class="hljs-keyword">case</span> Sync, Replaced, Added, Updated:<br><span class="hljs-keyword">if</span> old, exists, err := clientState.Get(obj); err == <span class="hljs-literal">nil</span> &amp;&amp; exists &#123;<br>        <span class="hljs-comment">// 更新 indexer 里的数据</span><br><span class="hljs-keyword">if</span> err := clientState.Update(obj); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>        <span class="hljs-comment">// 同时执行用户设置的回调函数</span><br>handler.OnUpdate(old, obj)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> err := clientState.Add(obj); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>handler.OnAdd(obj)<br>&#125;<br><span class="hljs-keyword">case</span> Deleted:<br><span class="hljs-keyword">if</span> err := clientState.Delete(obj); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>handler.OnDelete(obj)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="以下都是待废弃内容"><a href="#以下都是待废弃内容" class="headerlink" title="以下都是待废弃内容"></a>以下都是待废弃内容</h1><h1 id="informers-x2F-factory-go"><a href="#informers-x2F-factory-go" class="headerlink" title="informers&#x2F;factory.go"></a>informers&#x2F;factory.go</h1><h2 id="types"><a href="#types" class="headerlink" title="types"></a>types</h2><h3 id="sharedInformerFactory"><a href="#sharedInformerFactory" class="headerlink" title="sharedInformerFactory"></a>sharedInformerFactory</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> sharedInformerFactory <span class="hljs-keyword">struct</span> &#123;<br>   client           kubernetes.Interface<br>   namespace        <span class="hljs-type">string</span><br>   tweakListOptions internalinterfaces.TweakListOptionsFunc<br>   lock             sync.Mutex<br>   defaultResync    time.Duration<br>   customResync     <span class="hljs-keyword">map</span>[reflect.Type]time.Duration<br><br>   informers <span class="hljs-keyword">map</span>[reflect.Type]cache.SharedIndexInformer<br>   <span class="hljs-comment">// startedInformers is used for tracking which informers have been started.</span><br>   <span class="hljs-comment">// This allows Start() to be called multiple times safely.</span><br>   startedInformers <span class="hljs-keyword">map</span>[reflect.Type]<span class="hljs-type">bool</span><br>   <span class="hljs-comment">// wg tracks how many goroutines were started.</span><br>   wg sync.WaitGroup<br>   <span class="hljs-comment">// shuttingDown is true when Shutdown has been called. It may still be running</span><br>   <span class="hljs-comment">// because it needs to wait for goroutines.</span><br>   shuttingDown <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Start"><a href="#Start" class="headerlink" title="Start()"></a>Start()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-comment">// Start initializes all requested informers.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *sharedInformerFactory)</span></span> Start(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>f.lock.Lock()<br><span class="hljs-keyword">defer</span> f.lock.Unlock()<br><br>  <span class="hljs-comment">// 遍历 factory 中已注册的 informer，如果该 informer 还未运行过，则运行它</span><br><span class="hljs-keyword">for</span> informerType, informer := <span class="hljs-keyword">range</span> f.informers &#123;<br><span class="hljs-keyword">if</span> !f.startedInformers[informerType] &#123;<span class="hljs-comment">// 还未运行过</span><br><span class="hljs-keyword">go</span> informer.Run(stopCh)<span class="hljs-comment">// 运行该 informer</span><br>f.startedInformers[informerType] = <span class="hljs-literal">true</span><span class="hljs-comment">// 标记为已运行</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="InformerFor"><a href="#InformerFor" class="headerlink" title="InformerFor()"></a>InformerFor()</h4><p>InformerFor 填充 sharedInformerFactory 的 informers 字段</p><p>会检查该 type 是否已经注册，如果没注册则会调用传递进来的 newFunc 回调函数进行创建，并注册到 informers 中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// InternalInformerFor returns the SharedIndexInformer for obj using an internal</span><br><span class="hljs-comment">// client.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *sharedInformerFactory)</span></span> InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer &#123;<br>   f.lock.Lock()<br>   <span class="hljs-keyword">defer</span> f.lock.Unlock()<br><br>   <span class="hljs-comment">// 使用反射获取 obj 的类型</span><br>   informerType := reflect.TypeOf(obj)<br>   <span class="hljs-comment">// 查看是否已注册过该 informerType，如果注册过则直接返回，符合了 shared 的定义 </span><br>   informer, exists := f.informers[informerType]<br>   <span class="hljs-keyword">if</span> exists &#123;<br>      <span class="hljs-keyword">return</span> informer<br>   &#125;<br><br>   resyncPeriod, exists := f.customResync[informerType]<br>   <span class="hljs-keyword">if</span> !exists &#123;<br>      resyncPeriod = f.defaultResync<br>   &#125;<br><br>  <span class="hljs-comment">// 走到这里说明 informerType 还未注册过，那么就创建一个 informer 并注册</span><br>   informer = newFunc(f.client, resyncPeriod)<br>   f.informers[informerType] = informer<br><br>   <span class="hljs-keyword">return</span> informer<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>比如有一个 podInformer，它有一个 Informer 方法，该方法会调用 InformerFor</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *podInformer)</span></span> Informer() cache.SharedIndexInformer &#123;<br><span class="hljs-keyword">return</span> f.factory.InformerFor(&amp;corev1.Pod&#123;&#125;, f.defaultInformer)<br>&#125;<br></code></pre></td></tr></table></figure><p>它传递的回调函数是 f.defaultInformer，该函数定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *podInformer)</span></span> defaultInformer(client kubernetes.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer &#123;<br><span class="hljs-keyword">return</span> NewFilteredPodInformer(client, f.namespace, resyncPeriod, cache.Indexers&#123;cache.NamespaceIndex: cache.MetaNamespaceIndexFunc&#125;, f.tweakListOptions)<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数又调用了 NewFilteredPodInformer：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewFilteredPodInformer constructs a new informer for Pod type.</span><br><span class="hljs-comment">// Always prefer using an informer factory to get a shared informer instead of getting an independent</span><br><span class="hljs-comment">// one. This reduces memory footprint and number of connections to the server.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewFilteredPodInformer</span><span class="hljs-params">(client kubernetes.Interface, namespace <span class="hljs-type">string</span>, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc)</span></span> cache.SharedIndexInformer &#123;<br><span class="hljs-keyword">return</span> cache.NewSharedIndexInformer(<br>&amp;cache.ListWatch&#123;<br>ListFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(options metav1.ListOptions)</span></span> (runtime.Object, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> tweakListOptions != <span class="hljs-literal">nil</span> &#123;<br>tweakListOptions(&amp;options)<br>&#125;<br><span class="hljs-keyword">return</span> client.CoreV1().Pods(namespace).List(context.TODO(), options)<br>&#125;,<br>WatchFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(options metav1.ListOptions)</span></span> (watch.Interface, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> tweakListOptions != <span class="hljs-literal">nil</span> &#123;<br>tweakListOptions(&amp;options)<br>&#125;<br><span class="hljs-keyword">return</span> client.CoreV1().Pods(namespace).Watch(context.TODO(), options)<br>&#125;,<br>&#125;,<br>&amp;corev1.Pod&#123;&#125;,<br>resyncPeriod,<br>indexers,<br>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数又调用了 NewSharedIndexInformer ，最终会创建出一个 SharedIndexInformer，该函数定义在 tools&#x2F;cache&#x2F;shared_informer.go</p><h2 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h2><h3 id="NewSharedInformerFactory"><a href="#NewSharedInformerFactory" class="headerlink" title="NewSharedInformerFactory"></a>NewSharedInformerFactory</h3><p>实际调用的是 NewSharedInformerFactoryWithOptions</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewSharedInformerFactory constructs a new instance of sharedInformerFactory for all namespaces.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSharedInformerFactory</span><span class="hljs-params">(client kubernetes.Interface, defaultResync time.Duration)</span></span> SharedInformerFactory &#123;<br>   <span class="hljs-keyword">return</span> NewSharedInformerFactoryWithOptions(client, defaultResync)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NewSharedInformerFactoryWithOptions"><a href="#NewSharedInformerFactoryWithOptions" class="headerlink" title="NewSharedInformerFactoryWithOptions"></a>NewSharedInformerFactoryWithOptions</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewSharedInformerFactoryWithOptions constructs a new instance of a SharedInformerFactory with additional options.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSharedInformerFactoryWithOptions</span><span class="hljs-params">(client kubernetes.Interface, defaultResync time.Duration, options ...SharedInformerOption)</span></span> SharedInformerFactory &#123;<br>   factory := &amp;sharedInformerFactory&#123;<br>      client:           client,<br>      namespace:        v1.NamespaceAll,<br>      defaultResync:    defaultResync,<br>      informers:        <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[reflect.Type]cache.SharedIndexInformer),<br>      startedInformers: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[reflect.Type]<span class="hljs-type">bool</span>),<br>      customResync:     <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[reflect.Type]time.Duration),<br>   &#125;<br><br>   <span class="hljs-comment">// Apply all options</span><br>   <span class="hljs-keyword">for</span> _, opt := <span class="hljs-keyword">range</span> options &#123;<br>      factory = opt(factory)<br>   &#125;<br><br>   <span class="hljs-keyword">return</span> factory<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="tools-x2F-cache-x2F-shared-informer-go"><a href="#tools-x2F-cache-x2F-shared-informer-go" class="headerlink" title="tools&#x2F;cache&#x2F;shared_informer.go"></a>tools&#x2F;cache&#x2F;shared_informer.go</h1><h2 id="types-1"><a href="#types-1" class="headerlink" title="types"></a>types</h2><h3 id="sharedIndexInformer"><a href="#sharedIndexInformer" class="headerlink" title="sharedIndexInformer"></a>sharedIndexInformer</h3><p>sharedIndexInformer 结构体，里面的几个核心属性是用来 list-watch 的 <code>listerWatcher</code>，负责存储的 <code>indexer</code>，负责执行整套流程的的 controller（从 reflector 中 list-watch，从 DefltaFIFO 中 pop 并更新 indexer），负责执行用户设置的 eventHandle 的 processor</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// `*sharedIndexInformer` implements SharedIndexInformer and has three</span><br><span class="hljs-comment">// main components.  One is an indexed local cache, `indexer Indexer`.</span><br><span class="hljs-comment">// The second main component is a Controller that pulls</span><br><span class="hljs-comment">// objects/notifications using the ListerWatcher and pushes them into</span><br><span class="hljs-comment">// a DeltaFIFO --- whose knownObjects is the informer&#x27;s local cache</span><br><span class="hljs-comment">// --- while concurrently Popping Deltas values from that fifo and</span><br><span class="hljs-comment">// processing them with `sharedIndexInformer::HandleDeltas`.  Each</span><br><span class="hljs-comment">// invocation of HandleDeltas, which is done with the fifo&#x27;s lock</span><br><span class="hljs-comment">// held, processes each Delta in turn.  For each Delta this both</span><br><span class="hljs-comment">// updates the local cache and stuffs the relevant notification into</span><br><span class="hljs-comment">// the sharedProcessor.  The third main component is that</span><br><span class="hljs-comment">// sharedProcessor, which is responsible for relaying those</span><br><span class="hljs-comment">// notifications to each of the informer&#x27;s clients.</span><br><span class="hljs-keyword">type</span> sharedIndexInformer <span class="hljs-keyword">struct</span> &#123;<br>   indexer    Indexer<br>   controller Controller<br><br>   processor             *sharedProcessor<br>   cacheMutationDetector MutationDetector<br><br>   listerWatcher ListerWatcher<br><br>   <span class="hljs-comment">// objectType is an example object of the type this informer is</span><br>   <span class="hljs-comment">// expected to handle.  Only the type needs to be right, except</span><br>   <span class="hljs-comment">// that when that is `unstructured.Unstructured` the object&#x27;s</span><br>   <span class="hljs-comment">// `&quot;apiVersion&quot;` and `&quot;kind&quot;` must also be right.</span><br>   objectType runtime.Object<br><br>   <span class="hljs-comment">// resyncCheckPeriod is how often we want the reflector&#x27;s resync timer to fire so it can call</span><br>   <span class="hljs-comment">// shouldResync to check if any of our listeners need a resync.</span><br>   resyncCheckPeriod time.Duration<br>   <span class="hljs-comment">// defaultEventHandlerResyncPeriod is the default resync period for any handlers added via</span><br>   <span class="hljs-comment">// AddEventHandler (i.e. they don&#x27;t specify one and just want to use the shared informer&#x27;s default</span><br>   <span class="hljs-comment">// value).</span><br>   defaultEventHandlerResyncPeriod time.Duration<br>   <span class="hljs-comment">// clock allows for testability</span><br>   clock clock.Clock<br><br>   started, stopped <span class="hljs-type">bool</span><br>   startedLock      sync.Mutex<br><br>   <span class="hljs-comment">// blockDeltas gives a way to stop all event distribution so that a late event handler</span><br>   <span class="hljs-comment">// can safely join the shared informer.</span><br>   blockDeltas sync.Mutex<br><br>   <span class="hljs-comment">// Called whenever the ListAndWatch drops the connection with an error.</span><br>   watchErrorHandler WatchErrorHandler<br><br>   transform TransformFunc<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Run"><a href="#Run" class="headerlink" title="Run()"></a>Run()</h4><p>Run 会调用 s.controller.Run</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *sharedIndexInformer)</span></span> Run(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>   <span class="hljs-keyword">defer</span> utilruntime.HandleCrash()<br><br>   <span class="hljs-keyword">if</span> s.HasStarted() &#123;<br>      klog.Warningf(<span class="hljs-string">&quot;The sharedIndexInformer has started, run more than once is not allowed&quot;</span>)<br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   <span class="hljs-comment">// 创建一个 DeltaFIFO</span><br>   fifo := NewDeltaFIFOWithOptions(DeltaFIFOOptions&#123;<br>      KnownObjects:          s.indexer,<br>      EmitDeltaTypeReplaced: <span class="hljs-literal">true</span>,<br>   &#125;)<br><br>  <span class="hljs-comment">// 配置用来创建 controller 的 Config</span><br>   cfg := &amp;Config&#123;<br>      Queue:            fifo, <span class="hljs-comment">// 设置为 DeltaFIFO</span><br>      ListerWatcher:    s.listerWatcher,<br>      ObjectType:       s.objectType,<br>      FullResyncPeriod: s.resyncCheckPeriod,<br>      RetryOnError:     <span class="hljs-literal">false</span>,<br>      ShouldResync:     s.processor.shouldResync,<br><br>      Process:           s.HandleDeltas,<br>      WatchErrorHandler: s.watchErrorHandler,<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      s.startedLock.Lock()<br>      <span class="hljs-keyword">defer</span> s.startedLock.Unlock()<br><br>     <span class="hljs-comment">// 创建 controller</span><br>      s.controller = New(cfg)<br>      s.controller.(*controller).clock = s.clock<br>      s.started = <span class="hljs-literal">true</span><br>   &#125;()<br><br>   <span class="hljs-comment">// Separate stop channel because Processor should be stopped strictly after controller</span><br>   processorStopCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>   <span class="hljs-keyword">var</span> wg wait.Group<br>   <span class="hljs-keyword">defer</span> wg.Wait()              <span class="hljs-comment">// Wait for Processor to stop</span><br>   <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(processorStopCh) <span class="hljs-comment">// Tell Processor to stop</span><br>   wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)<br>   wg.StartWithChannel(processorStopCh, s.processor.run)<br><br>   <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      s.startedLock.Lock()<br>      <span class="hljs-keyword">defer</span> s.startedLock.Unlock()<br>      s.stopped = <span class="hljs-literal">true</span> <span class="hljs-comment">// Don&#x27;t want any new listeners</span><br>   &#125;()<br>   <span class="hljs-comment">// 运行 controller</span><br>   s.controller.Run(stopCh)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="HandleDeltas"><a href="#HandleDeltas" class="headerlink" title="HandleDeltas()"></a>HandleDeltas()</h4><p>对 DeltaFIFO 中 pop 出的元素进行处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *sharedIndexInformer)</span></span> HandleDeltas(obj <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>s.blockDeltas.Lock()<br><span class="hljs-keyword">defer</span> s.blockDeltas.Unlock()<br><br><span class="hljs-keyword">if</span> deltas, ok := obj.(Deltas); ok &#123;<br>    <span class="hljs-comment">// 又调用了 processDeltas，其中第二个参数传递的是 indexer</span><br><span class="hljs-keyword">return</span> processDeltas(s, s.indexer, s.transform, deltas)<br>&#125;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;object given as Process argument is not Deltas&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="AddEventHandler"><a href="#AddEventHandler" class="headerlink" title="AddEventHandler()"></a>AddEventHandler()</h4><p>添加事件处理函数，但发生事件时（add，update，delete）会调用对应的回调函数，实际调用的是AddEventHandlerWithResyncPeriod，该函数可以调用多次（也就是 add 多个 EventHandler），每次都会创建一个 listener，当发生事件时，会一并通知所有的 listener</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *sharedIndexInformer)</span></span> AddEventHandler(handler ResourceEventHandler) (ResourceEventHandlerRegistration, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> s.AddEventHandlerWithResyncPeriod(handler, s.defaultEventHandlerResyncPeriod)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="AddEventHandlerWithResyncPeriod"><a href="#AddEventHandlerWithResyncPeriod" class="headerlink" title="AddEventHandlerWithResyncPeriod()"></a>AddEventHandlerWithResyncPeriod()</h4><p>该函数会创建一个 listener</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *sharedIndexInformer)</span></span> AddEventHandlerWithResyncPeriod(handler ResourceEventHandler, resyncPeriod time.Duration) (ResourceEventHandlerRegistration, <span class="hljs-type">error</span>) &#123;<br>s.startedLock.Lock()<br><span class="hljs-keyword">defer</span> s.startedLock.Unlock()<br><br><span class="hljs-keyword">if</span> s.stopped &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;handler %v was not added to shared informer because it has stopped already&quot;</span>, handler)<br>&#125;<br><br><span class="hljs-keyword">if</span> resyncPeriod &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> resyncPeriod &lt; minimumResyncPeriod &#123;<br>klog.Warningf(<span class="hljs-string">&quot;resyncPeriod %v is too small. Changing it to the minimum allowed value of %v&quot;</span>, resyncPeriod, minimumResyncPeriod)<br>resyncPeriod = minimumResyncPeriod<br>&#125;<br><br><span class="hljs-keyword">if</span> resyncPeriod &lt; s.resyncCheckPeriod &#123;<br><span class="hljs-keyword">if</span> s.started &#123;<br>klog.Warningf(<span class="hljs-string">&quot;resyncPeriod %v is smaller than resyncCheckPeriod %v and the informer has already started. Changing it to %v&quot;</span>, resyncPeriod, s.resyncCheckPeriod, s.resyncCheckPeriod)<br>resyncPeriod = s.resyncCheckPeriod<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// if the event handler&#x27;s resyncPeriod is smaller than the current resyncCheckPeriod, update</span><br><span class="hljs-comment">// resyncCheckPeriod to match resyncPeriod and adjust the resync periods of all the listeners</span><br><span class="hljs-comment">// accordingly</span><br>s.resyncCheckPeriod = resyncPeriod<br>s.processor.resyncCheckPeriodChanged(resyncPeriod)<br>&#125;<br>&#125;<br>&#125;<br><br>  <span class="hljs-comment">// 创建一个 listener</span><br>listener := newProcessListener(handler, resyncPeriod, determineResyncPeriod(resyncPeriod, s.resyncCheckPeriod), s.clock.Now(), initialBufferSize)<br><br><span class="hljs-keyword">if</span> !s.started &#123;<br><span class="hljs-keyword">return</span> s.processor.addListener(listener), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// in order to safely join, we have to</span><br><span class="hljs-comment">// 1. stop sending add/update/delete notifications</span><br><span class="hljs-comment">// 2. do a list against the store</span><br><span class="hljs-comment">// 3. send synthetic &quot;Add&quot; events to the new handler</span><br><span class="hljs-comment">// 4. unblock</span><br>s.blockDeltas.Lock()<br><span class="hljs-keyword">defer</span> s.blockDeltas.Unlock()<br><br>  <span class="hljs-comment">// 将 listener 添加到 s.processor</span><br>handle := s.processor.addListener(listener)<br>  <span class="hljs-comment">// 遍历当前 indexer 里的所有数据，对所有的 listener 进行通知</span><br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> s.indexer.List() &#123;<br>listener.add(addNotification&#123;newObj: item&#125;)<br>&#125;<br><span class="hljs-keyword">return</span> handle, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="OnAdd"><a href="#OnAdd" class="headerlink" title="OnAdd()"></a>OnAdd()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Conforms to ResourceEventHandler</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *sharedIndexInformer)</span></span> OnAdd(obj <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-comment">// Invocation of this function is locked under s.blockDeltas, so it is</span><br><span class="hljs-comment">// save to distribute the notification</span><br>s.cacheMutationDetector.AddObject(obj)<br>s.processor.distribute(addNotification&#123;newObj: obj&#125;, <span class="hljs-literal">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="OnUpdate"><a href="#OnUpdate" class="headerlink" title="OnUpdate()"></a>OnUpdate()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Conforms to ResourceEventHandler</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *sharedIndexInformer)</span></span> OnUpdate(old, <span class="hljs-built_in">new</span> <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>isSync := <span class="hljs-literal">false</span><br><br><span class="hljs-comment">// If is a Sync event, isSync should be true</span><br><span class="hljs-comment">// If is a Replaced event, isSync is true if resource version is unchanged.</span><br><span class="hljs-comment">// If RV is unchanged: this is a Sync/Replaced event, so isSync is true</span><br><br><span class="hljs-keyword">if</span> accessor, err := meta.Accessor(<span class="hljs-built_in">new</span>); err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> oldAccessor, err := meta.Accessor(old); err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// Events that didn&#x27;t change resourceVersion are treated as resync events</span><br><span class="hljs-comment">// and only propagated to listeners that requested resync</span><br>isSync = accessor.GetResourceVersion() == oldAccessor.GetResourceVersion()<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Invocation of this function is locked under s.blockDeltas, so it is</span><br><span class="hljs-comment">// save to distribute the notification</span><br>s.cacheMutationDetector.AddObject(<span class="hljs-built_in">new</span>)<br>s.processor.distribute(updateNotification&#123;oldObj: old, newObj: <span class="hljs-built_in">new</span>&#125;, isSync)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="OnDelete"><a href="#OnDelete" class="headerlink" title="OnDelete()"></a>OnDelete()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Conforms to ResourceEventHandler</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *sharedIndexInformer)</span></span> OnDelete(old <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-comment">// Invocation of this function is locked under s.blockDeltas, so it is</span><br><span class="hljs-comment">// save to distribute the notification</span><br>s.processor.distribute(deleteNotification&#123;oldObj: old&#125;, <span class="hljs-literal">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sharedProcessor"><a href="#sharedProcessor" class="headerlink" title="sharedProcessor"></a>sharedProcessor</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// sharedProcessor has a collection of processorListener and can</span><br><span class="hljs-comment">// distribute a notification object to its listeners.  There are two</span><br><span class="hljs-comment">// kinds of distribute operations.  The sync distributions go to a</span><br><span class="hljs-comment">// subset of the listeners that (a) is recomputed in the occasional</span><br><span class="hljs-comment">// calls to shouldResync and (b) every listener is initially put in.</span><br><span class="hljs-comment">// The non-sync distributions go to every listener.</span><br><span class="hljs-keyword">type</span> sharedProcessor <span class="hljs-keyword">struct</span> &#123;<br>listenersStarted <span class="hljs-type">bool</span><br>listenersLock    sync.RWMutex<br><span class="hljs-comment">// Map from listeners to whether or not they are currently syncing</span><br>listeners <span class="hljs-keyword">map</span>[*processorListener]<span class="hljs-type">bool</span><br>clock     clock.Clock<br>wg        wait.Group<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="addListener"><a href="#addListener" class="headerlink" title="addListener()"></a>addListener()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *sharedProcessor)</span></span> addListener(listener *processorListener) &#123;<br>p.listenersLock.Lock()<br><span class="hljs-keyword">defer</span> p.listenersLock.Unlock()<br><br>p.addListenerLocked(listener)<br><span class="hljs-keyword">if</span> p.listenersStarted &#123;<br>p.wg.Start(listener.run)<br>p.wg.Start(listener.pop)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="distribute"><a href="#distribute" class="headerlink" title="distribute()"></a>distribute()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *sharedProcessor)</span></span> distribute(obj <span class="hljs-keyword">interface</span>&#123;&#125;, sync <span class="hljs-type">bool</span>) &#123;<br>p.listenersLock.RLock()<br><span class="hljs-keyword">defer</span> p.listenersLock.RUnlock()<br><br><span class="hljs-keyword">for</span> listener, isSyncing := <span class="hljs-keyword">range</span> p.listeners &#123;<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> !sync:<br><span class="hljs-comment">// non-sync messages are delivered to every listener</span><br>listener.add(obj)<br><span class="hljs-keyword">case</span> isSyncing:<br><span class="hljs-comment">// sync messages are delivered to every syncing listener</span><br>listener.add(obj)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// skipping a sync obj for a non-syncing listener</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="processorListener"><a href="#processorListener" class="headerlink" title="processorListener"></a>processorListener</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// processorListener relays notifications from a sharedProcessor to</span><br><span class="hljs-comment">// one ResourceEventHandler --- using two goroutines, two unbuffered</span><br><span class="hljs-comment">// channels, and an unbounded ring buffer.  The `add(notification)`</span><br><span class="hljs-comment">// function sends the given notification to `addCh`.  One goroutine</span><br><span class="hljs-comment">// runs `pop()`, which pumps notifications from `addCh` to `nextCh`</span><br><span class="hljs-comment">// using storage in the ring buffer while `nextCh` is not keeping up.</span><br><span class="hljs-comment">// Another goroutine runs `run()`, which receives notifications from</span><br><span class="hljs-comment">// `nextCh` and synchronously invokes the appropriate handler method.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// processorListener also keeps track of the adjusted requested resync</span><br><span class="hljs-comment">// period of the listener.</span><br><span class="hljs-keyword">type</span> processorListener <span class="hljs-keyword">struct</span> &#123;<br>nextCh <span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;<br>addCh  <span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;<br><br>handler ResourceEventHandler<br><br><span class="hljs-comment">// pendingNotifications is an unbounded ring buffer that holds all notifications not yet distributed.</span><br><span class="hljs-comment">// There is one per listener, but a failing/stalled listener will have infinite pendingNotifications</span><br><span class="hljs-comment">// added until we OOM.</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> This is no worse than before, since reflectors were backed by unbounded DeltaFIFOs, but</span><br><span class="hljs-comment">// we should try to do something better.</span><br>pendingNotifications buffer.RingGrowing<br><br><span class="hljs-comment">// requestedResyncPeriod is how frequently the listener wants a</span><br><span class="hljs-comment">// full resync from the shared informer, but modified by two</span><br><span class="hljs-comment">// adjustments.  One is imposing a lower bound,</span><br><span class="hljs-comment">// `minimumResyncPeriod`.  The other is another lower bound, the</span><br><span class="hljs-comment">// sharedIndexInformer&#x27;s `resyncCheckPeriod`, that is imposed (a) only</span><br><span class="hljs-comment">// in AddEventHandlerWithResyncPeriod invocations made after the</span><br><span class="hljs-comment">// sharedIndexInformer starts and (b) only if the informer does</span><br><span class="hljs-comment">// resyncs at all.</span><br>requestedResyncPeriod time.Duration<br><span class="hljs-comment">// resyncPeriod is the threshold that will be used in the logic</span><br><span class="hljs-comment">// for this listener.  This value differs from</span><br><span class="hljs-comment">// requestedResyncPeriod only when the sharedIndexInformer does</span><br><span class="hljs-comment">// not do resyncs, in which case the value here is zero.  The</span><br><span class="hljs-comment">// actual time between resyncs depends on when the</span><br><span class="hljs-comment">// sharedProcessor&#x27;s `shouldResync` function is invoked and when</span><br><span class="hljs-comment">// the sharedIndexInformer processes `Sync` type Delta objects.</span><br>resyncPeriod time.Duration<br><span class="hljs-comment">// nextResync is the earliest time the listener should get a full resync</span><br>nextResync time.Time<br><span class="hljs-comment">// resyncLock guards access to resyncPeriod and nextResync</span><br>resyncLock sync.Mutex<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="newProcessListener"><a href="#newProcessListener" class="headerlink" title="newProcessListener()"></a>newProcessListener()</h4><p>该函数在 sharedIndexInformer.AddEventHandlerWithResyncPeriod 中调用，创建一个新的 listener</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newProcessListener</span><span class="hljs-params">(handler ResourceEventHandler, requestedResyncPeriod, resyncPeriod time.Duration, now time.Time, bufferSize <span class="hljs-type">int</span>)</span></span> *processorListener &#123;<br>ret := &amp;processorListener&#123;<br>nextCh:                <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;),<br>addCh:                 <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;),<br>handler:               handler,<br>pendingNotifications:  *buffer.NewRingGrowing(bufferSize),<br>requestedResyncPeriod: requestedResyncPeriod,<br>resyncPeriod:          resyncPeriod,<br>&#125;<br><br>ret.determineNextResync(now)<br><br><span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="functions-1"><a href="#functions-1" class="headerlink" title="functions"></a>functions</h2><h3 id="NewSharedIndexInformer"><a href="#NewSharedIndexInformer" class="headerlink" title="NewSharedIndexInformer"></a>NewSharedIndexInformer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewSharedIndexInformer creates a new instance for the listwatcher.</span><br><span class="hljs-comment">// The created informer will not do resyncs if the given</span><br><span class="hljs-comment">// defaultEventHandlerResyncPeriod is zero.  Otherwise: for each</span><br><span class="hljs-comment">// handler that with a non-zero requested resync period, whether added</span><br><span class="hljs-comment">// before or after the informer starts, the nominal resync period is</span><br><span class="hljs-comment">// the requested resync period rounded up to a multiple of the</span><br><span class="hljs-comment">// informer&#x27;s resync checking period.  Such an informer&#x27;s resync</span><br><span class="hljs-comment">// checking period is established when the informer starts running,</span><br><span class="hljs-comment">// and is the maximum of (a) the minimum of the resync periods</span><br><span class="hljs-comment">// requested before the informer starts and the</span><br><span class="hljs-comment">// defaultEventHandlerResyncPeriod given here and (b) the constant</span><br><span class="hljs-comment">// `minimumResyncPeriod` defined in this file.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSharedIndexInformer</span><span class="hljs-params">(lw ListerWatcher, exampleObject runtime.Object, defaultEventHandlerResyncPeriod time.Duration, indexers Indexers)</span></span> SharedIndexInformer &#123;<br>realClock := &amp;clock.RealClock&#123;&#125;<br>sharedIndexInformer := &amp;sharedIndexInformer&#123;<br>processor:                       &amp;sharedProcessor&#123;clock: realClock&#125;,<br>indexer:                         NewIndexer(DeletionHandlingMetaNamespaceKeyFunc, indexers),<br>listerWatcher:                   lw,<br>objectType:                      exampleObject,<br>resyncCheckPeriod:               defaultEventHandlerResyncPeriod,<br>defaultEventHandlerResyncPeriod: defaultEventHandlerResyncPeriod,<br>cacheMutationDetector:           NewCacheMutationDetector(fmt.Sprintf(<span class="hljs-string">&quot;%T&quot;</span>, exampleObject)),<br>clock:                           realClock,<br>&#125;<br><span class="hljs-keyword">return</span> sharedIndexInformer<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="tools-x2F-cache-x2F-controller-go"><a href="#tools-x2F-cache-x2F-controller-go" class="headerlink" title="tools&#x2F;cache&#x2F;controller.go"></a>tools&#x2F;cache&#x2F;controller.go</h1><h2 id="types-2"><a href="#types-2" class="headerlink" title="types"></a>types</h2><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// `*controller` implements Controller</span><br><span class="hljs-keyword">type</span> controller <span class="hljs-keyword">struct</span> &#123;<br>config         Config<br>reflector      *Reflector<br>reflectorMutex sync.RWMutex<br>clock          clock.Clock<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="processLoop"><a href="#processLoop" class="headerlink" title="processLoop()"></a>processLoop()</h4><p>processLoop 会不断从 DeltaFIFO 中 pop 出元素，并调用 c.config.Process 对 pop 出的元素进行处理，这个 Process 实际是 HandleDeltas</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// processLoop drains the work queue.</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Consider doing the processing in parallel. This will require a little thought</span><br><span class="hljs-comment">// to make sure that we don&#x27;t end up processing the same object multiple times</span><br><span class="hljs-comment">// concurrently.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Plumb through the stopCh here (and down to the queue) so that this can</span><br><span class="hljs-comment">// actually exit when the controller is stopped. Or just give up on this stuff</span><br><span class="hljs-comment">// ever being stoppable. Converting this whole package to use Context would</span><br><span class="hljs-comment">// also be helpful.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *controller)</span></span> processLoop() &#123;<br>   <span class="hljs-keyword">for</span> &#123;<br>      obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         <span class="hljs-keyword">if</span> err == ErrFIFOClosed &#123;<br>            <span class="hljs-keyword">return</span><br>         &#125;<br>         <span class="hljs-keyword">if</span> c.config.RetryOnError &#123;<br>            <span class="hljs-comment">// This is the safe way to re-enqueue.</span><br>            c.config.Queue.AddIfNotPresent(obj)<br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Run-1"><a href="#Run-1" class="headerlink" title="Run()"></a>Run()</h4><p>sharedIndexInformer.Run 里会创建一个 DeltaFIFO，并将 config.Queue 设置为这个 DeltaFIFO</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Run begins processing items, and will continue until a value is sent down stopCh or it is closed.</span><br><span class="hljs-comment">// It&#x27;s an error to call Run more than once.</span><br><span class="hljs-comment">// Run blocks; call via go.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *controller)</span></span> Run(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br><span class="hljs-keyword">defer</span> utilruntime.HandleCrash()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-stopCh<br>c.config.Queue.Close()<br>&#125;()<br>  <br><span class="hljs-comment">// 创建一个 reflector 用来 list-watch</span><br>  <span class="hljs-comment">// 这里的 c.config.Queue 实际是一个 DeltaFIFO</span><br>r := NewReflector(<br>c.config.ListerWatcher,<br>c.config.ObjectType,<br>c.config.Queue,<br>c.config.FullResyncPeriod,<br>)<br>r.ShouldResync = c.config.ShouldResync<br>r.WatchListPageSize = c.config.WatchListPageSize<br>r.clock = c.clock<br><span class="hljs-keyword">if</span> c.config.WatchErrorHandler != <span class="hljs-literal">nil</span> &#123;<br>r.watchErrorHandler = c.config.WatchErrorHandler<br>&#125;<br><br>c.reflectorMutex.Lock()<br>c.reflector = r<br>c.reflectorMutex.Unlock()<br><br><span class="hljs-keyword">var</span> wg wait.Group<br><br>wg.StartWithChannel(stopCh, r.Run)<br><br>wait.Until(c.processLoop, time.Second, stopCh)<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>   <span class="hljs-comment">// The queue for your objects - has to be a DeltaFIFO due to</span><br>   <span class="hljs-comment">// assumptions in the implementation. Your Process() function</span><br>   <span class="hljs-comment">// should accept the output of this Queue&#x27;s Pop() method.</span><br>   <span class="hljs-comment">// 应该传递一个 DeltaFIFO 类型的 queue，Process() 中会从该 queue</span><br>   <span class="hljs-comment">// 中 pop 元素进行处理</span><br>   Queue<br><br>   <span class="hljs-comment">// Something that can list and watch your objects.</span><br>   ListerWatcher<br><br>   <span class="hljs-comment">// Something that can process a popped Deltas.</span><br>   <span class="hljs-comment">// Pop 出来的 obj 处理函数</span><br>   Process ProcessFunc<br><br>   <span class="hljs-comment">// ObjectType is an example object of the type this controller is</span><br>   <span class="hljs-comment">// expected to handle.  Only the type needs to be right, except</span><br>   <span class="hljs-comment">// that when that is `unstructured.Unstructured` the object&#x27;s</span><br>   <span class="hljs-comment">// `&quot;apiVersion&quot;` and `&quot;kind&quot;` must also be right.</span><br>   ObjectType runtime.Object<br><br>   <span class="hljs-comment">// FullResyncPeriod is the period at which ShouldResync is considered.</span><br>   FullResyncPeriod time.Duration<br><br>   <span class="hljs-comment">// ShouldResync is periodically used by the reflector to determine</span><br>   <span class="hljs-comment">// whether to Resync the Queue. If ShouldResync is `nil` or</span><br>   <span class="hljs-comment">// returns true, it means the reflector should proceed with the</span><br>   <span class="hljs-comment">// resync.</span><br>   ShouldResync ShouldResyncFunc<br><br>   <span class="hljs-comment">// If true, when Process() returns an error, re-enqueue the object.</span><br>   <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> add interface to let you inject a delay/backoff or drop</span><br>   <span class="hljs-comment">//       the object completely if desired. Pass the object in</span><br>   <span class="hljs-comment">//       question to this interface as a parameter.  This is probably moot</span><br>   <span class="hljs-comment">//       now that this functionality appears at a higher level.</span><br>   RetryOnError <span class="hljs-type">bool</span><br><br>   <span class="hljs-comment">// Called whenever the ListAndWatch drops the connection with an error.</span><br>   WatchErrorHandler WatchErrorHandler<br><br>   <span class="hljs-comment">// WatchListPageSize is the requested chunk size of initial and relist watch lists.</span><br>   WatchListPageSize <span class="hljs-type">int64</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ProcessFunc"><a href="#ProcessFunc" class="headerlink" title="ProcessFunc"></a>ProcessFunc</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ProcessFunc processes a single object.</span><br><span class="hljs-keyword">type</span> ProcessFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure><h2 id="functions-2"><a href="#functions-2" class="headerlink" title="functions"></a>functions</h2><h3 id="New"><a href="#New" class="headerlink" title="New"></a>New</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// New makes a new Controller from the given Config.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(c *Config)</span></span> Controller &#123;<br>   ctlr := &amp;controller&#123;<br>      config: *c,<br>      clock:  &amp;clock.RealClock&#123;&#125;,<br>   &#125;<br>   <span class="hljs-keyword">return</span> ctlr<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="processDeltas"><a href="#processDeltas" class="headerlink" title="processDeltas"></a>processDeltas</h3><p>如果是 HandleDeltas 调用该函数，那么第二个参数传递的是 indexer，那么这里就会根据 pop 的事件类型对 indexer 进行相应操作，同时还传递了一个 handler 参数，这是一个接口类型，需要实现 OnAdd、OnUpdate、OnDelete 三个方法，sharedIndexInformer 实现了这个接口，实际会调用 sharedProcessor 的 OnAdd 等方法，这些方法是用户自己设置的回调函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Multiplexes updates in the form of a list of Deltas into a Store, and informs</span><br><span class="hljs-comment">// a given handler of events OnUpdate, OnAdd, OnDelete</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processDeltas</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">// Object which receives event notifications from the given deltas</span></span><br><span class="hljs-params"><span class="hljs-function">handler ResourceEventHandler,</span></span><br><span class="hljs-params"><span class="hljs-function">clientState Store,</span></span><br><span class="hljs-params"><span class="hljs-function">transformer TransformFunc,</span></span><br><span class="hljs-params"><span class="hljs-function">deltas Deltas,</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// from oldest to newest</span><br><span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> deltas &#123;<br>obj := d.Object<br><span class="hljs-keyword">if</span> transformer != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>obj, err = transformer(obj)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">switch</span> d.Type &#123;<br><span class="hljs-keyword">case</span> Sync, Replaced, Added, Updated:<br><span class="hljs-keyword">if</span> old, exists, err := clientState.Get(obj); err == <span class="hljs-literal">nil</span> &amp;&amp; exists &#123;<br>        <span class="hljs-comment">// 更新 indexer 里的数据</span><br><span class="hljs-keyword">if</span> err := clientState.Update(obj); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>        <span class="hljs-comment">// 同时执行用户设置的回调函数</span><br>handler.OnUpdate(old, obj)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> err := clientState.Add(obj); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>handler.OnAdd(obj)<br>&#125;<br><span class="hljs-keyword">case</span> Deleted:<br><span class="hljs-keyword">if</span> err := clientState.Delete(obj); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>handler.OnDelete(obj)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/k8s-club/k8s-club/blob/main/articles/K8s%20%E7%B3%BB%E5%88%97(%E5%9B%9B)%20-%20%E6%B5%85%E8%B0%88%20Informer.md">K8s 系列(四) - 浅谈 Informer.md</a></p><p><a href="https://cloudnative.to/blog/client-go-informer-source-code/#indexer">深入了解 Kubernetes Informer</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubebuilder 实践</title>
    <link href="/2022/10/03/kubebuilder/"/>
    <url>/2022/10/03/kubebuilder/</url>
    
    <content type="html"><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="下载-kubebuiler"><a href="#下载-kubebuiler" class="headerlink" title="下载 kubebuiler"></a>下载 kubebuiler</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">os=$(go <span class="hljs-built_in">env</span> GOOS)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">arch</span>=$(go <span class="hljs-built_in">env</span> GOARCH)</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -L -o kubebuilder https://go.kubebuilder.io/dl/latest/<span class="hljs-variable">$&#123;os&#125;</span>/<span class="hljs-variable">$&#123;arch&#125;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> +x kubebuilder</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">mv</span> ./kubebuilder /usr/local/bin</span><br></code></pre></td></tr></table></figure><h2 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> operator</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> operator</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go mod init operator.example.com</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">我们将使用 my.domain 域，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">所以所有的 API 组将是&lt;group&gt;.my.domain.</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubebuilder init --domain my.domain</span><br></code></pre></td></tr></table></figure><h2 id="创建一个-API"><a href="#创建一个-API" class="headerlink" title="创建一个 API"></a>创建一个 API</h2><p>运行下面的命令，创建一个新的 API（组&#x2F;版本）为 “webapp&#x2F;v1”，并在上面创建新的 Kind(CRD) “Guestbook”。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubebuilder create api --group webapp --version v1 --kind Guestbook</span><br></code></pre></td></tr></table></figure><h2 id="安装-kustomize"><a href="#安装-kustomize" class="headerlink" title="安装 kustomize"></a>安装 kustomize</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cd</span> 到当前项目目录的 bin 目录下</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> bin</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">go version≥go1.17</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">GOBIN=$(<span class="hljs-built_in">pwd</span>)/ GO111MODULE=on go install sigs.k8s.io/kustomize/kustomize/v4@latest</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前目录下是否下载好 kustomize</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span></span><br>controller-gen kustomize<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>将 CRD 安装到集群中</p><p>这步操作需要你已经安装好 kustomize</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make install<br></code></pre></td></tr></table></figure><p>运行控制器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make run</span><br>go fmt ./...<br>go vet ./...<br>go run ./main.go<br>1.664805588618038e+09   INFO    controller-runtime.metrics      Metrics server is starting to listen    &#123;&quot;addr&quot;: &quot;:8080&quot;&#125;<br>1.664805588619189e+09   INFO    setup   starting manager<br>1.664805588620343e+09   INFO    Starting server &#123;&quot;path&quot;: &quot;/metrics&quot;, &quot;kind&quot;: &quot;metrics&quot;, &quot;addr&quot;: &quot;[::]:8080&quot;&#125;<br>1.664805588620474e+09   INFO    Starting server &#123;&quot;kind&quot;: &quot;health probe&quot;, &quot;addr&quot;: &quot;[::]:8081&quot;&#125;<br>1.664805588620887e+09   INFO    controller.guestbook    Starting EventSource    &#123;&quot;reconciler group&quot;: &quot;webapp.my.domain&quot;, &quot;reconciler kind&quot;: &quot;Guestbook&quot;, &quot;source&quot;: &quot;kind source: *v1.Guestbook&quot;&#125;<br>1.664805588620948e+09   INFO    controller.guestbook    Starting Controller     &#123;&quot;reconciler group&quot;: &quot;webapp.my.domain&quot;, &quot;reconciler kind&quot;: &quot;Guestbook&quot;&#125;<br>1.6648055887228339e+09  INFO    controller.guestbook    Starting workers        &#123;&quot;reconciler group&quot;: &quot;webapp.my.domain&quot;, &quot;reconciler kind&quot;: &quot;Guestbook&quot;, &quot;worker count&quot;: 1&#125;<br><br></code></pre></td></tr></table></figure><p>运行这个 CRD：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f config/samples/</span><br>guestbook.webapp.my.domain/guestbook-sample created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get Guestbook</span><br>NAME               AGE<br>guestbook-sample   33s<br></code></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>继续沿用 <strong>快速入门</strong> 里已经创建好的项目</p><p>注意这里的 group 必须要指定为和 <strong>快速入门</strong> 中相同的 webapp，如果指定为别的，会报错：<code>Error: failed to create API: unable to inject the resource to &quot;base.go.kubebuilder.io/v3&quot;: multiple groups are not allowed by default, to enable multi-group visit https://kubebuilder.io/migration/multi-group.html</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubebuilder create api --group webapp --version v1 --kind CronJob</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker tag 的用处</title>
    <link href="/2022/09/29/docker-tag/"/>
    <url>/2022/09/29/docker-tag/</url>
    
    <content type="html"><![CDATA[<p>docker tag 相当于对镜像做一次备份，将当前的镜像（比如 tag:latest）备份出去一份（比如 tag: v1），然后如果开发了新的镜像，可以直接覆盖掉当前的（tag:latest），然后再给 latest 打个标签：tag:v2，相当于又备份了一份，现在就有了 v1，v2，latest 三个镜像，使用 tag 不仅可以备份镜像，还可以对镜像做标注区分。</p><p>详细可以看下面的例子： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> hello-world-go</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim Dockerfile</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入以下内容</span><br>FROM golang:alpine AS builder<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">为我们的镜像设置必要的环境变量</span><br>ENV GO111MODULE=on \<br>    CGO_ENABLED=0 \<br>    GOOS=linux \<br>    GOARCH=arm64<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">移动到工作目录：/build</span><br>WORKDIR /build<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将代码复制到容器中</span><br>COPY . .<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将我们的代码编译成二进制可执行文件 app</span><br>RUN go build -o app .<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">##################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">接下来创建一个小镜像</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">##################</span></span><br>FROM scratch<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从builder镜像中把/dist/app 拷贝到当前目录</span><br>COPY --from=builder /build/app /<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">需要运行的命令</span><br>ENTRYPOINT [&quot;/app&quot;]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim hello.go</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入以下内容</span><br>package main<br><br>import (<br>        &quot;fmt&quot;<br>)<br><br>func main() &#123;<br>        fmt.Println(&quot;[v1] hello, world!&quot;)<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 go.mod</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go mod init helloworld</span><br>go: creating new go.mod: module helloworld<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">构建镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t hello-world .</span><br>Sending build context to Docker daemon  4.608kB<br>Step 1/8 : FROM golang:alpine AS builder<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">97a79d0cc013</span><br>Step 2/8 : ENV GO111MODULE=on     CGO_ENABLED=0     GOOS=linux     GOARCH=arm64<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Using cache</span><br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">accc05f16e78</span><br>Step 3/8 : WORKDIR /build<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Using cache</span><br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">3cbd504d7581</span><br>Step 4/8 : COPY . .<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">2bb03068056c</span><br>Step 5/8 : RUN go build -o app .<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="hljs-keyword">in</span> 6077f4d304a4</span><br>Removing intermediate container 6077f4d304a4<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">c9509017f175</span><br>Step 6/8 : FROM scratch<br><span class="hljs-meta prompt_"> ---&gt;</span><span class="language-bash"></span><br><span class="language-bash">Step 7/8 : COPY --from=builder /build/app /</span><br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">d97340567693</span><br>Step 8/8 : ENTRYPOINT [&quot;/app&quot;]<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="hljs-keyword">in</span> 7f5508753fa9</span><br>Removing intermediate container 7f5508753fa9<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">1b57ca8ce7d2</span><br>Successfully built 1b57ca8ce7d2<br>Successfully tagged hello-world:latest<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY                TAG       IMAGE ID       CREATED              SIZE<br>hello-world               latest    1b57ca8ce7d2   4 seconds ago        1.82MB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给镜像打个 tag</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag 1b57 hello-world:v1</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次查看镜像，发现已经有了一个新的 tag 为 v1 的镜像，并且 ID 和 latest 相同，相当于有了一份备份</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY                TAG       IMAGE ID       CREATED          SIZE<br>hello-world               latest    1b57ca8ce7d2   2 minutes ago    1.82MB<br>hello-world               v1        1b57ca8ce7d2   2 minutes ago    1.82MB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行镜像查看效果</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run hello-world:v1</span><br>hello, world!<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">现在可以再次开发镜像了，修改 hello.go，将输出内容修改为 [v2]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim hello.go</span><br>package main<br><br>import (<br>        &quot;fmt&quot;<br>)<br><br>func main() &#123;<br>        fmt.Println(&quot;[v2] hello, world!&quot;)<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次构建新版本的镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t hello-world .</span><br>Sending build context to Docker daemon  4.608kB<br>Step 1/8 : FROM golang:alpine AS builder<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">97a79d0cc013</span><br>Step 2/8 : ENV GO111MODULE=on     CGO_ENABLED=0     GOOS=linux     GOARCH=arm64<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Using cache</span><br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">accc05f16e78</span><br>Step 3/8 : WORKDIR /build<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Using cache</span><br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">3cbd504d7581</span><br>Step 4/8 : COPY . .<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Using cache</span><br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">6ee29a59885a</span><br>Step 5/8 : RUN go build -o app .<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="hljs-keyword">in</span> 9e6388ccd40c</span><br>Removing intermediate container 9e6388ccd40c<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">78cb76e165de</span><br>Step 6/8 : FROM scratch<br><span class="hljs-meta prompt_"> ---&gt;</span><span class="language-bash"></span><br><span class="language-bash">Step 7/8 : COPY --from=builder /build/app /</span><br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">9fbd2d306353</span><br>Step 8/8 : ENTRYPOINT [&quot;/app&quot;]<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="hljs-keyword">in</span> 49e410971798</span><br>Removing intermediate container 49e410971798<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">245cbeaf290f</span><br>Successfully built 245cbeaf290f<br>Successfully tagged hello-world:latest<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次查看镜像，新的镜像覆盖掉了之前的 hello-world:latest</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY                TAG       IMAGE ID       CREATED          SIZE<br>hello-world               latest    245cbeaf290f   11 seconds ago   1.82MB<br>hello-world               v1        1b57ca8ce7d2   37 minutes ago   1.82MB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看新镜像的运行效果</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run hello-world</span><br>[v2] hello, world!<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次给新镜像打 tag，相当于做一次备份</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag 245cbeaf290f hello-world:v2</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看现在的 iamge</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY                TAG       IMAGE ID       CREATED          SIZE<br>hello-world               latest    245cbeaf290f   49 seconds ago   1.82MB<br>hello-world               v2        245cbeaf290f   49 seconds ago   1.82MB<br>hello-world               v1        1b57ca8ce7d2   38 minutes ago   1.82MB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看新镜像的运行效果</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run hello-world:v2</span><br>[v2] hello, world!<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run hello-world:v1</span><br>[v1] hello, world!<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">现在就已经有了两个版本的镜像了</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s StatefulSet</title>
    <link href="/2022/09/11/k8s-statefulset/"/>
    <url>/2022/09/11/k8s-statefulset/</url>
    
    <content type="html"><![CDATA[<h1 id="有状态与无状态"><a href="#有状态与无状态" class="headerlink" title="有状态与无状态"></a>有状态与无状态</h1><p><strong>无状态应用</strong>，指的是在运行时不需要维护或跟踪任何特定状态的应用程序。例如，Web 服务器或 API 服务器通常可以处理来自客户端的请求，而无需了解以前的请求或客户端状态。这些应用程序可以很容易地水平扩展，因为它们不需要共享状态，所以可以在任何节点上运行。像 Deployment 也是一个典型的“无状态应用”，它会按照事先声明的模板创建出 pod，这表示每个 pod 的定义将会是一模一样的，此外，这些 pod 之间没有之间没有顺序相关性（什么是顺序相关性？比如一些集群应用包含主节点和从节点，而主节点必须先于从节点启动，这便是顺序相关性），也无所谓在哪台主机上运行，任何一个 pod 都可以提供完全相同的功能，不需要时，也可以结束任意一个 pod。</p><p>相比之下，有状态，指的是那些在运行时需要维护和跟踪特定状态的应用程序，例如数据库或缓存。这些应用程序需要将数据持久化到存储中，并且需要一个唯一的标识符来标识它们的状态。这意味着当应用程序重新启动或迁移到其他节点时，必须能够重新获取其以前的状态。</p><h1 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h1><h2 id="yaml-模板"><a href="#yaml-模板" class="headerlink" title="yaml 模板"></a>yaml 模板</h2><p>下面就是一个 StatefulSet 的 yaml 模板，这个 StatefulSet 中定义了一个包含 3 个副本的 Nginx Pod，每个 Pod 都有一个 PVC 挂载到 &#x2F;data 目录，用于存储应用程序数据。它还定义了一个 Headless Service，名为 example，用于为 Pod 提供唯一的稳定 DNS 名称。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">data</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/data</span><br>  <span class="hljs-attr">volumeClaimTemplates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">data</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">accessModes:</span> [ <span class="hljs-string">&quot;ReadWriteOnce&quot;</span> ]<br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">requests:</span><br>          <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br></code></pre></td></tr></table></figure><p>乍一看和 deployment 的模板非常类似，只是多了 <code>serviceName</code> 和 <code>volumeClaimTemplates</code> 这两个字段，这两个字段的作用如下：</p><ul><li><code>serviceName</code> 指定了与 StatefulSet 相关联的 <strong>Headless Service</strong> 的名称，用于 DNS 解析。</li><li><code>volumeClaimTemplates</code> 指定了 StatefulSet 中每个 Pod 对应的 PersistentVolumeClaim 模板，用于为每个 Pod 创建对应的 PVC。这些 PVC 可以用于存储 StatefulSet 中的数据，从而实现 StatefulSet 的持久化存储。</li></ul><p>所以要想创建 StatefulSet，还需要先创建一个 headless service，用如下的 yaml 来创建一个 headless service：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 该 service 的端口，不指定 targetPort，则默认与 port 相同</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span> <br></code></pre></td></tr></table></figure><p>创建完成后，预期结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get sts</span><br>NAME    READY   AGE<br>nginx   3/3     18m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME      READY   STATUS    RESTARTS   AGE<br>nginx-0   1/1     Running   0          18m<br>nginx-1   1/1     Running   0          17m<br>nginx-2   1/1     Running   0          16m<br></code></pre></td></tr></table></figure><p>现在我们要重点观察的是 <code>volumeClaimTemplates</code> 这个字段的作用，它会 <strong>为每个由 StatefulSet 创建的来的 pod 创建一个 pvc，并进行绑定</strong>。</p><p>查看所有的 pvc，发现现在已经有 3 个 pvc 了，并且它们的命名格式都是 &lt;volumeClaimTemplates.metadata.name&gt;-&lt;statefulSet.name&gt;-&lt;连续的序号&gt;。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pvc</span><br>NAME           STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE<br>data-nginx-0   Bound    pvc-03e2e475-c81b-47c6-932f-40a758640628   1Gi        RWO            local-path     21m<br>data-nginx-1   Bound    pvc-71776884-824a-4773-8a4d-a626b0381329   1Gi        RWO            local-path     20m<br>data-nginx-2   Bound    pvc-bf9d7f67-f59a-42e9-a1c1-03c29887dbbf   1Gi        RWO            local-path     20m<br></code></pre></td></tr></table></figure><p>我们再查看一下每个 pod 绑定的 pvc：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods -l app=nginx -o=jsonpath=<span class="hljs-string">&#x27;&#123;range .items[*]&#125;&#123;&quot;Pod Name: &quot;&#125;&#123;.metadata.name&#125; &#123;&quot;\t&quot;&#125; &#123;&quot;PVC Name: &quot;&#125;&#123;.spec.volumes[*].persistentVolumeClaim.claimName&#125;&#123;&quot;\n&quot;&#125;&#123;end&#125;&#x27;</span></span><br><br>Pod Name: nginx-0  PVC Name: data-nginx-0<br>Pod Name: nginx-1  PVC Name: data-nginx-1<br>Pod Name: nginx-2  PVC Name: data-nginx-2<br></code></pre></td></tr></table></figure><p>发现了吗，每个 pod 绑定的 pvc 的名字都是有规可循的，</p><blockquote><p>突发奇想：如果删除某个 pvc 会发生什么？</p><p>实践了一下，发现执行了 <code>kubectl delete pvc data-nginx-0</code> 后，会输出 <code>persistentvolumeclaim &quot;data-nginx-0&quot; deleted</code>，然后整个终端就阻塞了，按 <code>Ctrl+c</code> 强制退出后，这个 pvc 的 Status 变为 Terminating，但是对应的 pod 仍然为 Running 状态</p></blockquote><p>然后我们再尝试向 pod 挂载的目录里创建一个文件，并像文件内写入一条数据，然后删除这个 pod，看看会发生什么。</p><p>首先先创建文件并写入数据，我们这里写入的对象 pod 是 nginx-0：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it nginx-0 -- /bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cd</span> 到挂载目录</span><br>root@nginx-0:/# cd /data<br>root@nginx-0:/data# ls<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在该目录下创建文件并写入内容</span><br>root@nginx-0:/data# echo &quot;test&quot; &gt; test.txt<br>root@nginx-0:/data# ls<br>test.txt<br>root@nginx-0:/data# cat test.txt<br>test<br></code></pre></td></tr></table></figure><p>然后删除这个 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">删除前先看一下当前所有的 pod</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME      READY   STATUS    RESTARTS   AGE<br>nginx-0   1/1     Running   0          4d22h<br>nginx-1   1/1     Running   0          4d22h<br>nginx-2   1/1     Running   0          4d22h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删掉 nginx-0</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete po nginx-0</span><br>pod &quot;nginx-0&quot; deleted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看删除后效果</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME      READY   STATUS    RESTARTS   AGE<br>nginx-1   1/1     Running   0          4d22h<br>nginx-2   1/1     Running   0          4d22h<br>nginx-0   0/1     Pending   0          3s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">等待一会，nginx-0 会重新建出来</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po -w</span><br>NAME      READY   STATUS              RESTARTS   AGE<br>nginx-1   1/1     Running             0          4d22h<br>nginx-2   1/1     Running             0          4d22h<br>nginx-0   0/1     ContainerCreating   0          5s<br>nginx-0   1/1     Running             0          5s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次查看 pod 的挂载目录</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it nginx-0 -- <span class="hljs-built_in">ls</span> /data</span><br>test.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it nginx-0 -- <span class="hljs-built_in">cat</span> /data/test.txt</span><br>test<br></code></pre></td></tr></table></figure><p>通过上面的实践，我们发现删除 pod 后，StatefulSet 会自动重建 pod，并且重要的是，<strong>重建的 pod 名字和先前的会保持一致</strong>，我们删掉了 nginx-0 ，然后重建出来的 pod 也叫 nginx-0，又因为名字和先前的一致，按照 pvc 的绑定规则，它依然会绑定到 data-nginx-0 这个 pvc，进而挂载到和这个 pvc 绑定的 pv。这也表明，删除 pod 并不会删除其对应的 pvc 和 pv，所以 pod 对应的数据才会安全的保存。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>创建一个 handless service：</p><p><strong>kubia-service-headless.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f kubia-service-headless.yaml</span><br>service/kubia created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME                     TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE<br>kubernetes               ClusterIP   10.43.0.1      &lt;none&gt;        443/TCP   32h<br>kubia                    ClusterIP   None           &lt;none&gt;        80/TCP    9s<br></code></pre></td></tr></table></figure><p>准备一个程序用来测试，这是一个 HTTP 程序，如果发送 POST 请求，那么会在指定目录下创建&#x2F;打开一个文件，并将请求体内容写入该文件；如果发送 GET 请求，会在指定目录下读取文件内容，并作为 response 返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">const</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;os&#x27;</span>);<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-keyword">const</span> dataFile = <span class="hljs-string">&quot;/var/data/kubia.txt&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fileExists</span>(<span class="hljs-params">file</span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    fs.<span class="hljs-title function_">statSync</span>(file);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> handler = <span class="hljs-keyword">function</span>(<span class="hljs-params">request, response</span>) &#123;<br>  <span class="hljs-keyword">if</span> (request.<span class="hljs-property">method</span> == <span class="hljs-string">&#x27;POST&#x27;</span>) &#123;<br>    <span class="hljs-keyword">var</span> file = fs.<span class="hljs-title function_">createWriteStream</span>(dataFile);<br>    file.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">fd</span>) &#123;<br>      request.<span class="hljs-title function_">pipe</span>(file);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;New data has been received and stored.&quot;</span>);<br>      response.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>);<br>      response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;Data stored on pod &quot;</span> + os.<span class="hljs-title function_">hostname</span>() + <span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">var</span> data = <span class="hljs-title function_">fileExists</span>(dataFile) ? fs.<span class="hljs-title function_">readFileSync</span>(dataFile, <span class="hljs-string">&#x27;utf8&#x27;</span>) : <span class="hljs-string">&quot;No data posted yet&quot;</span>;<br>    response.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>);<br>    response.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;You&#x27;ve hit &quot;</span> + os.<span class="hljs-title function_">hostname</span>() + <span class="hljs-string">&quot;\n&quot;</span>);<br>    response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;Data stored on this pod: &quot;</span> + data + <span class="hljs-string">&quot;\n&quot;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> www = http.<span class="hljs-title function_">createServer</span>(handler);<br>www.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>);<br></code></pre></td></tr></table></figure><p>对应的 Dockerfile，注意这里使用的是 arm64 类型的镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> arm64v8/node:<span class="hljs-number">7</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> app.js /app.js</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;app.js&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>kubia-statefulset.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">kubia</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span> <span class="hljs-comment"># has to match .spec.template.metadata.labels</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/kubia-pet-arm64</span> <span class="hljs-comment"># 注意这里更换成了 arm64 架构的</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>          <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">data</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/data</span><br>  <span class="hljs-attr">volumeClaimTemplates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">data</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">requests:</span><br>          <span class="hljs-attr">storage:</span> <span class="hljs-string">1Mi</span><br>      <span class="hljs-attr">accessModes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f kubia-statefulset.yaml</span><br>statefulset.apps/kubia created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME             READY   STATUS    RESTARTS       AGE<br>kubia-0          1/1     Running   0              61s<br>kubia-1          1/1     Running   0              26s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pvc</span><br>NAME             STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE<br>local-path-pvc   Bound    pvc-0e7db0b6-fa32-4c2e-ac0c-53a354ead8a4   50Mi       RWO            local-path     21h<br>data-kubia-0     Bound    pvc-b2742307-c5d5-4402-a9a6-54730d60c4a3   1Mi        RWO            local-path     62m<br>data-kubia-1     Bound    pvc-28570e23-c08a-4610-8b6e-cc35434ded21   1Mi        RWO            local-path     61m<br></code></pre></td></tr></table></figure><p>使用 API server 访问 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl proxy</span><br>Starting to serve on 127.0.0.1:8001<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/</span><br>You&#x27;ve hit kubia-0<br>Data stored on this pod: No data posted yet<br></code></pre></td></tr></table></figure><p>本次发送的是 GET 请求，因为还没有发送过 POST 请求，所以文件还不存在，所以返回 No data posted yet</p><p>发送一个 POST 请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -X POST -d <span class="hljs-string">&quot;Hey there! This greeting was submitted to kubia-0.&quot;</span> localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/</span><br>Data stored on pod kubia-0<br></code></pre></td></tr></table></figure><p>此时已经将请求体里的内容保存在了容器内</p><p>再次发送 GET 请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/</span><br>You&#x27;ve hit kubia-0<br>Data stored on this pod: Hey there! This greeting was submitted to kubia-0.<br></code></pre></td></tr></table></figure><p>再次发送请求，发现可以输出文件内容了</p><p>现在删除一个 statefulset，看看其保存的数据会不会丢失：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete po kubia-0</span><br>pod &quot;kubia-0&quot; deleted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                                  READY   STATUS    RESTARTS   AGE<br>kubia-1                               1/1     Running   0          12h<br>kubia-0                               1/1     Running   0          27s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/</span><br>You&#x27;ve hit kubia-0<br>Data stored on this pod: Hey there! This greeting was submitted to kubia-0.<br></code></pre></td></tr></table></figure><p>发现该 po 被删除后立马就重新创建出了一个新的，并且名字与与之前被删除的 pod 完全相同，并且其存储的数据也没有丢失</p><h1 id="在-statefulset-中发现伙伴节点"><a href="#在-statefulset-中发现伙伴节点" class="headerlink" title="在 statefulset 中发现伙伴节点"></a>在 statefulset 中发现伙伴节点</h1><p>之前以已经创建了一个 handless service，通过解析（lookup）这个 service 的 dns 便可获取其管辖的所有 pod 的 ip，那么 pod 就可以通过这种方式来获取同属于一个 service 下的其他 pod 的地址，进而完成通信。下面就来实践一下：</p><p>首先来尝试一下获取 handless service 下所有 pod 的 SRV 记录：</p><blockquote><p><strong>什么是 SRV 记录？</strong></p></blockquote><p>查看 handless service 的 SRV 记录：</p><blockquote><p>PS: 书里写的是 –image&#x3D;tutum&#x2F;dnstuils，但是这个镜像是 amd64 的，所以我重新做了一个镜像：stdoutt&#x2F;dnstuils-arm64</p><p>附：该镜像的 Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:trusty<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -yq dnsutils &amp;&amp; apt-get clean &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists</span><br></code></pre></td></tr></table></figure></blockquote><p>具体操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">先看一下 handless service 的 name</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE<br>kubernetes   ClusterIP   10.43.0.1    &lt;none&gt;        443/TCP   2d3h<br>kubia        ClusterIP   None         &lt;none&gt;        80/TCP    12s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 kubia 这个 service 的 SRV 记录（该 service 的完整域名是 kubia.default.svc.cluster.local ），这个 pod 在</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行完毕后会立马删除，这里使用的是 stdoutt/dnsutils-arm64 这个适用于 arm64 的镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl run -it srvlookup --image=stdoutt/dnsutils-arm64 --<span class="hljs-built_in">rm</span> --restart=Never -- dig SRV kubia.default.svc.cluster.local</span><br><br>; &lt;&lt;&gt;&gt; DiG 9.9.5-3ubuntu0.19-Ubuntu &lt;&lt;&gt;&gt; SRV kubia.default.svc.cluster.local<br>;; global options: +cmd<br>;; Got answer:<br>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 24375<br>;; flags: qr aa rd; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 3<br>;; WARNING: recursion requested but not available<br><br>;; OPT PSEUDOSECTION:<br>; EDNS: version: 0, flags:; udp: 4096<br>;; QUESTION SECTION:<br>;kubia.default.svc.cluster.local. INSRV<br><br>;; ANSWER SECTION:<br>kubia.default.svc.cluster.local. 5 INSRV0 50 80 kubia-0.kubia.default.svc.cluster.local.<br>kubia.default.svc.cluster.local. 5 INSRV0 50 80 kubia-1.kubia.default.svc.cluster.local.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里便获取到了该 service 下的所有 pod 的 ip 地址</span><br>;; ADDITIONAL SECTION:<br>kubia-1.kubia.default.svc.cluster.local. 5 IN A10.42.0.22<br>kubia-0.kubia.default.svc.cluster.local. 5 IN A10.42.0.23<br><br>;; Query time: 12 msec<br>;; SERVER: 10.43.0.10#53(10.43.0.10)<br>;; WHEN: Mon Sep 26 16:37:29 UTC 2022<br>;; MSG SIZE  rcvd: 350<br><br>pod &quot;srvlookup&quot; deleted<br></code></pre></td></tr></table></figure><h1 id="使用-StatefulSet-搭建一个-MySQL-集群"><a href="#使用-StatefulSet-搭建一个-MySQL-集群" class="headerlink" title="使用 StatefulSet 搭建一个 MySQL 集群"></a>使用 StatefulSet 搭建一个 MySQL 集群</h1><p>主节点和从节点需要不同的配置文件，可以通过一个 configmap 定义，如下所示，这里定义了 master.cnf 和 slave.cnf 两个 MySQL 的配置文件。</p><ul><li>master.cnf 开启了 log-bin，即使用二进制日志文件的方式进行主从复制，这是一个标准的设置。</li><li>slave.cnf 开启了 super-read-only，表示从节点会拒绝除主节点的数据同步操作外的所有写操作，即它对用户是只读的。</li></ul><p><strong>mysql-configmap.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">mysql</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">primary.cnf:</span> <span class="hljs-string">|</span><br><span class="hljs-string">    # 仅在主服务器上应用此配置</span><br><span class="hljs-string">    [mysqld]</span><br><span class="hljs-string">    log-bin    </span><br><span class="hljs-string"></span>  <span class="hljs-attr">replica.cnf:</span> <span class="hljs-string">|</span><br><span class="hljs-string">    # 仅在副本服务器上应用此配置</span><br><span class="hljs-string">    [mysqld]</span><br><span class="hljs-string">    super-read-only  </span><br></code></pre></td></tr></table></figure><blockquote><p>ps：也可以使用下面的命令 <code>&lt;&lt;EOF</code> 写入到文件，它将持续读取你的多行输入，直到你输入一个 EOF。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &lt;&lt;EOF &gt; mysql-configmap.yaml<br>apiVersion: v1<br>kind: ConfigMap<br>metadata:<br>  name: mysql<br>  labels:<br>    app: mysql<br>    app.kubernetes.io/name: mysql<br>data:<br>  primary.cnf: |<br>    # 仅在主服务器上应用此配置<br>    [mysqld]<br>    log-bin<br>  replica.cnf: |<br>    # 仅在副本服务器上应用此配置<br>    [mysqld]<br>    super-read-only<br>EOF<br></code></pre></td></tr></table></figure></blockquote><p>创建这个 cm：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f mysql-configmap.yaml</span><br>configmap/mysql created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get cm</span><br>NAME               DATA   AGE<br>kube-root-ca.crt   1      5d22h<br>mysql              2      27s<br></code></pre></td></tr></table></figure><p>接下来，需要创建两个 Service 来供 StatefulSet 以及用户使用。这两个 Service 的定义如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 为 StatefulSet 成员提供稳定的 DNS 表项的无头服务（Headless Service）</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">mysql</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">3306</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 用于连接到任一 MySQL 实例执行读操作的客户端服务</span><br><span class="hljs-comment"># 对于写操作，你必须连接到主服务器：mysql-0.mysql</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-read</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">readonly:</span> <span class="hljs-string">&quot;true&quot;</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">3306</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span><br></code></pre></td></tr></table></figure><p>这两个 Service 都代理了含有 label <code>app: mysql</code> 的 Pod，端口映射都是用 Service 的 3306 端口对应 Pod 的 3306 端口，并且其中一个 Service 是 Headless Service（即 ClusterIP 为 None），它将为其代理的 Pod 分配一个 DNS 记录来固定其拓扑状态</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu arm64 使用 apt-get 安装 docker，以及 snap 的一些问题记录</title>
    <link href="/2022/09/10/ubuntu-arm64-an-zhuang-docker/"/>
    <url>/2022/09/10/ubuntu-arm64-an-zhuang-docker/</url>
    
    <content type="html"><![CDATA[<p>使用 snap 可以比较方便的安装 docker，但是有一次出现了 k8s pod 无法拉取镜像的问题，看了下 pod describe，发现是因为走代理的问题（我使用的是 ubuntu 虚拟机，连接宿主机的 clashx 进行代理），连接的代理是宿主机的老地址 192.168.2.5，但是因为重启过路由器，所以宿主机的地址变更为了 192.168.2.3，代理不通自然也拉取不了镜像了，报错：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Failed <span class="hljs-keyword">to</span> pull image &quot;redis&quot;: rpc error: code = <span class="hljs-type">Unknown</span> <span class="hljs-keyword">desc</span> = Error response <span class="hljs-keyword">from</span> daemon: <span class="hljs-keyword">Get</span> &quot;https://registry-1.docker.io/v2/&quot;: proxyconnect tcp: dial tcp <span class="hljs-number">192.168</span><span class="hljs-number">.2</span><span class="hljs-number">.5</span>:<span class="hljs-number">7890</span>: <span class="hljs-keyword">connect</span>: <span class="hljs-keyword">connection</span> refused<br></code></pre></td></tr></table></figure><p>虽然我重新设置了 https_proxy 等相关环境变量，并且 curl google 可以正常返回，但是 pod 这边依旧无法拉取，走的还是 192.168.2.5 这个地址。</p><p>于是我就尝试重启一下 docker 看能不能解决，按照网上提供的几个方案，<code>systemctl restart docker</code>，报错：<code>Failed to restart docker.service: Unit docker.service not found.</code>，于是我又尝试使用 <code>snap restart docker</code>，发现可以重启成功，输出信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Run service command &quot;restart&quot; for running services of snap &quot;docker&quot;<br>Restarted.<br></code></pre></td></tr></table></figure><p>看起来已经重启成功了，但是等我执行 docker ps 时，直接报错：<code>docker ps Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</code>，根本就没重启成功！于是我又尝试执行 <code>snap start docker </code> 命令，返回 <code>Started.</code>，但是然并卵，依然报之前的错误，实属是个坑爹玩意。</p><p>没得办法，只能从 snap 中删掉 docker，再重新使用 apt-get 安装了，但是 apt-get 安装就略有繁琐了，参照 <a href="https://zhuanlan.zhihu.com/p/143156163">这篇文章</a> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common<br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意这一步，<span class="hljs-built_in">arch</span> 这里，要根据你的机器架构来指定，通常是 arm64 或者是 amd64，我一开始就是直接复制文章中的命令，导致加入的是</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">amd64 的软件源，而我的机器是 arm 的，导致后面安装 docker 失败</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以使用 <span class="hljs-built_in">uname</span> -c（ubuntu 下是 <span class="hljs-built_in">arch</span>）查看机器的架构</span><br>sudo add-apt-repository &quot;deb [arch=arm64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者可以直接这样，就能自动下载符合机器架构的包：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">⚠️：这个方法不行，因为 amd64 架构的机器执行 <span class="hljs-built_in">arch</span> 显示的是 x86_64，而实际需要执行的参数为 amd64</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">sudo add-apt-repository <span class="hljs-string">&quot;deb [arch=<span class="hljs-subst">$(arch)</span>] https://download.docker.com/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span></span><br><br>sudo apt update<br>sudo apt install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><p>为了方便，直接贴出所有的安装命令：</p><p>amd64：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common -y<br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -<br>sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;<br>sudo apt update<br>sudo apt install docker-ce docker-ce-cli containerd.io -y<br></code></pre></td></tr></table></figure><p>arm64：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common -y<br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -<br>sudo add-apt-repository &quot;deb [arch=arm64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;<br>sudo apt update<br>sudo apt install docker-ce docker-ce-cli containerd.io -y<br></code></pre></td></tr></table></figure><p>使用 apt-get 安装的 docker 就可以使用 systemctl 操作了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl restart docker</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>issue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GoLand/Idea 启动闪退，报错 NSInternalInconsistencyException 的解决方法</title>
    <link href="/2022/09/08/jetbrain_crash/"/>
    <url>/2022/09/08/jetbrain_crash/</url>
    
    <content type="html"><![CDATA[<p>环境：</p><ul><li>机器：MacBook Air (M1, 2020)</li><li>系统：MacOS 12.5.1</li><li>Goland 版本：2022.2.2</li><li>Idea 版本：2022.1.1</li></ul><p>今天启动 GoLand 发现会立马闪退，提示程序意外退出，后来又试了下 Idea 和 Clion，发现全部都是如此，尝试在终端启动查看错误信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> ~/Library/Application\ Support/JetBrains/Toolbox/apps/Goland/ch-0/222.3739.57/GoLand.app/Contents/MacOS</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./goland</span><br>2022-09-07 22:53:36.422 goland[12904:58283] allVms required 1.8*,1.8+<br>2022-09-07 22:53:36.425 goland[12904:58286] Current Directory: /Users/zenghao/Library/Application Support/JetBrains/Toolbox/apps/Goland/ch-0/222.3739.57/GoLand.app/Contents/MacOS<br>2022-09-07 22:53:36.425 goland[12904:58286] parseVMOptions: GOLAND_VM_OPTIONS = /Users/zenghao/Downloads/jetbra/vmoptions/goland.vmoptions<br>2022-09-07 22:53:36.428 goland[12904:58286] parseVMOptions: platform=-1 user=-1 file=(null)<br>2022-09-07 22:53:36.531 goland[12904:58286] *** Terminating app due to uncaught exception &#x27;NSInternalInconsistencyException&#x27;, reason: &#x27;NSWindow drag regions should only be invalidated on the Main Thread!&#x27;<br>*** First throw call stack:<br>(<br>0   CoreFoundation                      0x00000001c26951a8 __exceptionPreprocess + 240<br>1   libobjc.A.dylib                     0x00000001c23dfe04 objc_exception_throw + 60<br>2   CoreFoundation                      0x00000001c26c0128 _CFBundleGetValueForInfoKey + 0<br>3   AppKit                              0x00000001c51a3930 -[NSWindow(NSWindow_Theme) _postWindowNeedsToResetDragMarginsUnlessPostingDisabled] + 372<br>4   AppKit                              0x00000001c518e92c -[NSWindow _initContent:styleMask:backing:defer:contentView:] + 948<br>5   AppKit                              0x00000001c533607c -[NSPanel _initContent:styleMask:backing:defer:contentView:] + 48<br>6   AppKit                              0x00000001c518e56c -[NSWindow initWithContentRect:styleMask:backing:defer:] + 56<br>7   AppKit                              0x00000001c5336030 -[NSPanel initWithContentRect:styleMask:backing:defer:] + 48<br>8   AppKit                              0x00000001c518cd94 -[NSWindowTemplate nibInstantiate] + 292<br>9   AppKit                              0x00000001c51579e8 -[NSIBObjectData instantiateObject:] + 236<br>10  AppKit                              0x00000001c515726c -[NSIBObjectData nibInstantiateWithOwner:options:topLevelObjects:] + 392<br>11  AppKit                              0x00000001c514b800 loadNib + 416<br>12  AppKit                              0x00000001c514ad30 +[NSBundle(NSNibLoading) _loadNibFile:nameTable:options:withZone:ownerBundle:] + 800<br>13  AppKit                              0x00000001c514a934 -[NSBundle(NSNibLoading) loadNibNamed:owner:topLevelObjects:] + 220<br>14  AppKit                              0x00000001c54b4674 -[NSAlert init] + 148<br>15  goland                              0x0000000100415270 -[Launcher buildArgsFor:] + 1144<br>16  goland                              0x0000000100415878 -[Launcher launch] + 312<br>17  Foundation                          0x00000001c34f060c __NSThread__start__ + 808<br>18  libsystem_pthread.dylib             0x00000001c254826c _pthread_start + 148<br>19  libsystem_pthread.dylib             0x00000001c254308c thread_start + 8<br>)<br>libc++abi: terminating with uncaught exception of type NSException<br>[1]    12904 abort      ./goland<br></code></pre></td></tr></table></figure><p>发现报错信息是 NSInternalInconsistencyException，最终找到了 <a href="https://youtrack.jetbrains.com/issue/JBR-4296">解决方法</a></p><p>这个 issue 下面有一条回复：</p><blockquote><p>hey I could fix this issue with following instructions:</p><p>open this file &#x2F;Users&#x2F;{USER_NAME}&#x2F;Library&#x2F;LaunchAgents&#x2F;jetbrains.vmoptions.plist</p><p>and then remove all <code>launchctl setenv &quot;*_OPTIONS&quot;</code>.</p><p>save and close it.</p><p>reboot your mac.</p><p>now you can use jetbrain :)</p></blockquote><p>流程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> ~/Library/LaunchAgents</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">open jetbrains.vmoptions.plist</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除所有以 launchctl setenv 开头的行，也就是除第一行和最后一行外的所有内容</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启 mac</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">5.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">大功告成</span><br></code></pre></td></tr></table></figure><p>不知道是什么原因导致的，个人感觉大概率是因为用了破解的缘故，按照上面的流程重启以后会发现认证信息已经没有了，需要重新执行破解脚本并输入激活码。</p>]]></content>
    
    
    
    <tags>
      
      <tag>issue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 虚拟网络设备 Veth-Pair</title>
    <link href="/2022/09/06/Veth%20%E8%AE%BE%E5%A4%87/"/>
    <url>/2022/09/06/Veth%20%E8%AE%BE%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="Veth-Pair-是什么"><a href="#Veth-Pair-是什么" class="headerlink" title="Veth-Pair 是什么"></a>Veth-Pair 是什么</h3><p>顾名思义，Veth-Pair 就是一对的虚拟设备接口，它总是以两张虚拟网卡（Veth Peer）<strong>成对出现</strong>，每个 Veth 都有两端，<strong>其中一端连着网络协议栈，另一端连接另一个 Veth</strong>。比如下图所示，该 Veth-Pair 有两张虚拟网卡 <code>veth0</code> 和 <code>veth1</code>，它们彼此相连，此外每个虚拟网卡都还连接着网络协议栈。</p><p>比如创建了一对 Veth，其中一个放到 namespace 中，那么 namespace 经过 Veth 发出的包，就会到达另一个 Veth，该 Veth 位于宿主机，所以会流经宿主机的网络协议栈，进行后续操作。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">---------------------------------------------<br>|<span class="hljs-string">                                           </span>|<br>|<span class="hljs-string">               网络协议栈                    </span>|<br>|<span class="hljs-string">                                           </span>|<br>---------------------------------------------<br>    ^             ^               ^<br>    |<span class="hljs-string">             </span>|<span class="hljs-string">               </span>|<br>    |<span class="hljs-string">             </span>|<span class="hljs-string">               </span>|<br>    |<span class="hljs-string">         ---------       ---------</span><br><span class="hljs-string">    </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> veth0 </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> veth1 </span>|<br>--------      ---------       ---------<br>|<span class="hljs-string"> eth0 </span>|<span class="hljs-string">          ^               ^</span><br><span class="hljs-string">--------          </span>|<span class="hljs-string">               </span>|<span class="hljs-string"></span><br><span class="hljs-string">                  </span>|<span class="hljs-string">               </span>|<br>                   ---------------<br></code></pre></td></tr></table></figure><p>搞清楚 Veth-Pair 的大致概念了，接下来需要了解一下 Veth-Pair 的作用，其实从上面的图中已经可以大致猜到了，既然这些东西都连在一起，那么一定和数据传输脱不了关系，实际上确实如此，对于 Veth-Pair 而言，从其中一张虚拟网卡发出的数据包，可以被另一张虚拟网卡接收到，而每张虚拟网卡又都连接到了网络协议栈，也就是说，Veth-Pair 可以充当网络协议栈中某些接口设备传递数据的桥梁。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>通过如下命令进行创建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一对 veth，一个叫 veth0，另一个叫 veth1</span><br>ip <span class="hljs-built_in">link</span> add veth0 <span class="hljs-built_in">type</span> veth peer name veth1<br><br><span class="hljs-comment"># 其中一个放到 namespace ns1 中</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 netns ns1<br><span class="hljs-comment"># 也可以接到网桥</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth0 master br0<br><br><span class="hljs-comment"># 添加 IP</span><br>ip netns <span class="hljs-built_in">exec</span> ns1 ip a a 10.1.2.3/24 dev veth1<br><br><span class="hljs-comment"># 启用</span><br>ip <span class="hljs-built_in">set</span> veth1 up<br></code></pre></td></tr></table></figure><p>如何查看 Veth 对端设备？</p><p>Veth 设备的名字以 xxx@ifx 格式命名，@ 后面的 ifx 代表的就是对端设备是第几个接口。比如下面是一对 Veth：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">7: veth0@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether 1a:<span class="hljs-built_in">cd</span>:6c:65:56:ef brd ff:ff:ff:ff:ff:ff link-netns ns2<br>    inet 10.1.1.2/24 scope global veth0<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::18cd:6cff:fe65:56ef/64 scope <span class="hljs-built_in">link</span><br>       valid_lft forever preferred_lft forever<br>    <br>$ ip netns <span class="hljs-built_in">exec</span> ns2 ip addr<br>6: veth1@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether ea:01:47:a3:c9:e9 brd ff:ff:ff:ff:ff:ff link-netns ns1<br>    inet 10.1.1.3/24 scope global veth1<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::e801:47ff:fea3:c9e9/64 scope <span class="hljs-built_in">link</span><br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="两个-network-namespace-间通信（直接连接）"><a href="#两个-network-namespace-间通信（直接连接）" class="headerlink" title="两个 network namespace 间通信（直接连接）"></a>两个 network namespace 间通信（直接连接）</h3><p>首先我们创建两个网络 namespace，然后再创建一对 Veth-Pair，并且给该 Veth-Pair 的两个虚拟网卡分配 IP 地址，最后，将这两个虚拟网卡分配给两个 namespace。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 2 个 namespace</span><br>ip netns add ns1<br>ip netns add ns2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看创建的 namespace</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ip netns</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ns2</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ns1</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建一对 veth-pair，分别命名为 veth0 veth1</span><br>ip l a veth0 type veth peer name veth1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以写成：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ip <span class="hljs-built_in">link</span> add veth0 <span class="hljs-built_in">type</span> veth peer name veth1</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将 veth0 veth1 分别加入两个 ns</span><br>ip l s veth0 netns ns1<br>ip l s veth1 netns ns2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给两个虚拟网卡 veth0 veth1 配上 IP 并启用</span><br>ip netns exec ns1 ip a a 10.1.1.2/24 dev veth0<br>ip netns exec ns1 ip l s veth0 up<br>ip netns exec ns2 ip a a 10.1.1.3/24 dev veth1<br>ip netns exec ns2 ip l s veth1 up<br></code></pre></td></tr></table></figure><p>添加完后可以看一下每个 namespace 的网卡设备：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip netns <span class="hljs-built_in">exec</span> ns1 ip addr</span><br>1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000<br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>7: veth0@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000<br>    link/ether 1a:cd:6c:65:56:ef brd ff:ff:ff:ff:ff:ff link-netns ns2<br>    inet 10.1.1.2/24 scope global veth0<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::18cd:6cff:fe65:56ef/64 scope link<br>       valid_lft forever preferred_lft forever<br>    <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip netns <span class="hljs-built_in">exec</span> ns2 ip addr</span><br>1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000<br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>6: veth1@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000<br>    link/ether ea:01:47:a3:c9:e9 brd ff:ff:ff:ff:ff:ff link-netns ns1<br>    inet 10.1.1.3/24 scope global veth1<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::e801:47ff:fea3:c9e9/64 scope link<br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>可以看到每个 namespace 都有一张以 veth 开头的网卡，这正是我们创建的 Veth-Pair 的两张虚拟网卡 <code>veth0</code> 和 <code>veth1</code>，并且每张网卡拥有一个 IP。 现在，我们创建了类似文章开头介绍中的图片的结构：veth0 和 veth1 相互连接，然后 veth0 又连接着 ns1，veth1 又连接着 ns2：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">---------       ---------<br>|<span class="hljs-string">  ns1  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  ns2  </span>|<br>---------       ---------    <br>    ^               ^<br>    |<span class="hljs-string">               </span>|<br>    |<span class="hljs-string">               </span>|<br>---------       ---------<br>|<span class="hljs-string"> veth0 </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> veth1 </span>|<br>---------       ---------<br>    ^               ^<br>    |<span class="hljs-string">               </span>|<span class="hljs-string"></span><br><span class="hljs-string">    </span>|<span class="hljs-string">               </span>|<br>     ---------------<br></code></pre></td></tr></table></figure><p>现在，两个本来相互隔离，各自拥有独立网络协议栈，像孤岛一样的网络命名空间，通过 Veth-Pair 这个“桥梁”，正式建立起了彼此沟通的渠道。让我们尝试一下，用 ns1 去 ping ns2，看看能不能 ping 通：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">从 veth0 ping veth1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip netns <span class="hljs-built_in">exec</span> ns1 ping 10.1.1.3</span><br>PING 10.1.1.3 (10.1.1.3) 56(84) bytes of data.<br>64 bytes from 10.1.1.3: icmp_seq=1 ttl=64 time=0.997 ms<br>64 bytes from 10.1.1.3: icmp_seq=2 ttl=64 time=0.102 ms<br>64 bytes from 10.1.1.3: icmp_seq=3 ttl=64 time=0.063 ms<br>^C<br>--- 10.1.1.3 ping statistics ---<br>3 packets transmitted, 3 received, 0% packet loss, time 2026ms<br>rtt min/avg/max/mdev = 0.063/0.387/0.997/0.431 ms<br></code></pre></td></tr></table></figure><p>可以看到 ping 能正常工作，说明二者已经可以通信了。</p><p>看一下路由表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip netns <span class="hljs-built_in">exec</span> ns1 ip r<br>10.1.1.0/24 dev veth0 proto kernel scope <span class="hljs-built_in">link</span> src 10.1.1.2<br><br><br>ip netns <span class="hljs-built_in">exec</span> ns2 ip r<br>10.1.1.0/24 dev veth1 proto kernel scope <span class="hljs-built_in">link</span> src 10.1.1.3<br></code></pre></td></tr></table></figure><p>这代表目标地址为 <code>10.1.1.0/24</code> 的包可以直接通过 veth 设备发出，<code>scope link</code> 代表是直连的，也就是在同一个二层，不需要网关转发。</p><p>抓包看看：</p><p>分别在 3 个终端执行：</p><p><code>sudo ip netns exec ns1 tcpdump -i veth0 -n -vvv -e -w veth0.pcap</code></p><p><code>sudo ip netns exec ns2 tcpdump -i veth1 -n -vvv -e -w veth1.pcap</code></p><p><code>ip netns exec ns1 ping 10.1.1.3</code></p><p>抓包分析：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250308122808.png" alt="image.png"></p><p>看起来没什么好分析的，源 IP 和目的 IP 就不说了，然后 ns1 通过 ARP 请求目的 IP 的 MAC，构建出最终的 ICMP 报文即可。</p><h3 id="多个-namespace-之间通信（通过-Bridge-相连）"><a href="#多个-namespace-之间通信（通过-Bridge-相连）" class="headerlink" title="多个 namespace 之间通信（通过 Bridge 相连）"></a>多个 namespace 之间通信（通过 Bridge 相连）</h3><p>上面 <strong>直接连接</strong> 的 demo 中，我们通过一对 Veth-Pair 让两个 namespace 之间实现了通信，但是如果我们想让三个，四个，甚至更多的 namespace 之间都能够通信呢？要还是采用直接连接的方式，那可就太复杂了，比如如果有四个 namespace，分别是 ns1，ns2，ns3，ns4，那么 ns1 和 ns2 通信需要一对 Veth-Pair，ns1 和 ns3，ns1 和 ns4，ns2 和 ns3，ns2 和 ns4，ns3 和 ns4 都需要一对 Veth-Pair。。。有什么办法可以解决这个问题呢？</p><p>解决办法就是引入一个新的网络设备：能够起到虚拟交换机作用的 <strong>网桥</strong>，它是一个在 <strong>数据链路层</strong> 工作的设备，主要功能是根据 MAC 地址学习将数据包转发到网桥的不同端口上。</p><blockquote><p>突击测试：什么是 MAC 地址学习？</p></blockquote><p>我们可以通过 Veth-Pair，将各个 namespace 与网桥连接起来，这些 namespace 全部都加入到同一个网桥，相当于都在同一个局域网下，所以彼此之间可以互相通信。</p><blockquote><p>🤔 这些虚拟网卡（连接到 namespace 这一端的，比如下图中的 veth0，veth1，veth2，veth3）的 IP 是否必须要处于同一网段？否则即使都在同一个网桥，也无法进行通信？</p><p>📢 如果两个网卡的 IP 不在同一个子网，将它们加入到同一个网桥后，它们在网络层（IP 层）仍然无法直接通信。这是因为网桥工作在数据链路层，它只负责根据 MAC 地址转发数据包，并不涉及 IP 地址的路由。</p><p>待实践</p></blockquote><p>拓扑结构如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">---------       ---------    ---------    ---------<br>|<span class="hljs-string">  ns1  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  ns2  </span>|<span class="hljs-string">    </span>|<span class="hljs-string">  ns3  </span>|<span class="hljs-string">    </span>|<span class="hljs-string">  ns4  </span>|<span class="hljs-string"> </span><br><span class="hljs-string">---------       ---------    ---------    ---------   </span><br><span class="hljs-string">    ^               ^            ^            ^</span><br><span class="hljs-string">    </span>|<span class="hljs-string">               </span>|<span class="hljs-string">            </span>|<span class="hljs-string">            </span>|<br>    |<span class="hljs-string">               </span>|<span class="hljs-string">            </span>|<span class="hljs-string">            </span>|<br>---------       ---------   ---------    ---------<br>|<span class="hljs-string"> veth0 </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> veth1 </span>|<span class="hljs-string">    </span>|<span class="hljs-string"> veth2 </span>|<span class="hljs-string">    </span>|<span class="hljs-string"> veth3 </span>|<br>---------       ---------    ---------    ---------<br>    ^               ^            ^            ^<br>    |<span class="hljs-string">               </span>|<span class="hljs-string">            </span>|<span class="hljs-string">            </span>|<br>    |<span class="hljs-string">               </span>|<span class="hljs-string">            </span>|<span class="hljs-string">            </span>|<br>    ∨               ∨            ∨            ∨<br>-----------     ------------  ------------  ------------<br>|<span class="hljs-string"> br-veth0 </span>|<span class="hljs-string">    </span>|<span class="hljs-string"> br-veth1 </span>|<span class="hljs-string">  </span>|<span class="hljs-string"> br-veth2 </span>|<span class="hljs-string">  </span>|<span class="hljs-string"> br-veth3 </span>|<br>-----------     ------------  ------------  ------------<br>    ^               ^               ^            ^<br>    |<span class="hljs-string">               </span>|<span class="hljs-string">               </span>|<span class="hljs-string">            </span>|<br>    |<span class="hljs-string">               </span>|<span class="hljs-string">               </span>|<span class="hljs-string">            </span>|<br>    ∨               ∨               ∨            ∨<br>------------------------------------------------------<br>|<span class="hljs-string">                       网桥                          </span>|<br>------------------------------------------------------<br></code></pre></td></tr></table></figure><p>上面创建了 4 对 Veth-Pair，每对 Veth-Pair 的一端连接到一个 network namespace，另一端连接到 bridge。比如在最左边的 veth0 和 br-veth0 就是这对 Veth-Pair 的两端，即两张虚拟网卡，然后 veth0 连接到了 ns1，而 br-veth0 连接到了网桥。 </p><p>实践：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">首先创建 bridge br0</span><br>ip l a br0 type bridge<br>ip l s br0 up <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以查看一下创建出来的网桥</span><br>ip link show type bridge<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后我们在之前实验的基础上，再创建两个 namespace</span><br>ip netns add ns3<br>ip netns add ns4<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后创建 4 对新的 veth-pair</span><br>ip l a veth2 type veth peer name br-veth2<br>ip l a veth3 type veth peer name br-veth3<br>ip l a veth4 type veth peer name br-veth4<br>ip l a veth5 type veth peer name br-veth5<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将这 4 对 veth-pair 加入到 ns 和 br0</span><br>ip l s veth2 netns ns1<br>ip l s br-veth2 master br0<br>ip l s br-veth2 up<br><br>ip l s veth3 netns ns2<br>ip l s br-veth3 master br0<br>ip l s br-veth3 up<br><br>ip l s veth4 netns ns3<br>ip l s br-veth4 master br0<br>ip l s br-veth4 up<br><br>ip l s veth5 netns ns4<br>ip l s br-veth5 master br0<br>ip l s br-veth5 up<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给 veth 配置 IP 并启用</span><br>ip netns exec ns1 ip a a 10.1.2.2/24 dev veth2<br>ip netns exec ns1 ip l s veth2 up<br><br>ip netns exec ns2 ip a a 10.1.2.3/24 dev veth3<br>ip netns exec ns2 ip l s veth3 up<br><br>ip netns exec ns3 ip a a 10.1.2.4/24 dev veth4<br>ip netns exec ns3 ip l s veth4 up<br><br>ip netns exec ns4 ip a a 10.1.2.5/24 dev veth5<br>ip netns exec ns4 ip l s veth5 up<br></code></pre></td></tr></table></figure><p>同样的，我们也可以看一下各个 namespace 的网卡情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip netns <span class="hljs-built_in">exec</span> ns1 ip addr</span><br>1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000<br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>5: veth0@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000<br>    link/ether 4a:19:b1:f3:af:22 brd ff:ff:ff:ff:ff:ff link-netns ns2<br>    inet 10.1.1.2/24 scope global veth0<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::4819:b1ff:fef3:af22/64 scope link<br>       valid_lft forever preferred_lft forever<br>12: veth2@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000<br>    link/ether 0e:24:20:80:09:97 brd ff:ff:ff:ff:ff:ff link-netnsid 0<br>    inet 10.1.2.2/24 scope global veth2<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::c24:20ff:fe80:997/64 scope link<br>       valid_lft forever preferred_lft forever<br>       <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip netns <span class="hljs-built_in">exec</span> ns3 ip addr</span><br>1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000<br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>16: veth4@if15: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000<br>    link/ether 9e:84:97:27:44:c4 brd ff:ff:ff:ff:ff:ff link-netnsid 0<br>    inet 10.1.2.4/24 scope global veth4<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::9c84:97ff:fe27:44c4/64 scope link<br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>这里为了方便只查看了 ns1 和 ns3 这两个 namespace 的情况，因为 ns1 这个 namespace 是之前创建好的，在其基础上又插入了一个 Veth，所以有 veth0 和 veth2 两张网卡，而 ns3 是新创建的，所以只有 veth4 这一张网卡（lo 代表回环网卡，与本次实验无关，可以忽略）。</p><p>然后我们验证一下这几个 namespace 之间的连通情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip netns exec ns4 ping 10.1.2.2<br>ip netns exec ns4 ping 10.1.2.3<br>ip netns exec ns4 ping 10.1.2.4<br><span class="hljs-meta prompt_"># </span><span class="language-bash">.... 就不全部测试了，测过的都可以 ping 通</span><br></code></pre></td></tr></table></figure><h2 id="抓包实践"><a href="#抓包实践" class="headerlink" title="抓包实践"></a>抓包实践</h2><p>首先执行下面的命令来创建实验环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 创建网络命名空间（使用新名字）</span><br>ip netns add ns11<br>ip netns add ns22<br><br><span class="hljs-comment"># 2. 创建网桥（使用新名字）</span><br>ip <span class="hljs-built_in">link</span> add br11 <span class="hljs-built_in">type</span> bridge<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> br11 up<br><br><span class="hljs-comment"># 3. 创建两对veth（使用新名字）</span><br><span class="hljs-comment"># ns11 &lt;-&gt; br11 的连接</span><br>ip <span class="hljs-built_in">link</span> add veth11-ns <span class="hljs-built_in">type</span> veth peer name veth11-br<br><span class="hljs-comment"># ns22 &lt;-&gt; br11 的连接</span><br>ip <span class="hljs-built_in">link</span> add veth22-ns <span class="hljs-built_in">type</span> veth peer name veth22-br<br><br><span class="hljs-comment"># 4. 将veth一端移至namespace，另一端接入网桥</span><br><span class="hljs-comment"># 第一对</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth11-ns netns ns11<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth11-br master br11<br><span class="hljs-comment"># 第二对</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth22-ns netns ns22<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth22-br master br11<br><br><span class="hljs-comment"># 5. 配置namespace中的网卡</span><br><span class="hljs-comment"># ns11</span><br>ip netns <span class="hljs-built_in">exec</span> ns11 ip addr add 10.0.0.11/24 dev veth11-ns<br>ip netns <span class="hljs-built_in">exec</span> ns11 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth11-ns up<br><span class="hljs-comment"># ns22</span><br>ip netns <span class="hljs-built_in">exec</span> ns22 ip addr add 10.0.0.22/24 dev veth22-ns<br>ip netns <span class="hljs-built_in">exec</span> ns22 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth22-ns up<br><br><span class="hljs-comment"># 6. 启用网桥上的接口</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth11-br up<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth22-br up<br></code></pre></td></tr></table></figure><p>上面的命令会创建两个 namespace，一个网桥，两对 veth-pair，然后每对分别连接到 namespace 和网桥。然后，namespace 会尝试去 Ping 另一个 namespace。</p><p>抓包结果如下：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250308171449.png" alt="image.png"></p><p>可以看到，首先 ns11 会通过 ARP 来尝试获取目标的 MAC 地址。这个 ARP 包会来到网桥，然后网桥进行广播发给每一个连接它的设备，同时进行 MAC 学习，记录这个端口连接的是 ns11 到 FDB 表中。当 ns22 响应时，它同样也会记录到 FDB 表。然后 ns22 发送 ARP 响应报文，ns11 收到后，就知道了 MAC 地址，就可以构建完整报文了。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="发送包"><a href="#发送包" class="headerlink" title="发送包"></a>发送包</h3><p>发送入口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">netdev_tx_t</span> <span class="hljs-title function_">veth_xmit</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sk_buff *skb, <span class="hljs-keyword">struct</span> net_device *dev)</span><br>&#123;<br>    <span class="hljs-comment">// 设备私有数据结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">veth_priv</span> *<span class="hljs-title">rcv_priv</span>, *<span class="hljs-title">priv</span> =</span> netdev_priv(dev);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">veth_rq</span> *<span class="hljs-title">rq</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> ret = NETDEV_TX_OK;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_device</span> *<span class="hljs-title">rcv</span>;</span><br><span class="hljs-type">int</span> length = skb-&gt;len;<br><span class="hljs-type">bool</span> use_napi = <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span> rxq;<br><br><span class="hljs-comment">// 使用 RCU 读锁保护</span><br>rcu_read_lock();<br>rcv = rcu_dereference(priv-&gt;peer); <span class="hljs-comment">// 获取对端设备</span><br><span class="hljs-comment">// 检查对端设备是否存在，及确保包至少有以太网头长度</span><br><span class="hljs-keyword">if</span> (unlikely(!rcv) || !pskb_may_pull(skb, ETH_HLEN)) &#123;<br>kfree_skb(skb);<br><span class="hljs-keyword">goto</span> drop;<br>&#125;<br><br><span class="hljs-comment">// 获取接收端私有数据</span><br>rcv_priv = netdev_priv(rcv);<br>rxq = skb_get_queue_mapping(skb);<br><span class="hljs-keyword">if</span> (rxq &lt; rcv-&gt;real_num_rx_queues) &#123;<br><span class="hljs-comment">// 获取对应的接收队列</span><br>rq = &amp;rcv_priv-&gt;rq[rxq];<br><br><span class="hljs-comment">/* The napi pointer is available when an XDP program is</span><br><span class="hljs-comment"> * attached or when GRO is enabled</span><br><span class="hljs-comment"> * Don&#x27;t bother with napi/GRO if the skb can&#x27;t be aggregated</span><br><span class="hljs-comment"> */</span><br>use_napi = rcu_access_pointer(rq-&gt;napi) &amp;&amp;<br>   veth_skb_is_eligible_for_gro(dev, rcv, skb);<br>&#125;<br><br>skb_tx_timestamp(skb);<br><span class="hljs-comment">// 转发数据包</span><br><span class="hljs-keyword">if</span> (likely(veth_forward_skb(rcv, skb, rq, use_napi) == NET_RX_SUCCESS)) &#123;<br><span class="hljs-keyword">if</span> (!use_napi)<br><span class="hljs-comment">// 更新软件统计信息</span><br>dev_sw_netstats_tx_add(dev, <span class="hljs-number">1</span>, length);<br><span class="hljs-keyword">else</span><br>__veth_xdp_flush(rq);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>drop:<br>atomic64_inc(&amp;priv-&gt;dropped);<br>ret = NET_XMIT_DROP;<br>&#125;<br>    <span class="hljs-comment">// 释放 RCU 读锁</span><br>rcu_read_unlock();<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>转发处理 veth_forward_skb：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">veth_forward_skb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> net_device *dev, <span class="hljs-keyword">struct</span> sk_buff *skb,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> veth_rq *rq, <span class="hljs-type">bool</span> xdp)</span><br>&#123;<br><span class="hljs-keyword">return</span> __dev_forward_skb(dev, skb) ?: xdp ?<br>veth_xdp_rx(rq, skb) :<br>__netif_rx(skb);<br>&#125;<br><br><span class="hljs-type">int</span> __dev_forward_skb(<span class="hljs-keyword">struct</span> net_device *dev, <span class="hljs-keyword">struct</span> sk_buff *skb)<br>&#123;<br><span class="hljs-keyword">return</span> __dev_forward_skb2(dev, skb, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __dev_forward_skb2(<span class="hljs-keyword">struct</span> net_device *dev, <span class="hljs-keyword">struct</span> sk_buff *skb,<br>      <span class="hljs-type">bool</span> check_mtu)<br>&#123;<br><span class="hljs-type">int</span> ret = ____dev_forward_skb(dev, skb, check_mtu);<br><br><span class="hljs-keyword">if</span> (likely(!ret)) &#123;<br>skb-&gt;protocol = eth_type_trans(skb, dev);<br>skb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);<br>&#125;<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><code>__dev_forward_skb</code> 如果成功了，继续根据是否启用 xdp 来选择转发方式。</p><p><code>____dev_forward_skb</code> 是数据包转发过程中的基础预处理函数</p><p>普通接收路径：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __netif_rx(<span class="hljs-keyword">struct</span> sk_buff *skb)<br>&#123;<br><span class="hljs-type">int</span> ret;<br><br>lockdep_assert_once(hardirq_count() | softirq_count());<br><br>trace_netif_rx_entry(skb);<br>ret = netif_rx_internal(skb);<br>trace_netif_rx_exit(ret);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">netif_rx_internal</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sk_buff *skb)</span><br>&#123;<br><span class="hljs-type">int</span> ret;<br><br>net_timestamp_check(READ_ONCE(netdev_tstamp_prequeue), skb);<br><br>trace_netif_rx(skb);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_RPS</span><br>    <span class="hljs-comment">// 如果启用了 RPS</span><br>    <span class="hljs-keyword">if</span> (static_branch_unlikely(&amp;rps_needed)) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rps_dev_flow</span> <span class="hljs-title">voidflow</span>, *<span class="hljs-title">rflow</span> =</span> &amp;voidflow;<br>        <span class="hljs-type">int</span> cpu;<br><br>        rcu_read_lock();  <span class="hljs-comment">// RCU 读锁保护</span><br><br>        <span class="hljs-comment">// 根据包的特征选择目标 CPU</span><br>        cpu = get_rps_cpu(skb-&gt;dev, skb, &amp;rflow);<br>        <span class="hljs-keyword">if</span> (cpu &lt; <span class="hljs-number">0</span>)<br>            cpu = smp_processor_id();  <span class="hljs-comment">// 如果选择失败，使用当前 CPU</span><br><br>        <span class="hljs-comment">// 将包加入选中 CPU 的后备队列</span><br>        ret = enqueue_to_backlog(skb, cpu, &amp;rflow-&gt;last_qtail);<br><br>        rcu_read_unlock();<br>    &#125; <span class="hljs-keyword">else</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">// 非 RPS 处理</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> qtail;<br><span class="hljs-comment">// 直接使用当前 CPU</span><br>ret = enqueue_to_backlog(skb, smp_processor_id(), &amp;qtail);<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>enqueue_to_backlog</code> 把 skb 入队到对端 Veth 设备的接收队列，并且触发软中断，然后对端设备就能开始处理了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">enqueue_to_backlog</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sk_buff *skb, <span class="hljs-type">int</span> cpu,</span><br><span class="hljs-params">      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *qtail)</span><br>&#123;<br>enqueue:<br>__skb_queue_tail(&amp;sd-&gt;input_pkt_queue, skb);<br>input_queue_tail_incr_save(sd, qtail);<br>rps_unlock_irq_restore(sd, &amp;flags);<br><span class="hljs-keyword">return</span> NET_RX_SUCCESS;<br>&#125;<br><br><span class="hljs-comment">/* Schedule NAPI for backlog device</span><br><span class="hljs-comment"> * We can use non atomic operation since we own the queue lock</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!__test_and_set_bit(NAPI_STATE_SCHED, &amp;sd-&gt;backlog.state))<br><span class="hljs-comment">// 软中断</span><br>napi_schedule_rps(sd);<br><span class="hljs-keyword">goto</span> enqueue;<br>&#125;<br>reason = SKB_DROP_REASON_CPU_BACKLOG;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">enqueue_to_backlog()<br>    |<br>    +---&gt; 队列为空？<br>          |<br>          +---&gt; 是 ---&gt; NAPI 已调度？<br>          |             |<br>          |             +---&gt; 否 ---&gt; 设置 NAPI_STATE_SCHED<br>          |             |             触发软中断<br>          |             |<br>          |             +---&gt; 是 ---&gt; 直接入队<br>          |<br>          +---&gt; 否 ---&gt; 直接入队<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1. enqueue_to_backlog<br>   |<br>2. 触发软中断<br>   |<br>3. net_rx_action 执行<br>   |<br>4. process_backlog 处理队列<br>   |<br>5. __netif_receive_skb 处理包<br>   |<br>6. 协议栈处理<br>   |<br>7. 最终到达应用层或其他目的地<br></code></pre></td></tr></table></figure><h3 id="接收包"><a href="#接收包" class="headerlink" title="接收包"></a>接收包</h3><p>处理 backlog：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">process_backlog</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> napi_struct *napi, <span class="hljs-type">int</span> quota)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softnet_data</span> *<span class="hljs-title">sd</span> =</span> container_of(napi, <span class="hljs-keyword">struct</span> softnet_data, backlog);<br><span class="hljs-type">bool</span> again = <span class="hljs-literal">true</span>;<br><span class="hljs-type">int</span> work = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* Check if we have pending ipi, its better to send them now,</span><br><span class="hljs-comment"> * not waiting net_rx_action() end.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (sd_has_rps_ipi_waiting(sd)) &#123;<br>local_irq_disable();<br>net_rps_action_and_irq_enable(sd);<br>&#125;<br><br>napi-&gt;weight = READ_ONCE(net_hotdata.dev_rx_weight);<br><span class="hljs-keyword">while</span> (again) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff</span> *<span class="hljs-title">skb</span>;</span><br><br>local_lock_nested_bh(&amp;softnet_data.process_queue_bh_lock);<br><span class="hljs-keyword">while</span> ((skb = __skb_dequeue(&amp;sd-&gt;process_queue))) &#123;<br>local_unlock_nested_bh(&amp;softnet_data.process_queue_bh_lock);<br>rcu_read_lock();<br><span class="hljs-comment">// 这里处理</span><br>__netif_receive_skb(skb);<br>rcu_read_unlock();<br><span class="hljs-keyword">if</span> (++work &gt;= quota) &#123;<br>rps_input_queue_head_add(sd, work);<br><span class="hljs-keyword">return</span> work;<br>&#125;<br><br>local_lock_nested_bh(&amp;softnet_data.process_queue_bh_lock);<br>&#125;<br>local_unlock_nested_bh(&amp;softnet_data.process_queue_bh_lock);<br><br>backlog_lock_irq_disable(sd);<br><span class="hljs-keyword">if</span> (skb_queue_empty(&amp;sd-&gt;input_pkt_queue)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Inline a custom version of __napi_complete().</span><br><span class="hljs-comment"> * only current cpu owns and manipulates this napi,</span><br><span class="hljs-comment"> * and NAPI_STATE_SCHED is the only possible flag set</span><br><span class="hljs-comment"> * on backlog.</span><br><span class="hljs-comment"> * We can use a plain write instead of clear_bit(),</span><br><span class="hljs-comment"> * and we dont need an smp_mb() memory barrier.</span><br><span class="hljs-comment"> */</span><br>napi-&gt;state &amp;= NAPIF_STATE_THREADED;<br>again = <span class="hljs-literal">false</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>local_lock_nested_bh(&amp;softnet_data.process_queue_bh_lock);<br>skb_queue_splice_tail_init(&amp;sd-&gt;input_pkt_queue,<br>   &amp;sd-&gt;process_queue);<br>local_unlock_nested_bh(&amp;softnet_data.process_queue_bh_lock);<br>&#125;<br>backlog_unlock_irq_enable(sd);<br>&#125;<br><br><span class="hljs-keyword">if</span> (work)<br>rps_input_queue_head_add(sd, work);<br><span class="hljs-keyword">return</span> work;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 <code>__netif_receive_skb</code>，然后一路会调用到下面这个函数： </p><p><code>pt_prev-&gt;func</code> 根据包的协议类型进行相应处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deliver_skb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sk_buff *skb,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> packet_type *pt_prev,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> net_device *orig_dev)</span><br>&#123;<br><span class="hljs-keyword">if</span> (unlikely(skb_orphan_frags_rx(skb, GFP_ATOMIC)))<br><span class="hljs-keyword">return</span> -ENOMEM;<br>refcount_inc(&amp;skb-&gt;users);<br><span class="hljs-keyword">return</span> pt_prev-&gt;func(skb, skb-&gt;dev, pt_prev, orig_dev);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="剥夺"><a href="#剥夺" class="headerlink" title="剥夺"></a>剥夺</h1><p>一旦一张虚拟网卡被“插”在网桥上，它就会变成该网桥的“从设备”。从设备会被“剥夺”调用网络协议栈处理数据包的资格，从而“降级”成为网桥上的一个端口。而这个端口唯一的作用，就是接收流入的数据包，然后把这些数据包的“生杀大权”（比如转发或者丢弃），全部交给对应的网桥。</p><p>container1 -&gt; veth -&gt; bridge</p><p>当 container1 发送给 veth 时，会直接流入到 bridge</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/bakari/p/10613710.html">https://www.cnblogs.com/bakari/p/10613710.html</a></p><p><a href="https://segmentfault.com/a/1190000009251098">https://segmentfault.com/a/1190000009251098</a></p><p><a href="https://mp.weixin.qq.com/s/dP12ptPlsxS35qPr0mDjCw">https://mp.weixin.qq.com/s/dP12ptPlsxS35qPr0mDjCw</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>linux</tag>
      
      <tag>k8s</tag>
      
      <tag>k8s网络</tag>
      
      <tag>needSyncToBlog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个 EOF 引发的低级错误</title>
    <link href="/2022/09/06/EOF_cuo_wu/"/>
    <url>/2022/09/06/EOF_cuo_wu/</url>
    
    <content type="html"><![CDATA[<p>今天更新了一下之前写的 tcp server，结果测试的时候发现了一个十分诡异的 BUG：客户端这边发送完数据，进程都已经退出了，但是服务端却依然源源不断的接收到客户端发来的数据，而且数据包的大小都为 0，这个 BUG 花费了我大半天的时间，终于找到了问题所在，特此记录。</p><p>问题关键就是对 io.EOF 的判断逻辑出了问题，以下是部分代码：</p><p>错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TCPConn)</span></span> UnpackHeader(d *DataPack) (*Message, <span class="hljs-type">error</span>) &#123;<br>head := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, d.HeadSize())<br><br>_, err := io.ReadFull(t.socketConn, head)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &amp;&amp; err != io.EOF &#123;<br>log.Println(<span class="hljs-string">&quot;read head error: &quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>body, err := d.UnPack(head)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> body, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TCPConn)</span></span> Receive() (*Message, <span class="hljs-type">error</span>) &#123;<br>pack := NewDataPack()<br>header, err := t.UnpackHeader(pack)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>dataLen := header.dataLen<br>msgType := header.typ<br>&#125;<br></code></pre></td></tr></table></figure><p><code>UnpackHeader</code> 这里的判断逻辑是 <code>if err != nil &amp;&amp; err != io.EOF</code>，问题就出在这里，如果 err 是 EOF，那么就不满足条件，也就不会 return err，而是继续走下面的代码，最终的 error return 为 nil。EOF 代表已经无数据可读了，所以返回的 Message 为空，没有读到任何东西。</p><p>然后 <code>Receive</code> 又调用了 <code>UnpackHeader</code>，因为 err &#x3D;&#x3D; nil，所以继续执行到 <code>dataLen := header.dataLen</code> 这里，又因为 EOF 导致 dataLen &#x3D;&#x3D; 0，这便是为何调试时发现数据包大小为 0 的原因。</p><p>而因为没有对 EOF 错误进行 return error，导致 Receive 这边一直返回空包，而我又在另一个函数 Handle 中通过一个死循环来持续调用 Receive，这就导致服务端可以源源不断的接收到客户端发来的数据，实际上这是因为没有对 EOF 进行合理的处理。</p><p>正确：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TCPConn)</span></span> UnpackHeader(d *DataPack) (*Message, <span class="hljs-type">error</span>) &#123;<br>head := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, d.HeadSize())<br><br>_, err := io.ReadFull(t.socketConn, head)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err != io.EOF &#123;<br>log.Println(<span class="hljs-string">&quot;read head error: &quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>body, err := d.UnPack(head)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> body, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只需要将判断逻辑修改一下即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err != io.EOF &#123;<br>log.Println(<span class="hljs-string">&quot;read head error: &quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br></code></pre></td></tr></table></figure><p>只要产生了错误就必须 return err，如果不是 EOF 的话要额外输出错误信息。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>issue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个 go nil pointer 错误记录</title>
    <link href="/2022/09/05/go_nil_pointer/"/>
    <url>/2022/09/05/go_nil_pointer/</url>
    
    <content type="html"><![CDATA[<p>看看下面这段代码的运行结果是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:7788&quot;</span>)<br>assert(err, <span class="hljs-string">&quot;listen error: %v&quot;</span>, err.Error())<br>    _ = lis<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(err <span class="hljs-type">error</span>, format, msg <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(format, msg))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>细心眼尖的你一定立马想到了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run nil_pointer.go</span><br>panic: runtime error: invalid memory address or nil pointer dereference<br>[signal SIGSEGV: segmentation violation code=0x2 addr=0x18 pc=0x100412238]<br><br>goroutine 1 [running]:<br>main.main()<br>/Users/zenghao/pj/justtest/nil_pointer.go:10 +0x38<br>exit status 2<br></code></pre></td></tr></table></figure><p>没错，就是一个普通的空指针错误，发生在 err.Error() 这里，如果 net.Listen 没有产生错误，那么 err &#x3D;&#x3D; nil，err.Error() 自然就会产生空指针异常了。但这个错误居然困扰了许久，虽然 panic 提示了代码行数，但是我一开始硬是没注意到 err.Error() 这里，加上 [signal SIGSEGV: segmentation violation code&#x3D;0x2 addr&#x3D;0x18 pc&#x3D;0x100412238] 这里混淆了我（因为之前跑过一个项目，也是运行就会 panic，提示的也是 SIG 之类的，但是这个项目 panic 的原因是有些包没有适配当时最新的 go1.17 版本，需要使用 go get -u 来更新部分包，即可解决问题），导致我朝着一个错误的方向解决问题。</p><p>问题到这里就算结束了，但是这种低级错误耽误了许多时间，我在想有没有什么工具可以对这种空指针错误进行检测呢？</p><p>使用 go vet：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> vet nil_pointer.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>没有输出任何信息</p><p>此外，GoLand 和 Vscode 也没有任何 warning 警告</p><p>使用 golangci-lint：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">$ golangci-lint run nil_pointer.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>也没有输出任何信息</p><p>暂时没有找到可以检测这类问题的工具，虽然 Goland 可以对部分潜在的 nil pointer 问题进行警告，但是在这篇文章的代码中无效。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>issue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP 粘包/拆包问题</title>
    <link href="/2022/09/05/tcp_zhan_bao/"/>
    <url>/2022/09/05/tcp_zhan_bao/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>TCP 的粘包拆包也属于老生常谈的问题了，虽然不少人都鄙夷的认为粘包是一个错误的说法，因为 TCP 是面向流传输的，但无论如何，粘包这个词都已经算得上是深入人心了。</p><p>TCP 的流式传输，简单的说就是没有消息边界记录，比如发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据包，合并成一个大的数据包发送(把发送端的缓冲区填满一次性发送。这样接收端收到的整个数据中其实是包含了多个小包，需要将数据拆分，还原成小包，从而才能进行处理，但因为没有消息边界记录，所以如何还原就成了一个问题。</p><p>在上面的例子中，TCP 将多次写入缓冲区的数据包合并为一次发送，就是 <strong>粘包</strong> 问题。</p><p>此外 TCP 还存在 <strong>拆包</strong> 问题，就是发送包的大小超过了缓冲区大小或者 MSS，比如发送端使用 protobuf 编码数据，然后使用 TCP 进行传输，这个编码的数据大小是 10000 byte，超过了 TCP 的发送缓存区大小 5000 byte（随便写的数字，仅用作举例），一次性无法全部发送，所以便会发生拆包，分两次发送，接收端这边第一次只收到了 5000 byte 数据，因为数据使用 protobuf 编码的，不同于文本消息，必须要拿到不多不少刚刚好的 10000 byte 大小的数据，才能反序列化出原始的数据，但因为 TCP 不记录消息长度，所以接收端这边无法知道到底要拿多少数据，这也是一个问题。</p><p>可以看到发生粘包和拆包的原因都是因为 TCP 不记录消息边界（也就是消息长度），既然 TCP 自身不记录，那就只能用户自己解决了，比如设计一个协议，让报文内容由消息头 + 消息两部分构成，在消息头中记录消息的长度，然后将消息头 + 消息本体作为一个整体发送，（这里的消息头是需要定长的，比如固定为 10 byte），接收端这边根据协议定义，去读取这个定长的消息头，从里面获取到消息本体的长度，知道了消息的长度以后，上面的问题就可以很好的解决了。</p><h1 id="拆包演示程序"><a href="#拆包演示程序" class="headerlink" title="拆包演示程序"></a>拆包演示程序</h1><p>下面先使用一个错误的 protobuf 的示例程序来演示一下拆包问题：</p><h2 id="server-端"><a href="#server-端" class="headerlink" title="server 端"></a>server 端</h2><p>server 负责读取报文，然后通过 proto.Unmarshal 还原出原始的数据。其中将缓冲区大小设置为了 client 要发送的大小 279896。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;protobuftest/pb/pbfile&quot;</span><br><br><span class="hljs-string">&quot;google.golang.org/protobuf/proto&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:7788&quot;</span>)<br>assert(err, <span class="hljs-string">&quot;listen error: %v&quot;</span>)<br><br><span class="hljs-keyword">for</span> &#123;<br>conn, err := lis.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// b := make([]byte, 1024)// proto: cannot parse invalid wire-format data</span><br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">279896</span>)<br>n, err := conn.Read(b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;read %v bytes\n&quot;</span>, n)<br><br><span class="hljs-keyword">var</span> m pbfile.Message<br><span class="hljs-keyword">if</span> err := proto.Unmarshal(b, &amp;m); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Println(m.Uid)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(err <span class="hljs-type">error</span>, format <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(format, err.Error()))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="client-端"><a href="#client-端" class="headerlink" title="client 端"></a>client 端</h2><p>client 使用 protobuf 序列化 struct pbfile.Message，然后使用 tcp 发送，这个 struct 中有一个 Data 字段，这里我将一张 140k 的图片读取出来，然后将 Data 字段设置为读取出的 []byte 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;google.golang.org/protobuf/proto&quot;</span><br><span class="hljs-string">&quot;google.golang.org/protobuf/types/known/wrapperspb&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;path/filepath&quot;</span><br><span class="hljs-string">&quot;protobuftest/pb/pbfile&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>home := os.Getenv(<span class="hljs-string">&quot;HOME&quot;</span>)<br>fp := filepath.Join(home, <span class="hljs-string">&quot;Downloads/jDKUARa.jpg&quot;</span>)<br><br>f, err := os.Open(fp)<br>assert(err, <span class="hljs-string">&quot;open file error: %v&quot;</span>)<br><span class="hljs-keyword">defer</span> f.Close()<br><br>file, err := os.ReadFile(fp)<br>assert(err, <span class="hljs-string">&quot;read file error: %v&quot;</span>)<br><br>msg := pbfile.Message&#123;<br>Uid:         wrapperspb.UInt64(<span class="hljs-number">10086</span>),<br>Data:        file,<br>MessageType: wrapperspb.String(<span class="hljs-string">&quot;image&quot;</span>),<br>&#125;<br><br>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:7788&quot;</span>)<br>assert(err, <span class="hljs-string">&quot;dial error: %v&quot;</span>)<br><span class="hljs-keyword">defer</span> conn.Close()<br><br>b, err := proto.Marshal(&amp;msg)<br>assert(err, <span class="hljs-string">&quot;proto marshal error: %v&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;proto marshal size: %v\n&quot;</span>, <span class="hljs-built_in">len</span>(b))<br><br>n, err := conn.Write(b)<br>assert(err, <span class="hljs-string">&quot;write to conn error: %v&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;write %v bytes\n&quot;</span>, n)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(err <span class="hljs-type">error</span>, format <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(format, err.Error()))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h2><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax=<span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;/pbfile&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/protobuf/wrappers.proto&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Message</span> &#123;<br>  google.protobuf.UInt64Value uid = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">bytes</span> data = <span class="hljs-number">2</span>;<br>  google.protobuf.StringValue messageType = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>分别运行 server 和 client，输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">client</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./client</span><br>proto marshal size: 279896<br>write 279896 bytes<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">server</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./server</span>          <br>read 81660 bytes<br>proto: cannot parse invalid wire-format data<br></code></pre></td></tr></table></figure><p>可以看到 client 这边发送了 279896 字节的数据，但是 server 这边只读到了 81660 字节，因为 protobuf 使用二进制编码，所以如果数据不完整会无法解析，从而报错：<code>proto: cannot parse invalid wire-format data</code></p><p>部分测试结果可以印证这一点，只要读取的长度不等于 279896 就会解析失败：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">read 97992 bytes<br>proto: cannot parse invalid wire-format data<br>read 81660 bytes<br>proto: cannot parse invalid wire-format data<br>read 130656 bytes<br>proto: cannot parse invalid wire-format data<br></code></pre></td></tr></table></figure><p>但是有时候又是正常的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">client</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./client</span><br>proto marshal size: 279896<br>write 279896 bytes<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">server</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">read</span> 279896 bytes</span><br>value:10086<br>EOF<br></code></pre></td></tr></table></figure><blockquote><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>这里有个疑问，既然 server 的缓冲区已经将长度设置为了 279896，刚好等于 client 要发送的包的大小，但是为什么会出现没有读取满的情况？</p><p>可能是因为：发送方虽然发送了 279896 长度的数据，但是这些数据不会直接通过网络传输，而是先添加到 socket 发送缓冲区，至于什么时候发送，发送多少，都是由系统内核来决定的，所以会出现诸如上面这种没有完全发完的情况，偶尔又会出现全部发送的情况。</p></blockquote><h1 id="粘包演示程序"><a href="#粘包演示程序" class="headerlink" title="粘包演示程序"></a>粘包演示程序</h1><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p>服务端试图从收到的包中反序列化出原始数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:7788&quot;</span>)<br>assert(err, <span class="hljs-string">&quot;listen error: %v&quot;</span>)<br><br><span class="hljs-keyword">for</span> &#123;<br>conn, err := lis.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>n, err := conn.Read(b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;read %v bytes\n&quot;</span>, n)<br><br><span class="hljs-keyword">var</span> m pbfile.Message<br><span class="hljs-keyword">if</span> err := proto.Unmarshal(b, &amp;m); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Println(m.Uid)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><p>客户端发送 10 条消息，每条消息设置不同的 Uid，且序列化的对象都比较小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:7788&quot;</span>)<br>assert(err, <span class="hljs-string">&quot;dial error: %v&quot;</span>)<br><span class="hljs-keyword">defer</span> conn.Close()<br><br>  <span class="hljs-keyword">var</span> totalN <span class="hljs-type">int</span> <br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>msg := pbfile.Message&#123;<br>Uid:         wrapperspb.UInt64(<span class="hljs-type">uint64</span>(i)),<br>Data:        []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;hello&quot;</span>),<br>MessageType: wrapperspb.String(<span class="hljs-string">&quot;text&quot;</span>),<br>&#125;<br><br>b, err := proto.Marshal(&amp;msg)<br>assert(err, <span class="hljs-string">&quot;proto marshal error: %v&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;proto marshal size: %v\n&quot;</span>, <span class="hljs-built_in">len</span>(b))<br><br>n, err := conn.Write(b)<br>    totalN += n<br>assert(err, <span class="hljs-string">&quot;write to conn error: %v&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;write %v bytes\n&quot;</span>, n)<br>&#125;<br>  fmt.Printf(<span class="hljs-string">&quot;total write %v bytes\n&quot;</span>, totalN)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run server.go</span><br>read 74 bytes<br>proto: cannot parse invalid wire-format data<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run client.go</span>                                           <br>proto marshal size: 17<br>write 17 bytes<br>proto marshal size: 19<br>write 19 bytes<br>proto marshal size: 19<br>write 19 bytes<br>proto marshal size: 19<br>write 19 bytes<br>proto marshal size: 19<br>write 19 bytes<br>proto marshal size: 19<br>write 19 bytes<br>proto marshal size: 19<br>write 19 bytes<br>proto marshal size: 19<br>write 19 bytes<br>proto marshal size: 19<br>write 19 bytes<br>proto marshal size: 19<br>write 19 bytes<br>total write 188 bytes<br></code></pre></td></tr></table></figure><p>可以看到客户端这边每次发送的报文长度基本都是 19 ，只有第一次是 17，一共发送了 188 bytes 的数据，而服务端这边，第一次从连接中接收到的数据大小是 74 bytes，这显然是有几个包 “粘” 在了一起，最终显然也是无法反序列化成功的。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>我写了一个简单的 tcp server 库，里面解决了上面的粘包拆包问题，思路是自定义一个协议，协议的头部记录了数据的长度，然后接收端在收到报文后，先解析出头部，获取到数据的长度，在进行下一步读取。为了保证读满，可以使用 io.ReadFull 这个函数，大致的读取逻辑如下：</p><p>首先是读取协议头部的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TCPConn)</span></span> UnpackHeader(d *DataPack) (*Message, <span class="hljs-type">error</span>) &#123;<br>head := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, d.HeadSize())<br><br>_, err := io.ReadFull(t.socketConn, head)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err != io.EOF &#123;<br>log.Println(<span class="hljs-string">&quot;read head error: &quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>body, err := d.UnPack(head)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> body, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后是读取数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TCPConn)</span></span> Receive() (*Message, <span class="hljs-type">error</span>) &#123;<br>pack := NewDataPack()<br>header, err := t.UnpackHeader(pack)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>  &#125;<br>  <br>  dataLen := header.dataLen<br>  <br>  <span class="hljs-keyword">var</span> (<br>tmpBuf = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4096</span>)<br>needN  = dataLen <span class="hljs-comment">// 还剩多少需要读取</span><br>readN  <span class="hljs-type">int64</span>     <span class="hljs-comment">// 总共需要读取多少</span><br>)<br>  <br>  <span class="hljs-keyword">for</span> &#123;<br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, needN)<br><span class="hljs-comment">// 必须读满 len(buf)，否则返回一个 err</span><br>n, err := io.ReadFull(t.socketConn, buf)<br><br><span class="hljs-comment">// 没有读满 buf</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 虽然没读满，但是返回了 EOF 错误，说明没有数据可读了，可能是对方已经断开了连接，</span><br><span class="hljs-comment">// 此时就不需要再尝试读取了</span><br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-comment">// 将当前读的这部分添加到 tmp 中，暂时保存</span><br>tmpBuf = <span class="hljs-built_in">append</span>(tmpBuf, buf[:n]...)<br>needN -= <span class="hljs-type">uint64</span>(n) <span class="hljs-comment">// 更新 needN 的值</span><br>readN += <span class="hljs-type">int64</span>(n)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// 读满了</span><br>tmpBuf = <span class="hljs-built_in">append</span>(tmpBuf, buf...)<br>readN += <span class="hljs-type">int64</span>(n)<br><br><span class="hljs-keyword">if</span> readN == <span class="hljs-type">int64</span>(dataLen) &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>m := NewMessage(tmpBuf, msgType)<br><span class="hljs-keyword">return</span> m, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试了前面的粘包拆包代码，发现结果都正确，说明可以解决这类问题，但是目前测试的依据较少，也可能不一定准确。</p><p>附：</p><p><a href="https://github.com/autsu/revrespct">项目地址</a></p><p><a href="https://github.com/autsu/revrespct/tree/master/testdata">用 protobuf 来进行粘包拆包的测试代码</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>epoll 打断/唤醒</title>
    <link href="/2022/09/02/epoll_zhong_duan/"/>
    <url>/2022/09/02/epoll_zhong_duan/</url>
    
    <content type="html"><![CDATA[<p>写这篇文章是因为最近在看 go netpoll 的源码，里面有一部分代码是创建一个管道，一开始没有搞懂用意何在，后来查阅了网上的文章，有说法是这个管道是为了打断 epoll_wait 的等待，将这个管道的 fd 添加到 epoll 中，如果想主动打断 epoll_wait，那么就往管道中写入数据，然后在 epoll_wait 处就会产生事件，终止阻塞。</p><p>搜索 epoll 打断，发现资料非常少，go netpoll 这部分的源码讲解也比较少（主要是 netpollBreak 这个函数），这导致我不明白为什么需要打断 epoll，我的猜测是：可能是为了避免让某条线程持续阻塞在 epoll_wait，这样会导致这条线程比较闲，如果当前系统的任务比较繁忙，为了保证性能就需要让每条线程都 “忙” 起来，就需要主动打断这些阻塞在 epoll_wait 的线程，先给它们分配一些任务，让它们忙起来。</p><p>在一篇博客上还看到了一种说法：</p><blockquote><h3 id="和poll-x2F-epoll搭配使用，一个消费者多生产者场景"><a href="#和poll-x2F-epoll搭配使用，一个消费者多生产者场景" class="headerlink" title="和poll&#x2F;epoll搭配使用，一个消费者多生产者场景"></a>和poll&#x2F;epoll搭配使用，一个消费者多生产者场景</h3><p>实际这种使用场景会多一点，生产者是多个线程，可以通过 eventfd_write 唤醒消费者。消费者是单个线程，后台 loop 处理。使用 epoll 监听 eventfd 的可读事件，这样能做到一旦有请求入队，消费者就立马唤醒处理。所以这里可以总结出 eventfd 在实际场景中可以结合业务，做一个事件通知的通信机制，非常巧妙，而不用轮询这种耗时耗 cpu 的机制。这块就不详细写示例了。</p></blockquote><p>感觉说的挺有道理的，这种用 epoll 唤醒来描述更为合适，而不是 epoll 打断，个人的见解：eventfd 其实和 socket 类似，只不过是用于同一台机器上的一种进程间通信机制，而 socket 因为是网络传输所以可以跨机器。</p><h1 id="使用管道"><a href="#使用管道" class="headerlink" title="使用管道"></a>使用管道</h1><p>创建一个匿名管道，用 epoll 监听管道的读端，然后 fork 一个子进程，子进程在 sleep 几秒后会向管道写入数据，然后父进程的 epoll_wait 就会被触发事件，进而跳出死循环，执行其他任务（这里逻辑可能不太合理）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVENTS_SIZE 128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 1024</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> epfd = epoll_create(<span class="hljs-number">1024</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event1</span>, <span class="hljs-title">event2</span>, <span class="hljs-title">events</span>[<span class="hljs-title">EVENTS_SIZE</span>];</span><br><span class="hljs-type">char</span> buf[BUF_SIZE];<br><br>event1.events = EPOLLIN;<br> event1.data.fd = STDIN_FILENO;<br><span class="hljs-type">int</span> ret = epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &amp;event1);<br><span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span> ) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll_ctl error: %s\n&quot;</span>, strerror(errno));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (pipe(pipefd) == <span class="hljs-number">-1</span>) &#123;<br>perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br><span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-comment">// 注意要先调用 pipe() 创建管道，再添加到 epoll，否则报错 Bad file descriptor</span><br>event2.events = EPOLLIN;<br>event2.data.fd = pipefd[<span class="hljs-number">0</span>];<br>ret = epoll_ctl(epfd, EPOLL_CTL_ADD, pipefd[<span class="hljs-number">0</span>], &amp;event2); <span class="hljs-comment">// 将管道的读端添加到 epoll 监听队列</span><br><span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll_ctl error: %s\n&quot;</span>, strerror(errno));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">pid_t</span> cpid = fork();<br><br><span class="hljs-keyword">switch</span> (cpid) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>perror(<span class="hljs-string">&quot;fork&quot;</span>);<br><span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-comment">// child</span><br><span class="hljs-comment">// 发现一个新坑：如果使用 printf 进行调试，必须添加 \n 换行符，否则终端不会输出</span><br><span class="hljs-comment">// 搞得我还以为子进程没有执行</span><br><span class="hljs-comment">// printf(&quot;child in\n&quot;);</span><br>close(pipefd[<span class="hljs-number">0</span>]);<span class="hljs-comment">// 关闭管道的读端，因为子进程只负责向管道写入数据</span><br>sleep(<span class="hljs-number">3</span>);<br><span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;break&quot;</span>;<br>write(pipefd[<span class="hljs-number">1</span>], s, <span class="hljs-built_in">strlen</span>(s));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child send sign to pipe\n&quot;</span>);<br>close(pipefd[<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">// 必须要写这句，不然会出现程序已经退出（终端输出完毕，已经显示新行），</span><br><span class="hljs-comment">// 但是进程依然在执行的迷惑情况（终端输入全部会被当成 epoll 事件）</span><br><span class="hljs-keyword">default</span>: <span class="hljs-comment">// parent</span><br>close(pipefd[<span class="hljs-number">1</span>]);<span class="hljs-comment">// 关闭管道的写端，因为父进程只负责从管道中读取</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll is wait\n&quot;</span>);<br><span class="hljs-type">int</span> n = epoll_wait(epfd, events, EVENTS_SIZE, <span class="hljs-number">-1</span>); <span class="hljs-comment">// 无限阻塞</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-comment">//printf(&quot;event fd: %d\n&quot;, events[i].data.fd);</span><br><span class="hljs-keyword">if</span> (events[i].data.fd == STDIN_FILENO) &#123;<br><span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE);<br>read(events[i].data.fd, buf, BUF_SIZE);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read from stdin: %s\n&quot;</span>, buf);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].data.fd == pipefd[<span class="hljs-number">0</span>]) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pipe break epoll_wait!\n&quot;</span>);<br><span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE);<br>read(events[i].data.fd, buf, BUF_SIZE);<span class="hljs-comment">// 消费掉事件</span><br>close(pipefd[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">goto</span> STOP_WAIT;<br>&#125;<br>&#125;<br>&#125;<br>STOP_WAIT:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;do something\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">clang pipe_break_epoll.c</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./a.out</span><br>epoll is wait<br>pipe break epoll_wait!<br>do something<br>child send sign to pipe<br></code></pre></td></tr></table></figure><p>输出顺序有点问题，但是无伤大雅</p><h1 id="使用-eventfd"><a href="#使用-eventfd" class="headerlink" title="使用 eventfd"></a>使用 eventfd</h1>]]></content>
    
    
    
    <tags>
      
      <tag>epoll</tag>
      
      <tag>多路复用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>孤儿进程与僵尸进程</title>
    <link href="/2022/08/31/gu_er_jin_cheng_he_jiang_shi_jin_cheng/"/>
    <url>/2022/08/31/gu_er_jin_cheng_he_jiang_shi_jin_cheng/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来源：<a href="https://www.cnblogs.com/Anker/p/3271773.html">https://www.cnblogs.com/Anker/p/3271773.html</a></p></blockquote><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>孤儿进程</strong>：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被 init 进程(进程号为 1 )所收养，并由 init 进程对它们完成状态收集工作。</p><p><strong>僵尸进程</strong>：一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p><h1 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h1><p>unix 提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号 the process ID,退出状态 the termination status of the process,运行时间 the amount of CPU time taken by the process等)。直到父进程通过 wait &#x2F; waitpid 来取时才释放。 但这样就导致了问题，<strong>如果进程不调用 wait &#x2F; waitpid 的话，</strong> <strong>那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</strong></p><p><strong>孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上</strong>，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。<strong>因此孤儿进程并不会有什么危害。</strong></p><p><strong>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。</strong>这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p><p>僵尸进程危害场景：</p><p>例如有个进程，它定期的产生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用 ps 命令查看的话，就会看到很多状态为 Z 的进程。 <strong>严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程</strong>。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是 <strong>把产生大量僵死进程的那个元凶枪毙掉</strong>（也就是通过 kill 发送 SIGTERM 或者 SIGKILL 信号啦）。<strong>枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被 init 进程接管，init 进程会 wait() 这些孤儿进程，释放它们占用的系统进程表中的资源</strong>，这样，这些已经僵死的孤儿进程就能瞑目而去了。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="孤儿进程测试程序"><a href="#孤儿进程测试程序" class="headerlink" title="孤儿进程测试程序"></a>孤儿进程测试程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-comment">//创建一个进程</span><br>    pid = fork();<br>    <span class="hljs-comment">//创建失败</span><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;fork error:&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//子进程</span><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am the child process.\n&quot;</span>);<br>        <span class="hljs-comment">//输出进程ID和父进程ID</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid: %d\tppid:%d\n&quot;</span>,getpid(),getppid());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I will sleep five seconds.\n&quot;</span>);<br>        <span class="hljs-comment">//睡眠5s，保证父进程先退出</span><br>        sleep(<span class="hljs-number">5</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid: %d\tppid:%d\n&quot;</span>,getpid(),getppid());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process is exited.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//父进程</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am father process.\n&quot;</span>);<br>        <span class="hljs-comment">//父进程睡眠1s，保证子进程输出进程id</span><br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father process is  exited.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>大致逻辑就是让子进程睡眠更长的时间，以达到比父进程后退出的效果，从而变成孤儿进程。</p><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./a.out</span><br>I am father process.<br>I am the child process.<br>pid: 15625ppid:15618<br>I will sleep five seconds.<br>father process is  exited.<br>➜  justtest git:(master) ✗ pid: 15625ppid:1<br>child process is exited.<br></code></pre></td></tr></table></figure><p>从 <code>pid: 15625 ppid:1</code> 这里就可以看出子进程被 init 进程接管了（init 进程的 pid 为 1，pid 代表当前进程的 id，ppid 代表当前进程的父进程的 id）。</p><p>（<code>➜  justtest git:(master) ✗ pid: 15625ppid:1</code> 这一行是因为父进程退出后，终端会结束输出，变成待输入状态，所以会出现 <code>justtest git:(master) ✗</code> 这部分，但是等几秒后子进程又会输出 <code>pid: 15625ppid:1</code>，所以就变成了这样的显示效果。而且在输出了 <code>child process is exited.</code>  这句话之后终端会卡住，此时只需要按一下回车即可。）</p><h2 id="僵尸进程测试程序"><a href="#僵尸进程测试程序" class="headerlink" title="僵尸进程测试程序"></a>僵尸进程测试程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;fork error:&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am child process.I am exiting.\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am father process.I will sleep two seconds\n&quot;</span>);<br>    <span class="hljs-comment">//等待子进程先退出</span><br>    sleep(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">//输出进程信息</span><br>    system(<span class="hljs-string">&quot;ps -o pid,ppid,state,tty,command&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father process is exiting.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段程序让子进程先退出，同时不适用 wait 或者 waitpid 来回收。</p><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">./a.out<br>I am father process.I will sleep two seconds<br>I am child process.I am exiting.<br>  PID  PPID STAT TTY      COMMAND<br> 7766  7750 S+   ttys000  -zsh<br> 7771  7751 S    ttys001  -zsh<br>91947  7771 S+   ttys001  ./a.out<br>91956 91947 Z+   ttys001  (a.out) # 僵尸进程<br></code></pre></td></tr></table></figure><p>其中 STAT 为 Z+ 的就是僵尸进程</p><h2 id="僵尸进程测试2"><a href="#僵尸进程测试2" class="headerlink" title="僵尸进程测试2"></a>僵尸进程测试2</h2><p>父进程循环创建子进程，子进程退出，造成多个僵尸进程，程序如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">pid_t</span>  pid;<br>    <span class="hljs-comment">//循环创建子进程</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;fork error:&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am a child process.\nI am exiting.\n&quot;</span>);<br>            <span class="hljs-comment">//子进程退出，成为僵尸进程</span><br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//父进程休眠20s继续创建子进程</span><br>            sleep(<span class="hljs-number">20</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/abaf1d3a8a58e0f3b3bcc8764c22728fc089faba/img/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%20.png"></p><h1 id="僵尸进程解决方法"><a href="#僵尸进程解决方法" class="headerlink" title="僵尸进程解决方法"></a>僵尸进程解决方法</h1><h2 id="fork-两次"><a href="#fork-两次" class="headerlink" title="fork 两次"></a>fork 两次</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">pid_t</span>  pid;<br>    <span class="hljs-comment">//创建第一个子进程</span><br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;fork error:&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//第一个子进程</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">//子进程再创建子进程（第二个子进程）</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am the first child process.pid:%d\tppid:%d\n&quot;</span>,getpid(),getppid());<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;fork error:&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 让第一个子进程退出</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;first procee is exited.\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">//第二个子进程</span><br>        <span class="hljs-comment">//睡眠3s保证第一个子进程退出，这样第二个子进程的父亲就是init进程里</span><br>        sleep(<span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am the second child process.pid: %d\tppid:%d\n&quot;</span>,getpid(),getppid());<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">//父进程处理第一个子进程退出</span><br>    <span class="hljs-keyword">if</span> (waitpid(pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>) != pid)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;waitepid error:&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>大致思路就是先创建一个子进程，再让这个子进程再创建一个子进程（代称为孙子进程），然后让子进程立马退出，这样孙子进程就会被 init 接管。（使用孙子进程来执行任务）</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。测试程序如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sig_child</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-comment">//创建捕捉子进程退出信号</span><br>    signal(SIGCHLD,sig_child);<br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;fork error:&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am child process,pid id %d.I am exiting.\n&quot;</span>,getpid());<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am father process.I will sleep two seconds\n&quot;</span>);<br>    <span class="hljs-comment">//等待子进程先退出</span><br>    sleep(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">//输出进程信息</span><br>    system(<span class="hljs-string">&quot;ps -o pid,ppid,state,tty,command&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father process is exiting.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sig_child</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span><br>&#123;<br>     <span class="hljs-type">pid_t</span>        pid;<br>     <span class="hljs-type">int</span>        stat;<br>     <span class="hljs-comment">//处理僵尸进程</span><br>     <span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, &amp;stat, WNOHANG)) &gt;<span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d terminated.\n&quot;</span>, pid);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何保证缓存和数据库的一致性</title>
    <link href="/2022/08/27/huan_cun_yi_zhi_xing/"/>
    <url>/2022/08/27/huan_cun_yi_zhi_xing/</url>
    
    <content type="html"><![CDATA[<p>一道高频面试题：如何保证缓存和数据库的一致性</p><p>通常情况下，容易想到以下几种策略：</p><h1 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h1><p>存在的问题：</p><ol><li><p>更新数据库成功，更新缓存失败</p></li><li><p>并发情况下可能会存在问题，如下（纵轴代表时间线）：</p><table><thead><tr><th align="center">A</th><th align="center">B</th></tr></thead><tbody><tr><td align="center">更新 DB x &#x3D; 1</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">更新 DB，x &#x3D; 2</td></tr><tr><td align="center"></td><td align="center">更新缓存，x &#x3D; 2</td></tr><tr><td align="center">更新缓存，x &#x3D; 1</td><td align="center"></td></tr></tbody></table><p>可以看到因为并发操作导致 A 把 B 的更新缓存结果给覆盖了，最终使得数据库结果（x &#x3D; 2）和缓存结果（x &#x3D; 1）不一致</p></li></ol><h1 id="先更新缓存，再更新数据库"><a href="#先更新缓存，再更新数据库" class="headerlink" title="先更新缓存，再更新数据库"></a>先更新缓存，再更新数据库</h1><p>存在的问题：</p><p>和 <strong>先更新数据库，再更新</strong> 类似，这里就不再赘述了。</p><h1 id="先删缓存，再更新数据库"><a href="#先删缓存，再更新数据库" class="headerlink" title="先删缓存，再更新数据库"></a>先删缓存，再更新数据库</h1><p>存在的问题：</p><ol><li><p>删除缓存成功，更新数据库失败</p></li><li><p>并发情况下可能会存在问题，如下（纵轴代表时间线）：</p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">C</th></tr></thead><tbody><tr><td align="center">删缓存</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">读缓存，miss</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">读 DB，x &#x3D; 1</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">写入缓存，x &#x3D; 1</td><td align="center"></td></tr><tr><td align="center">更新 db，x &#x3D; 2</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">读缓存，x &#x3D; 1，但此时 db 中 x &#x3D; 2，不一致</td></tr></tbody></table></li></ol><h1 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h1><p>存在的问题：</p><ol><li>更新数据库成功，删除缓存失败</li><li>并发情况下可能会存在问题，如下（纵轴代表时间线）：<table><thead><tr><th align="center">A</th><th align="center">B</th></tr></thead><tbody><tr><td align="center">读缓存，miss</td><td align="center"></td></tr><tr><td align="center">读 DB，x &#x3D; 1</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">更新 DB，x &#x3D; 2</td></tr><tr><td align="center"></td><td align="center">删除缓存</td></tr><tr><td align="center">写入缓存，x &#x3D; 1</td><td align="center"></td></tr></tbody></table></li></ol><p>此时数据库中的 x &#x3D; 2，但缓存中 x &#x3D; 1，存在不一致</p><p>但是这种情况发生的概率不高，因为缓存的写入速度大概率是要快于数据库的写入速度的（上表中就是因为更新数据库操作快于缓存写入操作，才导致最终不一致），所以多数情况下，都能保证缓存被删除，也就是下面的流程：</p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">C</th></tr></thead><tbody><tr><td align="center">读缓存，miss</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">读 DB，x &#x3D; 1</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">写入缓存，x &#x3D; 1（缓存的写入速度快于 DB 的写入速度）</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">更新 DB，x &#x3D; 2</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">删除缓存（旧的缓存已经被删掉了）</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">读缓存，miss</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">读 DB，x &#x3D; 2，并写入缓存，此时一致</td></tr></tbody></table><h1 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a>延迟双删</h1><p>该策略基于之前的 <strong>先删缓存，再更新数据库</strong> 策略</p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">C</th></tr></thead><tbody><tr><td align="center">删缓存</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">读缓存，miss</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">读 DB，x &#x3D; 1</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">写入缓存，x &#x3D; 1</td><td align="center"></td></tr><tr><td align="center">更新 db，x &#x3D; 2（此时缓存和 db 不一致）</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">延迟一会，再删除缓存</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">读缓存，miss，从 db 读取并写入缓存，此时一致</td></tr></tbody></table><p>为什么要延迟一会？</p><p>如果不延迟而是更新 db 后立马删除，可能存在下面的情况：</p><table><thead><tr><th align="center">A</th><th align="center">B</th></tr></thead><tbody><tr><td align="center">删缓存</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">读缓存，miss</td></tr><tr><td align="center"></td><td align="center">读 DB，x &#x3D; 1</td></tr><tr><td align="center">更新 db，x &#x3D; 2</td><td align="center"></td></tr><tr><td align="center">立马删除缓存（删早了）</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">写入缓存，x &#x3D; 1（此时写入的是旧值）</td></tr></tbody></table><p>最终 db 中的 x &#x3D; 2，而缓存中的 x &#x3D; 1，二者又不一致了。如果让 A 延迟一会，等到 B 写完缓存后再删，就不会出现上面的问题了。</p><table><thead><tr><th align="center">A</th><th align="center">B</th></tr></thead><tbody><tr><td align="center">删缓存</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">读缓存，miss</td></tr><tr><td align="center"></td><td align="center">读 DB，x &#x3D; 1</td></tr><tr><td align="center">更新 db，x &#x3D; 2</td><td align="center"></td></tr><tr><td align="center">延迟一会再删除缓存</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">写入缓存，x &#x3D; 1</td></tr><tr><td align="center">删掉缓存（将缓存中 x &#x3D; 1 的旧值删掉了）</td><td align="center"></td></tr></tbody></table><p>但问题来了，需要延迟多长时间才能达到前面所说的效果呢？毕竟 B 什么时候能写完缓存可是不可预料的，而且如果延迟时间设置的过长，也会导致系统的延迟变高。</p><h1 id="共同的问题"><a href="#共同的问题" class="headerlink" title="共同的问题"></a>共同的问题</h1><p>上面这些方法中都还存在一个共同的问题，就是它们这一整个操作实际都是由多个小操作构成的，比如上面的延迟双删，它就是由更新数据库和删除缓存两个操作共同组成的，这就必然会涉及到原子性的问题，比如一个操作执行成功了，另一个操作却执行失败了，那么此时依然会导致结果不正确，比如：</p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">C</th></tr></thead><tbody><tr><td align="center">删缓存</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">读缓存，miss</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">读 DB，x &#x3D; 1</td><td align="center"></td></tr><tr><td align="center">更新 db，x &#x3D; 2</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">延迟一会再删除缓存</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">写入缓存，x &#x3D; 1</td><td align="center"></td></tr><tr><td align="center">删掉缓存（网络异常，删除失败了）</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">读到的缓存依旧是 x &#x3D; 1</td></tr></tbody></table><p>我们可以给缓存加上过期时间来一定程度上规避这个问题，但是根本的问题还是没有解决，如何保证多个操作都能执行成功？</p>]]></content>
    
    
    
    <tags>
      
      <tag>缓存</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 面试题</title>
    <link href="/2022/08/18/go-mian_shi_ti/"/>
    <url>/2022/08/18/go-mian_shi_ti/</url>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="map、channel、slice-的底层实现"><a href="#map、channel、slice-的底层实现" class="headerlink" title="map、channel、slice 的底层实现"></a>map、channel、slice 的底层实现</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 使用的是拉链法，用哈希桶来保存键值对，每个桶可以保存 8 个键值对，它会用哈希算法计算出 key 的 hash 值，然后用这个哈希值的高 8 位作为 tophash，用于在一个桶中区别出 key；然后桶的数量是 2^b ，用低 b 位来决定这个 key 放到哪个桶。每个桶还会连接一个溢出桶，如果一个桶已经满了，但是依然有 key 落入到这个桶，那么就会将其放到溢出桶中。</p><p>map 的默认负载因子是 6.5，负载因子表示的是当前键值对的数量 &#x2F; 当前桶的数量，如果 map 的负载因子达到了 6.5，那么就说明此时可能所有桶都快装满了，如果再添加键值对，大概率会放到溢出桶中，所以此时就需要进行扩容了，对应的扩容策略是：创建数量是之前桶的 2 倍的新桶，然后将旧桶中的值迁移到新桶中（迁移的策略是怎样的？rehash，例如，原来 B &#x3D; 5，计算出 key 的哈希后，只用看它的低 5 位，就能决定它落在哪个 bucket。扩容后，B 变成了 6，因此需要多看一位，它的低 6 位决定 key 落在哪个 bucket。这称为 <code>rehash</code>。），还有一种情况是溢出桶的数量过多，可能的原因是键值对数量少，但过于分散，导致桶的数量多，解决办法是创建同样数量（不包含溢出桶吗？）的新桶，将旧桶中的数据迁移到这些新桶中，使整体键值对的排布更紧凑。</p><p>此外 Go map 扩容采用的渐进式扩容，当执行插入、更新、删除操作时进行小部分扩容，而不是一次性将所有桶进行迁移，这样可以减少搬迁操作对性能的影响。</p><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>channel 底层主要由一个发送阻塞队列和一个接收阻塞队列，以及一把互斥锁组成，发送阻塞队列存储的是因为发送操作而被阻塞的 goroutine，接收阻塞队列同理，这里面存储的都是被挂起的 goroutine，当执行发送操作时，会先检查接收阻塞队列里有没有值，有的话从队头取出，并将这个 goroutine 唤醒，并将数据拷贝给它，执行接收操作同理。互斥锁用来保证 chan 的线程安全。此外如果是有缓冲的 chan，还会存在一个环形数组，</p><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>扩容策略：</p><p>1.18 开始的新策略：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">grow</span><span class="hljs-params">(oldCap <span class="hljs-type">int</span>, <span class="hljs-built_in">cap</span> <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>newcap := oldCap<br>doublecap := newcap + newcap<br><br>  <span class="hljs-comment">// 直接使用当前的期望容量，因为超过了旧容量的2倍</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &gt; doublecap &#123;<br>newcap = <span class="hljs-built_in">cap</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">const</span> threshold = <span class="hljs-number">256</span><br><span class="hljs-keyword">if</span> oldCap &lt; threshold &#123;<br>      <span class="hljs-comment">// 小切片容量翻倍</span><br>newcap = doublecap<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 除了每次增加 25 % 容量，还额外多加 192</span><br><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="hljs-built_in">cap</span> &#123;<br>newcap += (newcap + <span class="hljs-number">3</span>*threshold) / <span class="hljs-number">4</span><br>        <span class="hljs-comment">// newcap += (newcap)/4</span><br>        <span class="hljs-comment">// newcap += 192</span><br>&#125;<br><span class="hljs-keyword">if</span> newcap &lt;= <span class="hljs-number">0</span> &#123;<br>newcap = <span class="hljs-built_in">cap</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> newcap<br>&#125;<br></code></pre></td></tr></table></figure><p>1.18 之前的策略：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">grow</span><span class="hljs-params">(oldCap <span class="hljs-type">int</span>, <span class="hljs-built_in">cap</span> <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>newcap := oldCap<br>doublecap := newcap + newcap<br><br><span class="hljs-comment">// 直接使用当前的期望容量，因为超过了旧容量的 2 倍</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &gt; doublecap &#123;<br>newcap = <span class="hljs-built_in">cap</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 没有超过旧容量的两倍</span><br><span class="hljs-keyword">if</span> oldCap &lt; <span class="hljs-number">1024</span> &#123;<br>      <span class="hljs-comment">// 小切片 容量翻倍</span><br>newcap = doublecap<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 每次增加 25% 容量，直到新容量大于期望容量</span><br><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="hljs-built_in">cap</span> &#123;<br>newcap += newcap / <span class="hljs-number">4</span><br>&#125;<br><span class="hljs-keyword">if</span> newcap &lt;= <span class="hljs-number">0</span> &#123;<br>newcap = <span class="hljs-built_in">cap</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> newcap<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sync-map、sync-pool、sync-Once-的原理"><a href="#sync-map、sync-pool、sync-Once-的原理" class="headerlink" title="sync.map、sync.pool、sync.Once 的原理"></a>sync.map、sync.pool、sync.Once 的原理</h2><h2 id="sync-map"><a href="#sync-map" class="headerlink" title="sync.map"></a>sync.map</h2><p><code>sync.Map</code> 的实现原理可概括为：</p><ul><li>通过 read 和 dirty 两个字段将读写分离，read 负责并发读以及更新操作（已存在元素写） ，dirty 负责读写</li><li>读取时会先查询 read，不存在再查询 dirty，写入时则只写入 dirty</li><li>读取 read 并不需要加锁（原子操作），而读或写 dirty 都需要加锁</li><li>另外有 misses 字段来统计 read 被穿透的次数（被穿透指需要读 dirty 的情况），超过一定次数则将 dirty 提升为 read，即将 dirty 的数据拷贝到 read，然后清空 dirty</li><li>对于删除数据则直接通过标记来延迟删除</li></ul><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/go_sync_map.webp"></p><h2 id="netpoller-的原理"><a href="#netpoller-的原理" class="headerlink" title="netpoller 的原理"></a>netpoller 的原理</h2><blockquote><p>netpoller 可以直接看 <a href="https://strikefreedom.top/archives/go-netpoll-io-multiplexing-reactor#toc-head-8">这篇文章</a>，写的非常棒</p></blockquote><p>Go netpoller 通过在底层对 epoll&#x2F;kqueue&#x2F;iocp 的封装，从而实现了使用同步编程模式达到异步执行的效果。总结来说，所有的网络操作都以网络描述符 netFD 为中心实现。netFD 与底层 PollDesc 结构绑定，当在一个 netFD 上读写遇到 EAGAIN 错误时（socket 都会设置为非阻塞，这样可以避免陷入系统调用，因为陷入系统调用会使得 g 对应的 m 也被阻塞），就将当前 goroutine 存储到这个 netFD 对应的 PollDesc 中，同时调用 gopark 把当前 goroutine 给 park 住，直到这个 netFD 上再次发生读写事件，才将此 goroutine 给 ready 激活重新运行。显然，在底层通知 goroutine 再次发生读写等事件的方式就是 epoll&#x2F;kqueue&#x2F;iocp 等事件驱动机制。</p><p>在 epoll 实现中，会将 PollDesc 存储到 epollevent.data 里面，这是一个 uintptr，然后调用 epoll_ctl 将这个 epollevent 注册到 epoll，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">netpollopen</span><span class="hljs-params">(fd <span class="hljs-type">uintptr</span>, pd *pollDesc)</span></span> <span class="hljs-type">uintptr</span> &#123;<br><span class="hljs-keyword">var</span> ev syscall.EpollEvent<br>ev.Events = syscall.EPOLLIN | syscall.EPOLLOUT | syscall.EPOLLRDHUP | syscall.EPOLLET<br>tp := taggedPointerPack(unsafe.Pointer(pd), pd.fdseq.Load())<br>*(*taggedPointer)(unsafe.Pointer(&amp;ev.Data)) = tp<br><span class="hljs-keyword">return</span> syscall.EpollCtl(epfd, syscall.EPOLL_CTL_ADD, <span class="hljs-type">int32</span>(fd), &amp;ev)<br>&#125;<br><br><span class="hljs-keyword">type</span> EpollEvent <span class="hljs-keyword">struct</span> &#123;<br>Events <span class="hljs-type">uint32</span><br>Data   [<span class="hljs-number">8</span>]<span class="hljs-type">byte</span> <span class="hljs-comment">// unaligned uintptr</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在执行 accept、connect 等函数时，会调用上面的函数，将这个 socket 的 fd 注册到 epoll</p><p>然后会有一个 netpoll 函数，其内部实际就是调用了 epoll_wait，获取已经就绪的 epollevent，然后我们可以从这个就绪 epollevent.data 里拿到我们之前设置的 PollDesc，然后又可以进一步从 PollDesc 的 rg&#x2F;wg （分别保存的是 读阻塞&#x2F;写阻塞 的 goroutine）中拿到 g（gmp 中的 g），从而将这个 g 唤醒。</p><p>唤醒的过程也比较复杂，涉及到 gmp 调度相关，貌似是会把待唤醒的 g 扔到一个队列，然后调度器会在某个时刻拿出来进行唤醒。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">netpoll</span><span class="hljs-params">(delay <span class="hljs-type">int64</span>)</span></span> gList &#123;<br><span class="hljs-comment">// 省略 ...</span><br><span class="hljs-keyword">var</span> events [<span class="hljs-number">128</span>]syscall.EpollEvent<br>retry:<br>    <span class="hljs-comment">// 阻塞等待，直到有就绪的 event</span><br>n, errno := syscall.EpollWait(epfd, events[:], <span class="hljs-type">int32</span>(<span class="hljs-built_in">len</span>(events)), waitms)<br><span class="hljs-comment">// 省略 ...</span><br>    <span class="hljs-keyword">var</span> toRun gList<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">int32</span>(<span class="hljs-number">0</span>); i &lt; n; i++ &#123;<br>        <span class="hljs-comment">// 拿到就绪的 event</span><br>ev := events[i]<br>        <span class="hljs-comment">// 省略 ...</span><br><span class="hljs-keyword">var</span> mode <span class="hljs-type">int32</span><br>        <span class="hljs-comment">// 判断被唤醒的事件是读阻塞还是写阻塞，然后设置 mod，然后 PollDesc 根据 mod，选择从 rg 或者 wg 拿到 goroutine</span><br><span class="hljs-keyword">if</span> ev.Events&amp;(syscall.EPOLLIN|syscall.EPOLLRDHUP|syscall.EPOLLHUP|syscall.EPOLLERR) != <span class="hljs-number">0</span> &#123;<br>mode += <span class="hljs-string">&#x27;r&#x27;</span><br>&#125;<br><span class="hljs-keyword">if</span> ev.Events&amp;(syscall.EPOLLOUT|syscall.EPOLLHUP|syscall.EPOLLERR) != <span class="hljs-number">0</span> &#123;<br>mode += <span class="hljs-string">&#x27;w&#x27;</span><br>&#125;<br><span class="hljs-keyword">if</span> mode != <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// 从 epollevent.data 中拿到 pollDesc</span><br>tp := *(*taggedPointer)(unsafe.Pointer(&amp;ev.Data))<br>pd := (*pollDesc)(tp.pointer())<br>tag := tp.tag()<br><span class="hljs-keyword">if</span> pd.fdseq.Load() == tag &#123;<br>pd.setEventErr(ev.Events == syscall.EPOLLERR, tag)<br>                <span class="hljs-comment">// 调用这里对 g 进行唤醒</span><br>netpollready(&amp;toRun, pd, mode)<br>&#125;<br>&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">netpollready</span><span class="hljs-params">(toRun *gList, pd *pollDesc, mode <span class="hljs-type">int32</span>)</span></span> &#123;<br><span class="hljs-keyword">var</span> rg, wg *g<br><span class="hljs-keyword">if</span> mode == <span class="hljs-string">&#x27;r&#x27;</span> || mode == <span class="hljs-string">&#x27;r&#x27;</span>+<span class="hljs-string">&#x27;w&#x27;</span> &#123;<br>rg = netpollunblock(pd, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-literal">true</span>)<br>&#125;<br><span class="hljs-keyword">if</span> mode == <span class="hljs-string">&#x27;w&#x27;</span> || mode == <span class="hljs-string">&#x27;r&#x27;</span>+<span class="hljs-string">&#x27;w&#x27;</span> &#123;<br>wg = netpollunblock(pd, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-literal">true</span>)<br>&#125;<br><span class="hljs-keyword">if</span> rg != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 貌似是把 g 扔到 gList 队列</span><br>toRun.push(rg)<br>&#125;<br><span class="hljs-keyword">if</span> wg != <span class="hljs-literal">nil</span> &#123;<br>toRun.push(wg)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">netpollunblock</span><span class="hljs-params">(pd *pollDesc, mode <span class="hljs-type">int32</span>, ioready <span class="hljs-type">bool</span>)</span></span> *g &#123;<br>    <span class="hljs-comment">// 根据 mod 选择拿 rg 还是 wg</span><br>gpp := &amp;pd.rg<br><span class="hljs-keyword">if</span> mode == <span class="hljs-string">&#x27;w&#x27;</span> &#123;<br>gpp = &amp;pd.wg<br>&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br>old := gpp.Load()<br><span class="hljs-keyword">if</span> old == pdReady &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> old == pdNil &amp;&amp; !ioready &#123;<br><span class="hljs-comment">// Only set pdReady for ioready. runtime_pollWait</span><br><span class="hljs-comment">// will check for timeout/cancel before waiting.</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">var</span> <span class="hljs-built_in">new</span> <span class="hljs-type">uintptr</span><br><span class="hljs-keyword">if</span> ioready &#123;<br><span class="hljs-built_in">new</span> = pdReady<br>&#125;<br><span class="hljs-keyword">if</span> gpp.CompareAndSwap(old, <span class="hljs-built_in">new</span>) &#123;<br><span class="hljs-keyword">if</span> old == pdWait &#123;<br>old = pdNil<br>&#125;<br>            <span class="hljs-comment">// 最终将 rg/wg 转换为 g，也就是 goroutine</span><br><span class="hljs-keyword">return</span> (*g)(unsafe.Pointer(old))<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="GC-的过程、写屏障的含义及作用"><a href="#GC-的过程、写屏障的含义及作用" class="headerlink" title="GC 的过程、写屏障的含义及作用"></a>GC 的过程、写屏障的含义及作用</h2><h2 id="GMP-模型，触发-Goroutine-切换的原因有哪些？for-死循环会怎么样？全局-goroutine-里面存储什么？"><a href="#GMP-模型，触发-Goroutine-切换的原因有哪些？for-死循环会怎么样？全局-goroutine-里面存储什么？" class="headerlink" title="GMP 模型，触发 Goroutine 切换的原因有哪些？for 死循环会怎么样？全局 goroutine 里面存储什么？"></a>GMP 模型，触发 Goroutine 切换的原因有哪些？for 死循环会怎么样？全局 goroutine 里面存储什么？</h2><h2 id="interface-的底层实现，怎么判空？"><a href="#interface-的底层实现，怎么判空？" class="headerlink" title="interface 的底层实现，怎么判空？"></a>interface 的底层实现，怎么判空？</h2><h2 id="reflect-的使用"><a href="#reflect-的使用" class="headerlink" title="reflect 的使用"></a>reflect 的使用</h2><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><h2 id="context-的使用"><a href="#context-的使用" class="headerlink" title="context 的使用"></a>context 的使用</h2><h2 id="Go-性能问题的定位过程（pprof-的使用）"><a href="#Go-性能问题的定位过程（pprof-的使用）" class="headerlink" title="Go 性能问题的定位过程（pprof 的使用）"></a>Go 性能问题的定位过程（pprof 的使用）</h2><h2 id="协程池的使用"><a href="#协程池的使用" class="headerlink" title="协程池的使用"></a>协程池的使用</h2><p>Go 协程池的实现比较简单，看了一些库，大致逻辑都是把用户调用的 func 封装成一个 task，然后把 task 存到一个队列（用 chan 或者链表啥的都可以），然后开启指定数量的 goroutine，每个 goroutine 里面写一个死循环，持续从这些队列中消费，这样就达到了限制 goroutine 数量的目的。</p><p>比如字节的 <a href="https://github.com/bytedance/gopkg/tree/develop/util/gopool">gopkg</a> 库里面就实现了一个 gopool，代码很精短，就是把用户执行的 func 封装成一个 task，然后扔到 pool 的链表里面，然后运行指定数量的 worker，每个 worker 实际就是一个 goroutine，并且还绑定了 pool，然后去持续消费 pool 的链表里面的 task，如果 task 消费完了则退出。</p><h2 id="go-的-panic-一定能被-recover-恢复吗"><a href="#go-的-panic-一定能被-recover-恢复吗" class="headerlink" title="go 的 panic 一定能被 recover 恢复吗"></a>go 的 panic 一定能被 recover 恢复吗</h2><p>不一定，首先 recover 只能恢复本协程的 panic，比如下面的例子中，fn1 中的 recover 无法恢复 fn2 协程中发生的 panic</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn1</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, err)<br>&#125;<br>&#125;()<br><span class="hljs-keyword">if</span> num%<span class="hljs-number">5</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;fn1 error&quot;</span>)<br>&#125;<br><span class="hljs-keyword">go</span> fn2(num)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn2</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> num%<span class="hljs-number">4</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;fn2 error&quot;</span>)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, num)<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一些 runtime 级别的 panic 无法被恢复，比如 map 并发读写的 panic，死锁等</p><h1 id="GMP-相关"><a href="#GMP-相关" class="headerlink" title="GMP 相关"></a>GMP 相关</h1><blockquote><p>GMP 文章：</p><p><a href="https://zboya.github.io/post/go_scheduler/#ggoroutine">深入golang runtime的调度</a></p></blockquote><h2 id="说一下-GMP-模型"><a href="#说一下-GMP-模型" class="headerlink" title="说一下 GMP 模型"></a>说一下 GMP 模型</h2><p>GMP 是 Go 的协程调度模型，其中：</p><p>G 是 go 关键字执行的函数<br>G 的调度完全由 Go runtime 实现，相比物理线程不需要内核参与，减少了上下文切换</p><p>M 是实际的物理线程，M 只能通过 P 来获取 G 执行任务</p><p>P 类似一个队列，P 的数量默认情况下和 CPU 核的数量相同，G 会放到 P 中，然后 M 从 P 中拿到 G 并执行</p><h2 id="GMP-模型，为什么要有-P？"><a href="#GMP-模型，为什么要有-P？" class="headerlink" title="GMP 模型，为什么要有 P？"></a>GMP 模型，为什么要有 P？</h2><p>如果所有 G 都在一个全局队列中，由所有的 M 争抢，会导致全局锁竞争严重。有了 P 以后，可以把 G 分开存放在多个 P 队列中，每个 M 从自己绑定的 P 队列中获取 G，可以减少争抢。</p><p>P 可以起到负载均衡的作用，每个 P 队列首先会从全局 G 队列获取 G，如果还没拿到就会从别的 P 队列中窃取，保证每个 P 中的 G 数量相对均衡。</p><p>P 还可以存储一些东西，比如 sync.Pool 就会在 P 中存储临时对象达到复用的效果</p><h2 id="Goroutine-阻塞的话，是不是对应的-M-也会阻塞"><a href="#Goroutine-阻塞的话，是不是对应的-M-也会阻塞" class="headerlink" title="Goroutine 阻塞的话，是不是对应的 M 也会阻塞"></a>Goroutine 阻塞的话，是不是对应的 M 也会阻塞</h2><p><del>如果 G 被阻塞在某个系统调用上，那么不仅仅 G 会阻塞，执行 G 的 M 也会解绑 P，与 G 一起进入挂起状态。如果此时有空闲的 M，则 P 和与其绑定并继续执行其他的 G；如果没有空闲的 M，但还是有其他 G 需要去执行，那么会创建一个新 M。当系统调用返回后，阻塞在该系统调用上的 G 会尝试获取一个可用的 P，如果没有可用的 P，那么这个 G 会被标记为 <code>runnable</code> 并把它放入全局的 runqueue 中等待调度，之前的那个挂起的 M 将再次进入挂起状态。</del></p><p>出处：<a href="https://www.zbpblog.com/blog-242.html">https://www.zbpblog.com/blog-242.html</a></p><p>G 阻塞分为以下 4 种情况：</p><p><strong>1. 由于原子、互斥量或通道操作调用导致 Goroutine 阻塞</strong></p><p><strong>调度器将把当前阻塞的 Goroutine 切换出去（<del>相当于调用了runtime.Goexit，把当前的goroutine从运行中的状态换成Grunnable状态并放入可运行G队列中</del> 感觉这里说的不对？Goexit 不是退出 goroutine 吗，应该是 Gosched 吧），当前 M 会换其他的 goroutine 运行。</strong></p><p>该情况的 G 阻塞不会阻塞内核线程 M，因此不会导致 M 的上下文切换而只涉及到 G 的切换。</p><p>如下图：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/gmp_g_block_sync.png"></p><p>（这里 G1 添加到队尾的操作没太搞明白，想表达的意思是被阻塞的 G 在就绪后会回到之前所在的 P 吗？貌似就是这个意思）</p><p>如果 G1 是被 chan 阻塞住的话，情况会和上图中的有所不同，G1 不会回到当前 P 的可运行 G 队列，而是被挂在了 chan 的 recvq 和 sendq 这两个队列中。</p><p><strong>2. 由于网络请求和文件IO 操作导致 Goroutine 阻塞</strong></p><p>之前说过 Go 的网络 IO 其实用的是异步非阻塞的系统调用结合多路复用器的事件监听机制，所以当前 G 会由于 IO 事件未就绪而被切换，但是不会阻塞 M。另外，Go 的文件 IO 其实也是使用的异步的系统调用和多路复用的事件监听优化。</p><p>该情况的 G 阻塞不会阻塞内核线程 M，因此不会导致 M 的上下文切换而只涉及到 G 的切换。</p><p>如下图：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/gmp_g_block_net.png"></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/gmp_g_block_net1.png"></p><p><strong>3. 由于调用阻塞的系统调用时导致的 goroutine 阻塞</strong></p><p>这种情况会导致当前 M 阻塞，内核会进行 M 的切换。而与当前 M 关联的当前 P 不会等待 M 的阻塞，因为这意味当前 P 下的所有 G 都无法执行，所以此时 P 会与当前 M 解除关联，转而关联到另一个内核线程 M2，M2 可能是新创建的内核线程，也可能是之前空闲的内核线程被唤醒来执行 P 的 G<br>如下图：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/gmp_g_block_syscall.png"></p><p>如果 G 被阻塞在某个系统调用上，那么不仅仅 G 会阻塞，执行 G 的 M 也会解绑 P，与 G 一起进入挂起状态。如果此时有空闲的 M，则 P 和与其绑定并继续执行其他的 G；如果没有空闲的 M，但还是有其他 G 需要去执行，那么会创建一个新 M。当系统调用返回后，阻塞在该系统调用上的 G 会尝试获取一个可用的 P，如果没有可用的 P，那么这个 G 会被标记为 <code>runnable</code> 并把它放入全局的 runqueue 中等待调度，之前的那个挂起的 M 将再次进入挂起状态。</p><h2 id="GMP-当一个-G-阻塞时，G、M、P-会发生什么"><a href="#GMP-当一个-G-阻塞时，G、M、P-会发生什么" class="headerlink" title="GMP 当一个 G 阻塞时，G、M、P 会发生什么"></a>GMP 当一个 G 阻塞时，G、M、P 会发生什么</h2><blockquote><p><strong>Tips：其实可以参考上一个问题，这两比较类似</strong></p></blockquote><p><strong>用户态阻塞</strong></p><p>当 goroutine 因为 channel 操作或者 network I&#x2F;O 而阻塞时（实际上 golang 已经用 netpoller 实现了 goroutine 网络 I&#x2F;O 阻塞不会导致 M 被阻塞，仅阻塞 G ），对应的 G 会被放置到某个 wait 队列（如 channel 的 waitq ），该 G 的状态由 _Gruning 变为 _Gwaitting，而 M 会跳过该 G 尝试获取并执行下一个 G，如果此时没有 runnable 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态；当阻塞的 G 被另一端的 G2 唤醒时（比如 channel 的可读&#x2F;写通知），G 被标记为 runnable，尝试加入 G2 所在 P 的 runnext，然后再是 P 的 Local 队列和 Global  队列。</p><p><strong>系统调用阻塞</strong></p><p>当 G 被阻塞在某个系统调用上时，此时 G 会阻塞在 _Gsyscall 状态，M 也处于 block on syscall 状态，此时的 M 可被抢占调度：执行该 G 的 M 会与 P 解绑，而 P 则尝试与其它 idle 的 M 绑定，继续执行其它 G。如果没有其它idle 的 M，但 P 的 Local 队列中仍然有 G 需要执行，则创建一个新的 M；当系统调用完成后，G 会重新尝试获取一个 idle 的 P 进入它的 Local 队列恢复执行，如果没有 idle 的 P，G 会被标记为 runnable 加入到 Global 队列。</p><h2 id="P-和-M-数量可以无限扩增的吗？"><a href="#P-和-M-数量可以无限扩增的吗？" class="headerlink" title="P 和 M 数量可以无限扩增的吗？"></a>P 和 M 数量可以无限扩增的吗？</h2><p>不是无线扩增的。</p><p>P 的数量：由启动时环境变量 <code>$GOMAXPROCS</code> 或者是由 <code>runtime</code> 的方法 <code>GOMAXPROCS()</code> 决定。</p><p>M 的数量：goroutine 程序启动时，会设置 M 的最大数量，默认10000。但是内核很难创建出如此多的线程，因此默认情况下 M 的最大数量取决于内核。也可以调用 runtime&#x2F;debug 中的 SetMaxThreads 函数，手动设置 M 的最大数量。</p><h2 id="P-的调度逻辑"><a href="#P-的调度逻辑" class="headerlink" title="P 的调度逻辑"></a>P 的调度逻辑</h2><p>先从本地 runq 获取待执行的 G，如果没有，再从全局 runq 获取待执行的 G，还没有的话，就从别的 P 中拿（偷）走一半的 G</p><h2 id="如果一个-G-运行时间过长，导致队列中后续-G-都无法运行呢？"><a href="#如果一个-G-运行时间过长，导致队列中后续-G-都无法运行呢？" class="headerlink" title="如果一个 G 运行时间过长，导致队列中后续 G 都无法运行呢？"></a>如果一个 G 运行时间过长，导致队列中后续 G 都无法运行呢？</h2><p>内容出处：<a href="https://www.bilibili.com/video/BV1zT4y1F7XF?spm_id_from=333.999.0.0%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%9C%89%E9%9D%9E%E5%B8%B8%E8%AF%A6%E7%BB%86%E7%9A%84%E4%BB%8B%E7%BB%8D">https://www.bilibili.com/video/BV1zT4y1F7XF?spm_id_from=333.999.0.0，里面有非常详细的介绍</a></p><p>这涉及到 GMP 的抢占，在 main goroutine 启动时，会创建一个 <strong>sysmon goroutine</strong>，这是一个特殊的协程，其不依赖 P，也不由 GMP 调度，他会本着<strong>公平调度的原则，对运行时间过长的 P，实行抢占操作</strong>，就是告诉那些运行时间超过阈值的 P 该让出了，那么怎么知道运行时间过长了呢？P 里面有一个 <code>schedtick</code> 字段，每当调度执行一个新的 G，并且不继承上个 G 的时间片时（这里不懂），就会把它自增 1，还有一个 <code>sysmontick.schedwhen</code> 记录的是上次调度的时间，监测协程如果检测到 <code>sysmontick.schedtick</code> 不等于 <code>p.schedtick</code>，说明这个 P 又发生了新的调度，就会同步 <code>schedwhen</code> 和 <code>schedtick</code>，但如果相等，则说明子 <code>schedwhen</code> 这个时间点之后，这个 P 并未发生了新的调度，或者沿用了之前 G 的时间片，所以可以通过当前时间与 <code>schedwhen</code> 的差值，(sysmontick.schedwhen + forcePreemptNS &lt; now)，来判断当前 P 上的 G 是否运行时间过长了，如果运行时间过长，那么就要通知该 P 让出了。</p><p>如何通知 P 呢？使用的是 <strong>栈增长</strong> 的方式。除了对协程栈没什么消耗的函数调用，Go 语言编译器都会在函数头部插入栈增长检测相关代码，会根据栈帧大小来插入不同的代码，<code>SP</code> 表示当前的栈使用到了哪个位置，<code>stackguard0</code> 表示协程栈的空间下界，当栈的消耗达到或超过 <code>stackguard0</code> 时，就需要进行栈增长，会根据超出大小的多少来使用不同的增长代码（这个具体看视频里的说明，一共 3 种策略），如果调度器希望当前 P 让出，那么就会将 <code>stackguard0</code> 设置为 <code>stackPreempt</code>，这是一个非常大的值，真正的栈指针不可能指向这个位置，所以可以安全的用作特殊标识，此外因为该值足够大，那么 3 种策略都会满足条件，从而 goto 到 <code>morestack</code> 处，<code>morestack</code> 会调用 <code>runtime.newstack</code> 函数，负责栈增长工作，但是在增长前，会先判断 <code>stackguard0</code> 是否等于 <code>stackPreempt</code>，如果等于就不进行栈增长了，而是执行一次协程调度，从而达到抢占的目的。</p><p>不过这种抢占方式的缺陷就是过于依赖栈增长代码，如果来个 for{}，因为不涉及到函数调用，所以与栈增长无关，也就无法通过上面的方式来实现抢占，这一问题在 go1.14 中得到了解决，因为它实现了异步抢占，是通过信号（signal）实现的，当要抢占时，会向协程关联的 M 发送一个 <code>sigPreempt</code> 信号（好像底层是 SIGURG），目标线程（M）收到信号后会被中断，转去执行 <code>sigHandler</code>，该函数检测到信号为 <code>sigPreempt</code> 后，会调用 <code>runtime.doSigPreempt</code> 函数，它会向当前被打断的协程上下文中，注入一个异步抢占函数调用，之后返回，被打断的协程恢复，立刻执行被注入的异步抢占函数，该函数最终会调用 runtime 中的调度逻辑，从而实现让出。</p><h2 id="G-陷入系统调用会发生什么"><a href="#G-陷入系统调用会发生什么" class="headerlink" title="G 陷入系统调用会发生什么"></a>G 陷入系统调用会发生什么</h2><p><strong>Tips：和第一个问题类似</strong></p><p>一个协程要执行系统调用，就要切换到 g0 栈（为什么要切换到 g0 栈），在系统调用过程中，G 和 M 会一直绑定在一起，不能被分开，也就用不到 P 了，所以在陷入系统调用前，当前 M 会让出 P，解除 m.P 与当前 P 的强关联，并且记录到 m.oldp 中。但是这个 P 如果放着不管就有点浪费了，还是需要将其关联到其他 M，继续执行工作，当之前的 M 结束系统调用后，会先检查之前的 P（m.oldp）是否被占用，没有的话就继续使用（绑定之前的 P，否则就重新申请一个，没申请到的话（什么情况下会申请不到？），就把当前 G 放到全局 runq 中，然后 M 就进入睡眠。</p><ul><li><p><strong>为什么优先绑定到之前的 P (m.oldp)？</strong></p><ul><li><p><strong>亲和性 (Affinity) 和局部性 (Locality)：</strong> 这是最主要的原因。</p><ul><li><p><strong>数据局部性：</strong> 刚刚执行系统调用的那个 G（它现在需要继续执行）很可能其相关数据仍然在当前 M 运行的 CPU 核心的缓存 (L1&#x2F;L2 Cache) 中。如果能继续使用原来的 P，G 就能在同一个 M 上恢复执行，从而最大化利用 CPU 缓存，提高性能。</p></li><li><p><strong>P 本地队列：</strong> P 的本地运行队列可能仍然包含与刚完成系统调用的 G 相关或逻辑上接近的其他 G。保持 M 和 P 的关联有助于维护这种任务的局部性。</p></li><li><p><strong>内存分配器缓存 (mcache)：</strong> P 还关联了一个内存分配器的本地缓存 (mcache)。如果 M 能重新绑定到原来的 P，它可以继续使用这个热缓存，提高内存分配效率。</p></li></ul></li><li><p><strong>简单高效：</strong> 直接检查 m.oldp 是最快的尝试路径。如果成功，可以避免搜索全局空闲 P 列表或参与更复杂的调度逻辑。</p></li></ul></li></ul><h2 id="如果当前-M-没有绑定-P，那么如何获取-G"><a href="#如果当前-M-没有绑定-P，那么如何获取-G" class="headerlink" title="如果当前 M 没有绑定 P，那么如何获取 G"></a>如果当前 M 没有绑定 P，那么如何获取 G</h2><p>好的，这是一个非常好的问题，它触及了 GMP 调度模型的细节。</p><p>如果一个 M (操作系统线程) 当前没有绑定 P (逻辑处理器)，它**不能直接获取并执行 G (Goroutine)**。因为执行 Go 代码需要 P 提供的上下文环境（如内存分配器 <code>mcache</code>、调度信息等）。</p><p>因此，一个没有 P 的 M 的<strong>首要任务是尝试获取一个 P</strong>。这个过程大致如下：</p><ol><li><p><strong>检查全局空闲 P 列表 (<code>sched.pidle</code>)</strong>:</p><ul><li>调度器维护一个全局的空闲 P 列表。M 会首先尝试从这个列表中获取一个 P。</li><li>如果找到了一个空闲的 P，M 就会与这个 P 绑定。</li></ul></li><li><p><strong>如果找不到空闲 P</strong>:</p><ul><li>这意味着所有 P 都正忙于被其他 M 绑定并执行 G。</li><li>在这种情况下，这个 M 通常会进入**休眠状态 (park)**，将自己放入一个全局的空闲 M 列表 (<code>sched.midle</code>) 中，等待被唤醒。它不会主动去“抢”一个正在被使用的 P。</li></ul></li></ol><p><strong>一旦 M 成功获取并绑定了一个 P，它才会开始寻找 G 来执行。</strong> 获取 G 的过程遵循标准的优先级顺序：</p><ol><li><strong>检查绑定的 P 的本地运行队列 (LRQ - Local Run Queue):</strong> 这是最高效的方式，因为访问本地队列不需要加锁或只需要轻量级锁。</li><li><strong>检查全局运行队列 (GRQ - Global Run Queue):</strong> 如果 LRQ 为空，M 会尝试从全局队列获取 G。访问 GRQ 需要加锁，会有一定的开销。调度器会定期（例如每进行 61 次调度）检查一次全局队列，以确保全局队列中的 G 不会“饿死”。</li><li><strong>网络轮询器 (Netpoller):</strong> 检查是否有因网络 I&#x2F;O 完成而准备就绪的 G。</li><li><strong>工作窃取 (Work Stealing):</strong> 如果以上都没有找到 G，M 会尝试从<strong>其他随机选择的 P</strong> 的 LRQ 中“窃取”一半的 G 到自己的 LRQ 中来执行。这也是需要加锁的操作。</li><li><strong>再次检查全局队列和 Netpoller (可能):</strong> 在窃取失败后，可能会再次尝试检查这些地方。</li><li><strong>如果仍然找不到 G:</strong> 如果尝试了所有方法都找不到可运行的 G，这个 M 可能会<strong>释放它绑定的 P</strong> (将 P 放回全局空闲 P 列表)，然后 M 自己再次进入**休眠状态 (park)**。</li></ol><p><strong>总结:</strong></p><p>一个没有 P 的 M <strong>不能直接获取 G</strong>。它的流程是：</p><ol><li><strong>先尝试获取一个空闲的 P</strong>。</li><li>如果获取失败，M 就<strong>休眠</strong>。</li><li>如果获取成功，<strong>M 与 P 绑定</strong>。</li><li><strong>然后</strong>，这个绑定了 P 的 M 才开始按照 <strong>LRQ -&gt; GRQ -&gt; Netpoller -&gt; Work Stealing</strong> 的顺序去寻找 G 来执行。</li></ol><h2 id="GMP-的几个队列"><a href="#GMP-的几个队列" class="headerlink" title="GMP 的几个队列"></a>GMP 的几个队列</h2><p>貌似 GMP 里的全局队列有两种类型，一种就是单纯保存用作记录的（比如记录当前有哪些 G），还有一种是调度器的全局队列，里面保存的是空闲状态的 G&#x2F;M&#x2F;P</p><p><strong>调度器的可运行 G 队列</strong></p><p>存放等待执行的 G，新创建的 G 会先尝试保存到当前 G （这个 G 就是新创建 G 的父 goroutine）对应的 p 的本地队列，如果本地队列已满（256个），就会把 G 放到全局队列中。</p><p>该队列有容量限制吗？</p><p>该队列里的 G 什么时候被消费？</p><p>如果某个 p 的本地 g 队列为空，则会从全局队列里获取</p><p><strong>全局 M 队列</strong></p><ul><li>作用：</li></ul><ol><li>获取所有 M 的信息 </li><li>防止 M 被当作垃圾回收掉</li></ol><p><strong>调度器的空闲 M 队列</strong></p><p>运行时系统在停止 M 时，会把它放入调度器的空闲 M 队列</p><ul><li>什么时候被消费</li></ul><p>当 G 陷入系统调用时，与其关联的 M 也会被阻塞，而与之关联的 P 会被分离，使得这个 P 中剩余的 G 可以被执行，此时 P 就会去全局 M 队列里查找，如果有的话</p><p><strong>全局 P 队列</strong></p><p>保存了当前 runtime 创建的所有 P，runtime 会把这些 p 中的可运行 g 全部取出，并放入调度器的可运行 g 队列中，被转移的这些 g，会在以后经由调度再次放入某个 p 的可运行 g 队列</p><p><strong>调度器的空闲 P 队列</strong></p><p>当一个 p 不与任何 m 关联时，runtime 就会把它放入该列表，当 runtime 需要一个空闲的 p 来关联某个 m 时，就会从该队列获取。此外，p 进入空闲队列的一个重要条件是，本地队列里没有可运行的 g</p><p><strong>P 的 G 队列</strong></p><p>保存的是可运行的 g，新创建的 g 会先尝试放到这里，最大容量为 256。</p><p><strong>P 的自由 G 队列，调度器的自由 G 列表</strong></p><p>自由 g 表示的是已经运行完成的 g，主要是为了提高复用率，避免频繁创建 g，因为 g 本质也是一个对象。</p><p>运行完成的 g 会先放到对应的 p 的自由 g 队列里，如果太多了，就会转移一部分到调度器的自由 g 列表</p><p>当创建一个 goroutine 时，会先尝试从 p 的自由 g 队列中获取一个现成的 g，如果没有或者太少，会从调度器的自由 g 队列中拿一部分，如果调度器中也没有，才会新创建一个 g</p><h2 id="g0，m0-是什么"><a href="#g0，m0-是什么" class="headerlink" title="g0，m0 是什么"></a>g0，m0 是什么</h2><blockquote><p>网上的文章东抄西抄</p></blockquote><h3 id="g0"><a href="#g0" class="headerlink" title="g0"></a>g0</h3><p>Go 使用 <code>GOMAXPROCES</code> 变量控制运行的系统线程个数，这就意味着 Go 必须在每个运行着的系统线程上调度和管理 goroutine。这个调度工作被委托给一个特殊的goroutine，也就是 <code>g0</code>。调度过程中 <code>g0</code> 会把就绪状态的 goroutine 调度到系统线程上运行。因此 <code>g0</code> 是每个 os 线程创建的第一个 goroutine。</p><p>G0 代表系统栈的 Goroutine，它是一种特殊类型的 Goroutine，用于运行调度器自身的代码。G0 主要负责调度和管理任务，例如 Goroutine 的创建、销毁和调度。</p><p><strong>调度 g</strong>：G0 仅用于负责调度其他的 G（M 可能会有很多的 G，然后 G0 用来保持调度栈的信息)，当一个 M 从 G1 切换到 G2，首先应该切换到 G0，通过 G0 把 G1干掉，再切换到 G2</p><p>将一个运行中的 Goroutine 切换到另一个的过程涉及到两个切换：</p><ul><li>将运行中的 <code>g</code> 切换到 <code>g0</code></li><li>将 <code>g0</code> 切换到下一个将要运行的 <code>g</code>：</li></ul><h3 id="m0"><a href="#m0" class="headerlink" title="m0"></a>m0</h3><p>m0 是 Go runtime 创建的第一个系统线程（主线程），一个 Go 进程只有一个 m0。</p><p><strong>数据结构</strong>：从数据结构上看 m0 和其他 m 没有区别，同属于 m 结构体， m0 的定义是 var m0 m。</p><p><strong>创建</strong>：m0 是进程在启动时由汇编创建 m0 的，而其他的 m 是 Go 运行时创建，m0 在全局变量 runtime.m0 中，不需要在 heap 上分配。</p><p><strong>作用</strong>：负责执行初始化操作和启动第一个 G，启动第一个 G 后，M0 就和其他的一样了</p><h2 id="程序题"><a href="#程序题" class="headerlink" title="程序题"></a>程序题</h2><p>以下程序的运行结果是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">&quot;fmt&quot;</span><br>        <span class="hljs-string">&quot;sync&quot;</span><br>        <span class="hljs-string">&quot;runtime&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        runtime.GOMAXPROCS(<span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>        wg.Add(<span class="hljs-number">3</span>)<br><br>  <span class="hljs-comment">// goroutine1</span><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;<br>                fmt.Println(n)<br>                wg.Done()<br>        &#125;(<span class="hljs-number">1</span>)<br><br>  <span class="hljs-comment">// goroutine2</span><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;<br>                fmt.Println(n)<br>                wg.Done()<br>        &#125;(<span class="hljs-number">2</span>)<br><br>  <span class="hljs-comment">// goroutine3</span><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;<br>                fmt.Println(n)<br>                wg.Done()<br>        &#125;(<span class="hljs-number">3</span>)<br><br>        wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：3 1 2</p><p>P 有一个 runnext 字段，保存的是下一个要运行的 g，当创建一个新的 g 时，会调用 runqput 将其添加到 P 的 runq 中，如果当前 P 的 runq 中已经有 g 了，则会将其挤走，被挤走的那个进入 P 的本地 runq。runnext 的优先度比 runq 高，会先执行 runnext 的 g，再按顺序执行 runq 中的 g。</p><p>在上面的程序中，因为设置了 runtime.GOMAXPROCS(1)，所以整个 runtime 中只有 1 个 P，也就是说上面的 3 个goroutine 都共用这一个 P，首先，goroutine1（简称 g1） 先放到 runnext，之后 g2 进来把 g1 挤走，g1 放到 runq，再之后，g3 把 g2 挤走，g2 放到 runq，此时 runnext 保存的是 g3，runq 中是 g1，g2，所以输出结果是 3，1，2</p><h2 id="Goroutine-的调度时机有哪些"><a href="#Goroutine-的调度时机有哪些" class="headerlink" title="Goroutine 的调度时机有哪些"></a>Goroutine 的调度时机有哪些</h2><p>在四种情形下，goroutine 可能会发生调度，但也并不一定会发生，只是说 Go scheduler 有机会进行调度。</p><table><thead><tr><th>情形</th><th>说明</th></tr></thead><tbody><tr><td>使用关键字 <code>go</code></td><td>go 创建一个新的 goroutine，Go scheduler 会考虑调度</td></tr><tr><td>GC</td><td>由于进行 GC 的 goroutine 也需要在 M 上运行，因此肯定会发生调度。当然，Go scheduler 还会做很多其他的调度，例如调度不涉及堆访问的 goroutine 来运行。GC 不管栈上的内存，只会回收堆上的内存</td></tr><tr><td>系统调用</td><td>当 goroutine 进行系统调用时，会阻塞 M，所以它会被调度走，同时一个新的 goroutine 会被调度上来</td></tr><tr><td>内存同步访问</td><td>atomic，mutex，channel 操作等会使 goroutine 阻塞，因此会被调度走。等条件满足后（例如其他 goroutine 解锁了）还会被调度上来继续运行</td></tr></tbody></table><h1 id="GC-相关"><a href="#GC-相关" class="headerlink" title="GC 相关"></a>GC 相关</h1><h2 id="GC-的原理"><a href="#GC-的原理" class="headerlink" title="GC 的原理"></a>GC 的原理</h2><p>三色标记法+混合写屏障</p><p>三色标记法：首先所有对象都是白色，然后先从根节点开始遍历，当前遍历的节点会置为灰色，放到灰色队列中。然后 GC 会不断从灰色队列中取出灰色对象，把它标记为黑色，同时把它引用的对象（白色）标记为灰色，放到灰色队列中，就这样循环往复，直到灰色队列为空。此时还是白色的对象说明就是可以被清理的对象。</p><p>根节点：全局对象，以及栈对象</p><p>灰色代表：该对象已被 GC 发现（即它是可达的，不会是垃圾），但它的子对象<strong>尚未</strong>被完全扫描处理。灰色对象代表了标记过程正在推进的<strong>前沿</strong>或<strong>工作列表</strong>。灰色明确地区分了“已发现但待处理子节点”和“已发现且子节点已处理完毕”这两种状态。</p><p>在标记过程中需要进入 STW 阶段，也就是暂停所有的线程，让 GC 能够不受干扰的进行标记。否则可能会造成混乱，比如一个已经标记为黑色（这代表本轮 GC 不会再扫描它引用的对象）的对象，在 GC 标记过程中，又被其他线程修改，让它指向一个白色对象，这就会导致这个白色对象被错误的清理掉。</p><p>但是 STW 势必会造成程序的暂停，对于一些性能敏感的应用显然无法接受。为了允许普通线程和 GC 线程能够同时并发执行，Go GC 引入了写屏障功能来解决。</p><p>写屏障是一小段由编译器插入的代码，它会在<strong>用户 Goroutine 修改指针</strong>时执行。比如当用户协程尝试将一个黑色对象指向一个白色对象时，写屏障会把这个白色对象修改为灰色对象，这样就可以让这个对象被 GC 扫描到，从而避免被错误的清理。</p><p>问题：为什么要引入一个灰色状态？不引入会有什么问题？</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个类似的堆问题：leetcode 347 前 K 个高频元素 和 692. 前 K 个高频单词 </title>
    <link href="/2022/08/17/leetcode_347_and_692/"/>
    <url>/2022/08/17/leetcode_347_and_692/</url>
    
    <content type="html"><![CDATA[<p>首先先来看一下这两个问题：</p><h1 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h1><blockquote><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p><p>示例 1:</p><p>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>输出: [1,2]</p><p>示例 2:</p><p>输入: nums &#x3D; [1], k &#x3D; 1<br>输出: [1]</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>k 的取值范围是 [1, 数组中不相同的元素的个数]<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的</p><p>进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。</p></blockquote><h1 id="692-前-K-个高频单词"><a href="#692-前-K-个高频单词" class="headerlink" title="692. 前 K 个高频单词"></a><a href="https://leetcode.cn/problems/top-k-frequent-words/">692. 前 K 个高频单词</a></h1><blockquote><p>给定一个单词列表 words 和一个整数 k ，返回前 k 个出现次数最多的单词。</p><p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， 按字典顺序 排序。</p><p>示例 1：</p><p>输入: words &#x3D; [“i”, “love”, “leetcode”, “i”, “love”, “coding”], k &#x3D; 2<br>输出: [“i”, “love”]<br>解析: “i” 和 “love” 为出现次数最多的两个单词，均为2次。<br>    注意，按字母顺序 “i” 在 “love” 之前。</p><p>示例 2：</p><p>输入: [“the”, “day”, “is”, “sunny”, “the”, “the”, “the”, “sunny”, “is”, “is”], k &#x3D; 4<br>输出: [“the”, “is”, “sunny”, “day”]<br>解析: “the”, “is”, “sunny” 和 “day” 是出现次数最多的四个单词，<br>    出现次数依次为 4, 3, 2 和 1 次。</p><p>注意：</p><p>1 &lt;&#x3D; words.length &lt;&#x3D; 500<br>1 &lt;&#x3D; words[i] &lt;&#x3D; 10<br>words[i] 由小写英文字母组成。<br>k 的取值范围是 [1, 不同 words[i] 的数量]</p><p>进阶：尝试以 O(n log k) 时间复杂度和 O(n) 空间复杂度解决。</p></blockquote><p>发现这两个问题有点类似（从名字都能看出来），只不过一个是从 int 数组里找，且结果对顺序没有要求（也就是说如果有两个元素出现的次数相同，那么不需要考虑它们的顺序问题，谁前谁后都可以）；另一个是从 string 数组里找，如果两个单词出现次数相同，那么需要按字典序进行排序，比如 a 和 b 都出现了 10 次，那么 a 要排在前面。</p><p>像这种 topk 问题，貌似都可以使用 <strong>堆</strong> 来解决，大致逻辑是：用最小堆来解决，建一个大小为 K 的堆，然后遍历数组，如果当前堆的元素不到 K 个，则直接将元素添加到堆中，如果堆的元素 &gt;&#x3D; K，此时堆顶保存的是整个堆中最小的元素，那么就比较当前元素是否小于堆顶，如果比堆顶还小，那么直接跳过，如果大于堆顶，那么可以将堆顶这个最小的元素 pop 掉，然后把 push 当前元素，因为堆会自动调整结构，所以 push 后堆顶依然是整个堆中最小的元素。当数组遍历完后，整个堆中保存的就是最大的 K 个元素。</p><p>以上只是大致的逻辑，但是相对来说还是比较通用的，只是比较的规则需要调整一下，按照上面的逻辑写一下这两道题。</p><h1 id="347-代码"><a href="#347-代码" class="headerlink" title="347 代码"></a>347 代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myheap <span class="hljs-keyword">struct</span> &#123;<br>    s []<span class="hljs-type">int</span><br>    mp <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>    m.s[i], m.s[j] = m.s[j], m.s[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(m.s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> m.mp[m.s[i]] &lt; m.mp[m.s[j]]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *myheap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    m.s = <span class="hljs-built_in">append</span>(m.s, x.(<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *myheap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    p := m.s[<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    m.s = m.s[:<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> p<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> (res []<span class="hljs-type">int</span>) &#123;<br>    h := &amp;myheap&#123;mp : <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)&#125;<br><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>        h.mp[v]++<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> h.mp &#123;<br>        <span class="hljs-keyword">if</span> h.Len() &lt; k &#123;<br>            heap.Push(h, v)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> h.mp[h.s[<span class="hljs-number">0</span>]] &lt; h.mp[v] &#123;<br>                heap.Pop(h)<br>                heap.Push(h, v)<br>            &#125; <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> h.s<br>&#125;<br></code></pre></td></tr></table></figure><p>（不得不吐槽一下 go 的容器库，实在太蛋疼了，没有泛型就算了，只提供一个最基本的 heap，需要自己实现  2 个接口 5 个方法，写起来实在繁琐，不像其他语言的优先队列用起来那么方便 ）</p><p>因为题目要求的是出现次数，所以需要用一个 map 来保存所有元素的出现次数，然后基于这个 map 来进行比较，这里需要注意的是 Less() 这个方法，它的实现逻辑是 <code>return m.mp[m.s[i]] &lt; m.mp[m.s[j]]</code>，也就是基于元素的出现次数来作为堆的比较依据；还有当前元素和堆顶的比较逻辑 <code>h.mp[h.s[0]] &lt; h.mp[v]</code> 也是基于元素的出现次数进行比较。除了这两点以外，基本和之前的通用逻辑相似。</p><h1 id="692-代码"><a href="#692-代码" class="headerlink" title="692 代码"></a>692 代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myheap <span class="hljs-keyword">struct</span> &#123;<br>    s []<span class="hljs-type">string</span><br>    mp <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>    m.s[i], m.s[j] = m.s[j], m.s[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(m.s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Less(i, j <span class="hljs-type">int</span>) (res <span class="hljs-type">bool</span>) &#123;<br>    o1 := m.s[i]<br>    o2 := m.s[j]<br>    m1 := m.mp[o1]<br>    m2 := m.mp[o2]<br>    <span class="hljs-keyword">if</span> m1 == m2 &#123;<br>        <span class="hljs-keyword">return</span> o1 &gt; o2 <span class="hljs-comment">// 如果出现频率相同，按字典序排列</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> m1 &lt; m2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *myheap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    m.s = <span class="hljs-built_in">append</span>(m.s, x.(<span class="hljs-type">string</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *myheap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    p := m.s[<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    m.s = m.s[:<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> p<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(words []<span class="hljs-type">string</span>, k <span class="hljs-type">int</span>)</span></span> (res []<span class="hljs-type">string</span>) &#123;<br>    m := &amp;myheap&#123;<br>        mp: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>),<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> words &#123;<br>        m.mp[v]++<br>    &#125; <br><br>    <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> m.mp &#123;<br>        <span class="hljs-keyword">if</span> m.Len() &lt; k &#123;<br>            heap.Push(m, v)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (m.mp[v] == m.mp[m.s[<span class="hljs-number">0</span>]] &amp;&amp; v &lt; m.s[<span class="hljs-number">0</span>]) ||<br>                    m.mp[v] &gt; m.mp[m.s[<span class="hljs-number">0</span>]] &#123;<br>                heap.Pop(m)<br>                heap.Push(m, v)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>  res = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, m.Len())<br>    <span class="hljs-keyword">for</span> i := k; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>        res[i<span class="hljs-number">-1</span>] = heap.Pop(m).(<span class="hljs-type">string</span>)<br>    &#125;<br>    <span class="hljs-comment">//for i := 0; i &lt; k; i++ &#123;</span><br>    <span class="hljs-comment">//    res = append(res, heap.Pop(m).(string))</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">// 因为是小顶堆，堆顶为出现次数最小的，而题目要求次数多的排在前面，所以需要反转结果</span><br>    <span class="hljs-comment">//for i, j := 0, len(res)-1; i &lt; j; i++ &#123;</span><br>    <span class="hljs-comment">//    res[i], res[j] = res[j], res[i]</span><br>    <span class="hljs-comment">//    j--</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这道题相比 347 要麻烦一些，当时写的时候有一个比较迷的地方，就是 Less() 里的判断逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">o1 := m.s[i]<br>o2 := m.s[j]<br>m1 := m.mp[o1]<br>m2 := m.mp[o2]<br><br><span class="hljs-keyword">if</span> m1 == m2 &#123;<br>   <span class="hljs-keyword">return</span> o1 &gt; o2 <span class="hljs-comment">// 如果出现频率相同，按字典序排列</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当时没搞懂为什么是 o1 &gt; o2，其实这里需要理解 go heap 的底层实现，Less() 是用来判断是否需要交换元素的，如果 Less 返回 true 才需要交换，也就是说如果 o1 &gt; o2（这是两个 string，且 o1 对应下标 i，o2 对应下标 j，这里假设 i 在前，j 在后），那么按照字典序排列，应该是小在前大在后（也就是 i 对应的元素要小于 j 对应的元素），所以需要进行交换，把小的 o2 换到前面，大的 o1 换到后面。</p><p>此外还有和堆顶比较的逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> (m.mp[v] == m.mp[m.s[<span class="hljs-number">0</span>]] &amp;&amp; v &lt; m.s[<span class="hljs-number">0</span>]) ||<br>                    m.mp[v] &gt; m.mp[m.s[<span class="hljs-number">0</span>]]<br></code></pre></td></tr></table></figure><p>这里为什么又是 <code>v &lt; m.s[0])</code> 呢？还是因为字典序。比如 [“i”,”love”,”leetcode”,”i”,”love”,”coding”]，k&#x3D;3 这个测试用例，最终的结果是[“i”,”love”,”coding”]，leetcode 和 coding 都出现了 1 次，所以要比较它们的字典序，而 coding &lt; leetcode，所以选择 coding 这个较小的。对应到堆，如果此时堆顶为 leetcode，现在要添加 coding 到堆中，需要判断逻辑为：在出现次数相同的情况下，如果当前元素的字典序小于堆顶，则 pop 堆顶，并 push 当前元素，这样才能让这个较小的元素入堆。</p><p>此外，因为题目要求返回的答案按单词出现频率由高到低排序，所以也不能像 347 那样，直接把堆中的元素返回，因为堆是不保证整体有序的，它只保证两个子节点都小于（大于）父节点，那如何让其有序呢？只需要不断 pop 即可，这里 go heap 的 pop 接口实现看起来有点诡异：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *myheap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    p := m.s[<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    m.s = m.s[:<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> p<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这里难免会有点纳闷，我明明是要 pop 堆顶元素，不应该是移除 m.s[0] 才对吗？为什么这里要移除最后一个元素？这里又得看源码了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pop</span><span class="hljs-params">(h Interface)</span></span> any &#123;<br>n := h.Len() - <span class="hljs-number">1</span><br>h.Swap(<span class="hljs-number">0</span>, n)<br>down(h, <span class="hljs-number">0</span>, n)<br><span class="hljs-keyword">return</span> h.Pop()<br>&#125;<br></code></pre></td></tr></table></figure><p>这下明白了，原来底层实现会将堆顶换到堆尾，所以才需要移除最后一个元素。同时也知道了，在交换堆顶到堆尾后，会从堆顶开始，执行 down 操作，调整整体的堆，让堆顶继续是整个堆中最小的元素（会忽略末尾元素，也就是刚刚被换到末尾的那个最小的元素），所以每次 pop 都是当前堆中最小的那个元素，进而保证有序。</p><p>代码里将 pop 的元素保存到一个 slice 里面，因为是小顶堆，所以 pop 的元素是由小到大的，<del>而这不满足题目 “由大到小” 的要求，需要将 slice 翻转，变成降序排列。其实这里用一个链表保存更合理，每次 pop 往链表头部添加即可，如果是 slice 的话，每次都往头部添加会导致开销特别大（频繁的分配拷贝，效率还不如整体翻转），但是题目给的定义是返回一个 slice，也只能这么做了（java 版本的题目定义返回的就是一个 linkedlist）。</del>  而题目要求的是由大到小，只需要先预分配 slice 的空间为堆的长度，然后从尾部向头部添加就可以了。</p><h1 id="另一种模板"><a href="#另一种模板" class="headerlink" title="另一种模板"></a>另一种模板</h1><p>看了一些题解，发现他们的写法略有不同，主要是在添加到堆的逻辑这里，不需要和堆顶元素进行比较，而是先 push 进去，如果发现长度大于 K 了，则执行 pop，感觉这种写法的代码会比较简洁明了容易理解，但是可能效率会低一些，像之前的逻辑会和堆顶进行比较，如果不满足某些条件会直接跳过，不执行任何操作，而这里的逻辑是遍历的每个元素都先无脑 push 进去，push 还需要执行堆的调整操作，所以相比叫而言会多做一些无用功。</p><h2 id="692"><a href="#692" class="headerlink" title="692"></a>692</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myheap <span class="hljs-keyword">struct</span> &#123;<br>    s []<span class="hljs-type">string</span><br>    mp <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>    m.s[i], m.s[j] = m.s[j], m.s[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(m.s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    o1 := m.s[i]<br>    o2 := m.s[j]<br>    m1 := m.mp[o1]<br>    m2 := m.mp[o2]<br>    <span class="hljs-keyword">if</span> m1 == m2 &#123;<br>        <span class="hljs-keyword">return</span> o1 &gt; o2 <span class="hljs-comment">// 如果出现频率相同，按字典序排列</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> m1 &lt; m2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *myheap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    m.s = <span class="hljs-built_in">append</span>(m.s, x.(<span class="hljs-type">string</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *myheap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    p := m.s[<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    m.s = m.s[:<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> p<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(words []<span class="hljs-type">string</span>, k <span class="hljs-type">int</span>)</span></span> (res []<span class="hljs-type">string</span>) &#123;<br>    m := &amp;myheap&#123;<br>        mp: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>),<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> words &#123;<br>        m.mp[v]++<br>    &#125; <br><br>    <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> m.mp &#123;<br>        heap.Push(m, v)<br>        <span class="hljs-keyword">if</span> m.Len() &gt; k &#123;<br>            heap.Pop(m)<br>        &#125;<br>    &#125;<br>  <br>  res = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, m.Len())<br>    <span class="hljs-keyword">for</span> i := k; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>        res[i<span class="hljs-number">-1</span>] = heap.Pop(m).(<span class="hljs-type">string</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不得不说确实简洁很多，主要是 range m.mp 这里的逻辑，对比一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第一种写法</span><br>    <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> m.mp &#123;<br>        <span class="hljs-keyword">if</span> m.Len() &lt; k &#123;<br>            heap.Push(m, v)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (m.mp[v] == m.mp[m.s[<span class="hljs-number">0</span>]] &amp;&amp; v &lt; m.s[<span class="hljs-number">0</span>]) ||<br>                    m.mp[v] &gt; m.mp[m.s[<span class="hljs-number">0</span>]] &#123;<br>                heap.Pop(m)<br>                heap.Push(m, v)<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 第二种写法    </span><br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> m.mp &#123;<br>        heap.Push(m, v)<br>        <span class="hljs-keyword">if</span> m.Len() &gt; k &#123;<br>            heap.Pop(m)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="347"><a href="#347" class="headerlink" title="347"></a>347</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myheap <span class="hljs-keyword">struct</span> &#123;<br>    s []<span class="hljs-type">int</span><br>    mp <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>    m.s[i], m.s[j] = m.s[j], m.s[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(m.s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> m.mp[m.s[i]] &lt; m.mp[m.s[j]]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *myheap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    m.s = <span class="hljs-built_in">append</span>(m.s, x.(<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *myheap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    p := m.s[<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    m.s = m.s[:<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> p<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> (res []<span class="hljs-type">int</span>) &#123;<br>    h := &amp;myheap&#123;mp : <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)&#125;<br><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>        h.mp[v]++<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> h.mp &#123;<br>        heap.Push(h, v)<br>        <span class="hljs-keyword">if</span> h.Len() &gt; k &#123;<br>            heap.Pop(h)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> h.s<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go binary 使用指南 </title>
    <link href="/2022/08/08/go_binary/"/>
    <url>/2022/08/08/go_binary/</url>
    
    <content type="html"><![CDATA[<p>一个示例 demo：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;encoding/binary&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>Do()<br>&#125;<br><br><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123;<br>Id   <span class="hljs-type">int64</span><br>Name [<span class="hljs-number">10</span>]<span class="hljs-type">byte</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *S)</span></span> Do() &#123; fmt.Println(<span class="hljs-string">&quot;Do&quot;</span>) &#125;<br><br><span class="hljs-keyword">var</span> _ I = &amp;S&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">(b io.Writer, i I)</span></span> &#123;<br><span class="hljs-keyword">if</span> err := binary.Write(b, binary.BigEndian, i); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">read</span><span class="hljs-params">(b io.Reader, i I)</span></span> &#123;<br><span class="hljs-keyword">if</span> err := binary.Read(b, binary.BigEndian, i); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>buf = <span class="hljs-built_in">new</span>(bytes.Buffer)<br><span class="hljs-comment">//_buf = make([]byte, 4096)</span><br><span class="hljs-comment">//buf  = bytes.NewBuffer(_buf) 这样写会导致无法 read 出数据，原因未知</span><br>s = &amp;S&#123;<br>Id:   <span class="hljs-number">10001</span>,<br>Name: [<span class="hljs-number">10</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;,<br>&#125;<br>s_ = &amp;S&#123;&#125;<br>)<br>write(buf, s)<br>read(buf, s_)<br>fmt.Println(s_)<br>s_.Do()<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">&amp;&#123;10001 [97 98 99 0 0 0 0 0 0 0]&#125;<br>Do<br></code></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="1-如果写入的是结构体，那么结构体中不能有非定长的数据类型"><a href="#1-如果写入的是结构体，那么结构体中不能有非定长的数据类型" class="headerlink" title="1. 如果写入的是结构体，那么结构体中不能有非定长的数据类型"></a>1. 如果写入的是结构体，那么结构体中不能有非定长的数据类型</h2><p>比如 int 和 string，这两个都是不定长的，int 会根据操作系统来决定长度，而 string 代表的是字符串，可以进行拼接&#x2F;删除等操作，所以也不是定长的，这些类型都无法通过 binary.Write 进行写入。如果想写入 int 类型的变量，应该显示指定其长度，比如 int64。切片类型也是不定长的，所以只能传入需要指定长度的数组。</p><p>如果将 demo 中的结构体 S 修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123;<br>  pri  <span class="hljs-type">int64</span><br>Id   <span class="hljs-type">int64</span><br>Name []<span class="hljs-type">byte</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><code>panic: binary.Write: invalid type *main.S</code></p><h2 id="2-但是可以单独写入-byte"><a href="#2-但是可以单独写入-byte" class="headerlink" title="2. 但是可以单独写入 []byte"></a>2. 但是可以单独写入 []byte</h2><p>比如下面的程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/binary&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;bytes&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    b := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;123&quot;</span>)<br>    <span class="hljs-comment">//b := &quot;123456&quot;</span><br>    buf := <span class="hljs-built_in">new</span>(bytes.Buffer)<br>    bb := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(b), <span class="hljs-built_in">len</span>(b))<br><br>    <span class="hljs-keyword">if</span> err := binary.Write(buf, binary.BigEndian, b); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> err := binary.Read(buf, binary.BigEndian, bb); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    fmt.Println(b, bb)<br>&#125;<br><br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// [49 50 51] [49 50 51]</span><br></code></pre></td></tr></table></figure><p>这里单独将 b 写入，发现是可以正常运行的，但是 string 类型依然不能写入，会报错：panic: binary.Write: invalid type string</p><h2 id="3-如果写入的是-struct，需要保证所有字段为-public，但是结构体本身可以为-private"><a href="#3-如果写入的是-struct，需要保证所有字段为-public，但是结构体本身可以为-private" class="headerlink" title="3. 如果写入的是 struct，需要保证所有字段为 public，但是结构体本身可以为 private"></a>3. 如果写入的是 struct，需要保证所有字段为 public，但是结构体本身可以为 private</h2><p>注意是 <strong>所有字段</strong>，如果有非导出（private）字段，会报错：reflect: reflect.Value.SetInt using value obtained using unexported field</p><h2 id="4-可以写入接口类型"><a href="#4-可以写入接口类型" class="headerlink" title="4. 可以写入接口类型"></a>4. 可以写入接口类型</h2><p>通过开头的示例程序，说明是可以写入接口类型的（也就是说，binary.Read 和 binary.Write 的第三个参数可以传入接口类型）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP 拥塞控制</title>
    <link href="/2022/08/02/tcp_yong_se_kong_zhi/"/>
    <url>/2022/08/02/tcp_yong_se_kong_zhi/</url>
    
    <content type="html"><![CDATA[<p>发送方维护一个叫做 <strong>拥塞窗口 cwnd</strong> 的状态变量，其值 <strong>取决于网络的拥塞程度</strong>，并且 <strong>动态变化</strong>。</p><ul><li>拥塞窗口 <strong>cwnd 的维护原则</strong>：只要网络 <strong>没有出现拥塞</strong>，<strong>拥塞窗口</strong> 就再 <strong>增大</strong> 一些；但只要网络 <strong>出现拥塞</strong>，<strong>拥塞窗口就减少一些。</strong></li><li>判断出现 <strong>网络拥塞的依据</strong>：没有按时收到应当到达的确认报文（即<strong>发生超时重传</strong>）。</li></ul><p>发送方将拥塞窗口作为 <strong>发送窗口 swnd</strong>，即 <strong>swnd &#x3D; cwnd</strong>。**拥塞窗口的大小也就是发送方能发送的报文的数量，即：cwnd增加1也就是相当于字节数增加1个MSS大小 <del>（这里存疑，是数量还是总大小？）</del>**。</p><p>维护一个 <strong>慢开始门限 ssthresh</strong> 状态变量：</p><ul><li>当 cwnd &lt; ssthresh 时，使用慢开始算法；</li><li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法，该用拥塞避免算法；</li><li>当 cwnd &#x3D; ssthresh 时，即可以使用慢开始算法，也可以使用拥塞避免算法；</li></ul><h1 id="1-慢开始"><a href="#1-慢开始" class="headerlink" title="1. 慢开始"></a>1. 慢开始</h1><p>发送方发送报文后，如果收到了对方的确认报文（可以简称为一个 <strong>传输轮次</strong>），那么就将自己的 cwnd 在 <strong>原基础上乘以 2</strong>，比如从 1 开始，之后的窗口大小依次是：2，4，8，16，32，64…（按指数规律增长）</p><p>慢开始可以理解为 “在死亡边缘不断试探”，一开始试探性的向网络中发送少量报文，如果没有出现拥塞，就 “得寸进尺” 的多发送一些，以此类推。所以不要被慢开始的“慢”字给欺骗了，它可一点都不慢，慢开始并不是指 cwnd 的增长速度慢，而是指一开始向网络注入的报文段少。</p><h2 id="慢开始何时结束？"><a href="#慢开始何时结束？" class="headerlink" title="慢开始何时结束？"></a>慢开始何时结束？</h2><p>既然慢开始的增长速度如此之快，那么肯定不能让其无限制增长，当出现以下情况时，会停止慢开始阶段，进入拥塞避免阶段：</p><ul><li><p>当 cwnd 达到 ssthresh 时，会进入拥塞避免阶段。</p></li><li><p>发送超时重传时，此时网络可能出现了阻塞（也就是说，<strong>TCP 判断网络是否阻塞的依据是是否发生了超时重传</strong>）</p></li></ul><blockquote><p>疑问：sshthresh 的值默认是多少？</p><p>在一片博客上看的答案是：对于大多数 TCP 实现来说，ssthresh 的值是 65536(同样以字节计算)，这里的字节计算是什么意思，是 cwnd 的门限值 &#x3D; 65535&#x2F;mss 的意思吗？</p></blockquote><h1 id="2-拥塞避免"><a href="#2-拥塞避免" class="headerlink" title="2. 拥塞避免"></a>2. 拥塞避免</h1><p>到了拥塞避免阶段，就说明发送报文的数量可能快引起拥塞了（cwnd &#x3D; ssthresh），或者可能已经出现了拥塞（发生了超时重传），此时的拥塞窗口值就不能再像慢开始那样快速增长了，对于这两种情况，有不同的处理方法。</p><h2 id="当-cwnd-达到-ssthresh-时"><a href="#当-cwnd-达到-ssthresh-时" class="headerlink" title="当 cwnd 达到  ssthresh 时"></a>当 cwnd 达到  ssthresh 时</h2><p>此时说明发送报文的数量可能快引起拥塞了，不能再指数级增长了，变为线性增长，也就是每个传输轮次只将 cwnd + 1。</p><h2 id="发送超时重传"><a href="#发送超时重传" class="headerlink" title="发送超时重传"></a>发送超时重传</h2><p>如果 <strong>发送方发生了超时重传</strong>，那么说明此时网络可能已经出现拥塞，此时需要做以下工作：</p><ol><li>将慢开始门限值 ssthresh 更新为发生拥塞时拥塞窗口值的一半。比如在 cwnd&#x3D;24 时发生了超时重传，那么就会将 ssthresh 更新为 12.</li><li>将 cwnd 更新为 1，并重新开始慢开始算法。</li></ol><p>拥塞避免 <strong>并非指完全能够避免拥塞</strong>，而是指在拥塞避免阶段将 <strong>拥塞窗口控制为按线性规律增长</strong>，使网络不容易出现拥塞。</p><p>拥塞控制的整个流程如下图所示：</p><p>（图片出自：<a href="https://www.bilibili.com/video/BV1c4411d7jb?p=61&vd_source=2ff613424b86c58a71ba91b7304ffe9b">计算机网络微课堂（有字幕无背景音乐版）</a>）</p><p><img src="https://raw.githubusercontent.com/youseebiggirl/diagrams/2559f2fca5561b35e08edbdd0103ba1feaa3ec22/img/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg"></p><h1 id="3-快重传"><a href="#3-快重传" class="headerlink" title="3. 快重传"></a>3. 快重传</h1><p>报文发生了超时重传，并不一定就代表网络发生了拥塞，也有可能是别的原因，比如因为误码，被路由器给扔了，或者网络出现了延迟，如果直接简单粗暴的进入到拥塞避免阶段，让 cwnd 回归到 1，可能会导致网络的传输效率降低。</p><p><strong>快重传算法可以让发送方尽早知道发生了个别报文段的丢失</strong>。</p><p>所谓快重传，就是使发送方 <strong>尽快进行重传</strong>，而 <strong>不是等待超时重传计时器超时</strong> 再重传。</p><ul><li>要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认；</li><li>即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。</li><li>发送方一旦收到 3 个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传。</li></ul><p>比如下图的情况，M3 在网络传输过程中丢失了，接收方在收到 M4 后，发现 M3 还没收到，于是回复 ACK&#x3D;2，表示已经收到 M2 包了，希望接下来收到 M3 包，之后发送的 M4，M5 也都是如此。此时发送方发现收到了 3 个 ACK&#x3D;2，知道了 M2 这个包对方没有收到，于是就可以立马重传了，而不是等到 M3 的超时重传到期后再重传。</p><p>这样对于个别丢失的报文段，<strong>发送方就不会出现超时重传，也就不会误认为出现了拥塞</strong>，避免了将拥塞窗口  cwnd 降低为 1。使用快重传可以使整个网络的吞吐量提高约 20 %。</p><p><img src="https://raw.githubusercontent.com/youseebiggirl/diagrams/2559f2fca5561b35e08edbdd0103ba1feaa3ec22/img/%E5%BF%AB%E9%87%8D%E4%BC%A0.jpg"></p><h1 id="4-快恢复"><a href="#4-快恢复" class="headerlink" title="4. 快恢复"></a>4. 快恢复</h1><p>发送方一旦 <strong>收到 3 个重复确认</strong>，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而 <strong>执行快恢复算法</strong>；</p><ul><li><p><strong>发送方将慢开始门限 ssthresh 值和拥塞窗口 cwnd 值调整为当前窗口的一半；开始执行拥塞避免算法</strong>。</p></li><li><p>也有的快恢复实现是把快恢复开始时的拥塞窗口 cwnd 值再增大一些，即等于新的 ssthresh +3。</p><ul><li><p>既然发送方收到3个重复的确认，就表明有3个数据报文段己经离开了网络：</p></li><li><p>这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中；</p></li><li><p>可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些。</p></li></ul></li></ul><p>下图描述了整个流程，可以看到快恢复是将 cwnd 调整为发生重复确认时，窗口的一半，而不是像拥塞避免直接将 cwnd 调整为 1，一定程度上提高了吞吐率。</p><p><img src="https://raw.githubusercontent.com/youseebiggirl/diagrams/2559f2fca5561b35e08edbdd0103ba1feaa3ec22/img/%E5%BF%AB%E6%81%A2%E5%A4%8D.jpg"></p><h1 id="参考-x2F-引用"><a href="#参考-x2F-引用" class="headerlink" title="参考&#x2F;引用"></a>参考&#x2F;引用</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=61&vd_source=2ff613424b86c58a71ba91b7304ffe9b">计算机网络微课堂（有字幕无背景音乐版）</a></p><p><a href="https://blog.csdn.net/ydyang1126/article/details/72842274">TCP慢启动、拥塞避免、快速重传、快速恢复</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么 go 需要 nil chan</title>
    <link href="/2022/07/18/wei-shen-me-go-you-nil-chan/"/>
    <url>/2022/07/18/wei-shen-me-go-you-nil-chan/</url>
    
    <content type="html"><![CDATA[<p>如果没有调用 make 来对一个 chan 进行初始化，那么这个 chan 就是 nil chan。</p><p>对于 nil chan：</p><ul><li>从 nil chan 接收将永远阻塞</li><li>发送值到 nil chan 会永远阻塞</li><li>close 一个 nil chan 会引发 panic</li></ul><p>看到这里我不禁有点疑问，这样设计的意义在哪里？为什么写入和读取要阻塞，而不是像 nil map 一样直接 panic？</p><p>带着这个问题找到了一篇文章：<a href="https://medium.com/justforfunc/why-are-there-nil-channels-in-go-9877cc0b2308">Why are there nil channels in Go?</a></p><p>中译版：<a href="https://lingchao.xin/post/why-are-there-nil-channels-in-go.html">为什么 Go 会有 nil channels</a></p><p>里面提到了 nil chan 的意义，这里简单概括一下：</p><p><strong>nil chan 主要是为了防止 select 的空转。</strong></p><p>比如以下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn</span><span class="hljs-params">(c1 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, c2 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> v := &lt;- c1:<br>    <span class="hljs-keyword">case</span> v := &lt;- c2:<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果某个时间 c1，c2 都被关闭了，按照 chan 的规则，如果尝试读取一个已关闭的 chan，将会读取出类型的空值，所以此时的 <code>case v := &lt;- c1:</code>  和 <code>case v := &lt;- c2:</code> 分支依然是会被选择的，而一个 chan 被关闭则说明我们已经不需要它了，这显然是一个多余的操作。</p><p>而 select 的规则是，如果所有 case 都满足，则随机选择一个，此时的 c1，c2 依然满足条件，所以 select 会随机选择一个，又因为 select 定义在一个死循环里面，所以会导致 cpu 空转。</p><p>现在终于知道 nil chan 阻塞的意义何在了，将上面的代码修改如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn</span><span class="hljs-params">(c1 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, c2 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> v, ok := &lt;- c1:<br>      <span class="hljs-keyword">if</span> !ok &#123;c1 = <span class="hljs-literal">nil</span>&#125;<br>    <span class="hljs-keyword">case</span> v, ok := &lt;- c2:<br>      <span class="hljs-keyword">if</span> !ok &#123;c2 = <span class="hljs-literal">nil</span>&#125;<br>    <span class="hljs-keyword">default</span>:  <br>      <span class="hljs-keyword">return</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果某个 chan 被 close 了，那么将其设置为 nil，而 nil chan 的读取会阻塞，所以 select 就不会选择这个分支了，这样就避免了上述情况的空准，但是不要忘记加一个 <code>default</code> 分支，不然这个 select 就被永久阻塞了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rabbitmq 学习笔记</title>
    <link href="/2022/07/14/go-rabbitmq/"/>
    <url>/2022/07/14/go-rabbitmq/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本笔记主要记录 go rabbitmq 库的使用示例，同时结合学习 rabbitmq</p></blockquote><h1 id="一个基本的发布-x2F-订阅程序示例"><a href="#一个基本的发布-x2F-订阅程序示例" class="headerlink" title="一个基本的发布&#x2F;订阅程序示例"></a>一个基本的发布&#x2F;订阅程序示例</h1><p>首先可以通过一个最基础的程序，来一览 rabbitmq 的大致面貌：</p><blockquote><p>PS：这段代码没有定义 exchange 以及执行队列和 exchange 的绑定操作，这是因为存在一个默认交换机的概念。具体参见 <strong>组件&#x2F;exchange 交换机&#x2F;exchange 类型&#x2F;Default Exchange</strong>。如果你是新手，可以先忽略这个警告。</p></blockquote><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>    <br>    amqp <span class="hljs-string">&quot;github.com/rabbitmq/amqp091-go&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Assert</span><span class="hljs-params">(err <span class="hljs-type">error</span>, msg <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Panicf(<span class="hljs-string">&quot;%s: %s&quot;</span>, msg, err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 1. 尝试连接 RabbitMQ，建立连接</span><br><span class="hljs-comment">// 该连接抽象了套接字连接，并为我们处理协议版本协商和认证等。</span><br>conn, err := amqp.Dial(<span class="hljs-string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)<br>Assert(err, <span class="hljs-string">&quot;Failed to connect to RabbitMQ&quot;</span>)<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-comment">// 2. 接下来，我们创建一个通道，大多数 API 都是用过该通道操作的。</span><br>ch, err := conn.Channel()<br>Assert(err, <span class="hljs-string">&quot;Failed to open a channel&quot;</span>)<br><span class="hljs-keyword">defer</span> ch.Close()<br><br><span class="hljs-comment">// 3. 声明消息要发送到的队列</span><br>q, err := ch.QueueDeclare(<br><span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-comment">// name</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// durable 是否为持久化队列</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// delete when unused</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// exclusive</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// no-wait</span><br><span class="hljs-literal">nil</span>,     <span class="hljs-comment">// arguments</span><br>)<br>Assert(err, <span class="hljs-string">&quot;Failed to declare a queue&quot;</span>)<br><br>log.Printf(<span class="hljs-string">&quot;Enter q or Q to exit.&quot;</span>)<br>scanner := bufio.NewScanner(os.Stdin)<br><span class="hljs-keyword">for</span> scanner.Scan() &#123;<br><span class="hljs-keyword">if</span> scanner.Err() != <span class="hljs-literal">nil</span> &#123;<br>Assert(scanner.Err(), <span class="hljs-string">&quot;read stdin error&quot;</span>)<br>&#125;<br>body := scanner.Bytes()<br><span class="hljs-keyword">if</span> <span class="hljs-type">string</span>(body) == <span class="hljs-string">&quot;q&quot;</span> || <span class="hljs-type">string</span>(body) == <span class="hljs-string">&quot;Q&quot;</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;bye^&quot;</span>)<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-comment">// 4.将消息发布到声明的队列（这里其实有歧义，不是发布到队列，而是发布到默认交换机，因为 rabbitmq 并不允许将消息直接发送到队列，而是</span><br>        <span class="hljs-comment">// 必须发送给交换机，由交换机进行路由转发到队列）</span><br>        <span class="hljs-comment">// 疑问：直接发布到队列吗？消息不是需要先发送给 exchange，然后再由 exchange 转发给该消息对应的队列吗？</span><br><span class="hljs-comment">// 参阅默认交换机，这里我们指定的 routing-key 是队列的名字，所以给人一种将消息直接发送到队列的 “错觉”，</span><br><span class="hljs-comment">// 实际上，我们创建的队列会自动绑定到默认交换机上，并且绑定的 routing-key 就是该队列的名字，所以如果我们</span><br><span class="hljs-comment">// 想将消息发送到该队列，就需要指定 exchange 为 “”，代表将其发送到默认交换机，然后 routing-key 指定为</span><br>        <span class="hljs-comment">// 该队列的名字，就像我们下面做的这样。</span><br>err = ch.Publish(<br><span class="hljs-string">&quot;&quot;</span>,     <span class="hljs-comment">// exchange</span><br>q.Name, <span class="hljs-comment">// routing key，这里指定为队列名，因为我们使用的是默认交换机</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// mandatory</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// immediate</span><br>amqp.Publishing&#123;<br>ContentType: <span class="hljs-string">&quot;text/plain&quot;</span>,<br>Body:        body,<br><span class="hljs-comment">// 是否持久化消息，瞬态（Transient）或持久（Persistent）</span><br>DeliveryMode: amqp.Transient,<br>&#125;)<br>Assert(err, <span class="hljs-string">&quot;Failed to publish a message&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br>    <br>    amqp <span class="hljs-string">&quot;github.com/rabbitmq/amqp091-go&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Assert</span><span class="hljs-params">(err <span class="hljs-type">error</span>, msg <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Panicf(<span class="hljs-string">&quot;%s: %s&quot;</span>, msg, err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := amqp.Dial(<span class="hljs-string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)<br>Assert(err, <span class="hljs-string">&quot;Failed to connect to RabbitMQ&quot;</span>)<br><span class="hljs-keyword">defer</span> conn.Close()<br><br>ch, err := conn.Channel()<br>Assert(err, <span class="hljs-string">&quot;Failed to open a channel&quot;</span>)<br><span class="hljs-keyword">defer</span> ch.Close()<br><br>q, err := ch.QueueDeclare(<br><span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-comment">// name</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// durable</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// delete when unused</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// exclusive</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// no-wait</span><br><span class="hljs-literal">nil</span>,     <span class="hljs-comment">// arguments</span><br>)<br>Assert(err, <span class="hljs-string">&quot;Failed to declare a queue&quot;</span>)<br><br><br>msgs, err := ch.Consume(<br>q.Name, <span class="hljs-comment">// queue</span><br><span class="hljs-string">&quot;&quot;</span>,     <span class="hljs-comment">// consumer</span><br><span class="hljs-literal">true</span>,   <span class="hljs-comment">// auto-ack</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// exclusive</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// no-local</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// no-wait</span><br><span class="hljs-literal">nil</span>,    <span class="hljs-comment">// args</span><br>)<br>Assert(err, <span class="hljs-string">&quot;Failed to register a consumer&quot;</span>)<br><br><span class="hljs-keyword">var</span> neverStop <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> d := <span class="hljs-keyword">range</span> msgs &#123;<br>log.Printf(<span class="hljs-string">&quot;Received a message: %s&quot;</span>, d.Body)<br>&#125;<br>&#125;()<br><br>log.Printf(<span class="hljs-string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>)<br>&lt;-neverStop<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h1><p>通过上面的基本示例程序，可以看到有以下几个核心方法：</p><h3 id="QueueDeclare"><a href="#QueueDeclare" class="headerlink" title="QueueDeclare"></a>QueueDeclare</h3><p>用于 <strong>创建一个队列</strong>，或者 <strong>连接到一个已存在的队列</strong>，需要提供以下参数：</p><ul><li><p>name：指定队列的名称，如果留空且执行的是创建操作，则会随机分配一个名称</p></li><li><p>durable：是否持久化</p></li><li><p>autoDelete: 是否自动删除队列，如果为 true 表示没有消息也没有消费者连接自动删除队列</p></li><li><p>exclusive: 是否独占，即当前声明队列的连接关闭后即被删除</p></li><li><p>noWait: 是否等待服务器返回 ok，也就是该操作是否执行成功？（不太确定，好像一般设置为 false 即可）</p></li><li><p>args:  指定一些队列参数，比如如果是死信队列，需要将该参数提供为如下值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">amqp.Table&#123;<br><span class="hljs-string">&quot;x-message-ttl&quot;</span>:             <span class="hljs-number">5000</span>,            <span class="hljs-comment">// 消息过期时间,毫秒</span><br><span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>:    dlxExchangeName, <span class="hljs-comment">// 指定死信交换机</span><br><span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>: dlxRoutingKey,   <span class="hljs-comment">// 指定死信 routing-key</span><br>&#125;,<br></code></pre></td></tr></table></figure></li></ul><h3 id="Consume"><a href="#Consume" class="headerlink" title="Consume"></a>Consume</h3><ul><li>queue：要消费的队列的名字</li><li>consumer：</li><li>autoAck：如果为 true，则 consume 拿到这条消息后会自动置为确认，不会考虑消费者是否真正的消费了这条消息</li><li>exclusive </li><li>noLocal</li><li>noWait </li><li>args</li></ul><h3 id="Publish"><a href="#Publish" class="headerlink" title="Publish"></a>Publish</h3><ul><li>exchange：交换机的名称，用于确定消息要投放到哪个交换机</li><li>key：路由键，类似路由的功能，可以为一个交换机定义多个路由键，通过不同路由键连接到不同的队列</li><li>mandatory ：</li><li>immediate ：</li><li>msg：要推送的消息，字节类型</li></ul><p>除此之外，还有这些核心 API：</p><h3 id="QueueBind"><a href="#QueueBind" class="headerlink" title="QueueBind"></a>QueueBind</h3><ul><li>name：要绑定的队列的名字</li><li>key：路由键</li><li>exchange：传入一个交换机名，该队列会绑定到这个 exchange</li><li>noWait：同其他 API</li><li>args：同其他 API</li></ul><h1 id="组件-x2F-概念"><a href="#组件-x2F-概念" class="headerlink" title="组件&#x2F;概念"></a>组件&#x2F;概念</h1><h2 id="Producer∶-生产者——投递消息的一方"><a href="#Producer∶-生产者——投递消息的一方" class="headerlink" title="Producer∶ 生产者——投递消息的一方"></a>Producer∶ 生产者——投递消息的一方</h2><p>发送消息的应用程序称为生产者。生产者将消息发布到 RabbitMQ 的交换机中。</p><h2 id="Consumer∶-消费者——接收消息的一方"><a href="#Consumer∶-消费者——接收消息的一方" class="headerlink" title="Consumer∶ 消费者——接收消息的一方"></a>Consumer∶ 消费者——接收消息的一方</h2><p>消费者连接到 RabbitMQ 服务器，并订阅某个队列，然后从队列中消费，并进行处理。</p><h2 id="Exchange：交换机——路由消息到队列"><a href="#Exchange：交换机——路由消息到队列" class="headerlink" title="Exchange：交换机——路由消息到队列"></a>Exchange：交换机——路由消息到队列</h2><p>exchange 是消息交换机，它根据消息的规则，将其路由到相应的队列。</p><p><del>比如下图，x 就是一个交换机，它定义了 3 个 routing_key，routing_key 就是上面说的规则，不同的 routing_key 关联到不同的队列，在下图中，orange 这个 key 关联到了队列 Q1，black 和 green 这两个 key 关联到了队列 Q2，消费者可以根据 routing_key 来消费不同的队列。</del></p><p>比如下图，X 就是一个交换机，并且它是 direct 类型的（交换机类型的作用会在后面介绍），然后 P 代表生产者，它会生产消息并将其发送给交换机，然后交换机会根据每条消息的属性（比如路由键），将其路由到对应的队列，在下图中，路由键为 orange 的消息将被路由到 Q1 队列。</p><p><img src="https://www.liwenzhou.com/images/Go/rabbitmq/tutorials04/direct-exchange.png"></p><p>exchange 的程序大致流程是：</p><p>生产者：</p><ol><li>定义或者连接一个 exchange</li><li>推送消息到这个 exchange</li></ol><p>消费者：</p><ol><li>定义一个队列</li><li>将队列和上面的 exchange 绑定（这二者如何绑定？调用 <code>QueueBind</code> 方法）</li><li>然后就可以从队列中消费了</li></ol><p>其实上面的流程不是固定的，只需要记住一个固定的规则即可：<strong>消费者只能从队列消费，队列必须绑定一个 exchange</strong>，所以队列的定义和绑定（也就是消费者流程的 1，2 步）完全也可以让生产者去做，消费者直接进行消费就可以了，只要保证 rabbitmq 中存在这个将要绑定到 exchange 的队列即可。</p><div class="note note-warning">            <p>🤔 这里可能会有一个疑问：在文章最开始的示例中，并没有创建一个 exchange，也没有进行绑定操作，生产者和消费者都是直接操作队列，这是如何做到的呢？其实在 rabbitmq 中存在一个 <strong>默认的 exchange</strong>，如果没有指定 exchange，那么就会使用这个默认交换器，<del>对于 routing key 也是一样的，如果没有指定，则使用默认的。</del> 并且创建的每个队列都会使用与队列名称相同的路由键自动绑定到它。（我们示例程序中调用  Publish 方法传入的 routing key 正是队列名）。</p>          </div><p>绑定调用的函数是 QueueBind，其签名可以在 <strong>核心 API</strong> 这一节中查阅。其使用示例类似下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">channel.QueueBind(<span class="hljs-string">&quot;Q1&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">nil</span>)<br></code></pre></td></tr></table></figure><p>通过这段代码，会将名为 Q1 的队列绑定到名为 X 的交换机上，并且还定义了自己的路由键 orange，这代表着如果生产者生产的某条消息的路由键与 orange 匹配，那么 exchange 会将这条消息路由到 Q1 这个队列。</p><h3 id="exchange-类型"><a href="#exchange-类型" class="headerlink" title="exchange 类型"></a>exchange 类型</h3><p>exchange 有多种类型，下面会详细介绍，在这之前，为了方便后续的实验，我们可以抽象出一个灵活的实用程序，该程序可以通过一系列命令行参数来完成各种操作，比如创建指定类型，指定名称的 exchange 等，该程序代码如下：</p><h4 id="实用程序"><a href="#实用程序" class="headerlink" title="实用程序"></a>实用程序</h4><h5 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h5><p>生产者这里指定了 2 个命令行参数，-e 用来指定交换机名称，-k 用来指定交换机类型，代码会根据这两个值来创建交换机，然后用户可以在终端中输入值来 push 到交换机，输入值的格式为 &lt;路由键&gt;:&lt;消息实体&gt;，比如如果用户输入 key:value，那么代表将 value push 到交换机，同时该 value 的路由键为 key，之后消费者就可以通过 key 匹配来拿到该 value。</p><p>生产者这里没有定义和绑定队列，这些工作交给了消费者来完成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>    <br>    amqp <span class="hljs-string">&quot;github.com/rabbitmq/amqp091-go&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> ExchangeKind = <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> (<br>ExchangeKind_Direct  ExchangeKind = <span class="hljs-string">&quot;direct&quot;</span><br>ExchangeKind_Topic   ExchangeKind = <span class="hljs-string">&quot;topic&quot;</span><br>ExchangeKind_Headers ExchangeKind = <span class="hljs-string">&quot;headers&quot;</span><br>ExchangeKind_Fanout  ExchangeKind = <span class="hljs-string">&quot;fanout&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Assert</span><span class="hljs-params">(err <span class="hljs-type">error</span>, msg <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Panicf(<span class="hljs-string">&quot;%s: %s&quot;</span>, msg, err)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 检查输入的 exchange kind 是否合法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkExchangeKind</span><span class="hljs-params">(kind <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>&#123;<br>ExchangeKind_Direct:  <span class="hljs-literal">true</span>,<br>ExchangeKind_Topic:   <span class="hljs-literal">true</span>,<br>ExchangeKind_Headers: <span class="hljs-literal">true</span>,<br>ExchangeKind_Fanout:  <span class="hljs-literal">true</span>,<br>&#125;<br><span class="hljs-keyword">if</span> exist := m[kind]; exist &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;not found this kind&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>log.Printf(<span class="hljs-string">&quot;usage: ./main -e [exchange name] -k [exchange kind]&quot;</span>)<br><span class="hljs-keyword">var</span> (<br>exchangeName = flag.String(<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;exchange name&quot;</span>)<br>exchangeKind = flag.String(<span class="hljs-string">&quot;k&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;exchange kind&quot;</span>)<br>)<br>flag.Parse()<br><br><span class="hljs-keyword">if</span> err := checkExchangeKind(*exchangeKind); err != <span class="hljs-literal">nil</span> &#123;<br>Assert(err, <span class="hljs-string">&quot;check exchange kind error: &quot;</span>)<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;exchangeName: %v, exchangeKind: %v\n&quot;</span>,<br>*exchangeName, *exchangeKind)<br><br><span class="hljs-comment">// 1. 尝试连接 RabbitMQ，建立连接</span><br><span class="hljs-comment">// 该连接抽象了套接字连接，并为我们处理协议版本协商和认证等。</span><br>conn, err := amqp.Dial(<span class="hljs-string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)<br>Assert(err, <span class="hljs-string">&quot;Failed to connect to RabbitMQ&quot;</span>)<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-comment">// 2. 接下来，我们创建一个通道，大多数 API 都是用过该通道操作的。</span><br>ch, err := conn.Channel()<br>Assert(err, <span class="hljs-string">&quot;Failed to open a channel&quot;</span>)<br><span class="hljs-keyword">defer</span> ch.Close()<br><br><span class="hljs-comment">// 声明一个交换器 exchange</span><br>err = ch.ExchangeDeclare(<br>*exchangeName, <span class="hljs-comment">// name 交换器名</span><br>*exchangeKind, <span class="hljs-comment">// type 交换器类型</span><br><span class="hljs-literal">true</span>,          <span class="hljs-comment">// durable</span><br><span class="hljs-literal">false</span>,         <span class="hljs-comment">// auto-deleted</span><br><span class="hljs-literal">false</span>,         <span class="hljs-comment">// internal</span><br><span class="hljs-literal">false</span>,         <span class="hljs-comment">// no-wait</span><br><span class="hljs-literal">nil</span>,           <span class="hljs-comment">// arguments</span><br>)<br>Assert(err, <span class="hljs-string">&quot;Failed to declare a exchange&quot;</span>)<br><br>log.Printf(<span class="hljs-string">&quot;Enter q or Q to exit.&quot;</span>)<br>log.Printf(<span class="hljs-string">&quot;usage: &lt;routing_key&gt;:&lt;message&gt;&quot;</span>)<br>scanner := bufio.NewScanner(os.Stdin)<br><span class="hljs-keyword">for</span> scanner.Scan() &#123;<br><span class="hljs-keyword">if</span> scanner.Err() != <span class="hljs-literal">nil</span> &#123;<br>Assert(scanner.Err(), <span class="hljs-string">&quot;read stdin error&quot;</span>)<br>&#125;<br>body := scanner.Bytes()<br><span class="hljs-keyword">if</span> <span class="hljs-type">string</span>(body) == <span class="hljs-string">&quot;q&quot;</span> || <span class="hljs-type">string</span>(body) == <span class="hljs-string">&quot;Q&quot;</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;bye^&quot;</span>)<br><span class="hljs-keyword">break</span><br>&#125;<br>        <span class="hljs-comment">// 输入的格式：&lt;路由键&gt;:&lt;消息实体&gt;</span><br>before, after, found := bytes.Cut(body, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;:&quot;</span>))<br><span class="hljs-keyword">if</span> !found &#123;<br>log.Printf(<span class="hljs-string">&quot;usage: &lt;routing_key&gt;:&lt;message&gt;&quot;</span>)<br><span class="hljs-keyword">continue</span><br>&#125;<br>log.Printf(<span class="hljs-string">&quot;routingKey: %s, message: %s\n&quot;</span>, before, after)<br><br><span class="hljs-comment">// 4.将消息发布到 exchange 而不是某个单独的队列</span><br>err = ch.Publish(<br>*exchangeName,  <span class="hljs-comment">// exchange</span><br><span class="hljs-type">string</span>(before), <span class="hljs-comment">// routing key</span><br><span class="hljs-literal">false</span>,          <span class="hljs-comment">// mandatory</span><br><span class="hljs-literal">false</span>,          <span class="hljs-comment">// immediate</span><br>amqp.Publishing&#123;<br>ContentType: <span class="hljs-string">&quot;text/plain&quot;</span>,<br>Body:        after,<br><span class="hljs-comment">// 是否持久化消息，瞬态（0 或 1）或持久（2）</span><br>DeliveryMode: amqp.Transient,<br>&#125;)<br>Assert(err, <span class="hljs-string">&quot;Failed to publish a message&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./producer_exchange -e [exchange name] -k [exchange kind]<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">推送消息到名为 logs_direct ，类型为 direct 的 exchange</span><br>./producer_exchange -e logs_direct -k direct<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">推送消息到名为 logs_topic ，类型为 topic 的 exchange</span><br>./producer_exchange -e logs_topic -k topic<br></code></pre></td></tr></table></figure><h5 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h5><p>消费者这里定义了 3 个命令行参数，-q 用来指定队列名，会用这个名称来创建队列；-e 用来指定要连接的交换机的名称，也就是我们在生产者中创建的交换机名；-r 指定消费的路由键，可以指定多个，消费者会根据自己的 key 去消费相应的队列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>amqp <span class="hljs-string">&quot;github.com/rabbitmq/amqp091-go&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>. <span class="hljs-string">&quot;rabbitmq&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><br><span class="hljs-comment">// 实现了 flag.Value 接口，这样我们就可以通过命令行参数来填充该类型的值了</span><br><span class="hljs-keyword">type</span> routingKeys []<span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *routingKeys)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%v&quot;</span>, *s)<br>&#125;<br><br><span class="hljs-comment">// Set 通过 , 来分割值，比如命令行参数为 -r error,info,warning，那么对应 s 的值将为 [error, info, warning]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *routingKeys)</span></span> Set(value <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>ss := strings.Split(value, <span class="hljs-string">&quot;,&quot;</span>)<br>*s = <span class="hljs-built_in">append</span>(*s, ss...)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Assert</span><span class="hljs-params">(err <span class="hljs-type">error</span>, msg <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Panicf(<span class="hljs-string">&quot;%s: %s&quot;</span>, msg, err)<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>log.Printf(<span class="hljs-string">`</span><br><span class="hljs-string">usage: ./main </span><br><span class="hljs-string">-q [queue name] </span><br><span class="hljs-string">-e [exchange name] </span><br><span class="hljs-string">-r [routing key, can provide more, use &#x27;,&#x27; to sep, </span><br><span class="hljs-string">example: info,error,warning (don&#x27;t have space) ]</span><br><span class="hljs-string">`</span>)<br><span class="hljs-keyword">var</span> (<br>exchangeName = flag.String(<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;exchange name&quot;</span>)<br>queueName    = flag.String(<span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;queue name&quot;</span>)<br>rks          routingKeys<br>)<br>flag.Var(&amp;rks, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-string">&quot;routing key&quot;</span>)<br>flag.Parse()<br><br>log.Printf(<span class="hljs-string">&quot;queueName: %v, exchangeName: %v, routingKey: %v\n&quot;</span>,<br>*queueName, *exchangeName, &amp;rks)<br><br>conn, err := amqp.Dial(<span class="hljs-string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)<br>Assert(err, <span class="hljs-string">&quot;Failed to connect to RabbitMQ&quot;</span>)<br><span class="hljs-keyword">defer</span> conn.Close()<br><br>ch, err := conn.Channel()<br>Assert(err, <span class="hljs-string">&quot;Failed to open a channel&quot;</span>)<br><span class="hljs-keyword">defer</span> ch.Close()<br><br><span class="hljs-comment">// 声明一个临时队列，一旦消费者断开连接，该队列就会被删除</span><br>q, err := ch.QueueDeclare(<br>*queueName, <span class="hljs-comment">// name 空字符串作为队列名称，表示使用随机名称</span><br><span class="hljs-literal">false</span>,      <span class="hljs-comment">// durable</span><br><span class="hljs-literal">false</span>,      <span class="hljs-comment">// delete when unused</span><br><span class="hljs-literal">true</span>,       <span class="hljs-comment">// exclusive 独占队列（当前声明队列的连接关闭后即被删除）</span><br><span class="hljs-literal">false</span>,      <span class="hljs-comment">// no-wait</span><br><span class="hljs-literal">nil</span>,        <span class="hljs-comment">// arguments</span><br>)<br>Assert(err, <span class="hljs-string">&quot;Failed to declare a queue&quot;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rks) == <span class="hljs-number">0</span> &#123;<br>err = ch.QueueBind(<br>q.Name,<br><span class="hljs-string">&quot;&quot;</span>,<br>*exchangeName,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">nil</span>,<br>)<br>Assert(err, <span class="hljs-string">&quot;Failed to bind a queue&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> _, key := <span class="hljs-keyword">range</span> rks &#123;<br><span class="hljs-comment">// 将 queue 绑定到对应的 exchange，使用 exchangeName + routingKeys 进行匹配</span><br>err = ch.QueueBind(<br>q.Name,<br>key,<br>*exchangeName,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">nil</span>,<br>)<br>Assert(err, <span class="hljs-string">&quot;Failed to bind a queue&quot;</span>)<br>&#125;<br>&#125;<br><br>msgs, err := ch.Consume(<br>q.Name, <span class="hljs-comment">// queue</span><br><span class="hljs-string">&quot;&quot;</span>,     <span class="hljs-comment">// consumer</span><br><span class="hljs-literal">true</span>,   <span class="hljs-comment">// auto-ack</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// exclusive</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// no-local</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// no-wait</span><br><span class="hljs-literal">nil</span>,    <span class="hljs-comment">// args</span><br>)<br>Assert(err, <span class="hljs-string">&quot;Failed to register a consumer&quot;</span>)<br><br><span class="hljs-keyword">var</span> forever <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> d := <span class="hljs-keyword">range</span> msgs &#123;<br>log.Printf(<span class="hljs-string">&quot;Received a message: %s&quot;</span>, d.Body)<br>&#125;<br>&#125;()<br><br>log.Printf(<span class="hljs-string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>)<br>&lt;-forever<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">usage: ./main <br>-q [queue name] <br>-e [exchange name] <br>-r [routing key, 可以提供多个, 使用 , 来分隔, 比如: info,error,warning (注意 , 前后不要有空格) ]<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">从 logs_direct 这个交换机消费，并且只消费路由键为 error 的消息</span><br>./consumer_exchange -e logs_direct -r error<br>./consumer_exchange -e logs_direct -r error,info,warning<br>./consumer_exchange -e logs_topic -r &quot;*.orange.*&quot;<br>./consumer_exchange -e logs_topic -r &quot;*.*.rabbit&quot;,&quot;lazy.#&quot;<br></code></pre></td></tr></table></figure><h4 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h4><p>fanout 类型的 exchange 提供广播功能，即将消息投递到所有与该 exchange 所绑定的 queue 上，此时指定的 routing key 会被忽略。</p><p><strong>示例</strong></p><p>这里直接使用上面的通用代码，只要在运行时指定不同的 flag 即可</p><p><strong>生产者</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./producer_exchange -e logs -k fanout<br></code></pre></td></tr></table></figure><p><strong>消费者 1</strong></p><p>因为 fanout 会忽略 routing key，所以 -r 也不需要指定了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./consumer_exchange -e logs<br></code></pre></td></tr></table></figure><p><strong>消费者 2</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./consumer_exchange -e logs <br></code></pre></td></tr></table></figure><p>先运行生产者，再分别运行消费者1，2</p><p>生产者运行后在终端输入消息（消息格式是 &lt;路由键&gt;:&lt;消息&gt;，因为是 fanout 类型，所以无需指定路由键，类似 :123 这样即可）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建一个名为 logs，类型为 fanout 的 exchange</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./producer_exchange -e logs -k fanout</span> <br>2022/07/24 12:16:22 usage: ./main -e [exchange name] -k [exchange kind]<br>2022/07/24 12:16:22 exchangeName: logs, exchangeKind: fanout<br>2022/07/24 12:16:22 Enter q or Q to exit.<br>2022/07/24 12:16:22 usage: &lt;routing_key&gt;:&lt;message&gt; # 开始输入<br>:123<br>2022/07/24 12:20:27 routingKey: , message: 123<br><br></code></pre></td></tr></table></figure><p>之后观察两个消费者的 terminal，发现都收到了消息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./consumer_exchange -e logs</span> <br>2022/07/24 12:20:23 <br>        usage: ./main <br>        -q [queue name] <br>        -e [exchange name] <br>        -r [routing key, can provide more, use &#x27;,&#x27; to sep, <br>                example: info,error,warning (don&#x27;t have space) ]<br>2022/07/24 12:20:23 queueName: , exchangeName: logs, routingKey: []<br>2022/07/24 12:20:23  [*] Waiting for messages. To exit press CTRL+C<br>2022/07/24 12:20:27 Received a message: 123<br></code></pre></td></tr></table></figure><h4 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h4><p>direct 类型的 exchange 会严格按照 routing key 进行精准匹配，没有什么特殊的地方，这里就不记录了。</p><h4 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h4><p>topic 类型的 exchange 提供了 routing key 的通配符匹配功能，支持 * 和 # 语法，”#” 代表匹配一个或多个单词，”*” 则匹配不多不少刚好一个单词</p><p><strong>示例</strong></p><p>这里直接使用上面的通用代码，只要在运行时指定不同的 flag 即可</p><p><strong>生产者</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./producer_exchange -e logs_topic -k topic</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">开始输入</span><br>quick.orange.rabbit:666<br>lazy.orange.elephant:aaa<br>quick.orange.fox:888<br></code></pre></td></tr></table></figure><p><strong>消费者 1</strong></p><p>这个消费者消费 routing key 匹配 <code>*.orange.*</code>  的消息，表示单词个数必须是 3 个，且中间的必须是 orange</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./consumer_exchange -e logs_topic -r <span class="hljs-string">&quot;*.orange.*&quot;</span></span><br></code></pre></td></tr></table></figure><p><strong>消费者 2</strong></p><p>注意这里要用 “” 将 routing key 包裹起来，否则 * 会被 shell 错误解析</p><p><code>*.*.rabbit</code>表示单词个数必须是 3 个，且最后一个单词必须是 rabbit</p><p><code>lazy.#</code> 表示的是只要第一个单词为 lazy 即可，之后的内容忽略</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./consumer_exchange -e logs_topic -r <span class="hljs-string">&quot;*.*.rabbit&quot;</span>,<span class="hljs-string">&quot;lazy.#&quot;</span></span><br></code></pre></td></tr></table></figure><p>匹配情况：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">quick.<span class="hljs-property">orange</span>.<span class="hljs-property">rabbit</span>:<span class="hljs-number">666</span>=&gt; *.<span class="hljs-property">orange</span>.*  | *.*.<span class="hljs-property">rabbit</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">lazy.<span class="hljs-property">orange</span>.<span class="hljs-property">elephant</span>:<span class="hljs-function"><span class="hljs-params">aaa</span>    =&gt;</span>*.<span class="hljs-property">orange</span>.*</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">quick.<span class="hljs-property">orange</span>.<span class="hljs-property">fox</span>:<span class="hljs-number">888</span>=&gt;*.<span class="hljs-property">orange</span>.*</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">lazy.<span class="hljs-property">brown</span>.<span class="hljs-property">fox</span>:<span class="hljs-number">666</span>=&gt;lazy.#</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">lazy.<span class="hljs-property">pink</span>.<span class="hljs-property">rabbit</span>:<span class="hljs-function"><span class="hljs-params">xxx</span>=&gt;</span>lazy.# | *.*.<span class="hljs-property">rabbit</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">quick.<span class="hljs-property">brown</span>.<span class="hljs-property">fox</span>:<span class="hljs-function"><span class="hljs-params">yyy</span>=&gt;</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-attr">orange</span>:<span class="hljs-function"><span class="hljs-params">ccc</span>=&gt;</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">quick.<span class="hljs-property">orange</span>.<span class="hljs-property">male</span>.<span class="hljs-property">rabbit</span>:<span class="hljs-function"><span class="hljs-params">bbb</span>        =&gt;</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">lazy.<span class="hljs-property">orange</span>.<span class="hljs-property">male</span>.<span class="hljs-property">rabbit</span>:<span class="hljs-function"><span class="hljs-params">ooo</span>    =&gt;</span>lazy.#</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">lazy.<span class="hljs-property">orange</span>.<span class="hljs-property">male</span>.<span class="hljs-property">rabbit</span>.<span class="hljs-property">io</span>:<span class="hljs-function"><span class="hljs-params">zzz</span>                    =&gt;</span>lazy.#</span><br></code></pre></td></tr></table></figure><p>可以按照上表的内容自己实践一下，看看不同的 routing_key 会传递给哪个消费者。</p><h4 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h4><p>（引用自 <a href="https://zhuanlan.zhihu.com/p/37198933">知乎</a>）</p><blockquote><p>Headers Exchange 会忽略 RoutingKey 而根据消息中的 Headers 和创建绑定关系时指定的 Arguments 来匹配决定路由到哪些 Queue。</p><p>Headers Exchange 的性能比较差，而且 Direct Exchange 完全可以代替它，所以不建议使用。</p></blockquote><p>实践：TODO</p><h4 id="default-Exchange"><a href="#default-Exchange" class="headerlink" title="default Exchange"></a>default Exchange</h4><p>引用自 <a href="https://zhuanlan.zhihu.com/p/37198933">知乎</a>：</p><p>Default Exchange 是一种特殊的 Direct Exchange。当你手动创建一个队列时，后台会自动将这个队列绑定到一个名称为空的 Direct Exchange 上，绑定 RoutingKey 与队列名称相同。有了这个默认的交换机和绑定，使我们只关心队列这一层即可，这个比较适合做一些简单的应用。</p><p>引用官方文档：</p><blockquote><p><a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchange-default">Default Exchange</a></p><p>The default exchange is a direct exchange with no name (empty string) pre-declared by the broker. It has one special property that makes it very useful for simple applications: every queue that is created is automatically bound to it with a routing key which is the same as the queue name.</p><p>For example, when you declare a queue with the name of “search-indexing-online”, the AMQP 0-9-1 broker will bind it to the default exchange using “search-indexing-online” as the routing key (in this context sometimes referred to as the binding key). Therefore, a message published to the default exchange with the routing key “search-indexing-online” will be routed to the queue “search-indexing-online”. In other words, the default exchange makes it seem like it is possible to deliver messages directly to queues, even though that is not technically what is happening.</p></blockquote><p>用 ChatGPT 翻译一下：</p><blockquote><p>默认交换机是由代理服务器预先声明的没有名称（空字符串）的直接交换机。它具有一个特殊的属性，使其在简单应用程序中非常有用：每个创建的队列都会自动使用与队列名称相同的路由键绑定到它。</p><p>例如，当你声明一个名为 “search-indexing-online” 的队列时，AMQP 0-9-1 代理服务器将使用 “search-indexing-online” 作为路由键（在这种情况下有时称为绑定键）将其绑定到默认交换机。因此，使用路由键 “search-indexing-online” 将消息发布到默认交换机时，该消息将被路由到队列 “search-indexing-online”。换句话说，默认交换机使得似乎可以直接将消息投递到队列中，尽管从技术上讲并不是这样的。</p></blockquote><h2 id="Binding∶-绑定"><a href="#Binding∶-绑定" class="headerlink" title="Binding∶ 绑定"></a>Binding∶ 绑定</h2><p>RabbitMQ 中通过绑定将 <strong>交换器与队列关联</strong> 起来，在绑定的时候一般会指定一个 <strong>绑定键</strong>（BindingKey），这样 RabbitMQ 就知道如何正确地将消息路由到队列了。</p><h1 id="功能-x2F-应用"><a href="#功能-x2F-应用" class="headerlink" title="功能&#x2F;应用"></a>功能&#x2F;应用</h1><h2 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h2><p>TODO</p><h2 id="延迟队列（使用死信队列实现）"><a href="#延迟队列（使用死信队列实现）" class="headerlink" title="延迟队列（使用死信队列实现）"></a>延迟队列（使用死信队列实现）</h2><p>延迟队列可以用于订单超时取消的场景，可以用 rabbitmq 的死信队列来实现一个延迟队列。</p><p><strong>死信队列</strong>，顾名思义，就是用来存储那些无法被消费的，已经“死掉“的消息，和普通队列一样，也是由 exchange、routing_key 和 queue 三大组件构成的。</p><p>什么条件下会将消息放到死信队列？</p><ul><li>消息被拒绝，并且 requeue 参数为 false，这个参数代表是否将被拒绝的消息重新放回队列，让其他消费者进行消费</li><li>消息的 TTL 过期</li><li>队列达到最大长度或队列空间已满，此时需要 queue 的拒绝策略设置为 reject-public-dlx，后续投递至该队列的消息会重新投递到死信队列中</li></ul><p>这里需要注意的一点是：消息的 TTL 和消息的 ACK 是不相干的，比如设置了消息的 TTL 为 5s，但是消息超过 5s 没有回复 ACK，此时是不会判定这条消息过期的，引用书上的一段话：<strong>RabbitMQ 不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否己经断开，这么设计的原因是 RabbitMQ 允许消费者长时间的消费一条消息。</strong> </p><p>消息过期的依据是：如果一条消息超过 TTL 还没有被消费，则判断为过期。而 ACK 是在已经消费的情况下才能回复的东西，所以这两个东西当然不相干。</p><p>之所以会记录上面的问题，是因为我在写代码时犯了这个错误，我在消费者开了两个线程，分别消费普通队列和死信队列，生产者这边会先将消息投放到普通队列，然后我的逻辑是消息普通队列的时候加一个随机的 sleep，让部分消息的 ACK 超过 TTL 的时间，从而让消息超时进入死信队列，但是运行时我发现消息始终不会进入死信队列，除非是直接结束掉消费者进程，然后生产者这边投放几条消息，等过了 TTL 时间后再运行消费者进程，此时就会从死信队列里消费到过期消息。</p><p><strong>实现延迟队列的基本逻辑</strong></p><p>生产者：</p><ol><li>创建一个正常交换机</li><li>创建一个死信交换机</li><li>创建一个正常队列，并绑定正常交换机和 routing_key，同时设置以下几个参数，代表超过指定时间没有被消费的消息，将会使用指定的 routing-key 投递到指定的死信交换机：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;x-message-ttl&quot;</span>:             <span class="hljs-number">5000</span>,            <span class="hljs-regexp">//</span> 消息过期时间,毫秒<br><span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>:    dlxExchangeName, <span class="hljs-regexp">//</span> 指定死信交换机<br><span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>: dlxRoutingKey,   <span class="hljs-regexp">//</span> 指定死信 routing-key<br></code></pre></td></tr></table></figure><ol start="4"><li>创建一个死信队列，并绑定死信交换机和 routing_key</li><li>推送消息到正常交换机</li></ol><p>消费者：</p><p>因为队列和交换机都已经由生产者创建好了，所以消费者这边直接消费即可，并且只需要从死信交换机进行消费即可，这样一来，生产者放到正常队列里的消息在 TTL 之后过期，会放到死信队列，这样消费者就可以直接进行消费了。</p><p>比如订单超时未支付自动取消的场景，当用户提交订单时，生产者将订单信息放到正常队列，同时设置过期时间，当到达时间后进入死信队列，消费者这边就可以开始进行消费了，具体的业务逻辑这里就不展开了，比如可以查询一下订单 ID，看支付状态是否为未支付，如果未支付就说明可以取消这个订单了。</p><h2 id="Ack，Nack，Reject"><a href="#Ack，Nack，Reject" class="headerlink" title="Ack，Nack，Reject"></a>Ack，Nack，Reject</h2><p>消费者消费到消息后，可以决定如何处理这条消息，也就是标题里的三种方法（注意要把 Consume 方法的 autoack 参数设置为 false，这样我们才能够对消息进行手动处理），其中</p><ul><li>Ack：表示自己已经处理完了这条消息，此时 mq 会从队列中移除这个消息。</li><li>Nack：表示自己没有成功处理这条消息，消费者可以选择是否让其重新入队，使得该消息被再次消费处理（看该方法的注释，说的是会转交给其他消费者处理？不确定）。</li><li>Reject：表示消费者拒绝处理这条消息，同样也可以选择是否让其重新入队（看注释同样也是会转交给其他消费者）</li></ul><p>Ack 和 Nack 都有一个 multiple 参数，是一个布尔值，问了下 ChatGPT，其作用是：</p><blockquote><p>🤖</p><p>Ack</p><p><code>ack</code> 方法中的 <code>multiple</code> 参数也是一个布尔值，用于控制是否确认多个消息。</p><ul><li>当 <code>multiple</code> 参数设置为 <code>true</code> 时，表示确认当前消费者获取但尚未确认的所有消息。即将从队列中获取的所有未确认消息都进行确认。这样做的好处是，可以一次性确认多个消息，避免多次单独确认消息的开销，提高消息确认的效率。</li><li>当 <code>multiple</code> 参数设置为 <code>false</code> 时，表示只确认当前传递的一条消息。即仅确认当前处理的一条消息。</li></ul><p>Nack</p><p><code>Nack</code> 方法用于向 RabbitMQ 发送 Negative Acknowledgment（Nack）。其中，<code>multiple</code> 参数是一个布尔值，用于控制是否拒绝多个消息。</p><ul><li><p>当 <code>multiple</code> 参数设置为 <code>true</code> 时，表示拒绝当前消费者未确认的所有消息（即在当前通道上通过 <code>Get</code> 或 <code>Consume</code> 获取的但尚未确认的所有消息）。如果当前消费者处理了一批消息中的某个消息出现了问题，可以通过设置 <code>multiple</code> 为 <code>true</code>，将这一批消息全部拒绝，然后重新投递到 RabbitMQ，由其他消费者重新处理。</p></li><li><p>当 <code>multiple</code> 参数设置为 <code>false</code> 时，表示只拒绝当前传递的一条消息。这时，RabbitMQ 会将该消息重新投递到队列中，等待后续重新处理。</p></li></ul></blockquote><h2 id="平均分摊"><a href="#平均分摊" class="headerlink" title="平均分摊"></a>平均分摊</h2><p>TODO</p><h2 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h2><p>TODO</p>]]></content>
    
    
    
    <tags>
      
      <tag>mq</tag>
      
      <tag>rabbitmq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>minikube 问题汇总</title>
    <link href="/2022/07/14/minikube_wen_ti_hui_zong/"/>
    <url>/2022/07/14/minikube_wen_ti_hui_zong/</url>
    
    <content type="html"><![CDATA[<h1 id="设置代理后，minikube-kubectl-无响应"><a href="#设置代理后，minikube-kubectl-无响应" class="headerlink" title="设置代理后，minikube kubectl 无响应"></a>设置代理后，minikube kubectl 无响应</h1><p>在给虚拟机设置了代理后，整个网络体验爽快多了，再也不用担心拉不下来包了。。。</p><p>只需要将虚拟机的网络设置为桥接模式，然后开启 clashx 的 “允许局域网连接”（非常重要的一步，之前就是因为忽略了这一步，导致虚拟机无法使用宿主机代理），然后再点击 clashx 的 “复制终端代理命令”，将里面的 127.0.0.1 替换为宿主机的 ip，然后粘贴到虚拟机的终端上允许，即可成功开启代理。</p><p>为了方便起见，可以封装成两个函数，放到 .zshrc（或者 .bashrc）里面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">host_ip=&quot;192.168.2.5&quot; # 宿主机 IP<br><br>function proxy_on() &#123;<br>    export https_proxy=http://$host_ip:7890 http_proxy=http://$host_ip:7890 all_proxy=socks5://$host_ip:7890<br>    # curl https://www.google.com/<br>    # echo -e &quot;\n&quot;<br>    echo -e &quot;\033[32m已开启代理\033[0m&quot;<br>&#125;<br><br>function proxy_off() &#123;<br>    unset http_proxy<br>    unset https_proxy<br>    unset all_proxy<br>    echo -e &quot;已关闭代理&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后重新载入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source ~/.zshrc<br></code></pre></td></tr></table></figure><p>现在在终端可以输入 <code>proxy_on</code> 来开启代理了，同样可以输入 <code>proxy_off</code> 来关闭。</p><p>但是之后发现了一个问题，kubectl 命令无响应，不管是使用 snap 下载的 kubectl，还是使用 minikube kubectl 下载的 kubectl 都是如此。</p><p>如果执行 kubectl get po 会一直阻塞，但是 kubectl version 在等待一会后会返回错误信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">minikube kubectl version</span><br>WARNING: This version information is deprecated and will be replaced with the output from kubectl version --short.  Use --output=yaml|json to get the full version.<br>Client Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;24&quot;, GitVersion:&quot;v1.24.3&quot;, GitCommit:&quot;aef86a93758dc3cb2c658dd9657ab4ad4afc21cb&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2022-07-13T14:30:46Z&quot;, GoVersion:&quot;go1.18.3&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/arm64&quot;&#125;<br>Kustomize Version: v4.5.4<br>error: Get &quot;https://192.168.49.2:8443/version?timeout=32s&quot;: context deadline exceeded - error from a previous attempt: read tcp 192.168.2.2:35044-&gt;192.168.2.5:7890: read: connection reset by peer<br></code></pre></td></tr></table></figure><p>看到这里的 192.168.2.2:35044-&gt;192.168.2.5:7890，我才发现有点不对劲，这不是我设置的代理地址吗？难道问题出在这里？</p><p>然后查阅了一下 minikube 的官方文档，发现里面专门 <a href="https://minikube.sigs.k8s.io/docs/handbook/vpn_and_proxy/">有一节</a> 专门提到了代理的问题：</p><p>里面特别提到了：</p><blockquote><p>如果需要 HTTP 代理来访问互联网，您可能需要使用环境变量将代理连接信息传递给 minikube 和 Docker：</p><ul><li><code>HTTP_PROXY</code>- 您的 HTTP 代理的 URL</li><li><code>HTTPS_PROXY</code>- HTTPS 代理的 URL</li><li><code>NO_PROXY</code>- 不应通过代理的主机的逗号分隔列表。</li></ul><p>这里的 NO_PROXY 变量很重要：如果不设置它，minikube 可能无法访问 VM 内的资源。minikube 使用四个默认 IP 范围，它们不应通过代理：</p><ul><li><strong>192.168.59.0&#x2F;24</strong>：由 minikube VM 使用。可通过以下方式为某些管理程序配置<code>--host-only-cidr</code></li><li><strong>192.168.39.0&#x2F;24</strong>：由 minikube kvm2 驱动程序使用。</li><li><strong>192.168.49.0&#x2F;24</strong>：由 minikube docker 驱动程序的第一个集群使用。</li><li><strong>10.96.0.0&#x2F;12</strong>：由服务集群 IP 使用。可通过以下方式配置 <code>--service-cluster-ip-range</code></li></ul></blockquote><p>并且给出了示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">export HTTP_PROXY=http://&lt;proxy hostname:port&gt;<br>export HTTPS_PROXY=https://&lt;proxy hostname:port&gt;<br>export NO_PROXY=localhost,127.0.0.1,10.96.0.0/12,192.168.59.0/24,192.168.49.0/24,192.168.39.0/24<br></code></pre></td></tr></table></figure><p>现在照猫画虎，修改之前的 proxy_on 函数（这里我同样删除了 all_proxy 配置，不知道这个配置是否有影响）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">host_ip=&quot;192.168.2.5&quot;<br><br>function proxy_on() &#123;<br>    export no_proxy=localhost,127.0.0.1,10.96.0.0/12,192.168.59.0/24,192.168.49.0/24,192.168.39.0/24<br>    export https_proxy=http://$host_ip:7890<br>    export http_proxy=http://$host_ip:7890<br>    # curl https://www.google.com/<br>    # echo -e &quot;\n&quot;<br>    echo -e &quot;\033[32m已开启代理\033[0m&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在 kubectl 就可以正常使用了。</p><p>更新：</p><p>最近发现又出现这个问题了，我的 proxy_on 函数也没有发生任何修改，报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl version</span><br>WARNING: This version information is deprecated and will be replaced with the output from kubectl version --short.  Use --output=yaml|json to get the full version.<br>Client Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;24&quot;, GitVersion:&quot;v1.24.4&quot;, GitCommit:&quot;95ee5ab382d64cfe6c28967f36b53970b8374491&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2022-08-18T02:40:28Z&quot;, GoVersion:&quot;go1.18.5&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/arm64&quot;&#125;<br>Kustomize Version: v4.5.4<br>error: Get &quot;https://192.168.58.2:8443/version?timeout=32s&quot;: context deadline exceeded - error from a previous attempt: read tcp 192.168.2.4:45562-&gt;192.168.2.3:7890: read: connection reset by peer<br></code></pre></td></tr></table></figure><p>这里我注意到了 “<a href="https://192.168.58.2:8443/version?timeout=32s">https://192.168.58.2:8443/version?timeout=32s</a>“ 这部分，发现请求的是 192.168.58.2 这个地址，我尝试将这个地址段（也就是 192.168.58.0&#x2F;24）也添加到 no_proxy 列表中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">function proxy_on() &#123;<br>    export no_proxy=localhost,127.0.0.1,10.96.0.0/12,192.168.59.0/24,192.168.49.0/24,192.168.39.0/24,192.168.58.0/24<br>    export https_proxy=http://$host_ip:7890<br>    export http_proxy=http://$host_ip:7890<br>    # curl https://www.google.com/<br>    # echo -e &quot;\n&quot;<br>    echo &quot;host_ip: $host_ip&quot;<br>    echo -e &quot;\033[32m已开启代理\033[0m&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加后 source .zshrc，proxy_off 一下，再重新 proxy_on，发现 kubectl 可以正常执行了。</p><p>不过具体原因还不清楚，我的 minikube version 是 v1.26.1，是官方文档与这个版本不匹配吗？或者可能是因为 192.168.59.0 这个网段被占用了，导致 minikube 重新选择了 192.168.58.0 这个网段？暂时不知道原因，不过只要按照 kubectl version 里的报错信息，将请求的网段添加到 no_proxy 环境变量里就可以解决问题了。</p><h1 id="minikube-无法启动"><a href="#minikube-无法启动" class="headerlink" title="minikube 无法启动"></a>minikube 无法启动</h1><p>重装了一下 docker，发现 minikube 无法启动了，部分报错信息如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs applescript">[kubelet-check] Initial <span class="hljs-keyword">timeout</span> <span class="hljs-keyword">of</span> <span class="hljs-number">40</span>s passed.<br><br>Unfortunately, an <span class="hljs-keyword">error</span> has occurred:<br>timed out waiting <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> condition<br><br>This <span class="hljs-keyword">error</span> <span class="hljs-keyword">is</span> likely caused <span class="hljs-keyword">by</span>:<br>- The kubelet <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">running</span><br>- The kubelet <span class="hljs-keyword">is</span> unhealthy due <span class="hljs-keyword">to</span> a misconfiguration <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> node <span class="hljs-keyword">in</span> <span class="hljs-keyword">some</span> way (required cgroups disabled)<br><br>If you are <span class="hljs-keyword">on</span> a systemd-powered system, you can <span class="hljs-keyword">try</span> <span class="hljs-keyword">to</span> troubleshoot <span class="hljs-keyword">the</span> <span class="hljs-keyword">error</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> following commands:<br>- &#x27;systemctl status kubelet&#x27;<br>- &#x27;journalctl -xeu kubelet&#x27;<br></code></pre></td></tr></table></figure><p>解决方法，<a href="https://github.com/kubernetes/minikube/issues/14477">参考这里</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">minikube delete</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">minikube start --kubernetes-version=v1.23.8</span><br></code></pre></td></tr></table></figure><p>可能是 kubernetes 1.24 的问题导致的</p><h1 id="创建-pod-错误，Error-ImagePullBackOff"><a href="#创建-pod-错误，Error-ImagePullBackOff" class="headerlink" title="创建 pod 错误，Error: ImagePullBackOff"></a>创建 pod 错误，Error: ImagePullBackOff</h1><p>一个 redis yaml 如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">redis</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">redis</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">6379</span><br>      <span class="hljs-attr">hostPort:</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>这是我之前使用过的 redis yaml，yaml 本身应该没问题，但是 <code>kubectl apply -f redis.yaml</code> 后，pod 无法创建成功，处于 ImagePullBackOff 状态，查看 describe，报错信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">Events:<br>  Type     Reason     Age                     From               Message<br>  ----     ------     ----                    ----               -------<br>  Normal   Scheduled  9m47s                   default-scheduler  Successfully assigned default/redis to minikube<br>  Warning  Failed     9m31s                   kubelet            Failed to pull image &quot;redis&quot;: rpc error: code = Unknown desc = Error response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: context deadline exceeded (Client.Timeout exceeded while awaiting headers)<br>  Warning  Failed     8m21s (x2 over 9m2s)    kubelet            Failed to pull image &quot;redis&quot;: rpc error: code = Unknown desc = Error response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br>  Normal   Pulling    7m26s (x4 over 9m47s)   kubelet            Pulling image &quot;redis&quot;<br>  Warning  Failed     7m11s (x4 over 9m31s)   kubelet            Error: ErrImagePull<br>  Warning  Failed     7m11s                   kubelet            Failed to pull image &quot;redis&quot;: rpc error: code = Unknown desc = Error response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: dial tcp 54.242.59.189:443: i/o timeout<br>  Warning  Failed     6m56s (x6 over 9m31s)   kubelet            Error: ImagePullBackOff<br>  Normal   BackOff    4m37s (x14 over 9m31s)  kubelet            Back-off pulling image &quot;redis&quot;<br></code></pre></td></tr></table></figure><p>但是我使用 docker pull redis 是成功的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull redis</span><br>Using default tag: latest<br>latest: Pulling from library/redis<br>5b1423465504: Pull complete<br>4216a986e3df: Pull complete<br>f74254280149: Pull complete<br>64dfe9963acc: Pull complete<br>097894d6d055: Pull complete<br>b9381c45e088: Pull complete<br>Digest: sha256:495732ba570db6a3626370a1fb949e98273a13d41eb3e26f7ecb1f6e31ad4041<br>Status: Downloaded newer image for redis:latest<br>docker.io/library/redis:latest<br></code></pre></td></tr></table></figure><p>而且我注意到 docker pull 的地址是 library&#x2F;redis，而 k8s pod get 的地址是 registry-1.docker.io&#x2F;v2&#x2F;，因为虚拟机我挂了代理，应该也不是网络的问题。我又将 redis.yaml 里面的 spec.containers[0].image 改为了 library&#x2F;redis，依旧创建失败，还是会 Get <a href="https://registry-1.docker.io/v2/">https://registry-1.docker.io/v2/</a> 这个地址。</p><p>不知道问题出在哪里，试了下用 k3s 执行同样的操作，可以创建成功</p>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
      <tag>minikube</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TLS 握手流程</title>
    <link href="/2022/07/14/tls_wo_shou/"/>
    <url>/2022/07/14/tls_wo_shou/</url>
    
    <content type="html"><![CDATA[<blockquote><p>注：以下内容引用自 <a href="https://www.cloudflare.com/zh-cn/learning/ssl/what-happens-in-a-tls-handshake/">cloudflare 学习中心</a></p></blockquote><h1 id="TLS-握手有哪些步骤？"><a href="#TLS-握手有哪些步骤？" class="headerlink" title="TLS 握手有哪些步骤？"></a>TLS 握手有哪些步骤？</h1><p>TLS 握手是由客户端和服务器交换的一系列数据报或消息。TLS 握手涉及多个步骤，因为客户端和服务器要交换完成握手和进行进一步对话所需的信息。</p><p>TLS 握手的确切步骤将根据所使用的密钥交换算法的类型以及双方支持的密码套件而有所不同。RSA 密钥交换算法最为常用。具体如下：</p><ol><li><p><strong>“客户端问候（client hello）” 消息：</strong> 客户端通过向服务器发送“问候”消息来开始握手。该消息将包含 <strong>客户端支持的 TLS 版本，支持的密码套件</strong>，以及称为一串称为“<strong>客户端随机数（client random）</strong>”的随机字节。</p></li><li><p><strong>“服务器问候（server hello）”消息：</strong> 作为对 client hello 消息的回复，服务器发送一条消息，内含<strong>服务器的 <a href="https://www.cloudflare.com/learning/ssl/what-is-an-ssl-certificate/">SSL 证书</a><strong>、</strong>服务器选择的密码套件（从客户端支持的套件中选择）</strong>，以及“<strong>服务器随机数</strong>（server random）”，即由服务器生成的另一串随机字节。</p></li><li><p><strong>身份验证：</strong> 客户端使用颁发该证书的证书颁发机构验证服务器的 SSL 证书。此举确认服务器是其声称的身份，且客户端正在与该域的实际所有者进行交互。</p></li><li><p><strong>预主密钥：</strong> 客户端再发送一串随机字节，即“<strong>预主密钥（premaster secret）</strong>”。预主密钥是使用公钥加密的，只能使用服务器的私钥解密。（客户端从服务器的 SSL 证书中获得<a href="https://www.cloudflare.com/learning/ssl/how-does-public-key-encryption-work/">公钥</a>。），也就是说，客户端将使用公钥加密预主密钥，然后发送给服务端。</p></li><li><p><strong>私钥被使用</strong>：服务器使用自己的 <strong>私钥</strong> 对预主密钥进行解密。</p></li><li><p><strong>生成会话密钥</strong>：至此，客户端和服务端经过一系列信息交换后，各自都拥有了以下数据：</p><ol><li><p>客户端生成的随机数</p></li><li><p>服务端生成的随机数 </p></li><li><p>预主密钥</p></li></ol><p> 然后，客户端和服务器均使用客户端随机数、服务器随机数和预主密钥生成 <strong>会话密钥</strong>。双方应得到相同的结果。</p></li><li><p><strong>客户端就绪</strong>：客户端发送一条“已完成”消息，该消息用会话密钥加密。</p></li><li><p><strong>服务器就绪</strong>：服务器发送一条“已完成”消息，该消息用会话密钥加密。</p></li><li><p><strong>实现安全对称加密</strong>：已完成握手，并使用 <strong>会话密钥</strong> 继续进行通信，之后的通信都会使用该密钥，以 <strong>对称加密</strong> 的方式进行通信。</p></li></ol><p>具体的流程可以用下面这张图来概括：</p><blockquote><p>图片来源：<a href="https://segmentfault.com/a/1190000021559557">https://segmentfault.com/a/1190000021559557</a></p></blockquote><p><img src="https://raw.githubusercontent.com/autsu/diagrams/2d20c2027f78f57ae0087ea3b33de34456234cbf/img/tls%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B.png"></p><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><ol><li><p>为什么不直接使用非对称加密进行通信？</p><p> 非对称加密的计算量比较大，加解密速度较慢，因此在数据量较大的情况下，使用非对称加密进行加解密会比较耗时，不利于高效的通信。而对称加密的计算量较小，加解密速度较快，可以很好地满足数据传输的需求。因此，<strong>TLS 在握手阶段使用非对称加密来协商对称密钥</strong>，并且之后的通信过程中使用对称加密方式，以保证通信的安全性和高效性。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输入 url 到浏览器显示网页，期间发生了什么？</title>
    <link href="/2022/07/14/url_dao_xian_shi_wang_ye_fa_shen_le_shen_me/"/>
    <url>/2022/07/14/url_dao_xian_shi_wang_ye_fa_shen_le_shen_me/</url>
    
    <content type="html"><![CDATA[<h1 id="1-解析-URL-并构建请求报文"><a href="#1-解析-URL-并构建请求报文" class="headerlink" title="1. 解析 URL 并构建请求报文"></a>1. 解析 URL 并构建请求报文</h1><p>首先浏览器做的第一步工作就是要对 <code>URL</code> 进行解析，从而构建出发送给 <code>Web</code> 服务器的请求报文。</p><p>URL 由三部分组成：<strong>协议类型，服务器地址和资源文件路径</strong>。比如 <a href="http://www.server.com/dir1/file1.html">http://www.server.com/dir1/file1.html</a> 这个 URL，它的协议类型是 http，服务器地址（域名）是 <a href="http://www.server.com,dir1/file1.html">www.server.com，dir1/file1.html</a> 就是文件路径。</p><p>对 <code>URL</code> 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。</p><p>HTTP 请求报文的格式如下：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/http_request_proto.png"></p><p>然后我们就可以根据 URL 里面的一些信息，以及一些其他信息（比如浏览器自动携带的 Cookie 等），构建出这个报文，类似下面这样：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/http_request_data.webp"></p><h1 id="2-从请求-URL-中解析域名地址（如果需要的话）"><a href="#2-从请求-URL-中解析域名地址（如果需要的话）" class="headerlink" title="2. 从请求 URL 中解析域名地址（如果需要的话）"></a>2. 从请求 URL 中解析域名地址（如果需要的话）</h1><p>URL 的服务器地址可能直接提供的就是 IP 地址，但是也有可能提供的是域名，如果是域名，那我们就需要将其解析成对应的 IP 地址。<strong>获取域名对应 IP 地址的流程如下：</strong></p><h2 id="发送-DNS-请求报文到-DNS-域名服务器"><a href="#发送-DNS-请求报文到-DNS-域名服务器" class="headerlink" title="发送 DNS 请求报文到 DNS 域名服务器"></a><strong>发送 DNS 请求报文到 DNS 域名服务器</strong></h2><ol><li><p>首先需要知道 DNS <strong>域名服务器</strong> 的 IP 地址，这样才能给它发送 DNS 请求报文，而根据网络模型，光有 IP 地址是不够的，还需要知道 MAC 地址才能构建数据链路层的报文，所以需要通过 ARP 协议来根据 IP 获取对应的 MAC 地址。域名服务器的 IP 地址一般是默认配置好的，所以这里假定已经知道了 IP 地址，只需要获取 MAC 地址。</p><p>首先，主机会先检查一下自己的 ARP 表，看看有没有该 IP 缓存记录，有的话可以直接获取到对应的 MAC 地址，如果没有，就需要构建一个 ARP 请求报文，源 IP 和源 MAC 填写自己的，目的 IP 填写域名服务器的，目的 MAC 填写广播地址（FF-FF-FF-FF-FF-FF-FF），然后这个报文会发送给当前子网的所有主机，每个主机会查看报文里的目的 IP 地址是否与自己的 IP 地址相同，如果相同的话，就会回复 ARP 响应报文，里面有自己的 MAC 地址；如果不相同则会直接丢弃报文。主机获得域名服务器的 MAC 地址后，记录到自己的 ARP 表中，至此，主机已经获取到域名服务器的 MAC 地址了。</p></li><li><p>知道了域名服务器的 IP 地址和 MAC 地址后，就可以向其发送 DNS 请求报文了，DNS 请求报文在运输层被封装为 UDP 用户数据报，目的端口号为 53；UDP 用户数据报在网络层被封装为 IP 数据包，目的 IP 地址为域名服务器的 IP 地址；IP 数据报被封装在以太单播帧中发送，目的 MAC 地址为之前 ARP 请求获得的 MAC 地址，该单播帧通过交换机转发给本地域名服务器，本地域名服务器在收到报文后逐层解封，知道这是一个 DNS 请求，于是进入域名解析阶段。<del>给主机发送 DNS 响应报文，里面包含了域名对应的 IP 地址。</del></p></li></ol><h2 id="域名解析阶段"><a href="#域名解析阶段" class="headerlink" title="域名解析阶段"></a><strong>域名解析阶段</strong></h2><p>根据域名的层级关系，由大到小为：<strong>根域、顶级域、权威域</strong>，层级代表的意思是：<del>高层级里面保存了下一层级的域名到 IP 的映射记录</del>，对应到域名是从右往左，也就是右边最大，左边最小，比如 <a href="http://www.baidu.com/">www.baidu.com</a> 这个域名，（最高层的根域在这个域名里没有体现出来，看了下别的博客，说的是实际是最后还有一个隐藏的 . 代表的就是根域名，这里暂时先不研究了），根域里保存的下一级顶级域的记录，也就是最右边的 .com 的记录，而 .com 又保存了 baidu.com 这个权威域的记录，最终再从 baidu.com 这个权威域里面找到最终的域名 <a href="http://www.baidu.com/">www.baidu.com</a> 的记录。</p><p>知道了上面的前置概念后，我们就可以开始了解域名查询操作的流程了，域名查询分为了迭代查询和递归查询两种方式，<a href="https://www.xiaolincoding.com/network/1_base/what_happen_url.html#%E7%9C%9F%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%9F%A5%E8%AF%A2-dns">下面这张图</a> 清晰的展示了 DNS 查询的流程，并且这是迭代查询的方式。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/dns_iterative_query.webp"></p><p>从上图可以看到，迭代查询是所有的查询操作都落在一个 server 上，比如 A 问 B 要 C 的地址，然后 B 把 C 的地址给 A，A 再去问 C 要 D 的地址。。。所有请求都是 A 发出的；而递归操作则是 A 问 B，B 再问 C 这样。。。</p><p><strong>递归查询</strong></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/dns_query_digui.webp"></p><p><strong>迭代查询</strong></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/dns_query_iter.webp"></p><h2 id="DNS-域名服务器传回-DNS-响应报文"><a href="#DNS-域名服务器传回-DNS-响应报文" class="headerlink" title="DNS 域名服务器传回 DNS 响应报文"></a><strong>DNS 域名服务器传回 DNS 响应报文</strong></h2><p>然后我们就可以拿到该域名对应的 IP 地址了。</p><h1 id="3-运输层封装应用层的-HTTP-报文"><a href="#3-运输层封装应用层的-HTTP-报文" class="headerlink" title="3. 运输层封装应用层的 HTTP 报文"></a>3. 运输层封装应用层的 HTTP 报文</h1><p>在之前我们已经构建好了应用层的 HTTP 请求报文，根据网络模型，我们需要按照 应用层 —— 运输层 —— 网络层 —— 数据链路层 —— 物理层 的方式构建报文，所以我们需要构建一个传输层协议的报文，来封装应用层的 HTTP 请求报文。HTTP 使用的传输层协议一般都是 TCP（除了 HTTP 3 没有使用，其他版本的 HTTP 都是使用的 TCP），所以接下来我们需要构建一个 TCP 报文。</p><p>TCP 报文结构如下：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/tcp_proto.webp"></p><p>TCP 报文里包含非常多的参数，这里我们先不管其他的，只关注源端口和目标端口这两个，因为这两个值都是基于我们之前得到的结果进行填写的。其中，目标端口通过请求的 URL 获取，如果没有指定，则使用 HTTP 默认的 80 端口，或者 HTTPS 的默认端口 443，源端口取决于是否显式指定，如果没有则会由系统随机分配一个。</p><p>然后我们会把之前的 HTTP 请求报文放到 TCP 报文的数据部分，也就是所谓的封装。需要注意的是 TCP 报文存在一个 MSS（最大分段大小）的概念，即 TCP 的报文段中的数据部分的最大字节数，如果我们的 HTTP 请求报文比较大，那么将会进行数据分割操作，也就是将数据拆成多个小的数据块，然后分多次发送，这也是为什么 TCP 称为流式传输的原因。</p><p>至此我们已经封装好了 TCP 报文，类似下面这样：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/tcp_wrap_http.webp"></p><p>最后，在 TCP 传输数据之前，要先通过三次握手建立连接，这个所谓的「连接」，其实就是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/tcp_san_ci_wo_shou.webp"></p><ul><li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</li><li>然后客户端主动发起连接 <code>SYN</code>，之后处于 <code>SYN-SENT</code> 状态。</li><li>服务端收到发起的连接，返回 <code>SYN</code>，并且 <code>ACK</code> 客户端的 <code>SYN</code>，之后处于 <code>SYN-RCVD</code> 状态。</li><li>客户端收到服务端发送的 <code>SYN</code> 和 <code>ACK</code> 之后，发送对 <code>SYN</code> 确认的 <code>ACK</code>，之后处于 <code>ESTABLISHED</code> 状态，因为它一发一收成功了。</li><li>服务端收到 <code>ACK</code> 的 <code>ACK</code> 之后，处于 <code>ESTABLISHED</code> 状态，因为它也一发一收了。</li></ul><p>所以三次握手目的是 <strong>保证双方都有发送和接收的能力</strong>。</p><blockquote><p>下面这段内容不确定正确性，只做记录</p><p>TCP 三次握手发送的包，也是普通的 TCP 报文，结构和 TCP 结果相同，它会根据具体的操作来填充对应的填充位（SYN，ACK …）以及一些其他数据，然后发送出去，我们注意到在 TCP 报文中是不需要填写 IP 地址的，那它如何方式给对方呢？和常规的网络包一样，我们需要将这个运输层的包继续封装到一个网络层 IP 数据报中，而 IP 就是在此时填写，然后再继续按照网络模型层层封装，最后发送出去。。。</p></blockquote><p>至此，我们已经封装好了运输层 TCP 报文，并且使用三次握手建立的连接，做好了数据传输的准备。</p><h1 id="4-网络层封装传输层的-TCP-报文"><a href="#4-网络层封装传输层的-TCP-报文" class="headerlink" title="4. 网络层封装传输层的 TCP 报文"></a>4. 网络层封装传输层的 TCP 报文</h1><p>运输层报文已经准备好了，按照网络模型，我们需要继续将这个 TCP 报文封装到一个 IP 数据报中，添加上 IP 的报文头，然后报文头里面需要填写源 IP 地址和目的 IP 地址，这里的源地址填写我们自己（也就是某张网卡）的 IP，目的地址填写之前从 DNS 获取到的 IP，这样就知道该发送给哪台机器了。</p><blockquote><p>在 TCP 报文中，我们只填写了端口号，但是没有填写 IP，所以运输层是 <strong>端到端</strong> 的，它负责把报文交给一个具体的应用；而网络层是 <strong>点到点</strong> 的，它负责把报文交给一台机器，这也体现了网络模型中的分层思想。</p></blockquote><p>封装好的 IP 数据报类似下面这样：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/ip_proto_data.webp"></p><h1 id="5-数据链路层封装-IP-数据报"><a href="#5-数据链路层封装-IP-数据报" class="headerlink" title="5. 数据链路层封装 IP 数据报"></a>5. 数据链路层封装 IP 数据报</h1><p>我们已经封装好了网络层的 IP 数据报，接下里我们需要继续创建一个数据链路层报文。</p><blockquote><p><strong>一点杂谈</strong></p><p>互联网其实就是由一个一个小的局域网组成的大的网络，就像一个国家是由一个个城市组成的一样，每个城市又通过道路连接起来。发送一个网络报文就可以类比成现实生活中的开车旅游，我们要想到达目的地，就需要地图导航，告诉我们前进的路线。比如我们要想从 A 市到 C 市的 XX 小镇，根据地图的指引，我们需要先沿着 a 号公路行驶到 B 市，再从 B 市走 b 路到达 C 市市中心，最后，我们再走 c 小道到达最终的目的地 XX 小镇。</p><p>同理，我们重新回到计算机网络，城市就相当于一个局域网，小镇就相当于这个局域网中的一台机器，网络报文就相当于汽车，道路就相当于网络设备，报文将在一个个局域网中穿梭，根据一系列的规则（地图指引），来选择其前进的方向，最终到达目的局域网中的某台机器。</p></blockquote><blockquote><p><strong>Tips：网络层负责点到点的传输，其工作于大的网络，比如互联网&#x2F;广域网，而数据链路层负责同一局域网下的两点之间传输，其工作于小的局域网。</strong></p></blockquote><p>数据链路层报文里有两个字段：接收方 MAC 地址，发送方 MAC 地址，我们主要关注这两个字段即可。MAC 地址可以唯一标识局域网中的一台机器。</p><p>**接收方 **的 MAC 地址就有点复杂，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。</p><p>**发送方 **的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。</p><p>那我们如何知道接收方的 MAC 地址呢？我们已经拿到了接收方的 IP 地址了，那么我们就可以通过 ARP 协议来获取该 IP 对应的 MAC 地址。</p><p>我们需要构建一个 ARP 请求报文，源 IP 和源 MAC 填写自己的，目的 IP 填写目标 IP 的，目的 MAC 填写广播地址（FF-FF-FF-FF-FF-FF-FF），然后这个报文会发送给 <strong>当前子网的所有主机</strong>，每个主机会查看报文里的目的 IP 地址是否与自己的 IP 地址相同，如果相同的话，就会回复 ARP 响应报文，里面有自己的 MAC 地址；如果不相同则会直接丢弃报文。主机获得域名服务器的 MAC 地址后，记录到自己的 ARP 表中进行缓存，这样下次再问的话就可以直接返回了。</p><p>这里可能会想到一个问题：ARP 只能在一个子网内工作，如果请求的 IP 不是一个子网内的，那将没人会进行应答，此时该如何获取对应的 MAC 地址呢？原来在每个子网中，都配置了一台网关路由器，它连接了其他几个子网的交换机，当请求的 IP 不属于同一个子网时，就需要这台网关路由器来做转发（也就是将 MAC 地址填写为这个网关路由器的 MAC 地址），传递到另一个子网，具体如何转发取决于路由表，整个流程就像坐公交使用地图导航一样，选择一条路径，在不同的公交站间穿梭前进，网络也是这样的，多个子网相互连接组成一个大网络，数据报在这些互联的子网中选择一条道路前进，经过一个个子网，最终到达目的地。这里也发现了一个问题：<strong>在网络包传输的过程中，源 IP 和目标 IP 始终是不会变的（前提：没有使用 NAT 网络的），一直变化的是 MAC 地址，因为需要 MAC 地址在以太网内进行两个设备之间的包传输。</strong>可能这也是为什么需要 IP 和 MAC 两个地址的一点原因。</p><p>最终，封装好的数据链路层报文如下：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/mac_proto_data.webp"></p><h1 id="6-网卡发送最终的网络包"><a href="#6-网卡发送最终的网络包" class="headerlink" title="6. 网卡发送最终的网络包"></a>6. 网卡发送最终的网络包</h1><p>到现在，软件层面的网络包已经封装好了，接下来我们就需要借助硬件，将 <strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。负责执行这一操作的是 <strong>网卡</strong>，要控制网卡还需要靠 <strong>网卡驱动程序</strong>。网卡驱动获取网络包之后，会将其 <strong>复制</strong> 到网卡内的缓存区中，接着会在其 <strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p><p>最后网卡会将包转为电信号，通过网线发送出去。</p><h1 id="7-已经变成电信号的网络包顺着网线打爆交换机的狗头"><a href="#7-已经变成电信号的网络包顺着网线打爆交换机的狗头" class="headerlink" title="7. 已经变成电信号的网络包顺着网线打爆交换机的狗头"></a>7. 已经变成电信号的网络包顺着网线打爆交换机的狗头</h1><p>网卡把网络包转为电信号后，发送给了交换机</p><blockquote><p>🤔 网线一定是连接着交换机吗？</p></blockquote><p><strong>交换机的包接收操作</strong></p><p>首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。</p><p>然后通过包末尾的 <code>FCS</code> 校验错误，如果没问题则放到缓冲区。</p><p>与网卡不同，网卡在收到包后会检查该包的目的 MAC 地址，看和自己的 MAC 地址一不一致，如果不一致则说明这个包不是发给自己的，会直接丢弃；但是交换机不会进行这一步操作，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p><p>将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。</p><blockquote><p>读者注：交换机与多个接口，每个接口都可以通过网线连接一台设备。</p><p>然后交换机还有有一个 MAC 地址表，里面记录了每个接口到该接口连接设备的 MAC 地址的映射</p><p>比如</p><p>00-60-97-A5-43-3C 1代表接口 1 所连接的设备的 MAC 地址为 00-60-97-A5-43-3C</p></blockquote><p>交换机的 MAC 地址表主要包含两个信息：</p><ul><li>一个是设备的 MAC 地址，</li><li>另一个是该设备连接在交换机的哪个端口上。</li></ul><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/mac_addr_table.webp"></p><p>举个例子，如果收到的包的接收方 MAC 地址为 <code>00-02-B3-1C-9C-F9</code>，则与图中表中的第 3 行匹配，根据端口列的信息，可知这个地址位于 <code>3</code> 号端口上，然后就可以通过交换电路将包发送到相应的端口了。</p><p>所以，<strong>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>。</p><h1 id="8-继续打爆路由器"><a href="#8-继续打爆路由器" class="headerlink" title="8. 继续打爆路由器"></a>8. 继续打爆路由器</h1><p>网络包经过交换机之后，现在到达了 <strong>路由器</strong>，并在此被转发到下一个路由器或目标设备。</p><blockquote><p>🤔 一定要先通过交换机，再通过路由器吗？</p></blockquote><p><strong>路由器的包接收操作</strong></p><p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。</p><p>如果没问题则检查 MAC 头部中的 <strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p><p>完成包接收操作之后，路由器就会 <strong>去掉</strong> 包开头的 MAC 头部。</p><p><strong>MAC 头部的作用就是将包送达路由器</strong>，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会 <strong>被丢弃</strong>。</p><blockquote><p>🤔 在前面的交换机发送操作中，交换机会根据自己的 MAC 地址表来转发包（转发给路由器），那么按理说路由器收到的包应该是属于自己的（也就是自身的 MAC 地址与包的目的 MAC 地址相同），那为啥这里又要再检查一遍呢？</p><p>看 <a href="https://www.xiaolincoding.com/network/1_base/what_happen_url.html">文章</a> 里面有这样一段内容：</p><p><strong>当 MAC 地址表找不到指定的 MAC 地址会怎么样？</strong></p><p>地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。</p><p>这种情况下，交换机无法判断应该把包转发到哪个端口，只能 <strong>将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包</strong>。</p><p>可能就是因为存在这种情况，所以路由器这边就还需要再判断一次</p></blockquote><p>接下来，路由器会根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作。</p><p>转发操作分为几个阶段，首先是查询 <strong>路由表</strong> 判断转发目标。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/route_table.webp"></p><p>具体的工作流程根据上图，举个例子。</p><p>假设地址为 <code>10.10.1.101</code> 的计算机要向地址为 <code>192.168.1.100</code> 的服务器发送一个包，这个包先到达图中的路由器。</p><p>判断转发目标的第一步，就是根据包的接收方 IP 地址查询路由表中的目标地址栏，以找到相匹配的记录。</p><p>路由匹配和前面讲的一样，每个条目的子网掩码和 <code>192.168.1.100</code> IP 做 <strong>&amp; 与运算</strong>后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。</p><p>如第二条目的子网掩码 <code>255.255.255.0</code> 与 <code>192.168.1.100</code> IP 做 <strong>&amp; 与运算</strong>后，得到结果是 <code>192.168.1.0</code> ，这与第二条目的目标地址 <code>192.168.1.0</code> 匹配，该第二条目记录就会被作为转发目标。</p><p>实在找不到匹配路由时，就会选择 <strong>默认路由</strong>，路由表中子网掩码为 <code>0.0.0.0</code> 的记录表示「默认路由」。</p><p><strong>路由器的发送操作</strong></p><p>接下来就会进入包的 <strong>发送操作</strong>。</p><p>首先，我们需要根据 <strong>路由表的网关列</strong> 判断对方的地址。</p><ul><li>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</li><li>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</li></ul><p>知道对方的 IP 地址之后，接下来需要通过 <code>ARP</code> 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。</p><p>路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。</p><p>接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 <code>0800</code> （十六进制）表示 IP 协议。</p><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。</p><p>发送出去的网络包会通过 <strong>交换机</strong> 到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p><p>接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p><p>不知你发现了没有，在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC 地址在以太网内进行 <strong>两个设备</strong> 之间的包传输。</p><h1 id="9-开始扒皮"><a href="#9-开始扒皮" class="headerlink" title="9. 开始扒皮"></a>9. 开始扒皮</h1><p>经过一系列的操作后，我们的网络包终于到达目的主机了，接下来就可以将一个个层层封装的报文，再层层解开，拿到我们想要的信息。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/net_pack_wrap_unwrap.webp"></p><p>数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。</p><p>接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。</p><p>于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP 头部里面还有端口号， HTTP 的服务器正在监听这个端口号。</p><p>于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。</p><p>服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。</p><p>HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。</p><p>穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。</p><p>最后跳到了客户端的城门把守的路由器，路由器扒开 IP 头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。</p><p>客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！</p><p>于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！</p><p>最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。</p><h1 id="参考-x2F-抄袭"><a href="#参考-x2F-抄袭" class="headerlink" title="参考&#x2F;抄袭"></a>参考&#x2F;抄袭</h1><p><a href="https://www.xiaolincoding.com/network/1_base/what_happen_url.html">https://www.xiaolincoding.com/network/1_base/what_happen_url.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go mutex 原理</title>
    <link href="/2022/07/12/go-mutex-yuan-ma/"/>
    <url>/2022/07/12/go-mutex-yuan-ma/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<br><a href="https://www.bilibili.com/video/BV15V411n7fM?p=2&spm_id_from=pageDriver&vd_source=2ff613424b86c58a71ba91b7304ffe9b">https://www.bilibili.com/video/BV15V411n7fM?p=2&amp;spm_id_from=pageDriver&amp;vd_source=2ff613424b86c58a71ba91b7304ffe9b</a></p></blockquote><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>mutex 的数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;<br>state <span class="hljs-type">int32</span><br>sema  <span class="hljs-type">uint32</span><br>&#125;<br></code></pre></td></tr></table></figure><p>mutex 零值可用，代表一个未锁定的锁。</p><p><code>state</code> 存储的是互斥锁的状态，加锁和解锁都是通过 cas 来实现的<br>加锁：atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked)，其中 mutexLocked &#x3D; 1<br>解锁：atomic.AddInt32(&amp;m.state, -mutexLocked)，代表将 state 变为 0，因为只有加锁状态下才能解锁，如果对一个未加锁的锁执行解锁操作会 panic，而加锁状态下的 state &#x3D; 1，这个操作又是将 state - 1，所以会将 state 变为 0。</p><p><code>sema</code> 用作一个信号量，主要用作等待队列</p><p>mutex 有两种模式：<strong>正常模式</strong> 和 <strong>饥饿模式</strong></p><p>在 <strong>正常模式</strong> 下，一个尝试加锁的 goroutine 会先自旋几次，尝试通过原子操作获得锁，若几次自旋后仍然不能获得锁，则通过信号量排队等待（？啥叫通过信号量排队，信号量是如何工作的？），所有的等待者会按照先入先出的顺序排队。</p><p>但是当锁释放，第一个等待者被唤醒后并不会直接拥有锁，而是要和后来者竞争，后来者也就是新的 goroutine，它们处于自旋状态，且尚未排队，这些后来者因为占有了 CPU，且数量可能不少，而队列中被唤醒的 goroutine 只有一个，所以被唤醒的 goroutine 大概率抢不到锁，这种情况下，它会重新插入到队列的头部，而不是尾部。</p><p>当一个 goroutine 本次加锁等待时间超过了 1ms 后，它会把当前 mutex 从正常模式切换到 <strong>饥饿模式</strong>，<strong>在饥饿模式下，mutex 的所有权从执行 unlock 的 goroutine 直接传递给等待队列头部的 goroutine</strong>，后来者不会自旋，也不会尝试获得锁，而是直接到队尾排队等待。</p><p><strong>何时从饥饿模式切换到正常模式</strong><br>当一个等待者获得锁之后，它会在以下情况将锁从饥饿模式切换到正常模式：</p><ol><li>它的等待时间小于 1ms</li><li>它是队列的最后一个元素，也就是除自己以外没有其他等待者了，自然也就没有饥饿的 goroutine 了。</li></ol><p>正常模式下性能更好，但是可能会出现队列尾端的 goroutine 迟迟抢不到锁的情况，也就是尾端延迟，而饥饿模式下，goroutine 不再自旋，所有 goroutine 都要排队，严格的先来后到，可以有效解决尾端延迟问题，但是性能会差一些。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go chan 原理（人话版）</title>
    <link href="/2022/06/26/go-chan-yuan-ma/"/>
    <url>/2022/06/26/go-chan-yuan-ma/</url>
    
    <content type="html"><![CDATA[<h1 id="chan-原理（人话版）"><a href="#chan-原理（人话版）" class="headerlink" title="chan 原理（人话版）"></a>chan 原理（人话版）</h1><blockquote><p>说明：这里只是用大白话来阐述 chan 的大致原理，不保证严谨性，也不考虑一些繁枝细节（比如 sudog，gopark，goready），仅作为一个简单的参考理解，如果想深入理解 chan 的底层实现，请自行参阅其他博客</p></blockquote><p>chan 底层有两个队列：<code>sendq</code> 和 <code>recvq</code>，这两个队列保存的都是被阻塞的 goroutine（简称 g），顾名思义，<code>sendq</code> 里面保存的是因为发送操作而被阻塞的 g，而 <code>recvq</code> 保存的是因为接收操作被阻塞的 g，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>  ch &lt;- <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为没有接收者，所以 ch &lt;- 1 这个操作会被阻塞，那么就会把执行这个 chan 的 g 给放到 sendq 中</p><p>当执行 <strong>发送</strong> 操作时，会先看看 recvq 中有没有因为接收操作而被阻塞的 g，如果有的话，那么出队 g，并将数据拷贝给它，之后再将其唤醒；</p><p>同理，当执行 <strong>接收</strong> 操作时，会先看看 sendq 中有没有因为发送而被阻塞的 g，如果有，则执行和上面相同的操作。</p><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>  ch &lt;- <span class="hljs-number">1</span><br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    v := &lt;-ch<br>  &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>ch &lt;- 1 这个操作对应的 main goroutine 被阻塞，会放到 ch 的 sendq 中，之后的 &lt;-ch 会检查 ch 的 sendq，发现里面有元素，那么就将这个元素取出来，并将值拷贝给接收者 v，并唤醒 main goroutine ，让其不再是阻塞状态。</p><p>用过 chan 的同学都知道这是一个并发安全的数据结构，那么这里是如何实现的呢？其实也是加锁，chan 的底层有一个 mutex 锁来对其他字段进行保护。</p><p>此外，上面提到的发送和接收操作都是基于无缓存的 chan，如果是有缓存的 chan，那么流程会有所不同。</p><p>缓存（简称 buf）在底层其实是一个 <strong>环形队列</strong>，这是一个非常经典的数据结构，这里就不多阐述了，发送和接收的流程如下：</p><p><strong>发送</strong>：</p><ol><li>先看看 recvq 中有没有元素，有的话直接按照之前的操作，将数据拷贝给对应的接收者，就不需要经过缓存这一部分了</li><li>如果 recvq 中没有元素，则先检查缓存是否已满，则将数据拷贝到缓存中；如果缓存已满，那么将当前的 g 阻塞并放到 sendq 中</li></ol><p><strong>接收</strong>：</p><ol><li>如果 sendq 中有元素，此时又分为两种情况：<ol><li>无缓存 chan，直接取出 sendq 中的队头 g，并将 g 的数据拷贝给当前的接收者，并唤醒该 g</li><li>有缓存 chan，先从缓存中取出一个数据（通过 recvx 取出），并拷贝给接收者，此时缓存中相当于空了一个位置（环形队列，可以用覆盖值代替显式删除），所以可以取出 sendq 中的队头元素，放到这个空位里</li></ol></li><li>如果 sendq 为空：<ol><li>看缓存里有没有值，有的话则取出，并执行拷贝操作</li><li>缓存中没有值，将当前执行接收操作的 g 阻塞并放到 recvq 中</li></ol></li></ol><p>buf 底层是一个数组，通过两个变量 <code>sendx</code> 和 <code>recvx</code>  来完成 <strong>环形</strong> 的操作，通过下图来进行说明：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1656262263446.png"></p><h1 id="附：部分源码注释"><a href="#附：部分源码注释" class="headerlink" title="附：部分源码注释"></a>附：部分源码注释</h1><h2 id="hchan"><a href="#hchan" class="headerlink" title="hchan"></a>hchan</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// channel 的数据结构</span><br><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 环形队列（buf）中元素的个数</span><br>qcount <span class="hljs-type">uint</span> <span class="hljs-comment">// total data in the queue</span><br><br><span class="hljs-comment">// 环形队列容量，即可以存放的元素个数</span><br><span class="hljs-comment">// 即 make(chan int, 2) 的第二个参数，如果不指定则为 0</span><br>dataqsiz <span class="hljs-type">uint</span> <span class="hljs-comment">// size of the circular queue</span><br><br><span class="hljs-comment">// 指针，指向环形队列头节点</span><br>buf unsafe.Pointer <span class="hljs-comment">// points to an array of dataqsiz elements</span><br><br><span class="hljs-comment">// 队列中每个元素的大小</span><br>elemsize <span class="hljs-type">uint16</span><br><br><span class="hljs-comment">// chan 是否关闭</span><br>closed <span class="hljs-type">uint32</span><br><br><span class="hljs-comment">// 队列中的元素数据类型</span><br>elemtype *_type <span class="hljs-comment">// element type</span><br><br><span class="hljs-comment">// 队列已发送位置的索引</span><br>sendx <span class="hljs-type">uint</span> <span class="hljs-comment">// send index</span><br><br><span class="hljs-comment">// 队列已接收位置的索引</span><br>recvx <span class="hljs-type">uint</span> <span class="hljs-comment">// receive index</span><br><br><span class="hljs-comment">// sendq 和 recvq 存储了当前 Channel 由于缓冲区空间不足而阻塞的 Goroutine 列表，</span><br><span class="hljs-comment">// 这些等待队列使用双向链表 runtime.waitq 表示：</span><br><span class="hljs-comment">// type waitq struct &#123;</span><br><span class="hljs-comment">//first *sudog</span><br><span class="hljs-comment">//last  *sudog</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 链表中所有的元素都是 runtime.sudog 结构：</span><br><br><span class="hljs-comment">// 等待读消息的 goroutine 队列</span><br><span class="hljs-comment">// 存储试图从 channel 接收数据(&lt;-ch)的阻塞 goroutines</span><br>recvq waitq <span class="hljs-comment">// list of recv waiters</span><br><br><span class="hljs-comment">// 等待写消息的 goroutine 队列</span><br><span class="hljs-comment">// 存储试图发送数据(ch&lt;-)到 channel 的阻塞 goroutines</span><br>sendq waitq <span class="hljs-comment">// list of send waiters</span><br><br><span class="hljs-comment">// lock protects all fields in hchan, as well as several</span><br><span class="hljs-comment">// fields in sudogs blocked on this channel.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Do not change another G&#x27;s status while holding this lock</span><br><span class="hljs-comment">// (in particular, do not ready a G), as this can deadlock</span><br><span class="hljs-comment">// with stack shrinking.</span><br>lock mutex<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="chansend"><a href="#chansend" class="headerlink" title="chansend"></a>chansend</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 发送数据到 channel 时，直观的理解是将数据放到 chan 的环形队列中，不过 go 做了一些优化：</span><br><span class="hljs-comment">// 先判断是否有等待接收数据的 groutine，如果有，直接将数据发给 Groutine，唤醒 groutine，</span><br><span class="hljs-comment">// 就不放入队列中了。当然还有另外一种情况就是：buf 如果满了，那就只能放到队列中等待，直到有</span><br><span class="hljs-comment">// 数据被取走才能发送。</span><br><br><span class="hljs-comment">// 核心逻辑：</span><br><span class="hljs-comment">// 如果 recvq 不为空，从 recvq 中取出一个等待接收数据的 Groutine，将数据发送给该 Groutine</span><br><span class="hljs-comment">// 如果 recvq 为空，才将数据放入 buf 中</span><br><span class="hljs-comment">// 如果 buf 已满，则将要发送的数据和当前的 Groutine 打包成 Sudog 对象放入 sendq，</span><br><span class="hljs-comment">// 并将 groutine 置为等待状态</span><br><br><span class="hljs-comment">// ep    指向要发送数据的首地址</span><br><span class="hljs-comment">// c     chan</span><br><span class="hljs-comment">// block 是否阻塞</span><br><span class="hljs-comment">// callerpc 调用地址</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 比较迷惑的是这个 block 参数，block 是为了实现如下代码的语义：</span><br><span class="hljs-comment">// 因为加了 default，所以是非阻塞</span><br><span class="hljs-comment">// c := make(chan int)</span><br><span class="hljs-comment">//        // ...</span><br><span class="hljs-comment">//    select &#123;</span><br><span class="hljs-comment">//    case &lt;-c:</span><br><span class="hljs-comment">//        // ...</span><br><span class="hljs-comment">//    default:</span><br><span class="hljs-comment">//        // ...</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 上面这段代码被编译成对 selectnbsend 的调用：</span><br><span class="hljs-comment">// if selectnbsend(c, v) &#123;</span><br><span class="hljs-comment">//    ... foo</span><br><span class="hljs-comment">//&#125; else &#123;</span><br><span class="hljs-comment">//    ... bar</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// selectnbsend 的实现如下</span><br><span class="hljs-comment">// func selectnbsend(c *hchan, elem unsafe.Pointer) (selected bool) &#123;</span><br><span class="hljs-comment">// block 设置为 false</span><br><span class="hljs-comment">//    return chansend(c, elem, false, getcallerpc()) // 非阻塞的发送</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>, callerpc <span class="hljs-type">uintptr</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !block &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> debugChan &#123;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;chansend: chan=&quot;</span>, c, <span class="hljs-string">&quot;\n&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racereadpc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(chansend))<br>&#125;<br><br><span class="hljs-comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// After observing that the channel is not closed, we observe that the channel is</span><br><span class="hljs-comment">// not ready for sending. Each of these observations is a single word-sized read</span><br><span class="hljs-comment">// (first c.closed and second full()).</span><br><span class="hljs-comment">// Because a closed channel cannot transition from &#x27;ready for sending&#x27; to</span><br><span class="hljs-comment">// &#x27;not ready for sending&#x27;, even if the channel is closed between the two observations,</span><br><span class="hljs-comment">// they imply a moment between the two when the channel was both not yet closed</span><br><span class="hljs-comment">// and not ready for sending. We behave as if we observed the channel at that moment,</span><br><span class="hljs-comment">// and report that the send cannot proceed.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// It is okay if the reads are reordered here: if we observe that the channel is not</span><br><span class="hljs-comment">// ready for sending and then observe that it is not closed, that implies that the</span><br><span class="hljs-comment">// channel wasn&#x27;t closed during the first observation. However, nothing here</span><br><span class="hljs-comment">// guarantees forward progress. We rely on the side effects of lock release in</span><br><span class="hljs-comment">// chanrecv() and closechan() to update this thread&#x27;s view of c.closed and full().</span><br><span class="hljs-keyword">if</span> !block &amp;&amp; c.closed == <span class="hljs-number">0</span> &amp;&amp; full(c) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">var</span> t0 <span class="hljs-type">int64</span><br><span class="hljs-keyword">if</span> blockprofilerate &gt; <span class="hljs-number">0</span> &#123;<br>t0 = cputicks()<br>&#125;<br><br><span class="hljs-comment">// 加锁</span><br>lock(&amp;c.lock)<br><br><span class="hljs-comment">// 如果向已关闭的 channel 中发送数据，会引发 panic</span><br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;send on closed channel&quot;</span>))<br>&#125;<br><br><span class="hljs-comment">// blog1. 从接收队列中（存放等待接收的 goroutine）取出 goroutine，</span><br><span class="hljs-comment">// 如果取到数据，就将数据传过去</span><br><br><span class="hljs-comment">// blog3. 如果目标 Channel 没有被关闭并且已经有处于读等待的 Goroutine，</span><br><span class="hljs-comment">// 那么 runtime.chansend 会从接收队列 recvq 中取出最先陷入等待的 Goroutine</span><br><span class="hljs-comment">// 并直接向它发送数据：</span><br><br><span class="hljs-comment">// 如果 recvq 不为空，从 recvq 中取出一个等待接收数据的 Groutine，将数据发送给该 Groutine</span><br><span class="hljs-keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// Found a waiting receiver. We pass the value we want to send</span><br><span class="hljs-comment">// directly to the receiver, bypassing the channel buffer (if any).</span><br><span class="hljs-comment">// 找到一个等待的接收者。我们将要发送的值直接传递给接收者，绕过 chan buf（如果有）</span><br>send(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// 返回</span><br>&#125;<br><br><span class="hljs-comment">// 到这里说明 recvq 为空，没有等待接收的 goroutine，此时会判断 hchan.buf 是否可用</span><br><span class="hljs-comment">// 对于有缓冲的 channel 来说，如果当前缓冲区 hchan.buf 有可用空间，那么会将数据拷贝至缓冲区</span><br><span class="hljs-comment">// 如果用户使用的是无缓冲 channel，则 c.dataqsiz = 0，不满足 c.qcount &lt; c.dataqsiz 条件</span><br><span class="hljs-keyword">if</span> c.qcount &lt; c.dataqsiz &#123;<br><span class="hljs-comment">// c.sendx 是已发送的索引位置，这个方法通过指针偏移找到索引位置</span><br><span class="hljs-comment">// 相当于 c.buf[c.sendx]</span><br><span class="hljs-comment">// 计算出下一个可以存储数据的位置</span><br><span class="hljs-comment">// Space is available in the channel buffer. Enqueue the element to send.</span><br>qp := chanbuf(c, c.sendx)<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racenotify(c, c.sendx, <span class="hljs-literal">nil</span>)<br>&#125;<br><br><span class="hljs-comment">// typememmove 会调用 memmove 方法，完成数据的拷贝工作，是用汇编实现的</span><br><span class="hljs-comment">// 将要发送的数据拷贝到 buf 中</span><br>typedmemmove(c.elemtype, qp, ep)<br><span class="hljs-comment">// 发送索引号 + 1</span><br>c.sendx++<br><span class="hljs-comment">// 因为存储数据元素的结构是循环队列，所以当当前索引号已经到队末时，将索引号调整到队头</span><br><span class="hljs-keyword">if</span> c.sendx == c.dataqsiz &#123;<br>c.sendx = <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-comment">// 当前循环队列中存储元素数 + 1</span><br>c.qcount++<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// 走到这里，说明缓冲区也写满了</span><br><span class="hljs-comment">// 对于非阻塞的情况，直接返回</span><br><span class="hljs-keyword">if</span> !block &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 代码执行到这里，意味着：</span><br><span class="hljs-comment">// 1. 如果是有缓冲的 channel，则当前 hchan.buf 已满；</span><br><span class="hljs-comment">// 2. 如果是无缓冲的 channel，则当前没有接收的 goroutine</span><br><span class="hljs-comment">// 此时会将当前发送 goroutine 置于 sendq 中排队，并在运行时中挂起。</span><br><span class="hljs-comment">// Block on the channel. Some receiver will complete our operation for us.</span><br>gp := getg() <span class="hljs-comment">// 获取当前执行的 goroutine</span><br><br><span class="hljs-comment">// 执行 runtime.acquireSudog 获取 runtime.sudog 结构并设置这一次阻塞发送的相关信息，</span><br><span class="hljs-comment">// 例如发送的 Channel、是否在 select 中和待发送数据的内存地址等</span><br>mysg := acquireSudog()<br>mysg.releasetime = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> t0 != <span class="hljs-number">0</span> &#123;<br>mysg.releasetime = <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-comment">// No stack splits between assigning elem and enqueuing mysg</span><br><span class="hljs-comment">// on gp.waiting where copystack can find it.</span><br>mysg.elem = ep<br>mysg.waitlink = <span class="hljs-literal">nil</span><br>mysg.g = gp<br>mysg.isSelect = <span class="hljs-literal">false</span><br>mysg.c = c<br>gp.waiting = mysg<br>gp.param = <span class="hljs-literal">nil</span><br><br><span class="hljs-comment">// 将要发送的数据和当前 goroutine 打包成 sudog 对象放入到 sendq 中</span><br>c.sendq.enqueue(mysg)<br><span class="hljs-comment">// Signal to anyone trying to shrink our stack that we&#x27;re about</span><br><span class="hljs-comment">// to park on a channel. The window between when this G&#x27;s status</span><br><span class="hljs-comment">// changes and when we set gp.activeStackChans is not safe for</span><br><span class="hljs-comment">// stack shrinking.</span><br>atomic.Store8(&amp;gp.parkingOnChan, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// gopark 将当前 goroutine 转为 waiting 态</span><br><span class="hljs-comment">// 在用户看来，向 channel 发送数据的代码语句会阻塞</span><br>gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// Ensure the value being sent is kept alive until the</span><br><span class="hljs-comment">// receiver copies it out. The sudog has a pointer to the</span><br><span class="hljs-comment">// stack object, but sudogs aren&#x27;t considered as roots of the</span><br><span class="hljs-comment">// stack tracer.</span><br>KeepAlive(ep)<br><br><span class="hljs-comment">// someone woke us up.</span><br><span class="hljs-keyword">if</span> mysg != gp.waiting &#123;<br>throw(<span class="hljs-string">&quot;G waiting list is corrupted&quot;</span>)<br>&#125;<br>gp.waiting = <span class="hljs-literal">nil</span><br>gp.activeStackChans = <span class="hljs-literal">false</span><br>closed := !mysg.success<br>gp.param = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> mysg.releasetime &gt; <span class="hljs-number">0</span> &#123;<br>blockevent(mysg.releasetime-t0, <span class="hljs-number">2</span>)<br>&#125;<br>mysg.c = <span class="hljs-literal">nil</span><br>releaseSudog(mysg)<br><span class="hljs-keyword">if</span> closed &#123;<br><span class="hljs-keyword">if</span> c.closed == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;chansend: spurious wakeup&quot;</span>)<br>&#125;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;send on closed channel&quot;</span>))<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="send"><a href="#send" class="headerlink" title="send"></a>send</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// send processes a send operation on an empty channel c.</span><br><span class="hljs-comment">// The value ep sent by the sender is copied to the receiver sg.</span><br><span class="hljs-comment">// The receiver is then woken up to go on its merry way.</span><br><span class="hljs-comment">// Channel c must be empty and locked.  send unlocks c with unlockf.</span><br><span class="hljs-comment">// sg must already be dequeued from c.</span><br><span class="hljs-comment">// ep must be non-nil and point to the heap or the caller&#x27;s stack.</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// send 在 recvq 不为空时调用，sg 就是从 recvq 中取出的</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">send</span><span class="hljs-params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="hljs-keyword">func</span>()</span></span>, skip <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br><span class="hljs-keyword">if</span> c.dataqsiz == <span class="hljs-number">0</span> &#123;<br>racesync(c, sg)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Pretend we go through the buffer, even though</span><br><span class="hljs-comment">// we copy directly. Note that we need to increment</span><br><span class="hljs-comment">// the head/tail locations only when raceenabled.</span><br>racenotify(c, c.recvx, <span class="hljs-literal">nil</span>)<br>racenotify(c, c.recvx, sg)<br>c.recvx++<br><span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>c.recvx = <span class="hljs-number">0</span><br>&#125;<br>c.sendx = c.recvx <span class="hljs-comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> sg.elem != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// ep -&gt; sg</span><br>sendDirect(c.elemtype, sg, ep)<br>sg.elem = <span class="hljs-literal">nil</span><br>&#125;<br>gp := sg.g<br>unlockf()<br>gp.param = unsafe.Pointer(sg)<br>sg.success = <span class="hljs-literal">true</span><br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br><br><span class="hljs-comment">// 使得之前在接收等待队列中的第一个 goroutine 的状态变为 runnable，</span><br><span class="hljs-comment">// 这样 go 的调度器就可以重新让该 goroutine 得到执行。</span><br>goready(gp, skip+<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="chanrecv"><a href="#chanrecv" class="headerlink" title="chanrecv"></a>chanrecv</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// chanrecv receives on channel c and writes the received data to ep.</span><br><span class="hljs-comment">// ep may be nil, in which case received data is ignored.</span><br><span class="hljs-comment">// If block == false and no elements are available, returns (false, false).</span><br><span class="hljs-comment">// Otherwise, if c is closed, zeros *ep and returns (true, false).</span><br><span class="hljs-comment">// Otherwise, fills in *ep with an element and returns (true, true).</span><br><span class="hljs-comment">// A non-nil ep must point to the heap or the caller&#x27;s stack.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 在通道 c 上接收并将接收到的数据写入 ep，ep 可能为 nil，在这种情况下，接收到的数据会被忽略，</span><br><span class="hljs-comment">// 如果 block == false 并且没有可用的元素，则返回 (false, false)，</span><br><span class="hljs-comment">// 否则，如果 c 关闭，则将 ep 清零并返回 (true, false)。</span><br><span class="hljs-comment">// 否则，用一个元素填充 ep 并返回 (true, true)。</span><br><span class="hljs-comment">// 非 nil ep 必须指向堆或调用者的堆栈。</span><br><span class="hljs-comment">// block 貌似是用于 select</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>)</span></span> (selected, received <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-comment">// raceenabled: don&#x27;t need to check ep, as it is always on the stack</span><br><span class="hljs-comment">// or is new memory allocated by reflect.</span><br><br><span class="hljs-keyword">if</span> debugChan &#123;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;chanrecv: chan=&quot;</span>, c, <span class="hljs-string">&quot;\n&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 如果 c 为空且是非阻塞调用，那么直接返回 (false,false)</span><br><span class="hljs-keyword">if</span> !block &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 阻塞调用直接等待</span><br>gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span><br><span class="hljs-keyword">if</span> !block &amp;&amp; empty(c) &#123;<br><span class="hljs-comment">// After observing that the channel is not ready for receiving, we observe whether the</span><br><span class="hljs-comment">// channel is closed.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Reordering of these checks could lead to incorrect behavior when racing with a close.</span><br><span class="hljs-comment">// For example, if the channel was open and not empty, was closed, and then drained,</span><br><span class="hljs-comment">// reordered reads could incorrectly indicate &quot;open and empty&quot;. To prevent reordering,</span><br><span class="hljs-comment">// we use atomic loads for both checks, and rely on emptying and closing to happen in</span><br><span class="hljs-comment">// separate critical sections under the same lock.  This assumption fails when closing</span><br><span class="hljs-comment">// an unbuffered channel with a blocked send, but that is an error condition anyway.</span><br><span class="hljs-keyword">if</span> atomic.Load(&amp;c.closed) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Because a channel cannot be reopened, the later observation of the channel</span><br><span class="hljs-comment">// being not closed implies that it was also not closed at the moment of the</span><br><span class="hljs-comment">// first observation. We behave as if we observed the channel at that moment</span><br><span class="hljs-comment">// and report that the receive cannot proceed.</span><br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// The channel is irreversibly closed. Re-check whether the channel has any pending data</span><br><span class="hljs-comment">// to receive, which could have arrived between the empty and closed checks above.</span><br><span class="hljs-comment">// Sequential consistency is also required here, when racing with such a send.</span><br><span class="hljs-keyword">if</span> empty(c) &#123;<br><span class="hljs-comment">// The channel is irreversibly closed and empty.</span><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquire(c.raceaddr())<br>&#125;<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, ep)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> t0 <span class="hljs-type">int64</span><br><span class="hljs-keyword">if</span> blockprofilerate &gt; <span class="hljs-number">0</span> &#123;<br>t0 = cputicks()<br>&#125;<br><br>lock(&amp;c.lock)<br><br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &amp;&amp; c.qcount == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquire(c.raceaddr())<br>&#125;<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, ep)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 如果 sendq 中有 goroutine，则取出一个，将数据发送给它</span><br><span class="hljs-keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// Found a waiting sender. If buffer is size 0, receive value</span><br><span class="hljs-comment">// directly from sender. Otherwise, receive from head of queue</span><br><span class="hljs-comment">// and add sender&#x27;s value to the tail of the queue (both map to</span><br><span class="hljs-comment">// the same buffer slot because the queue is full).</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果是无缓冲 chan，则直接从 sg 中接收数据，</span><br><span class="hljs-comment">// 如果是有缓冲 chan，则接收 buf 中第一个元素的数据，并将 sg 中的数据放到 buf 的末尾</span><br>recv(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// 到这里说明 sendq 中没有等待的 goroutine</span><br><br><span class="hljs-comment">// 如果缓冲区中有数据，那么就从 buf 中获取</span><br><span class="hljs-keyword">if</span> c.qcount &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Receive directly from queue</span><br>qp := chanbuf(c, c.recvx)<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racenotify(c, c.recvx, <span class="hljs-literal">nil</span>)<br>&#125;<br><span class="hljs-comment">// 从缓冲区复制数据到 ep</span><br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemmove(c.elemtype, ep, qp)<br>&#125;<br><span class="hljs-comment">// typedmemclr 的作用是将 ep 指向的类型为 elemtype 的内存块置为 0 值。</span><br><span class="hljs-comment">// 这里就是将 buf[recvx] 置为 0，因为这里的元素已经拷贝给了 ep</span><br>typedmemclr(c.elemtype, qp)<br>c.recvx++<br><span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>c.recvx = <span class="hljs-number">0</span><br>&#125;<br>c.qcount--<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// 非阻塞，直接返回</span><br><span class="hljs-keyword">if</span> !block &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 到这里说明即没有等待的 groutine，环形队列中也没有数据，则阻塞该 groutine，</span><br><span class="hljs-comment">// 并将 goroutine 打包为 sudog 加入到 recevq 等待队列中</span><br><span class="hljs-comment">// no sender available: block on this channel.</span><br>gp := getg()<br><span class="hljs-comment">// 创建 sudog</span><br>mysg := acquireSudog()<br>mysg.releasetime = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> t0 != <span class="hljs-number">0</span> &#123;<br>mysg.releasetime = <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-comment">// No stack splits between assigning elem and enqueuing mysg</span><br><span class="hljs-comment">// on gp.waiting where copystack can find it.</span><br>mysg.elem = ep<br>mysg.waitlink = <span class="hljs-literal">nil</span><br>gp.waiting = mysg<br>mysg.g = gp<br>mysg.isSelect = <span class="hljs-literal">false</span><br>mysg.c = c<br>gp.param = <span class="hljs-literal">nil</span><br>c.recvq.enqueue(mysg)<br><span class="hljs-comment">// Signal to anyone trying to shrink our stack that we&#x27;re about</span><br><span class="hljs-comment">// to park on a channel. The window between when this G&#x27;s status</span><br><span class="hljs-comment">// changes and when we set gp.activeStackChans is not safe for</span><br><span class="hljs-comment">// stack shrinking.</span><br>atomic.Store8(&amp;gp.parkingOnChan, <span class="hljs-number">1</span>)<br>gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// someone woke us up</span><br><span class="hljs-keyword">if</span> mysg != gp.waiting &#123;<br>throw(<span class="hljs-string">&quot;G waiting list is corrupted&quot;</span>)<br>&#125;<br>gp.waiting = <span class="hljs-literal">nil</span><br>gp.activeStackChans = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> mysg.releasetime &gt; <span class="hljs-number">0</span> &#123;<br>blockevent(mysg.releasetime-t0, <span class="hljs-number">2</span>)<br>&#125;<br>success := mysg.success<br>gp.param = <span class="hljs-literal">nil</span><br>mysg.c = <span class="hljs-literal">nil</span><br>releaseSudog(mysg)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, success<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// recv processes a receive operation on a full channel c.</span><br><span class="hljs-comment">// There are 2 parts:</span><br><span class="hljs-comment">// 1) The value sent by the sender sg is put into the channel</span><br><span class="hljs-comment">//    and the sender is woken up to go on its merry way.</span><br><span class="hljs-comment">// 2) The value received by the receiver (the current G) is</span><br><span class="hljs-comment">//    written to ep.</span><br><span class="hljs-comment">// For synchronous channels, both values are the same.</span><br><span class="hljs-comment">// For asynchronous channels, the receiver gets its data from</span><br><span class="hljs-comment">// the channel buffer and the sender&#x27;s data is put in the</span><br><span class="hljs-comment">// channel buffer.</span><br><span class="hljs-comment">// Channel c must be full and locked. recv unlocks c with unlockf.</span><br><span class="hljs-comment">// sg must already be dequeued from c.</span><br><span class="hljs-comment">// A non-nil ep must point to the heap or the caller&#x27;s stack.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// recv 被 chanrecv() 调用，调用条件是 sendq 中有等待的 g</span><br><span class="hljs-comment">// c: chan</span><br><span class="hljs-comment">// sg: sendq 中的等待 goroutine</span><br><span class="hljs-comment">// ep: 用来接收数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recv</span><span class="hljs-params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="hljs-keyword">func</span>()</span></span>, skip <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">// 如果是无缓冲区 chan</span><br><span class="hljs-keyword">if</span> c.dataqsiz == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racesync(c, sg)<br>&#125;<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// copy data from sender</span><br><span class="hljs-comment">// 将 sg（sendq 中的对象）中的数据拷贝到 ep 中</span><br>recvDirect(c.elemtype, sg, ep)<br>&#125;<br><span class="hljs-comment">// 有缓冲区chan</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Queue is full. Take the item at the</span><br><span class="hljs-comment">// head of the queue. Make the sender enqueue</span><br><span class="hljs-comment">// its item at the tail of the queue. Since the</span><br><span class="hljs-comment">// queue is full, those are both the same slot.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 由于有发送者在等待，所以缓冲区一定是满的，因为 recv 的第二个参数 sudog</span><br><span class="hljs-comment">// 传入的是被阻塞的发送者，在 chanrecv 中的表现是：</span><br><span class="hljs-comment">// if sg := c.sendq.dequeue(); sg != nil &#123;</span><br><span class="hljs-comment">// recv(c, sg, ep, func() &#123; unlock(&amp;c.lock) &#125;, 3)</span><br><span class="hljs-comment">//return true, true</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">//</span><br>qp := chanbuf(c, c.recvx)<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racenotify(c, c.recvx, <span class="hljs-literal">nil</span>)<br>racenotify(c, c.recvx, sg)<br>&#125;<br><span class="hljs-comment">// copy data from queue to receiver</span><br><span class="hljs-comment">// 先将 buf 中的第一个数据（recvx）移动到 ep</span><br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemmove(c.elemtype, ep, qp)<br>&#125;<br><span class="hljs-comment">// copy data from sender to queue</span><br><span class="hljs-comment">// 因为已经将 buf 中的一个数据拷贝给 ep 了，等于此时的 ep 已经空了一个</span><br><span class="hljs-comment">// 位置了，所以可以将 sudog 中的元素放到这个空位置里</span><br><span class="hljs-comment">// 下面的逻辑也没有对 c.qcount 进行更新，因为移除了一个后又新添加了一个,</span><br><span class="hljs-comment">// 相当于长度没有发生改变</span><br>typedmemmove(c.elemtype, qp, sg.elem)<br>c.recvx++<br><span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>c.recvx = <span class="hljs-number">0</span><br>&#125;<br>c.sendx = c.recvx <span class="hljs-comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span><br>&#125;<br>sg.elem = <span class="hljs-literal">nil</span><br>gp := sg.g<br>unlockf()<br>gp.param = unsafe.Pointer(sg)<br>sg.success = <span class="hljs-literal">true</span><br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br>goready(gp, skip+<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>127.0.0.1，localhost，0.0.0.0 的区别（包含虚拟网卡相关操作）</title>
    <link href="/2022/06/24/127.0.0.1_localhost_0.0.0.0/"/>
    <url>/2022/06/24/127.0.0.1_localhost_0.0.0.0/</url>
    
    <content type="html"><![CDATA[<h1 id="127-0-0-1"><a href="#127-0-0-1" class="headerlink" title="127.0.0.1"></a>127.0.0.1</h1><p><code>127.0.0.1</code> 是 <strong>回环地址</strong>，当报文的目的地址是回环地址时，依然会走一遍网络协议栈，但是不会经过物理网卡，而是经过一个名为 lo 的虚拟网卡（mac 上交 lo0），具体的流程是：</p><p>从应用层到传输层再到网络层，到了网络层，系统会根据目的IP，在路由表中获取对应的<strong>路由信息</strong>，而这其中就包含选择<strong>哪个网卡</strong>把消息发出。</p><p>当发现 <strong>目标IP是外网IP</strong> 时，会从”真网卡”发出。</p><p>当发现 <strong>目标IP是回环地址</strong> 时，就会选择 <strong>本地网卡</strong>。</p><p>本地网卡，其实就是个”<strong>假网卡</strong>“，它不像”真网卡”那样有个<code>ring buffer</code>什么的，”假网卡”会把数据推到一个叫 <code>input_pkt_queue</code> 的 <strong>链表</strong> 中。这个链表，其实是所有网卡共享的，上面挂着发给本机的各种消息。消息被发送到这个链表后，会再触发一个 <strong>软中断</strong>。</p><p>专门处理软中断的工具人”<strong>ksoftirqd</strong>“ （这是个<strong>内核线程</strong>），它在收到软中断后就会立马去链表里把消息取出，然后顺着数据链路层、网络层等层层往上传递最后给到应用程序。</p><p><strong>之所以把 127.0.0.1 叫本地回环地址，可以理解为，消息发出到这个地址上的话，就不会出网络，而是在本机打个转就又回来了</strong>。所以即便断网，也依然能 <code>ping</code> 通 <code>127.0.0.1</code>。</p><p>以上内容摘自：</p><p>硬核图解！断网了，还能ping通 127.0.0.1 吗？为什么？<a href="https://www.eet-china.com/mp/a67490.html">https://www.eet-china.com/mp/a67490.html</a></p><blockquote><p>问题记录：</p><p>ping 127.0.0.1 走不走物理网卡？</p><p>网上的博客有说走的（<a href="https://blog.csdn.net/bandaoyu/article/details/87259631%EF%BC%8C">https://blog.csdn.net/bandaoyu/article/details/87259631，</a> 127.0.0.1 回环地址，不经过[链路层，<a href="https://so.csdn.net/so/search?q=%E7%89%A9%E7%90%86%E5%B1%82&spm=1001.2101.3001.7020">物理层</a>](网络接口层），在IP层就回去，依赖网卡，并受到网络防火墙和网卡相关的限制），也有说不走的，这时只能自己动手测试了，刚好有台闲置的 windows 笔记本可以拿来测试，执行 <code>netsh interface set interface wlan diable</code> 来关闭网卡，此时执行 <code>ping 127.0.0.1</code>，发现是可以 ping 通的，说明 127.0.0.1 是不走物理网卡的，但是会走 lo 虚拟网卡</p><p><a href="https://www.zhihu.com/question/43590414">https://www.zhihu.com/question/43590414</a></p></blockquote><h1 id="localhost"><a href="#localhost" class="headerlink" title="localhost"></a>localhost</h1><p>localhost是个 <strong>域名</strong> ，而不是一个 ip 地址。之所以我们经常把 localhost 与 127.0.0.1 认为是同一个东西，是因为我们使用的大多数电脑上都将 localhost 指向了 127.0.0.1 这个地址，在 linux 中这个文件的位置是 &#x2F;etc&#x2F;hosts ： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /etc/hosts</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Your system has configured <span class="hljs-string">&#x27;manage_etc_hosts&#x27;</span> as True.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">As a result, <span class="hljs-keyword">if</span> you wish <span class="hljs-keyword">for</span> changes to this file to persist</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">then</span> you will need to either</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">a.) make changes to the master file <span class="hljs-keyword">in</span> /etc/cloud/templates/hosts.debian.tmpl</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">b.) change or remove the value of <span class="hljs-string">&#x27;manage_etc_hosts&#x27;</span> <span class="hljs-keyword">in</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">    /etc/cloud/cloud.cfg or cloud-config from user-data</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash">127.0.1.1 primary primary</span><br>127.0.0.1 localhost<br></code></pre></td></tr></table></figure><h1 id="0-0-0-0"><a href="#0-0-0-0" class="headerlink" title="0.0.0.0"></a>0.0.0.0</h1><p><code>0.0.0.0</code> 可以作为监听地址使用，代表监听本机的所有 IP 地址（如果一台机器上有多个网卡，就会有多个 IP 地址），可以做一个实践测试一下：</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>创建一块虚拟网卡（在虚拟机上）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ifconfig enp0s1:0 192.168.64.8 up</span><br></code></pre></td></tr></table></figure><p>语句格式是：ifconfig [现有网卡名称]:[任意值,也可以为空] [虚拟网卡的 IP] up</p><p>按照上面的格式，继续创建多块虚拟网卡：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ifconfig enp0s1: 192.168.64.9 up</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ifconfig enp0s1:__ 192.168.64.10 up</span><br></code></pre></td></tr></table></figure><p>查看现在的网卡情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ifconfig</span><br>enp0s1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 192.168.64.7  netmask 255.255.255.0  broadcast 192.168.64.255<br>        inet6 fe80::5054:ff:fe97:e2bd  prefixlen 64  scopeid 0x20&lt;link&gt;<br>        inet6 fd02:feab:6557:b7c6:5054:ff:fe97:e2bd  prefixlen 64  scopeid 0x0&lt;global&gt;<br>        ether 52:54:00:97:e2:bd  txqueuelen 1000  (Ethernet)<br>        RX packets 45586  bytes 61327352 (61.3 MB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 27086  bytes 2915213 (2.9 MB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>enp0s1:0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 192.168.64.8  netmask 255.255.255.0  broadcast 192.168.64.255<br>        ether 52:54:00:97:e2:bd  txqueuelen 1000  (Ethernet)<br><br>enp0s1:: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 192.168.64.9  netmask 255.255.255.0  broadcast 192.168.64.255<br>        ether 52:54:00:97:e2:bd  txqueuelen 1000  (Ethernet)<br><br>enp0s1:__: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 192.168.64.10  netmask 255.255.255.0  broadcast 192.168.64.255<br>        ether 52:54:00:97:e2:bd  txqueuelen 1000  (Ethernet)<br></code></pre></td></tr></table></figure><p>用 Go 写一个 TCP server 进行测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">&quot;net&quot;</span><br>        <span class="hljs-string">&quot;fmt&quot;</span><br>        <span class="hljs-string">&quot;flag&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> host = flag.String(<span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;listen host&quot;</span>)<br><span class="hljs-keyword">var</span> port = flag.String(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>, <span class="hljs-string">&quot;listen port&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        flag.Parse()<br>        addr := fmt.Sprintf(<span class="hljs-string">&quot;%v:%v&quot;</span>, *host, *port)<br>        l, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, addr)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>        fmt.Printf(<span class="hljs-string">&quot;listen in %v\n&quot;</span>, addr)<br>        <span class="hljs-keyword">for</span> &#123;<br>                conn, err := l.Accept()<br>                <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                        fmt.Println(<span class="hljs-string">&quot;accept error: &quot;</span>, err)<br>                        <span class="hljs-keyword">continue</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> _, err := conn.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello\n&quot;</span>)); err != <span class="hljs-literal">nil</span> &#123;<br>                        fmt.Println(<span class="hljs-string">&quot;write error: &quot;</span>, err)<br>                        <span class="hljs-keyword">continue</span><br>                &#125;<br>                conn.Close()<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行程序（虚拟机上）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run hello_tcpserver.go -h 0.0.0.0</span><br>listen in 0.0.0.0:8080<br></code></pre></td></tr></table></figure><p>在 <strong>宿主机</strong> 上测试一下效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">nc 192.168.64.7 8080</span><br>Hello<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">nc 192.168.64.8 8080</span><br>Hello<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">nc 192.168.64.9 8080</span><br>Hello<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">nc 192.168.64.10 8080</span><br>Hello<br></code></pre></td></tr></table></figure><p>发现使用任意一个 IP 地址都可以访问到服务</p><p>此外，有的博客里说 <code>0.0.0.0</code> 是 ping 不通的，但是在我的虚拟机上却并非如此：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">uname</span> -a</span><br>Linux primary 5.4.0-120-generic #136-Ubuntu SMP Fri Jun 10 13:46:10 UTC 2022 aarch64 aarch64 aarch64 GNU/Linux<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ping 0.0.0.0</span><br>PING 0.0.0.0 (127.0.0.1) 56(84) bytes of data.<br>64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.299 ms<br>64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.091 ms<br>64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.076 ms<br>64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.108 ms<br>^C<br>--- 0.0.0.0 ping statistics ---<br>4 packets transmitted, 4 received, 0% packet loss, time 3244ms<br>rtt min/avg/max/mdev = 0.076/0.143/0.299/0.090 ms<br></code></pre></td></tr></table></figure><p>不知道什么情况</p><blockquote><p>监听 127.0.0.1 和 监听 0.0.0.0 有什么区别？</p><p>监听 127.0.0.1 的话就只能在本地访问了，外部是无法访问的，localhost 当然也是一样的</p><p>测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run hello_tcpserver.go -h localhost</span><br>listen in localhost:8080<br></code></pre></td></tr></table></figure><p>在宿主机上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">nc -v 192.168.64.9 8080</span><br>nc: connectx to 192.168.64.9 port 8080 (tcp) failed: Connection refused<br></code></pre></td></tr></table></figure><p>说到这里又让我想起了一件事：之前我部署过一个 Go HTTP 小程序到腾讯云服务器上，当时 listen 的地址就是 localhost，但是从外部依然能够访问到该服务，貌似是因为当时是用 docker 部署的，做了端口映射，所以才可以访问到</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go 熔断器 gobreaker 源码阅读</title>
    <link href="/2022/06/11/gobreaker/"/>
    <url>/2022/06/11/gobreaker/</url>
    
    <content type="html"><![CDATA[<blockquote><p>该文章仅作为本人笔记，不具备太大的参考价值</p><p>该文章着重记录源码，没有对熔断器这一概念做过多理念上的说明解释</p><p>该文章排版、思路较为混乱，后续可能会进行修改</p></blockquote><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h2><p>官方示例有点太简单了，完全无法体会到 <strong>熔断</strong> 这一概念</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-string">&quot;github.com/sony/gobreaker&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> cb *gobreaker.CircuitBreaker<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> st gobreaker.Settings<br>st.Name = <span class="hljs-string">&quot;HTTP GET&quot;</span><br>st.ReadyToTrip = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(counts gobreaker.Counts)</span></span> <span class="hljs-type">bool</span> &#123;<br>failureRatio := <span class="hljs-type">float64</span>(counts.TotalFailures) / <span class="hljs-type">float64</span>(counts.Requests)<br><span class="hljs-keyword">return</span> counts.Requests &gt;= <span class="hljs-number">3</span> &amp;&amp; failureRatio &gt;= <span class="hljs-number">0.6</span><br>&#125;<br><br>cb = gobreaker.NewCircuitBreaker(st)<br>&#125;<br><br><span class="hljs-comment">// Get wraps http.Get in CircuitBreaker.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Get</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>body, err := cb.Execute(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">defer</span> resp.Body.Close()<br>body, err := ioutil.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> body, <span class="hljs-literal">nil</span><br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> body.([]<span class="hljs-type">byte</span>), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>body, err := Get(<span class="hljs-string">&quot;http://www.google.com/robots.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br>fmt.Println(<span class="hljs-type">string</span>(body))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="我的示例"><a href="#我的示例" class="headerlink" title="我的示例"></a>我的示例</h2><p>先写一个 http server，他会随机为请求返回 200 或者 500</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> canVisit <span class="hljs-type">bool</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>rand.Seed(time.Now().Unix())<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>t := rand.Int63n(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-time.After(time.Duration(t) * time.Second):<br>canVisit = !canVisit<br>&#125;<br>&#125;<br>&#125;()<br><br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-keyword">if</span> canVisit &#123;<br>w.WriteHeader(http.StatusInternalServerError)<br>w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;server error&quot;</span>))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>w.WriteHeader(http.StatusOK)<br>w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;success&quot;</span>))<br>&#125;<br>&#125;)<br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:9000&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>熔断器程序，会一直访问上面的 http server，返回 200 算请求成功，500 算失败，来观察熔断器的状态和效果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;github.com/sony/gobreaker&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> cb *gobreaker.CircuitBreaker<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> st gobreaker.Settings<br>st.Name = <span class="hljs-string">&quot;HTTP GET&quot;</span><br>st.ReadyToTrip = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(counts gobreaker.Counts)</span></span> <span class="hljs-type">bool</span> &#123;<br>failureRatio := <span class="hljs-type">float64</span>(counts.TotalFailures) / <span class="hljs-type">float64</span>(counts.Requests)<br><span class="hljs-keyword">return</span> counts.Requests &gt;= <span class="hljs-number">3</span> &amp;&amp; failureRatio &gt;= <span class="hljs-number">0.5</span><br>&#125;<br>st.Timeout = time.Second * <span class="hljs-number">10</span><span class="hljs-comment">// 从开启切换到半开的时间</span><br>st.OnStateChange = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(name <span class="hljs-type">string</span>, from, to gobreaker.State)</span></span> &#123;<br>log.Printf(<span class="hljs-string">&quot;state change: [%v] -&gt; [%v]\n&quot;</span>, from, to)<br>&#125;<br>cb = gobreaker.NewCircuitBreaker(st)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Get</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>body, err := cb.Execute(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><span class="hljs-keyword">if</span> resp.StatusCode &gt;= <span class="hljs-number">400</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;[%v]%v&quot;</span>, resp.StatusCode, http.StatusText(resp.StatusCode))<br>&#125;<br>body, err := ioutil.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> body, <span class="hljs-literal">nil</span><br>&#125;)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> body.([]<span class="hljs-type">byte</span>), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>body, err := Get(<span class="hljs-string">&quot;http://localhost:9000&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;%v, %+v\n&quot;</span>, cb.State(), cb.Counts())<br>fmt.Println(<span class="hljs-type">string</span>(body))<br>time.Sleep(time.Millisecond * <span class="hljs-number">500</span>)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">2022/06/10 22:02:36 closed, &#123;Requests:1 TotalSuccesses:1 TotalFailures:0 ConsecutiveSuccesses:1 ConsecutiveFailures:0&#125;<br>....<br><br>2022/06/10 22:03:26 [500]Internal Server Error<br>2022/06/10 22:03:26 closed, &#123;Requests:101 TotalSuccesses:51 TotalFailures:50 ConsecutiveSuccesses:0 ConsecutiveFailures:8&#125;<br><br>2022/06/10 22:03:26 state change: [closed] -&gt; [open]<br>2022/06/10 22:03:26 [500]Internal Server Error<br>2022/06/10 22:03:26 open, &#123;Requests:0 TotalSuccesses:0 TotalFailures:0 ConsecutiveSuccesses:0 ConsecutiveFailures:0&#125;<br></code></pre></td></tr></table></figure><p>第二段日志记录了错误，此时的总请求次数是 101，总错误是 50，还没达到 ReadyToTrip 的条件（错误率 &gt;&#x3D; 50%），然后第三段日志，发现此时请求依然失败，此时总请求 102，总错误 51，达到了 50%，所以发生了状态转换，熔断器进行开启模式。</p><p>后续应该会一直保持开启状态，直到 10s 后切换为半开状态，这里日志就没记录了。</p><h1 id="熔断器的-3-种状态"><a href="#熔断器的-3-种状态" class="headerlink" title="熔断器的 3 种状态"></a>熔断器的 3 种状态</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// State is a type that represents a state of CircuitBreaker.</span><br><span class="hljs-keyword">type</span> State <span class="hljs-type">int</span><br><br><span class="hljs-comment">// These constants are states of CircuitBreaker.</span><br><span class="hljs-comment">// 熔断器的状态</span><br><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">// StateClosed 表示关闭状态，此时所有请求都会通过</span><br>StateClosed State = <span class="hljs-literal">iota</span><br><span class="hljs-comment">// StateHalfOpen 半开状态，会根据情况变更为开启或者关闭状态</span><br>StateHalfOpen<br><span class="hljs-comment">// StateOpen 开启状态，此时会拒绝所有请求</span><br>StateOpen<br>)<br></code></pre></td></tr></table></figure><p>熔断器有三种状态：</p><ul><li>开启：所有请求都会拒绝</li><li>关闭：所有请求都会通过</li><li>半开启：开启状态自然不能一直维持，需要某个条件将其切换到一种中间状态：也就是这里的半开启状态。当开启状态持续了一段时间后，就会变更为半开启状态，表示可以做试探了，如果此时请求依然失败，则变更为开启状态；如果成功次数达到了我们的需求，则变更为关闭状态</li></ul><h1 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h1><p>计数器保存了熔断器的所有信息，具体属性如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Counts 保存请求的数量及其成功失败的次数。</span><br><span class="hljs-comment">// CircuitBreaker 在状态更改或关闭状态间隔时清除内部计数。</span><br><span class="hljs-comment">// Counts 会忽略在清除之前发送的请求的结果。</span><br><span class="hljs-keyword">type</span> Counts <span class="hljs-keyword">struct</span> &#123;<br>Requests             <span class="hljs-type">uint32</span> <span class="hljs-comment">// 总请求次数</span><br>TotalSuccesses       <span class="hljs-type">uint32</span> <span class="hljs-comment">// 总成功次数</span><br>TotalFailures        <span class="hljs-type">uint32</span> <span class="hljs-comment">// 总失败次数</span><br>ConsecutiveSuccesses <span class="hljs-type">uint32</span> <span class="hljs-comment">// 连续成功次数</span><br>ConsecutiveFailures  <span class="hljs-type">uint32</span> <span class="hljs-comment">// 连续失败次数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此外还提供了一些列更新计数的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counts)</span></span> onRequest() &#123;<br>c.Requests++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counts)</span></span> onSuccess() &#123;<br>c.TotalSuccesses++<br>c.ConsecutiveSuccesses++<br>c.ConsecutiveFailures = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counts)</span></span> onFailure() &#123;<br>c.TotalFailures++<br>c.ConsecutiveFailures++<br>c.ConsecutiveSuccesses = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counts)</span></span> clear() &#123;<br>c.Requests = <span class="hljs-number">0</span><br>c.TotalSuccesses = <span class="hljs-number">0</span><br>c.TotalFailures = <span class="hljs-number">0</span><br>c.ConsecutiveSuccesses = <span class="hljs-number">0</span><br>c.ConsecutiveFailures = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h1><p>CircuitBreaker 定义了熔断器结构体，这也是最核心的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// CircuitBreaker is a state machine to prevent sending requests that are likely to fail.</span><br><span class="hljs-keyword">type</span> CircuitBreaker <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 虚线内的属性和 Settings 中的相同，如果 Settings 中没有设置，则使用默认值来填充</span><br><span class="hljs-comment">// ==================</span><br>name        <span class="hljs-type">string</span><br>  <span class="hljs-comment">// 比较迷的一个变量，源码里有两种情况：</span><br><span class="hljs-comment">// 1. 请求总数（Requests） &gt;= MaxRequests，那么会返回请求过多的错误</span><br><span class="hljs-comment">// 2. 连续成功次数（ConsecutiveSuccesses） &gt;= MaxRequests，那么变更为关闭状态</span><br><span class="hljs-comment">// 1 在 beforeRequest() 函数中，2 在 afterRequest() -&gt; onSuccess() 的 HalfOpen 分支中</span><br><span class="hljs-comment">// 也就是在请求前会确保请求总数不超过 MaxRequest，请求后如果处于半开状态且连续成功数 &gt;= MaxRequest</span><br><span class="hljs-comment">// 那么会变更为关闭状态</span><br>maxRequests <span class="hljs-type">uint32</span><br>  <br><span class="hljs-comment">// 关闭状态下定期清空计数的时间，如果为 0，则不清空</span><br>  <span class="hljs-comment">// 这里我不太明白清空计数的原因，在网上找了一个分析，意思是如果一直处于成功状态，</span><br><span class="hljs-comment">// 那么计数的意义就不是很大，此外如果请求量过大可能会导致溢出，所以需要定期清空</span><br>interval      time.Duration<br>  <br><span class="hljs-comment">// 打开状态的持续时间，到时后会变更为半打开状态。</span><br>timeout time.Duration<br>  <br><span class="hljs-comment">// 关闭状态下会调用该回调函数，如果返回 true，则进入打开状态</span><br>readyToTrip   <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(counts Counts)</span></span> <span class="hljs-type">bool</span><br>  <br>  <span class="hljs-comment">// 用来判断请求是否成功的回调函数</span><br>isSuccessful  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span><br>  <br>  <span class="hljs-comment">// 发生状态变更时的回调函数</span><br>onStateChange <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(name <span class="hljs-type">string</span>, from State, to State)</span></span><br>  <span class="hljs-comment">// ====================</span><br><br>mutex      sync.Mutex<br>state      State<br>generation <span class="hljs-type">uint64</span><br>counts     Counts<br>  <span class="hljs-comment">// 这个变量貌似有两种情况：</span><br><span class="hljs-comment">// 1. 开启状态下，代表切换到半开启的绝对时间（time.Time 代表一个绝对时间）</span><br><span class="hljs-comment">//    具体值是 time.Now + timeout</span><br><span class="hljs-comment">// 2. 关闭状态下，代表进入下一个周期的绝对时间（进入下一个周期会清空计数）</span><br><span class="hljs-comment">//   具体值是 time.Now + interval</span><br>expiry time.Time<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的一部分值是通过配置类来指定的，如果不指定则会设置为默认配置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCircuitBreaker</span><span class="hljs-params">(st Settings)</span></span> *CircuitBreaker &#123;<br>cb := <span class="hljs-built_in">new</span>(CircuitBreaker)<br><br>cb.name = st.Name<br>cb.onStateChange = st.OnStateChange<br><br><span class="hljs-keyword">if</span> st.MaxRequests == <span class="hljs-number">0</span> &#123;<br>cb.maxRequests = <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.maxRequests = st.MaxRequests<br>&#125;<br><br><span class="hljs-keyword">if</span> st.Interval &lt;= <span class="hljs-number">0</span> &#123;<br>cb.interval = defaultInterval<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.interval = st.Interval<br>&#125;<br><br><span class="hljs-keyword">if</span> st.Timeout &lt;= <span class="hljs-number">0</span> &#123;<br>cb.timeout = defaultTimeout<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.timeout = st.Timeout<br>&#125;<br><br><span class="hljs-keyword">if</span> st.ReadyToTrip == <span class="hljs-literal">nil</span> &#123;<br>cb.readyToTrip = defaultReadyToTrip<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.readyToTrip = st.ReadyToTrip<br>&#125;<br><br><span class="hljs-keyword">if</span> st.IsSuccessful == <span class="hljs-literal">nil</span> &#123;<br>cb.isSuccessful = defaultIsSuccessful<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.isSuccessful = st.IsSuccessful<br>&#125;<br><br>cb.toNewGeneration(time.Now())<br><br><span class="hljs-keyword">return</span> cb<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Settings <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 熔断器的名称</span><br>Name <span class="hljs-type">string</span><br><br><span class="hljs-comment">// MaxRequests 是 CircuitBreaker 半开时允许通过的最大请求数。</span><br><span class="hljs-comment">// 如果 MaxRequests 为 0，则 CircuitBreaker 只允许 1 个请求。</span><br><span class="hljs-comment">// FIXME 比较迷的一个变量，源码里有两种情况：</span><br><span class="hljs-comment">// 1. 请求总数（Requests） &gt;= MaxRequests，那么会返回请求过多的错误</span><br><span class="hljs-comment">// 2. 连续成功次数（ConsecutiveSuccesses） &gt;= MaxRequests，那么变更为关闭状态</span><br><span class="hljs-comment">// 1 在 beforeRequest() 函数中，2 在 afterRequest() -&gt; onSuccess() 的 HalfOpen 分支中</span><br><span class="hljs-comment">// 也就是在请求前会确保请求总数不超过 MaxRequest，请求后如果处于半开状态且连续成功数 &gt;= MaxRequest</span><br><span class="hljs-comment">// 那么会变更为关闭状态</span><br>MaxRequests <span class="hljs-type">uint32</span><br><br><span class="hljs-comment">// Interval 是熔断器处于关闭状态时，定期清除内部 Counts 的时间。</span><br><span class="hljs-comment">// 如果 Interval 小于或等于 0，CircuitBreaker 在关闭状态期间不会清除内部计数。</span><br><span class="hljs-comment">// FIXME 这个东西暂时没发现用处何在</span><br><span class="hljs-comment">// 在网上找了一个分析，意思是如果一直处于成功状态，那么计数的意义就不是很大，</span><br><span class="hljs-comment">// 需要定期清空，不然可能会溢出</span><br>Interval time.Duration<br><br><span class="hljs-comment">// Timeout 是打开状态的持续时间，到时后会变更为半打开状态。</span><br><span class="hljs-comment">// 如果 Timeout 小于或等于 0，则将 CircuitBreaker 的超时值设置为 60 秒。</span><br>Timeout time.Duration<br><br><span class="hljs-comment">// 每当请求在关闭状态下失败时，就会调用 ReadyToTrip，参数传递的是 Counts 的副本。</span><br><span class="hljs-comment">// 如果 ReadyToTrip 返回 true，CircuitBreaker 将进入打开状态。</span><br><span class="hljs-comment">// 如果 ReadyToTrip 为 nil，则使用默认 ReadyToTrip。</span><br><span class="hljs-comment">// 当连续失败次数超过 5 次时，默认 ReadyToTrip 返回 true。</span><br>ReadyToTrip <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(counts Counts)</span></span> <span class="hljs-type">bool</span><br><br><span class="hljs-comment">// OnStateChange 是熔断器状态变更时的回调函数</span><br>OnStateChange <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(name <span class="hljs-type">string</span>, from State, to State)</span></span><br><br><span class="hljs-comment">// IsSuccessful 判断请求是否成功，传入的 err 是执行用户请求函数后返回的。</span><br><span class="hljs-comment">// （也就是 CircuitBreaker.Execute 的参数 req）</span><br><span class="hljs-comment">// 如果 IsSuccessful 返回 true， 则说明请求发生了错误，否则说明没有错误。</span><br><span class="hljs-comment">// 如果 IsSuccessful 为 nil， 则使用默认 IsSuccessful，该默认函数的逻辑是：</span><br><span class="hljs-comment">// if err == nil &#123; return true &#125;</span><br>IsSuccessful <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><p>默认配置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> defaultInterval = time.Duration(<span class="hljs-number">0</span>) * time.Second<br><span class="hljs-keyword">const</span> defaultTimeout = time.Duration(<span class="hljs-number">60</span>) * time.Second<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defaultReadyToTrip</span><span class="hljs-params">(counts Counts)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> counts.ConsecutiveFailures &gt; <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defaultIsSuccessful</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> err == <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h1><p>一共有一下几种状态转换：</p><ul><li>关闭 -&gt; 开启</li><li>开启 -&gt; 半开</li><li>半开 -&gt; 开启</li><li>半开 -&gt; 关闭</li></ul><p>gobreaker 定义了一些方法来完成上面的状态转换，顾名思义，如下所示：</p><h2 id="CircuitBreaker-onSuccess"><a href="#CircuitBreaker-onSuccess" class="headerlink" title="CircuitBreaker.onSuccess"></a><strong>CircuitBreaker.onSuccess</strong></h2><p>这个函数定义了 <strong>半开 -&gt; 关闭</strong> 的状态转换 ，是通过 cb.setState 来完成的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 熔断器请求成功时调用该函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> onSuccess(state State, now time.Time) &#123;<br><span class="hljs-keyword">switch</span> state &#123;<br><span class="hljs-keyword">case</span> StateClosed: <span class="hljs-comment">// 如果此时是关闭状态，则更新计数</span><br>cb.counts.onSuccess()<br><span class="hljs-keyword">case</span> StateHalfOpen: <span class="hljs-comment">// 半开状态</span><br>cb.counts.onSuccess() <span class="hljs-comment">// 更新计数</span><br><span class="hljs-comment">// 连续成功总数超过了设置的 maxRequests，变更为关闭状态</span><br><span class="hljs-keyword">if</span> cb.counts.ConsecutiveSuccesses &gt;= cb.maxRequests &#123;<br>cb.setState(StateClosed, now)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CircuitBreaker-onFailure"><a href="#CircuitBreaker-onFailure" class="headerlink" title="CircuitBreaker.onFailure"></a><strong>CircuitBreaker.onFailure</strong></h2><p>这个函数定义了 **半开 -&gt; 开启 ** 和 <strong>关闭 -&gt; 开启</strong> 的状态转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 熔断器请求失败时调用该函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> onFailure(state State, now time.Time) &#123;<br><span class="hljs-keyword">switch</span> state &#123;<br><span class="hljs-comment">// 关闭状态下请求失败了</span><br><span class="hljs-keyword">case</span> StateClosed:<br>cb.counts.onFailure() <span class="hljs-comment">// 更新计数</span><br><span class="hljs-comment">// 如果回调函数 readyToTrip 返回 true</span><br><span class="hljs-comment">// 因为一次失败可能不足以直接判定为需要熔断，所以可能失败多次后才会返回 true</span><br><span class="hljs-comment">// 比如官方示例中设置的回调函数是：</span><br><span class="hljs-comment">// st.ReadyToTrip = func(counts gobreaker.Counts) bool &#123;</span><br><span class="hljs-comment">//failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)</span><br><span class="hljs-comment">//return counts.Requests &gt;= 3 &amp;&amp; failureRatio &gt;= 0.6</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">// 可以看到这里需要请求次数大于3，且总失败率大于等于 60% 才会返回 true</span><br><span class="hljs-keyword">if</span> cb.readyToTrip(cb.counts) &#123;<br>cb.setState(StateOpen, now) <span class="hljs-comment">// 变更熔断器为开启状态</span><br>&#125;<br><span class="hljs-keyword">case</span> StateHalfOpen: <span class="hljs-comment">// 半开状态下失败了，变更为开启状态</span><br>cb.setState(StateOpen, now)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CircuitBreaker-currentState"><a href="#CircuitBreaker-currentState" class="headerlink" title="CircuitBreaker.currentState"></a><strong>CircuitBreaker.currentState</strong></h2><p>这个函数定义了 <strong>开启 -&gt; 半开</strong> 的状态转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// currentState 返回熔断器当前的状态，now 用来判断是否发生了状态变更</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> currentState(now time.Time) (State, <span class="hljs-type">uint64</span>) &#123;<br>   <span class="hljs-comment">// func toNewGeneration</span><br>   <span class="hljs-comment">// case StateClosed:</span><br>   <span class="hljs-comment">//    if cb.interval == 0 &#123;</span><br>   <span class="hljs-comment">//       cb.expiry = zero</span><br>   <span class="hljs-comment">//    &#125; else &#123;</span><br>   <span class="hljs-comment">//       cb.expiry = now.Add(cb.interval)</span><br>   <span class="hljs-comment">//    &#125;</span><br>   <span class="hljs-keyword">switch</span> cb.state &#123;<br>   <span class="hljs-comment">// 如上面的注释代码所示，如果 cb.interval 为 0，那么 cb.expiry 会设置为 zero，</span><br>   <span class="hljs-comment">// 此时下面的 if 条件就不满足了，关闭状态下也不会调用 cb.toNewGeneration 来清空计数</span><br>   <span class="hljs-comment">// 如果设置了 cb.interval，那么会设置 cb.expiry 的时间，如果处于关闭状态且达到了</span><br>   <span class="hljs-comment">// expiry 的时间，就会调用 cb.toNewGeneration 来清空计数</span><br>   <span class="hljs-keyword">case</span> StateClosed:<br>      <span class="hljs-keyword">if</span> !cb.expiry.IsZero() &amp;&amp; cb.expiry.Before(now) &#123;<br>         cb.toNewGeneration(now)<br>      &#125;<br>   <span class="hljs-keyword">case</span> StateOpen:<br>      <span class="hljs-comment">// 超过了 expiry 的时间，可以切换到半开状态了</span><br>      <span class="hljs-keyword">if</span> cb.expiry.Before(now) &#123;<br>         cb.setState(StateHalfOpen, now)<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> cb.state, cb.generation<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="核心方法-Execute"><a href="#核心方法-Execute" class="headerlink" title="核心方法 Execute"></a>核心方法 Execute</h1><p>这个方法就是熔断器的执行方法，用户传入一个函数，熔断器会根据当前状态进行相应的操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> Execute(req <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>generation, err := cb.beforeRequest()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>e := <span class="hljs-built_in">recover</span>()<br><span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<br>cb.afterRequest(generation, <span class="hljs-literal">false</span>)<br><span class="hljs-built_in">panic</span>(e)<br>&#125;<br>&#125;()<br><br>result, err := req()<br>cb.afterRequest(generation, cb.isSuccessful(err))<br><span class="hljs-keyword">return</span> result, err<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到其中调用了用户传入的函数，此外还有两个函数：beforeRequest() 和 afterRequest() 代表执行请求前和执行请求后，这两个函数内部会更新熔断器的计数以及状态</p><h1 id="beforeRequest"><a href="#beforeRequest" class="headerlink" title="beforeRequest"></a><strong>beforeRequest</strong></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> beforeRequest() (<span class="hljs-type">uint64</span>, <span class="hljs-type">error</span>) &#123;<br>cb.mutex.Lock()<br><span class="hljs-keyword">defer</span> cb.mutex.Unlock()<br><br>now := time.Now()<br>state, generation := cb.currentState(now)<br><br><span class="hljs-comment">// 如果熔断器处于开启状态，直接返回错误，因为该方法在 Execute 中先于用户请求执行，</span><br><span class="hljs-comment">// 且逻辑是有 err 直接 return，所以不会执行之后的代码，具体查看 Execute，下面是截取的部分：</span><br><span class="hljs-comment">// generation, err := cb.beforeRequest()</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//return nil, err</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-keyword">if</span> state == StateOpen &#123;<br><span class="hljs-keyword">return</span> generation, ErrOpenState<br><span class="hljs-comment">// 请求前如果处于半开状态，会进行限流操作</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> state == StateHalfOpen &amp;&amp; cb.counts.Requests &gt;= cb.maxRequests &#123;<br><span class="hljs-keyword">return</span> generation, ErrTooManyRequests<br>&#125;<br><br>cb.counts.onRequest() <span class="hljs-comment">// 更新计数</span><br><span class="hljs-keyword">return</span> generation, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="afterRequest"><a href="#afterRequest" class="headerlink" title="afterRequest"></a><strong>afterRequest</strong></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> afterRequest(before <span class="hljs-type">uint64</span>, success <span class="hljs-type">bool</span>) &#123;<br>cb.mutex.Lock()<br><span class="hljs-keyword">defer</span> cb.mutex.Unlock()<br><br>now := time.Now()<br>state, generation := cb.currentState(now)<br><span class="hljs-keyword">if</span> generation != before &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>  <span class="hljs-comment">// 更新状态和计数</span><br><span class="hljs-keyword">if</span> success &#123;<br>cb.onSuccess(state, now)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.onFailure(state, now)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个函数又调用了同一个函数 <code>cb.currentState</code></p><h1 id="currentState"><a href="#currentState" class="headerlink" title="currentState"></a>currentState</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// currentState 返回熔断器当前的状态，now 用来判断是否需要执行某些操作，这些操作包括：</span><br><span class="hljs-comment">// 1. 关闭状态下清空计数（如果设置了 interval 且达到了清空时间）</span><br><span class="hljs-comment">// 2. 开启状态转换为半开启状态（到达了转换时间）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> currentState(now time.Time) (State, <span class="hljs-type">uint64</span>) &#123;<br><span class="hljs-comment">// func toNewGeneration</span><br><span class="hljs-comment">// case StateClosed:</span><br><span class="hljs-comment">//if cb.interval == 0 &#123;</span><br><span class="hljs-comment">//cb.expiry = zero</span><br><span class="hljs-comment">//&#125; else &#123;</span><br><span class="hljs-comment">//cb.expiry = now.Add(cb.interval)</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-keyword">switch</span> cb.state &#123;<br><span class="hljs-comment">// 如上面的注释代码所示，如果 cb.interval 为 0，那么 cb.expiry 会设置为 zero，</span><br><span class="hljs-comment">// 此时下面的 if 条件就不满足了，关闭状态下也不会调用 cb.toNewGeneration 来清空计数</span><br><span class="hljs-comment">// 如果设置了 cb.interval，那么会设置 cb.expiry 的时间，如果处于关闭状态且达到了</span><br><span class="hljs-comment">// expiry 的时间，就会调用 cb.toNewGeneration 来清空计数</span><br><span class="hljs-keyword">case</span> StateClosed:<br><span class="hljs-keyword">if</span> !cb.expiry.IsZero() &amp;&amp; cb.expiry.Before(now) &#123;<br>cb.toNewGeneration(now)<br>&#125;<br><span class="hljs-keyword">case</span> StateOpen:<br><span class="hljs-comment">// 超过了 expiry 的时间，可以切换到半开状态了</span><br><span class="hljs-keyword">if</span> cb.expiry.Before(now) &#123;<br>cb.setState(StateHalfOpen, now)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> cb.state, cb.generation<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数又调用了另一个函数 <code>toNewGeneration</code></p><h1 id="toNewGeneration"><a href="#toNewGeneration" class="headerlink" title="toNewGeneration"></a>toNewGeneration</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 进入一个新周期，会清空计数，并对 cb.expiry 进行更新</span><br><span class="hljs-comment">// 该函数会在 setState、currentState、NewCircuitBreaker 调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> toNewGeneration(now time.Time) &#123;<br>   cb.generation++<br>   cb.counts.clear()<br><br>   <span class="hljs-keyword">var</span> zero time.Time<br>   <span class="hljs-keyword">switch</span> cb.state &#123;<br>   <span class="hljs-keyword">case</span> StateClosed:<br>      <span class="hljs-keyword">if</span> cb.interval == <span class="hljs-number">0</span> &#123;<br>         cb.expiry = zero<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>         cb.expiry = now.Add(cb.interval)<br>      &#125;<br>   <span class="hljs-keyword">case</span> StateOpen:<br>      cb.expiry = now.Add(cb.timeout) <span class="hljs-comment">// 设置 open -&gt; halfOpen 的绝对时间</span><br>   <span class="hljs-keyword">default</span>: <span class="hljs-comment">// StateHalfOpen</span><br>      cb.expiry = zero<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>光看文档感觉熔断器并不是一个多么复杂的东西，但是等实际阅读代码才发现还是有点小复杂的，何况这个开源库还只是对熔断器的一个最精简实现，还有其他的更复杂的实现库，阅读这个源码主要有一些不清楚的点在于，里面的属性<code> CircuitBreaker.expiry</code> 和 <code>CircuitBreaker.maxRequests</code> 在不同情况下有不同的意义，导致看的有点头疼，状态的转换看着也有点绕，还有一开始对 <code>CircuitBreaker.interval</code> 这个属性的意义也不太理解</p><h1 id="完整源码注释"><a href="#完整源码注释" class="headerlink" title="完整源码注释"></a>完整源码注释</h1><p><a href="https://github.com/youseebiggirl/gobreaker_annotation">https://github.com/youseebiggirl/gobreaker_annotation</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package gobreaker implements the Circuit Breaker pattern.</span><br><span class="hljs-comment">// See https://msdn.microsoft.com/en-us/library/dn589784.aspx.</span><br><span class="hljs-keyword">package</span> gobreaker<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// State is a type that represents a state of CircuitBreaker.</span><br><span class="hljs-keyword">type</span> State <span class="hljs-type">int</span><br><br><span class="hljs-comment">// These constants are states of CircuitBreaker.</span><br><span class="hljs-comment">// 熔断器的状态</span><br><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">// StateClosed 表示关闭状态，此时所有请求都会通过</span><br>StateClosed State = <span class="hljs-literal">iota</span><br><span class="hljs-comment">// StateHalfOpen 半开状态，会根据情况变更为开启或者关闭状态</span><br>StateHalfOpen<br><span class="hljs-comment">// StateOpen 开启状态，此时会拒绝所有请求</span><br>StateOpen<br>)<br><br><span class="hljs-keyword">var</span> (<br><span class="hljs-comment">// ErrTooManyRequests is returned when the CB state is half open and the requests count is over the cb maxRequests</span><br><span class="hljs-comment">// 该错误在状态为半开且请求数超过 maxRequests 时返回</span><br>ErrTooManyRequests = errors.New(<span class="hljs-string">&quot;too many requests&quot;</span>)<br><span class="hljs-comment">// ErrOpenState is returned when the CB state is open</span><br><span class="hljs-comment">// 该错误在状态为开启时返回</span><br>ErrOpenState = errors.New(<span class="hljs-string">&quot;circuit breaker is open&quot;</span>)<br>)<br><br><span class="hljs-comment">// String implements stringer interface.</span><br><span class="hljs-comment">// String 继承了 stringer 接口，相当于自定义了 fmt.Println(State) 的输出</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s State)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">switch</span> s &#123;<br><span class="hljs-keyword">case</span> StateClosed:<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;closed&quot;</span><br><span class="hljs-keyword">case</span> StateHalfOpen:<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;half-open&quot;</span><br><span class="hljs-keyword">case</span> StateOpen:<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;open&quot;</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;unknown state: %d&quot;</span>, s)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Counts holds the numbers of requests and their successes/failures.</span><br><span class="hljs-comment">// CircuitBreaker clears the internal Counts either</span><br><span class="hljs-comment">// on the change of the state or at the closed-state intervals.</span><br><span class="hljs-comment">// Counts ignores the results of the requests sent before clearing.</span><br><span class="hljs-comment">// Counts 保存请求的数量及其成功失败的次数。</span><br><span class="hljs-comment">// CircuitBreaker 在状态更改或关闭状态间隔时清除内部计数。</span><br><span class="hljs-comment">// Counts 会忽略在清除之前发送的请求的结果。</span><br><span class="hljs-keyword">type</span> Counts <span class="hljs-keyword">struct</span> &#123;<br>Requests             <span class="hljs-type">uint32</span> <span class="hljs-comment">// 总请求次数</span><br>TotalSuccesses       <span class="hljs-type">uint32</span> <span class="hljs-comment">// 总成功次数</span><br>TotalFailures        <span class="hljs-type">uint32</span> <span class="hljs-comment">// 总失败次数</span><br>ConsecutiveSuccesses <span class="hljs-type">uint32</span> <span class="hljs-comment">// 连续成功次数</span><br>ConsecutiveFailures  <span class="hljs-type">uint32</span> <span class="hljs-comment">// 连续失败次数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counts)</span></span> onRequest() &#123;<br>c.Requests++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counts)</span></span> onSuccess() &#123;<br>c.TotalSuccesses++<br>c.ConsecutiveSuccesses++<br>c.ConsecutiveFailures = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counts)</span></span> onFailure() &#123;<br>c.TotalFailures++<br>c.ConsecutiveFailures++<br>c.ConsecutiveSuccesses = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counts)</span></span> clear() &#123;<br>c.Requests = <span class="hljs-number">0</span><br>c.TotalSuccesses = <span class="hljs-number">0</span><br>c.TotalFailures = <span class="hljs-number">0</span><br>c.ConsecutiveSuccesses = <span class="hljs-number">0</span><br>c.ConsecutiveFailures = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// Settings configures CircuitBreaker:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Name is the name of the CircuitBreaker.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// MaxRequests is the maximum number of requests allowed to pass through</span><br><span class="hljs-comment">// when the CircuitBreaker is half-open.</span><br><span class="hljs-comment">// If MaxRequests is 0, the CircuitBreaker allows only 1 request.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Interval is the cyclic period of the closed state</span><br><span class="hljs-comment">// for the CircuitBreaker to clear the internal Counts.</span><br><span class="hljs-comment">// If Interval is less than or equal to 0, the CircuitBreaker doesn&#x27;t clear internal Counts during the closed state.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Timeout is the period of the open state,</span><br><span class="hljs-comment">// after which the state of the CircuitBreaker becomes half-open.</span><br><span class="hljs-comment">// If Timeout is less than or equal to 0, the timeout value of the CircuitBreaker is set to 60 seconds.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// ReadyToTrip is called with a copy of Counts whenever a request fails in the closed state.</span><br><span class="hljs-comment">// If ReadyToTrip returns true, the CircuitBreaker will be placed into the open state.</span><br><span class="hljs-comment">// If ReadyToTrip is nil, default ReadyToTrip is used.</span><br><span class="hljs-comment">// Default ReadyToTrip returns true when the number of consecutive failures is more than 5.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// OnStateChange is called whenever the state of the CircuitBreaker changes.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// IsSuccessful is called with the error returned from a request.</span><br><span class="hljs-comment">// If IsSuccessful returns true, the error is counted as a success.</span><br><span class="hljs-comment">// Otherwise the error is counted as a failure.</span><br><span class="hljs-comment">// If IsSuccessful is nil, default IsSuccessful is used, which returns false for all non-nil errors.</span><br><span class="hljs-keyword">type</span> Settings <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 熔断器的名称</span><br>Name <span class="hljs-type">string</span><br><br><span class="hljs-comment">// MaxRequests 是 CircuitBreaker 半开时允许通过的最大请求数。</span><br><span class="hljs-comment">// 如果 MaxRequests 为 0，则 CircuitBreaker 只允许 1 个请求。</span><br><span class="hljs-comment">// FIXME 比较迷的一个变量，源码里有两种情况：</span><br><span class="hljs-comment">// 1. 请求总数（Requests） &gt;= MaxRequests，那么会返回请求过多的错误</span><br><span class="hljs-comment">// 2. 连续成功次数（ConsecutiveSuccesses） &gt;= MaxRequests，那么变更为关闭状态</span><br><span class="hljs-comment">// 1 在 beforeRequest() 函数中，2 在 afterRequest() -&gt; onSuccess() 的 HalfOpen 分支中</span><br><span class="hljs-comment">// 也就是在请求前会确保请求总数不超过 MaxRequest，请求后如果处于半开状态且连续成功数 &gt;= MaxRequest</span><br><span class="hljs-comment">// 那么会变更为关闭状态</span><br>MaxRequests <span class="hljs-type">uint32</span><br><br><span class="hljs-comment">// Interval 是熔断器处于关闭状态时，定期清除内部 Counts 的时间。</span><br><span class="hljs-comment">// 如果 Interval 小于或等于 0，CircuitBreaker 在关闭状态期间不会清除内部计数。</span><br><span class="hljs-comment">// FIXME 这个东西暂时没发现用处何在</span><br><span class="hljs-comment">// 在网上找了一个分析，意思是如果一直处于成功状态，那么计数的意义就不是很大，</span><br><span class="hljs-comment">// 需要定期清空，不然可能会溢出</span><br>Interval time.Duration<br><br><span class="hljs-comment">// Timeout 是打开状态的持续时间，到时后会变更为半打开状态。</span><br><span class="hljs-comment">// 如果 Timeout 小于或等于 0，则将 CircuitBreaker 的超时值设置为 60 秒。</span><br>Timeout time.Duration<br><br><span class="hljs-comment">// 每当请求在关闭状态下失败时，就会调用 ReadyToTrip，参数传递的是 Counts 的副本。</span><br><span class="hljs-comment">// 如果 ReadyToTrip 返回 true，CircuitBreaker 将进入打开状态。</span><br><span class="hljs-comment">// 如果 ReadyToTrip 为 nil，则使用默认 ReadyToTrip。</span><br><span class="hljs-comment">// 当连续失败次数超过 5 次时，默认 ReadyToTrip 返回 true。</span><br>ReadyToTrip <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(counts Counts)</span></span> <span class="hljs-type">bool</span><br><br><span class="hljs-comment">// OnStateChange 是熔断器状态变更时的回调函数</span><br>OnStateChange <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(name <span class="hljs-type">string</span>, from State, to State)</span></span><br><br><span class="hljs-comment">// IsSuccessful 判断请求是否成功，传入的 err 是执行用户请求函数后返回的。</span><br><span class="hljs-comment">// （也就是 CircuitBreaker.Execute 的参数 req）</span><br><span class="hljs-comment">// 如果 IsSuccessful 返回 true， 则说明请求发生了错误，否则说明没有错误。</span><br><span class="hljs-comment">// 如果 IsSuccessful 为 nil， 则使用默认 IsSuccessful，该默认函数的逻辑是：</span><br><span class="hljs-comment">// if err == nil &#123; return true &#125;</span><br>IsSuccessful <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-comment">// CircuitBreaker is a state machine to prevent sending requests that are likely to fail.</span><br><span class="hljs-keyword">type</span> CircuitBreaker <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 虚线内的属性和 Settings 中的相同，如果 Settings 中没有设置，则使用默认值来填充</span><br><span class="hljs-comment">// ==================</span><br>name <span class="hljs-type">string</span><br><span class="hljs-comment">// 比较迷的一个变量，源码里有两种情况：</span><br><span class="hljs-comment">// 1. 请求总数（Requests） &gt;= MaxRequests，那么会返回请求过多的错误</span><br><span class="hljs-comment">// 2. 连续成功次数（ConsecutiveSuccesses） &gt;= MaxRequests，那么变更为关闭状态</span><br><span class="hljs-comment">// 1 在 beforeRequest() 函数中，2 在 afterRequest() -&gt; onSuccess() 的 HalfOpen 分支中</span><br><span class="hljs-comment">// 也就是在请求前会确保请求总数不超过 MaxRequest，请求后如果处于半开状态且连续成功数 &gt;= MaxRequest</span><br><span class="hljs-comment">// 那么会变更为关闭状态</span><br>maxRequests <span class="hljs-type">uint32</span><br><br><span class="hljs-comment">// 关闭状态下定期清空计数的时间，如果为 0，则不清空</span><br><span class="hljs-comment">// 这里我不太明白清空计数的原因，在网上找了一个分析，意思是如果一直处于成功状态，</span><br><span class="hljs-comment">// 那么计数的意义就不是很大，此外如果请求量过大可能会导致溢出，所以需要定期清空</span><br>interval time.Duration<br><br><span class="hljs-comment">// 打开状态的持续时间，到时后会变更为半打开状态。</span><br>timeout time.Duration<br><br><span class="hljs-comment">// 关闭状态下会调用该回调函数，如果返回 true，则进入打开状态</span><br>readyToTrip <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(counts Counts)</span></span> <span class="hljs-type">bool</span><br><br><span class="hljs-comment">// 用来判断请求是否成功的回调函数</span><br>isSuccessful <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span><br><br><span class="hljs-comment">// 发生状态变更时的回调函数</span><br>onStateChange <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(name <span class="hljs-type">string</span>, from State, to State)</span></span><br><span class="hljs-comment">// ====================</span><br><br>mutex      sync.Mutex<br>state      State<br>generation <span class="hljs-type">uint64</span><br>counts     Counts<br><span class="hljs-comment">// 这个变量貌似有两种情况：</span><br><span class="hljs-comment">// 1. 开启状态下，代表切换到半开启的绝对时间（time.Time 代表一个绝对时间）</span><br><span class="hljs-comment">//    具体值是 time.Now + timeout</span><br><span class="hljs-comment">// 2. 关闭状态下，代表进入下一个周期的绝对时间（进入下一个周期会清空计数）</span><br><span class="hljs-comment">//   具体值是 time.Now + interval</span><br>expiry time.Time<br>&#125;<br><br><span class="hljs-comment">// TwoStepCircuitBreaker is like CircuitBreaker but instead of surrounding a function</span><br><span class="hljs-comment">// with the breaker functionality, it only checks whether a request can proceed and</span><br><span class="hljs-comment">// expects the caller to report the outcome in a separate step using a callback.</span><br><span class="hljs-keyword">type</span> TwoStepCircuitBreaker <span class="hljs-keyword">struct</span> &#123;<br>cb *CircuitBreaker<br>&#125;<br><br><span class="hljs-comment">// NewCircuitBreaker returns a new CircuitBreaker configured with the given Settings.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCircuitBreaker</span><span class="hljs-params">(st Settings)</span></span> *CircuitBreaker &#123;<br>cb := <span class="hljs-built_in">new</span>(CircuitBreaker)<br><br>cb.name = st.Name<br>cb.onStateChange = st.OnStateChange<br><br><span class="hljs-keyword">if</span> st.MaxRequests == <span class="hljs-number">0</span> &#123;<br>cb.maxRequests = <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.maxRequests = st.MaxRequests<br>&#125;<br><br><span class="hljs-keyword">if</span> st.Interval &lt;= <span class="hljs-number">0</span> &#123;<br>cb.interval = defaultInterval<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.interval = st.Interval<br>&#125;<br><br><span class="hljs-keyword">if</span> st.Timeout &lt;= <span class="hljs-number">0</span> &#123;<br>cb.timeout = defaultTimeout<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.timeout = st.Timeout<br>&#125;<br><br><span class="hljs-keyword">if</span> st.ReadyToTrip == <span class="hljs-literal">nil</span> &#123;<br>cb.readyToTrip = defaultReadyToTrip<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.readyToTrip = st.ReadyToTrip<br>&#125;<br><br><span class="hljs-keyword">if</span> st.IsSuccessful == <span class="hljs-literal">nil</span> &#123;<br>cb.isSuccessful = defaultIsSuccessful<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.isSuccessful = st.IsSuccessful<br>&#125;<br><br>cb.toNewGeneration(time.Now())<br><br><span class="hljs-keyword">return</span> cb<br>&#125;<br><br><span class="hljs-comment">// NewTwoStepCircuitBreaker returns a new TwoStepCircuitBreaker configured with the given Settings.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTwoStepCircuitBreaker</span><span class="hljs-params">(st Settings)</span></span> *TwoStepCircuitBreaker &#123;<br><span class="hljs-keyword">return</span> &amp;TwoStepCircuitBreaker&#123;<br>cb: NewCircuitBreaker(st),<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> defaultInterval = time.Duration(<span class="hljs-number">0</span>) * time.Second<br><span class="hljs-keyword">const</span> defaultTimeout = time.Duration(<span class="hljs-number">60</span>) * time.Second<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defaultReadyToTrip</span><span class="hljs-params">(counts Counts)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> counts.ConsecutiveFailures &gt; <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defaultIsSuccessful</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> err == <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Name returns the name of the CircuitBreaker.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> Name() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> cb.name<br>&#125;<br><br><span class="hljs-comment">// State returns the current state of the CircuitBreaker.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> State() State &#123;<br>cb.mutex.Lock()<br><span class="hljs-keyword">defer</span> cb.mutex.Unlock()<br><br>now := time.Now()<br>state, _ := cb.currentState(now)<br><span class="hljs-keyword">return</span> state<br>&#125;<br><br><span class="hljs-comment">// Counts returns internal counters</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> Counts() Counts &#123;<br>cb.mutex.Lock()<br><span class="hljs-keyword">defer</span> cb.mutex.Unlock()<br><br><span class="hljs-keyword">return</span> cb.counts<br>&#125;<br><br><span class="hljs-comment">// Execute runs the given request if the CircuitBreaker accepts it.</span><br><span class="hljs-comment">// Execute returns an error instantly if the CircuitBreaker rejects the request.</span><br><span class="hljs-comment">// Otherwise, Execute returns the result of the request.</span><br><span class="hljs-comment">// If a panic occurs in the request, the CircuitBreaker handles it as an error</span><br><span class="hljs-comment">// and causes the same panic again.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> Execute(req <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 执行请求前</span><br>generation, err := cb.beforeRequest()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>e := <span class="hljs-built_in">recover</span>()<br><span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<br>cb.afterRequest(generation, <span class="hljs-literal">false</span>)<br><span class="hljs-built_in">panic</span>(e)<br>&#125;<br>&#125;()<br><br>result, err := req()<br><span class="hljs-comment">// 执行请求后</span><br>cb.afterRequest(generation, cb.isSuccessful(err))<br><span class="hljs-keyword">return</span> result, err<br>&#125;<br><br><span class="hljs-comment">// Name returns the name of the TwoStepCircuitBreaker.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tscb *TwoStepCircuitBreaker)</span></span> Name() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> tscb.cb.Name()<br>&#125;<br><br><span class="hljs-comment">// State returns the current state of the TwoStepCircuitBreaker.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tscb *TwoStepCircuitBreaker)</span></span> State() State &#123;<br><span class="hljs-keyword">return</span> tscb.cb.State()<br>&#125;<br><br><span class="hljs-comment">// Counts returns internal counters</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tscb *TwoStepCircuitBreaker)</span></span> Counts() Counts &#123;<br><span class="hljs-keyword">return</span> tscb.cb.Counts()<br>&#125;<br><br><span class="hljs-comment">// Allow checks if a new request can proceed. It returns a callback that should be used to</span><br><span class="hljs-comment">// register the success or failure in a separate step. If the circuit breaker doesn&#x27;t allow</span><br><span class="hljs-comment">// requests, it returns an error.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tscb *TwoStepCircuitBreaker)</span></span> Allow() (done <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(success <span class="hljs-type">bool</span>)</span></span>, err <span class="hljs-type">error</span>) &#123;<br>generation, err := tscb.cb.beforeRequest()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(success <span class="hljs-type">bool</span>)</span></span> &#123;<br>tscb.cb.afterRequest(generation, success)<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> beforeRequest() (<span class="hljs-type">uint64</span>, <span class="hljs-type">error</span>) &#123;<br>cb.mutex.Lock()<br><span class="hljs-keyword">defer</span> cb.mutex.Unlock()<br><br>now := time.Now()<br>state, generation := cb.currentState(now)<br><br><span class="hljs-comment">// 如果熔断器处于开启状态，直接返回错误，因为该方法在 Execute 中先于用户请求执行，</span><br><span class="hljs-comment">// 且逻辑是有 err 直接 return，所以不会执行之后的代码，具体查看 Execute，下面是截取的部分：</span><br><span class="hljs-comment">// generation, err := cb.beforeRequest()</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//return nil, err</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-keyword">if</span> state == StateOpen &#123;<br><span class="hljs-keyword">return</span> generation, ErrOpenState<br><span class="hljs-comment">// 请求前如果处于半开状态，会进行限流操作</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> state == StateHalfOpen &amp;&amp; cb.counts.Requests &gt;= cb.maxRequests &#123;<br><span class="hljs-keyword">return</span> generation, ErrTooManyRequests<br>&#125;<br><br>cb.counts.onRequest() <span class="hljs-comment">// 更新计数</span><br><span class="hljs-keyword">return</span> generation, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> afterRequest(before <span class="hljs-type">uint64</span>, success <span class="hljs-type">bool</span>) &#123;<br>cb.mutex.Lock()<br><span class="hljs-keyword">defer</span> cb.mutex.Unlock()<br><br>now := time.Now()<br>state, generation := cb.currentState(now)<br><span class="hljs-keyword">if</span> generation != before &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 更新状态和计数</span><br><span class="hljs-keyword">if</span> success &#123;<br>cb.onSuccess(state, now)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.onFailure(state, now)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 熔断器请求成功时调用该函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> onSuccess(state State, now time.Time) &#123;<br><span class="hljs-keyword">switch</span> state &#123;<br><span class="hljs-keyword">case</span> StateClosed: <span class="hljs-comment">// 如果此时是关闭状态，则更新计数</span><br>cb.counts.onSuccess()<br><span class="hljs-keyword">case</span> StateHalfOpen: <span class="hljs-comment">// 半开状态</span><br>cb.counts.onSuccess() <span class="hljs-comment">// 更新计数</span><br><span class="hljs-comment">// 连续成功总数超过了设置的 maxRequests，变更为关闭状态</span><br><span class="hljs-keyword">if</span> cb.counts.ConsecutiveSuccesses &gt;= cb.maxRequests &#123;<br>cb.setState(StateClosed, now)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 熔断器请求失败时调用该函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> onFailure(state State, now time.Time) &#123;<br><span class="hljs-keyword">switch</span> state &#123;<br><span class="hljs-comment">// 关闭状态下请求失败了</span><br><span class="hljs-keyword">case</span> StateClosed:<br>cb.counts.onFailure() <span class="hljs-comment">// 更新计数</span><br><span class="hljs-comment">// 如果回调函数 readyToTrip 返回 true</span><br><span class="hljs-comment">// 因为一次失败可能不足以直接判定为需要熔断，所以可能失败多次后才会返回 true</span><br><span class="hljs-comment">// 比如官方示例中设置的回调函数是：</span><br><span class="hljs-comment">// st.ReadyToTrip = func(counts gobreaker.Counts) bool &#123;</span><br><span class="hljs-comment">//failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)</span><br><span class="hljs-comment">//return counts.Requests &gt;= 3 &amp;&amp; failureRatio &gt;= 0.6</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">// 可以看到这里需要请求次数大于3，且总失败率大于等于 60% 才会返回 true</span><br><span class="hljs-keyword">if</span> cb.readyToTrip(cb.counts) &#123;<br>cb.setState(StateOpen, now) <span class="hljs-comment">// 变更熔断器为开启状态</span><br>&#125;<br><span class="hljs-keyword">case</span> StateHalfOpen: <span class="hljs-comment">// 半开状态下失败了，变更为开启状态</span><br>cb.setState(StateOpen, now)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// currentState 返回熔断器当前的状态，now 用来判断是否需要执行某些操作，这些操作包括：</span><br><span class="hljs-comment">// 1. 关闭状态下清空计数（如果设置了 interval 且达到了清空时间）</span><br><span class="hljs-comment">// 2. 开启状态转换为半开启状态（到达了转换时间）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> currentState(now time.Time) (State, <span class="hljs-type">uint64</span>) &#123;<br><span class="hljs-comment">// func toNewGeneration</span><br><span class="hljs-comment">// case StateClosed:</span><br><span class="hljs-comment">//if cb.interval == 0 &#123;</span><br><span class="hljs-comment">//cb.expiry = zero</span><br><span class="hljs-comment">//&#125; else &#123;</span><br><span class="hljs-comment">//cb.expiry = now.Add(cb.interval)</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-keyword">switch</span> cb.state &#123;<br><span class="hljs-comment">// 如上面的注释代码所示，如果 cb.interval 为 0，那么 cb.expiry 会设置为 zero，</span><br><span class="hljs-comment">// 此时下面的 if 条件就不满足了，关闭状态下也不会调用 cb.toNewGeneration 来清空计数</span><br><span class="hljs-comment">// 如果设置了 cb.interval，那么会设置 cb.expiry 的时间，如果处于关闭状态且达到了</span><br><span class="hljs-comment">// expiry 的时间，就会调用 cb.toNewGeneration 来清空计数</span><br><span class="hljs-keyword">case</span> StateClosed:<br><span class="hljs-keyword">if</span> !cb.expiry.IsZero() &amp;&amp; cb.expiry.Before(now) &#123;<br>cb.toNewGeneration(now)<br>&#125;<br><span class="hljs-keyword">case</span> StateOpen:<br><span class="hljs-comment">// 超过了 expiry 的时间，可以切换到半开状态了</span><br><span class="hljs-keyword">if</span> cb.expiry.Before(now) &#123;<br>cb.setState(StateHalfOpen, now)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> cb.state, cb.generation<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> setState(state State, now time.Time) &#123;<br><span class="hljs-keyword">if</span> cb.state == state &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>prev := cb.state<br>cb.state = state<br><br>cb.toNewGeneration(now) <span class="hljs-comment">// 设置新状态后更新计数</span><br><br><span class="hljs-keyword">if</span> cb.onStateChange != <span class="hljs-literal">nil</span> &#123;<br>cb.onStateChange(cb.name, prev, state)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 进入一个新周期，会清空计数，并对 cb.expiry 进行更新</span><br><span class="hljs-comment">// 该函数会在 setState、currentState、NewCircuitBreaker 调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> toNewGeneration(now time.Time) &#123;<br>cb.generation++<br>cb.counts.clear()<br><br><span class="hljs-keyword">var</span> zero time.Time<br><span class="hljs-keyword">switch</span> cb.state &#123;<br><span class="hljs-keyword">case</span> StateClosed:<br><span class="hljs-keyword">if</span> cb.interval == <span class="hljs-number">0</span> &#123;<br>cb.expiry = zero<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.expiry = now.Add(cb.interval)<br>&#125;<br><span class="hljs-keyword">case</span> StateOpen:<br>cb.expiry = now.Add(cb.timeout) <span class="hljs-comment">// 设置 open -&gt; halfOpen 的绝对时间</span><br><span class="hljs-keyword">default</span>: <span class="hljs-comment">// StateHalfOpen</span><br>cb.expiry = zero<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go 文件操作的&quot;坑&quot;之 Seek()</title>
    <link href="/2022/06/08/go_seek/"/>
    <url>/2022/06/08/go_seek/</url>
    
    <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>最近买了块机械硬盘作为仓库盘，用硬盘盒连接到 mac，但是这块硬盘貌似有休眠机制（不确定），如果一段时间没有读写操作就会停转，等到需要操作时才会唤醒，唤醒会有比较明显的磁盘启动声音，并且需要等待 5s 左右才能使用。</p><p>但蛋疼的是不知道是系统原因还是什么，每次硬盘休眠后即便我没有对其进行操作仍然会自行唤醒，导致我总是能频繁听到硬盘的启停声，我还专门观察了一下，就算我躺在床上玩手机，完全不碰电脑，这块硬盘仍然会频繁的启停，先不说这烦人的声音，网上查了下，貌似这样频繁启停还会损害硬盘健康，还不如一直通电运行，为了解决这个问题，我打算写个小程序，期间遇到了一些问题，特此记录一下。</p><h1 id="问题1-读不出文件内容"><a href="#问题1-读不出文件内容" class="headerlink" title="问题1 读不出文件内容"></a>问题1 读不出文件内容</h1><p>具体流程是先在这块硬盘上创建一个文件，并获取 fd，然后用这个 fd 写入一段文字，再在一个死循环里不断读取这个 fd，我想的是这样不断读取硬盘，来达到禁止休眠的效果，结果发现写入成功，但是读直接报 EOF，后来研究发现，貌似是写入后导致 fd 偏移量改变移到末尾，此时再读取就会直接报 EOF，所以在读取前需要调用 Seek 来重置偏移量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := <span class="hljs-string">&quot;/Volumes/4t/DO_NOT_SLEEP&quot;</span><br>f, err := os.OpenFile(p, os.O_CREATE|os.O_RDWR, <span class="hljs-number">0777</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> f.Close()<br><br>_, err = f.WriteString(<span class="hljs-string">&quot;123&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>log.Println(<span class="hljs-string">&quot;DO_NOT_SLEEP is ready&quot;</span>)<br><span class="hljs-comment">// 注意：上面的写入操作会改变偏移量，导致后续的读取操作为 EOF</span><br><span class="hljs-comment">// 需要调用 Seek 来重置偏移量，这里设置为 SEEK_SET + 0 也就是从头开始读</span><br>f.Seek(<span class="hljs-number">0</span>, os.SEEK_SET)<br><br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> &#123;<br>n, err := f.Read(b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br>log.Println(n, <span class="hljs-type">string</span>(b[:n]))<br>f.Seek(<span class="hljs-number">0</span>, os.SEEK_SET)<br>time.Sleep(time.Second * <span class="hljs-number">3</span>)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="问题2-虽然在不断读取，但硬盘依然会休眠"><a href="#问题2-虽然在不断读取，但硬盘依然会休眠" class="headerlink" title="问题2 虽然在不断读取，但硬盘依然会休眠"></a>问题2 虽然在不断读取，但硬盘依然会休眠</h1><p>还是上面的程序，我跑起来以后发现终端在不断打印读取到的内容，本以为 ok 了，结果过了几分钟硬盘又给休眠了，最离谱的是此时终端还在不断打印日志。。。这是为什么？难不成 fd 打开后，会把文件内容缓存，之后直接从缓存中读？我又尝试了在一个死循环里不断调用 os.OpenFile，但是然并卵，磁盘依然会休眠，这个问题还有待研究，不知道是 go runtime 的设计问题，还是 linux fd 的机制问题</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>既然读解决不了问题，那我只能试试写了，感觉写问题应该不大，其实我一开始就是想用写操作来解决问题的，但是了解到读操作对硬盘是无损害的，而写操作会损害硬盘寿命，所以才尝试用读操作解决，</p><p>大致思路也很简单，就是不断向这个文件中写入文本即可，这里我把 open 也放到了死循环中，因为我不知道在死循环中操作同一个 fd 会不会出现上面的硬盘依然休眠的问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := <span class="hljs-string">&quot;/Volumes/4t/DO_NOT_SLEEP&quot;</span><br><span class="hljs-keyword">for</span> &#123;<br>f, err := os.OpenFile(p, os.O_CREATE|os.O_RDWR, <span class="hljs-number">0777</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>f.WriteString(<span class="hljs-string">&quot;123&quot;</span>)<br>log.Println(<span class="hljs-string">&quot;write ok&quot;</span>)<br>f.Close()<br>time.Sleep(time.Second * <span class="hljs-number">5</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h1><p>无意间看到一盘 <strong>页缓存</strong> 的文章，里面说系统会把磁盘里的内容放到缓存中，下次如果访问同样的内容，则不需要读取硬盘，而是直接从缓存中读取即可，这样就避免了 IO 的开销，提高了性能。如果是这样的话，那么问题2 就解释的通了</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s ConfigMap</title>
    <link href="/2022/06/07/k8s-configmap/"/>
    <url>/2022/06/07/k8s-configmap/</url>
    
    <content type="html"><![CDATA[<blockquote><p>说明：文章的部分地方会用 <code>cm</code> 来指代 <code>ConfigMap</code></p></blockquote><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>做过开发的同学都遇到过给程序进行配置的场景，比如非常常见的配置文件，将 Mysql 的地址、端口、用户名、密码等信息写到一个配置文件里，然后程序内部通过读取这个配置文件来获取信息，防止了硬编码信息到程序内部，这样如果发生变动只需要修改配置文件即可，无需重新编译整个程序；另一种常见的方式是运行程序时指定参数来进行配置，比如 Go 标准库里的 flag 包就可以方便的进行参数指定，然后运行时只要使用诸如 <code>go run main.go -a 123 -b 456</code> 这样的方式，便可读取到配置信息，比如在这个例子里传递了两个参数：a&#x3D;123，b&#x3D;456</p><p>那么在 k8s 中如何对容器进行配置呢？</p><h2 id="在-docker-中定义命令与参数"><a href="#在-docker-中定义命令与参数" class="headerlink" title="在 docker 中定义命令与参数"></a>在 docker 中定义命令与参数</h2><p>容器中运行的完整指令由两部分组成：命令和参数，比如 <code>./main -a 123</code>，main 就是命令，-a 就是参数，在 Dockerfile 中分别对应的是 ENTRYPOINT（命令）和 CMD（参数）。</p><p>实战：</p><p>准备一个 Dockerfile，内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:latest<br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update ; apt-get -y install fortune <span class="hljs-comment"># 安装 fortune</span></span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> fortuneloop.sh /bin/fortuneloop.sh</span><br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/fortuneloop.sh&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;10&quot;</span>] <span class="hljs-comment"># 每隔 10s 输出一次</span></span><br></code></pre></td></tr></table></figure><p>可以看到其通过 ADD 命令将本地的 fortuneloop.sh 拷贝到了容器内的 &#x2F;bin&#x2F; 目录下，然后指定了 ENTRYPOINT 和 CMD，等同于命令 <code>/bin/fortuneloop.sh 10</code>，也就是说构建出来的镜像实际会执行 <code>/bin/fortuneloop.sh 10</code> 这样一条命令。</p><p>在 Dockerfile 的同目录下准备一个名为 fortuneloop.sh 的文件，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>trap &quot;exit&quot; SIGINT<br><br>INTERVAL=$1 # 读取第一个参数，比如执行 fortuneloop.sh 10，那么 $1=10<br>echo Configured to generate new fortune every $INTERVAL seconds<br><br>mkdir -p /var/htdocs<br><br>while :<br>do<br>  echo $(date) Writing fortune to /var/htdocs/index.html<br>  /usr/games/fortune &gt; /var/htdocs/index.html # 执行 fortune 命令，将输出的内容写入到 index.html<br>  sleep $INTERVAL # 睡眠指定的时间<br>done<br></code></pre></td></tr></table></figure><p>接下来构建并运行，因为我的电脑是 arm 架构的，所以我给构建的镜像名加了一个  arm64 后缀：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">构建镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t stdoutt/fortune-args-arm64 .</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it stdoutt/fortune-args-arm6</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">观察效果</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">每隔 10s 就会打印一次</span><br>Configured to generate new fortune every 10 seconds<br>Sun Sep 25 02:23:01 UTC 2022 Writing fortune to /var/htdocs/index.html<br>Sun Sep 25 02:23:11 UTC 2022 Writing fortune to /var/htdocs/index.html<br></code></pre></td></tr></table></figure><p>因为在 Dockerfile 的 CMD 中指定值为 10，所以默认会每隔 10 秒打印一次，也可以自己指定值将默认值覆盖掉，比如下面我将其替换为了 1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it stdoutt/fortune-args-arm6 1</span><br>Configured to generate new fortune every 1 seconds<br>Sun Sep 25 02:24:55 UTC 2022 Writing fortune to /var/htdocs/index.html<br>Sun Sep 25 02:24:56 UTC 2022 Writing fortune to /var/htdocs/index.html<br>Sun Sep 25 02:24:57 UTC 2022 Writing fortune to /var/htdocs/index.html<br></code></pre></td></tr></table></figure><p>现在每间隔 1s 就会打印一次。</p><h2 id="在-k8s-中定义命令与参数"><a href="#在-k8s-中定义命令与参数" class="headerlink" title="在 k8s 中定义命令与参数"></a>在 k8s 中定义命令与参数</h2><p>在 k8s 中定义容器时，可以覆盖掉镜像的 ENTRYPOINT 和 CMD，通过 command 和 args 来指定，类似一下这种形式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span> <br><span class="hljs-attr">spec:</span><br><span class="hljs-attr">containers:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">some/image</span><br>  <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/command&quot;</span>]  <span class="hljs-comment"># 等同于 Dockerfile 中的 ENTRYPOINT</span><br><span class="hljs-attr">args:</span> [<span class="hljs-string">&quot;argl&quot;</span>, <span class="hljs-string">&quot;arg2&quot;</span>, <span class="hljs-string">&quot;arg3&quot;</span>] <span class="hljs-comment"># 等同于 Dockerfile 中的 CMD</span><br></code></pre></td></tr></table></figure><p>其中 command 等同于 Dockerfile 中的 ENTRYPOINT，args 等同于 Dockerfile 中的 CMD</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>yaml 如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fortune2s</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br><span class="hljs-comment"># - image: luksa/fortune:args # amd64 架构的用这个镜像</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/fortune-args-arm64</span> <span class="hljs-comment"># 注意此 image 仅适用于 arm64</span><br>    <span class="hljs-attr">args:</span> [<span class="hljs-string">&quot;2&quot;</span>] <span class="hljs-comment"># 等同于 Dockerfile 中的 CMD</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">html-generator</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/htdocs</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web-server</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>测试效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 pod</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f fortune-pod-args.yaml</span><br>pod/fortune2s created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启端口转发</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl port-forward fortune2s 8080:80</span><br>Forwarding from 127.0.0.1:8080 -&gt; 80<br>Forwarding from [::1]:8080 -&gt; 80<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">每隔 2s （和 args 中定义的一样）curl 一次，因为 args 也定义为 2s，代表每 2s 写入一次谚语，所以</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">每次 curl 都应该输出不同的内容</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> curl localhost:8080;<span class="hljs-built_in">sleep</span> 2s;<span class="hljs-keyword">done</span></span><br>Wagner&#x27;s music is better than it sounds.<br>-- Mark Twain<br>You plan things that you do not even attempt because of your extreme caution.<br>You never hesitate to tackle the most difficult problems.<br>The lovely woman-child Kaa was mercilessly chained to the cruel post of<br>the warrior-chief Beast, with his barbarian tribe now stacking wood at<br>her nubile feet, when the strong clear voice of the poetic and heroic<br>Handsomas roared, &#x27;Flick your Bic, crisp that chick, and you&#x27;ll feel my<br>steel through your last meal!&#x27;<br>-- Winning sentence, 1984 Bulwer-Lytton bad fiction contest.<br></code></pre></td></tr></table></figure><h2 id="在容器定义中指定环境变量"><a href="#在容器定义中指定环境变量" class="headerlink" title="在容器定义中指定环境变量"></a>在容器定义中指定环境变量</h2><p><strong>Dockerfile</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:latest<br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update ; apt-get -y install fortune</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> fortuneloop.sh /bin/fortuneloop.sh</span><br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/fortuneloop.sh&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>fortuneloop.sh</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>trap &quot;exit&quot; SIGINT<br><br>echo Configured to generate new fortune every $INTERVAL seconds<br><br>mkdir -p /var/htdocs<br><br>while :<br>do<br>  echo $(date) Writing fortune to /var/htdocs/index.html<br>  /usr/games/fortune &gt; /var/htdocs/index.html<br>  sleep $INTERVAL # 读取 INTERVAL 这个环境变量<br>done<br></code></pre></td></tr></table></figure><p><strong>fortune-pod-env.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-env</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/fortune-env-arm64</span> <span class="hljs-comment"># 注意此 image 仅适用于 arm64</span><br>    <span class="hljs-attr">env:</span> <span class="hljs-comment"># 在这里设置环境变量，用于 fortuneloop.sh 的读取</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">INTERVAL</span><br>      <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;5&quot;</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">html-generator</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/htdocs</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web-server</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>测试效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f fortune-env.yaml</span><br>pod/fortune-env created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>fortune2s     2/2     Running   0          84m<br>fortune-env   2/2     Running   0          18s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl port-forward fortune-env 8080:80</span><br>Forwarding from 127.0.0.1:8080 -&gt; 80<br>Forwarding from [::1]:8080 -&gt; 80<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> curl localhost:8080;<span class="hljs-built_in">sleep</span> 5s;<span class="hljs-keyword">done</span> <span class="hljs-comment"># sleep 同样的时间</span></span><br>It may or may not be worthwhile, but it still has to be done.<br>When I reflect upon the number of disagreeable people who I know who have gone<br>to a better world, I am moved to lead a different life.<br>-- Mark Twain, &quot;Pudd&#x27;nhead Wilson&#x27;s Calendar&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里额外测试一下，环境变量里设置的值是 5，也就是每 5s 生成一句新谚语并写入 index.html，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">但是这里每隔 1s 就 curl 一次，会发现前 5 此输出的内容都相同</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> curl localhost:8080;<span class="hljs-built_in">sleep</span> 1s;<span class="hljs-keyword">done</span></span><br>You will be surrounded by luxury.<br>You will be surrounded by luxury.<br>You will be surrounded by luxury.<br>You will be surrounded by luxury.<br>You will be surrounded by luxury.<br>Q:What happens when four WASPs find themselves in the same room?<br>A:A dinner party.<br></code></pre></td></tr></table></figure><h1 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h1><p>上面的方式都是直接在 pod 中硬编码的，就像 <code>- name: INTERVAL  value: &quot;5&quot;</code> 这样，如果之后需要更改 value 的值，那么需要修改 pod 的 yaml，然后删除旧的重新创建新的（这里还待验证），比较麻烦。</p><p>ConfigMap 将配置相关的内容抽取出来做成了一个单独的部分，然后 pod 再引用 ConfigMap 即可（又是万能的解决方法：加一层中间层），相比较直接在 pod spec 中的硬编码而言更加灵活。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>使用 <code>create</code> 命令而不是 yaml 来创建一个 configmap（之后简称为 cm），通过 <code>--from-literal</code> 来指定键值对（kv），形式为：–from-literal&#x3D;[key]&#x3D;[value]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create configmap fortune-config --from-literal=sleep-interval=25</span><br>configmap/fortune-config created<br></code></pre></td></tr></table></figure><p>通过指定多个 <code>--from-literal</code> 来添加多个 kv：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create configmap myconfigmap --from-literal=foo=bar --from-literal=bar=baz --from-literal=one=two</span><br>configmap/myconfigmap created<br></code></pre></td></tr></table></figure><p>查看 cm 的 yaml：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get cm myconfigmap -o yaml</span><br>apiVersion: v1<br>data:<br>  bar: baz<br>  foo: bar<br>  one: two<br>kind: ConfigMap<br>metadata:<br>  creationTimestamp: &quot;2022-06-07T11:39:32Z&quot;<br>  name: myconfigmap<br>  namespace: default<br>  resourceVersion: &quot;73938&quot;<br>  uid: c9814e7e-f3f9-4149-8530-74ea963420d9<br></code></pre></td></tr></table></figure><p>发现其实定义的 kv 都在 <code>data</code> 里，<code>metadata</code> 里唯一需要明确指定的是 <code>name</code>，所以通过 yaml 的形式来创建 cm 也比较简单</p><p>如果添加两个同样的 key 会怎样？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create configmap fortune-config1 --from-literal=sleep-interval=25 --from-literal=sleep-interval=30</span><br>error: cannot add key &quot;sleep-interval&quot;, another key by that name already exists in Data for ConfigMap &quot;fortune-config1&quot;<br></code></pre></td></tr></table></figure><p>可以看到直接创建失败了</p><p>cm 还可以将某个文件的内容作为 value 值，使用 <code>--from-file</code> 来引用文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create cm my-config --from-file=conf.conf</span><br>configmap/my-config created<br></code></pre></td></tr></table></figure><p><code>conf.conf</code> 内容如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span>:<span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">a</span>:<span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span>:<span class="hljs-selector-tag">b</span><br>c:c<br>d:d<br></code></pre></td></tr></table></figure><p>查看该 cm 的 yaml：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get cm my-config -o yaml</span><br>apiVersion: v1<br>data:<br>  conf.conf: |<br>    a:a<br>    b:b<br>    c:c<br>    d:d<br>kind: ConfigMap<br>metadata:<br>  creationTimestamp: &quot;2022-06-07T12:58:09Z&quot;<br>  name: my-config<br>  namespace: default<br>  resourceVersion: &quot;77327&quot;<br>  uid: 2937d396-8692-4c16-8798-236fc4015299<br></code></pre></td></tr></table></figure><p>发现这里是用文件名来做 key 的，value 就是文件的内容，只不过不是常规的 key:value 形式，而是在 key: 后多加了一个 |，之后才是 value</p><p>同样也可以通过指定多个 <code>--from-file</code> 来引用多个文件作为 cm 的条目，比如（这里我还专门测试了一下该 flag 是否对文件后缀有要求，我传入了一个 txt，这不是常见的配置文件后缀）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create cm my-config1 --from-file=conf.conf --from-file conf.txt</span><br>configmap/my-config1 created<br></code></pre></td></tr></table></figure><p>查看 yaml：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get cm my-config1 -o yaml</span><br>apiVersion: v1<br>data:<br>  conf.conf: |<br>    a:a<br>    b:b<br>    c:c<br>    d:d<br>  conf.txt: |<br>    大数据断开了撒娇漏打卡所经历的卡所经历的<br>kind: ConfigMap<br>metadata:<br>  creationTimestamp: &quot;2022-06-07T13:13:16Z&quot;<br>  name: my-config1<br>  namespace: default<br>  resourceVersion: &quot;77980&quot;<br>  uid: 3332d608-4184-48bc-8481-bd78ccf8b312<br></code></pre></td></tr></table></figure><p>貌似这里是直接简单粗暴的把文件内容作为 value 了，至于文件后缀是什么，cm 不会去考虑，不过想想确实也只能这么做，毕竟配置文件后缀非常多，conf、yaml、toml 等等，可能还有一些冷门的格式，如果要专门维护一个允许的后缀列表显然太麻烦了，也没啥太大必要。</p><p>上面的 key 都是直接使用文件名，如果想自行指定，可以使用类似下面的语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create cm my-config1 --from-file=myconf=conf.conf</span><br></code></pre></td></tr></table></figure><p>这里设置 key 为 myconf，也就是说格式是：–from-file&#x3D;[自定义 key 名]&#x3D;[value]</p><h2 id="给容器传递-ConfigMap-作为环境变量"><a href="#给容器传递-ConfigMap-作为环境变量" class="headerlink" title="给容器传递 ConfigMap 作为环境变量"></a>给容器传递 ConfigMap 作为环境变量</h2><p><strong>fortune-pod-env-configmap.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-env-from-configmap</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/fortune-env-arm64</span> <span class="hljs-comment"># 注意该 image 仅适用于 arm64</span><br>    <span class="hljs-attr">env:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">INTERVAL</span><br>      <span class="hljs-attr">valueFrom:</span> <span class="hljs-comment"># 引用 fortune-config 这个 configmap 中的，key 为 sleep-interval 对应的 value</span><br>        <span class="hljs-attr">configMapKeyRef:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-config</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">sleep-interval</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">html-generator</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/htdocs</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web-server</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="如果引用的-ConfigMap-不存在会怎样"><a href="#如果引用的-ConfigMap-不存在会怎样" class="headerlink" title="如果引用的 ConfigMap 不存在会怎样"></a>如果引用的 ConfigMap 不存在会怎样</h3><p>测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f fortune-pod-env-configmap.yaml</span><br>pod/fortune-env-from-configmap created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                         READY   STATUS                       RESTARTS   AGE<br>fortune2s                    2/2     Running                      0          117m<br>fortune-env                  2/2     Running                      0          33m<br>fortune-env-from-configmap   1/2     CreateContainerConfigError   0          2m27s<br></code></pre></td></tr></table></figure><p>发现当前 pod 的状态是 CreateContainerConfigError，这是肯定的，env 会从名为 keyfortune-config 的 configMap 中读取，但是现在没有创建这个 configMap，所以当然无法正常启动</p><p>查看 describe 也会发现有相应的警告：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Warning</span>  <span class="hljs-string">Failed</span>     <span class="hljs-string">80s</span> <span class="hljs-string">(x7</span> <span class="hljs-string">over</span> <span class="hljs-string">2m28s)</span>  <span class="hljs-attr">kubelet            Error:</span> <span class="hljs-string">configmap</span> <span class="hljs-string">&quot;fortune-config&quot;</span> <span class="hljs-string">not</span> <span class="hljs-string">found</span><br></code></pre></td></tr></table></figure><p>需要创建一个 configMap 来解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建一个 configMap，同时向其中写入 sleep-interval=5</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create configmap fortune-config --from-literal=sleep-interval=5</span><br>configmap/fortune-config created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在创建完 configMap 之后，之前的 pod 立马成功运行了</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                         READY   STATUS    RESTARTS   AGE<br>fortune2s                    2/2     Running   0          121m<br>fortune-env                  2/2     Running   0          37m<br>fortune-env-from-configmap   2/2     Running   0          7m3s<br></code></pre></td></tr></table></figure><p>也就是说如果引用的 ConfigMap 不存在，那么 pod 会创建失败，当所需要的 ConfigMap 被创建后，这个失败的 pod 会自动重启，无须重新创建 pod。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl port-forward fortune-env 8080:80</span><br>Forwarding from 127.0.0.1:8080 -&gt; 80<br>Forwarding from [::1]:8080 -&gt; 80<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> curl localhost:8080;<span class="hljs-built_in">sleep</span> 5s;<span class="hljs-keyword">done</span></span><br>You&#x27;ll feel much better once you&#x27;ve given up hope.<br>When I reflect upon the number of disagreeable people who I know who have gone<br>to a better world, I am moved to lead a different life.<br>-- Mark Twain, &quot;Pudd&#x27;nhead Wilson&#x27;s Calendar&quot;<br></code></pre></td></tr></table></figure><h2 id="给容器传递-ConfigMap-作为参数"><a href="#给容器传递-ConfigMap-作为参数" class="headerlink" title="给容器传递 ConfigMap 作为参数"></a>给容器传递 ConfigMap 作为参数</h2><p>pod.spec.containers.args 不能直接引用 ConfigMap 中的条目，但是可以”曲线救国“，将 ConfigMap 中的条目设置为一个环境变量，然后再让 args 来引用这个环境变量，便可达到效果。</p><p><strong>fortune-pod-args-configmap.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-args-from-configmap</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/fortune-args-arm64</span> <span class="hljs-comment"># 注意该 image 仅适用于 arm64</span><br>    <span class="hljs-attr">env:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">INTERVAL</span> <span class="hljs-comment"># 这个环境变量引用了 fortune-config 中的 sleep-interval 条目</span><br>      <span class="hljs-attr">valueFrom:</span> <br>        <span class="hljs-attr">configMapKeyRef:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-config</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">sleep-interval</span><br>    <span class="hljs-attr">args:</span> [<span class="hljs-string">&quot;$(INTERVAL)&quot;</span>] <span class="hljs-comment"># 引用 INTERVAL 这个环境变量</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">html-generator</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/htdocs</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web-server</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>测试效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f fortune-pod-args-configmap.yaml</span><br>pod/fortune-args-from-configmap created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                          READY   STATUS    RESTARTS   AGE<br>fortune2s                     2/2     Running   0          7h13m<br>fortune-env                   2/2     Running   0          5h49m<br>fortune-env-from-configmap    2/2     Running   0          5h18m<br>fortune-args-from-configmap   2/2     Running   0          5s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl port-forward fortune-env 8080:80</span><br>Forwarding from 127.0.0.1:8080 -&gt; 80<br>Forwarding from [::1]:8080 -&gt; 80<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> curl localhost:8080;<span class="hljs-built_in">sleep</span> 5s;<span class="hljs-keyword">done</span></span><br>What good is an obscenity trial except to popularize literature?<br>-- Nero Wolfe, &quot;The League of Frightened Men&quot;<br>They spell it &quot;da Vinci&quot; and pronounce it &quot;da Vinchy&quot;.  Foreigners<br>always spell better than they pronounce.<br>-- Mark Twain<br>Give your very best today.  Heaven knows it&#x27;s little enough.<br></code></pre></td></tr></table></figure><h2 id="使用-ConfigMap-卷"><a href="#使用-ConfigMap-卷" class="headerlink" title="使用 ConfigMap 卷"></a>使用 ConfigMap 卷</h2><p><del>前面提到的环境变量或者是参数的方式比较适用于配置数量较少的情况，如果配置数量过多，那么就不太适合了，此外还有一些特殊的配置文件格式，比如 nginx ，也不太适合。</del>（待修改）</p><p>还可以将 ConfigMap <del>挂载（感觉挂载这个词有点不太合适）</del> 做成一个 <strong>卷</strong>，然后 pod 中的容器可以将这个卷挂载到自己的某个目录下，来完成配置，比如一个 nginx 容器可以将卷挂载到自己的 &#x2F;etc&#x2F;nginx&#x2F;conf.d 目录下，就可以读取卷中的配置信息。</p><p><strong>configMap 卷会将 ConfigMap 中的每个条目均暴露成一个文件</strong>。 运行在容器中的进程可通过读取文件内容获得对应的条目值。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>创建一个文件夹 <strong>configmap-files</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> configmap-files</span><br></code></pre></td></tr></table></figure><p>然后向里面写入下面的这两个文件：</p><p><strong>my-nginx-config.conf</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>              <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>         www.kubia-example.com;<br><br>    <span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">gzip_types</span> text/plain application/xml;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>sleep-interval</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">25<br></code></pre></td></tr></table></figure><p>查看文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span><br>.<br>├── my-nginx-config.conf<br>└── sleep-interval<br></code></pre></td></tr></table></figure><p>创建一个 cm，将这个文件夹作为 value</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create configmap fortune-config --from-file=configmap-files</span><br>error: failed to create configmap: configmaps &quot;fortune-config&quot; already exists<br></code></pre></td></tr></table></figure><p>发现之前以及存在同名的 cm 了，看来重复创建 cm 不能覆盖更新，必须要删除旧的才能创建新的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get cm</span><br>NAME               DATA   AGE<br>kube-root-ca.crt   1      21h<br>fortune-config     1      6h4m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete cm fortune-config</span><br>configmap &quot;fortune-config&quot; deleted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create configmap fortune-config --from-file=configmap-files</span><br>configmap/fortune-config created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 cm</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get cm fortune-config -o yaml</span><br>apiVersion: v1<br>data:<br>  my-nginx-config.conf: |<br>    server &#123;<br>        listen              80;<br>        server_name         www.kubia-example.com;<br><br>        gzip on;<br>        gzip_types text/plain application/xml;<br><br>        location / &#123;<br>            root   /usr/share/nginx/html;<br>            index  index.html index.htm;<br>        &#125;<br><br>    &#125;<br>  sleep-interval: |<br>    25<br>kind: ConfigMap<br>metadata:<br>  creationTimestamp: &quot;2022-09-25T11:05:49Z&quot;<br>  name: fortune-config<br>  namespace: default<br>  resourceVersion: &quot;12886&quot;<br>  uid: c9f5ee8a-9078-46cc-955a-3ec72c6ceb62<br></code></pre></td></tr></table></figure><p>发现该 cm 有两个条目，条目名就是目标文件夹下的每个文件的文件名，value 就是文件内容</p><p>接下来定义一个 pod，这个 pod 里的 nginx 容器会将 configMap 卷挂载到自己的 &#x2F;etc&#x2F;nginx&#x2F;conf.d 目录下，而 nginx 会自动将该路径下的所有以 conf 为后缀的文件嵌入到默认配置文件中，而 configMap 卷里面刚好有我们定义的开启了 gzip 的配置文件 my-nginx-config.conf，nginx 读取这个文件来开启 gzip，而卷中的另一个文件 sleep-interval 因为不是以 conf 为后缀的，所以 nginx 不会将其内容嵌入到配置文件。</p><p><strong>fortune-configmap-volume</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-configmap-volume</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/fortune-env-arm64</span><br>    <span class="hljs-attr">env:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">INTERVAL</span> <span class="hljs-comment"># 从 fortune-config 这个 configmap 中读取 sleep-interval，用其值填充环境变量 INTERVAL</span><br>      <span class="hljs-attr">valueFrom:</span><br>        <span class="hljs-attr">configMapKeyRef:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-config</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">sleep-interval</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">html-generator</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/htdocs</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web-server</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/nginx/conf.d</span> <span class="hljs-comment"># 将 config 卷挂载到该路径下</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/tmp/whole-fortune-config-volume</span> <span class="hljs-comment"># 将 config 卷挂载到该路径下</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>        <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span> <span class="hljs-comment"># 定义一个名为 config 的卷，卷引用了 fortune-config 这个 cm 里的内容，会将每个条目做成一个文件</span><br>    <span class="hljs-attr">configMap:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-config</span><br></code></pre></td></tr></table></figure><p>测试效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f fortune-pod-configmap-volume.yaml</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                          READY   STATUS    RESTARTS   AGE<br>fortune-configmap-volume      2/2     Running   0          13s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl port-forward fortune-configmap-volume 8080:80</span><br>Forwarding from 127.0.0.1:8080 -&gt; 80<br>Forwarding from [::1]:8080 -&gt; 80<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -H <span class="hljs-string">&quot;Accept-Encoding: gzip&quot;</span> -I localhost:8080</span><br>HTTP/1.1 200 OK<br>Server: nginx/1.23.1<br>Date: Sun, 25 Sep 2022 11:38:16 GMT<br>Content-Type: text/html<br>Last-Modified: Sun, 25 Sep 2022 11:38:06 GMT<br>Connection: keep-alive<br>ETag: W/&quot;63303d9e-135&quot;<br>Content-Encoding: gzip # 这里说明已经开启了 gzip 压缩，配置文件已经生效<br></code></pre></td></tr></table></figure><p>验证挂载：</p><p>前面提到过 ConfigMap 卷会将 config 中的每个条目单独做成一个文件，我们实际验证一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入 web-server 这个容器</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it fortune-configmap-volume -c web-server -- /bin/sh</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">看一下挂载路径</span><br>/ # ls /tmp/whole-fortune-config-volume/<br>my-nginx-config.conf  sleep-interval<br><br>/ # ls /etc/nginx/conf.d<br>my-nginx-config.conf  sleep-interval<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">发现 configMap 卷全部都被挂载了，且里面有两个文件，每个文件对应 cm 中的一个条目</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出一下文件内容</span><br>/ # cat /etc/nginx/conf.d/sleep-interval<br>25<br><br>/ # cat /tmp/whole-fortune-config-volume/my-nginx-config.conf<br>server &#123;<br>    listen              80;<br>    server_name         www.kubia-example.com;<br><br>    gzip on;<br>    gzip_types text/plain application/xml;<br><br>    location / &#123;<br>        root   /usr/share/nginx/html;<br>        index  index.html index.htm;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="只挂载-ConfigMap-中的部分条目"><a href="#只挂载-ConfigMap-中的部分条目" class="headerlink" title="只挂载 ConfigMap 中的部分条目"></a>只挂载 ConfigMap 中的部分条目</h3><p>上面的例子存在一个问题：sleep-interval 这个配置文件也被挂载到了 nginx 的目录下，但是该配置文件与 nginx 是没任何关系的，为了解决这个问题，可以用指定 items 的方式，如下：</p><p><strong>fortune-pod-configmap-volume-with-items</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-configmap-volume-with-items</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/fortune-env-arm64</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">html-generator</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/htdocs</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web-server</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/nginx/conf.d/</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><br>    <span class="hljs-attr">configMap:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-config</span><br>      <span class="hljs-attr">items:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">my-nginx-config.conf</span> <span class="hljs-comment"># 引用 cm 中的 my-nginx-config.conf 这条条目</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">gzip.conf</span> <span class="hljs-comment"># 将这条条目的内容放到一个名为 gzip.conf 的文件中</span><br></code></pre></td></tr></table></figure><p>测试效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f fortune-pod-configmap-volume-with-items</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                                  READY   STATUS    RESTARTS   AGE<br>fortune2s                             2/2     Running   0          10h<br>fortune-env                           2/2     Running   0          8h<br>fortune-env-from-configmap            2/2     Running   0          8h<br>fortune-args-from-configmap           2/2     Running   0          171m<br>fortune-configmap-volume              2/2     Running   0          92m<br>fortune-configmap-volume-with-items   2/2     Running   0          14s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it fortune-configmap-volume-with-items -c web-server -- /bin/sh</span><br>/ # ls /etc/nginx/<br>conf.d/         fastcgi_params  modules/        scgi_params<br>fastcgi.conf    mime.types      nginx.conf      uwsgi_params<br>/ # ls /etc/nginx/conf.d<br>gzip.conf<br>/ # cat /etc/nginx/conf.d/gzip.conf<br>server &#123;<br>    listen              80;<br>    server_name         www.kubia-example.com;<br><br>    gzip on;<br>    gzip_types text/plain application/xml;<br><br>    location / &#123;<br>        root   /usr/share/nginx/html;<br>        index  index.html index.htm;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到挂载的目录 &#x2F;etc&#x2F;nginx&#x2F;conf.d 下只有 gzip.conf 这一个文件了，之前的 sleep-interval 文件已经没有了，并且 gzip.conf 文件的内容就是 configMap 中 my-nginx-config.conf 这个条目的内容。</p><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><p>使用环境变量或者命令行参数作为配置源的弊端在于无法在进程运行时更新配置，也就是说如果配置信息发生了变化，需要重启应用来重新读取，达到更新的效果。 而将 ConfigMap 暴露为卷可以达到配置热更新的效果，也就是无须重新创建 pod 或者重启容器。</p><p>使用 kubectl edit 修改 ConfigMap：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl edit cm fortune-config</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Please edit the object below. Lines beginning with a <span class="hljs-string">&#x27;#&#x27;</span> will be ignored,</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">and an empty file will abort the edit. If an error occurs <span class="hljs-keyword">while</span> saving this f</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">reopened with the relevant failures.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash">apiVersion: v1</span><br>data:<br>  my-nginx-config.conf: |<br>    server &#123;<br>        listen              80;<br>        server_name         www.kubia-example.com;<br><br>        gzip on;<br>        gzip_types text/plain application/xml;<br><br>        location / &#123;<br>            root   /usr/share/nginx/html;<br>            index  index.html index.htm;<br>        &#125;<br><br>    &#125;<br>  sleep-interval: |<br>    25<br>kind: ConfigMap<br>metadata:<br>  creationTimestamp: &quot;2022-09-25T11:05:49Z&quot;<br>  name: fortune-config<br>  namespace: default<br>  resourceVersion: &quot;12886&quot;<br>  uid: c9f5ee8a-9078-46cc-955a-3ec72c6ceb62<br>~<br>~<br>~<br>- /tmp/kubectl-edit-4270724913.yaml 12/29 41%<br></code></pre></td></tr></table></figure><p>和 vim 一样，按下 i，将 <code>gzip on</code> 修改为 <code>gzip off</code>，然后 esc，输入 :wq，退出并保存，输出 <code>configmap/fortune-config edited</code></p><p>查看修改是否生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it fortune-configmap-volume-with-items -c web-server -- <span class="hljs-built_in">cat</span> /etc/nginx/conf.d/gzip.conf</span><br>server &#123;<br>    listen              80;<br>    server_name         www.kubia-example.com;<br><br>    gzip off;<br>    gzip_types text/plain application/xml;<br><br>    location / &#123;<br>        root   /usr/share/nginx/html;<br>        index  index.html index.htm;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>发现修改已经生效</p><p>配置文件已经修改，继续测试一下 nginx 这边是否生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl port-forward fortune-configmap-volume 8080:80</span><br>Forwarding from 127.0.0.1:8080 -&gt; 80<br>Forwarding from [::1]:8080 -&gt; 80<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -H <span class="hljs-string">&quot;Accept-Encoding: gzip&quot;</span> -I localhost:8080</span><br>HTTP/1.1 200 OK<br>Server: nginx/1.23.1<br>Date: Sun, 25 Sep 2022 13:27:14 GMT<br>Content-Type: text/html<br>Last-Modified: Sun, 25 Sep 2022 13:26:55 GMT<br>Connection: keep-alive<br>ETag: W/&quot;6330571f-c6&quot;<br>Content-Encoding: gzip<br></code></pre></td></tr></table></figure><p>发现依然输出了 <code>Content-Encoding: gzip</code> ，这是因为虽然修改了配置文件，但是 nginx 并不会监听配置文件并作出响应，所以不会更新 gzip 的状态将其 off，需要手动通知 nginx ，告诉它配置文件发生了变化，需要你重新读取一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it fortune-configmap-volume-with-items -c web-server -- nginx -s reload</span><br>2022/09/25 13:30:40 [notice] 39#39: signal process started<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -H <span class="hljs-string">&quot;Accept-Encoding: gzip&quot;</span> -I localhost:8080</span><br>HTTP/1.1 200 OK<br>Server: nginx/1.23.1<br>Date: Sun, 25 Sep 2022 13:32:37 GMT<br>Content-Type: text/html<br>Content-Length: 27<br>Last-Modified: Sun, 25 Sep 2022 13:32:37 GMT<br>Connection: keep-alive<br>ETag: &quot;63305875-1b&quot;<br>Accept-Ranges: bytes<br></code></pre></td></tr></table></figure><p>此时发现 <code>Content-Encoding: gzip</code> 已经没有了，表示 nginx 这边也已经生效了</p><p>整个过程都没有重启或者重建过 pod，但是最终也达到了更新配置的效果，所以可以做到热更新。</p><p>但是对 k8s 而言，它只是保证在更新 ConfigMap 后同步修改其对应的 ConfigMap 卷，但是对于引用这个 ConfigMap 的应用，k8s 就管不到了，如果应用不会对配置文件的修改作出响应，或者类似 nginx 提供一个重新载入的命令，那么可能最终还是需要重启或者重建 pod（个人猜测）</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go GC 白话版</title>
    <link href="/2022/06/01/go-gc/"/>
    <url>/2022/06/01/go-gc/</url>
    
    <content type="html"><![CDATA[<h1 id="主流的垃圾回收算法"><a href="#主流的垃圾回收算法" class="headerlink" title="主流的垃圾回收算法"></a>主流的垃圾回收算法</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>根据对象自身的引用计数来回收，当引用计数归零时进行回收，但是计数频繁更新会带来更多开销，且无法解决循环引用的问题。</p><ul><li>优点：简单直接，回收速度快</li><li>缺点：需要额外的空间存放计数，无法处理循环引用的情况；</li></ul><h2 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h2><p>标记出所有不需要回收的对象，在标记完成后统一回收掉所有未被标记的对象。</p><ul><li>优点：简单直接，速度快，适合可回收对象不多的场景</li><li>缺点：会造成不连续的内存空间（内存碎片），导致有大的对象创建的时候，明明内存中总内存是够的，但是空间不是连续的造成对象无法分配，此外还需要 <strong>STW</strong> 来确保标记清除过程不被外部影响（比如 GC 前脚刚把一个对象标记为可达，用户程序后脚就释放了它）；<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1654446334006.jpg"><br>（内存碎片)</li></ul><blockquote><p>STW（Stop The World，Start The World）</p><p>通常意义上指的是从 Stop The World 到 Start The World 这一段时间间隔。垃圾回收过程中为了保证准确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图以完成垃圾回收。STW 时间越长，对用户代码造成的影响越大。</p></blockquote><h2 id="标记整理法"><a href="#标记整理法" class="headerlink" title="标记整理法"></a>标记整理法</h2><p>这种算法用于解决 <strong>标记清除法</strong> 的内存碎片问题，它的标记阶段与标记清除法相同，但是会在完成标记工作后，移动非垃圾数据，使它们尽可能紧凑的放在内存中。<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1654446315708.jpg"></p><ul><li>优点：解决了内存碎片的问题</li><li>缺点：性能低，因为在移动对象的时候不仅需要移动对象还要维护对象的引用地址，可能需要对内存经过几次扫描才能完成</li></ul><h2 id="复制回收法"><a href="#复制回收法" class="headerlink" title="复制回收法"></a>复制回收法</h2><p>和 <strong>标记整理法</strong> 一样，这种算法也是为了解决内存碎片问题，也会移动数据，它把堆内存划分为两个相等的空间 From 和 To，程序执行时使用 From 空间，垃圾回收执行时，会扫描 From 空间，把能追踪到的数据复制到 To 空间，当所有有用的数据都复制到 To 空间后，把 From 和 To 空间的角色交换一下，原来的 From 空间可以全部回收作为新的 To 空间；原来的 To 空间因为保存的都是有用的数据，所以可以作为新的 From 空间。<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1654446282139.jpg"></p><ul><li>优点：解决了内存碎片的问题，每次清除针对的都是整块内存，但是因为移动对象需要耗费时间，效率低于标记清除法；</li><li>缺点：只有一半的堆内存可以使用，导致堆内存使用效率低。为了提高内存的使用率，通常会和其他垃圾回收算法搭配使用，只在一部分堆内存中使用复制回收，</li></ul><h2 id="分代式"><a href="#分代式" class="headerlink" title="分代式"></a>分代式</h2><p>将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。</p><h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><p>到这里才是真正的重头戏，因为 Go 采用的正是这种 GC 算法。</p><p>三色标记法将对象的颜色分为了黑、灰、白，三种颜色。</p><ul><li>黑色：该对象已经被标记过了，且该对象下的属性也全部都被标记过了（程序所需要的对象）；</li><li>灰色：该对象已经被标记过了，但该对象下的属性没有全被标记完（GC 需要从此对象中去寻找垃圾）；</li><li>白色：该对象没有被标记过（垃圾对象）；</li></ul><p>在垃圾收集器开始工作时，从 GC Roots 开始进行遍历访问，访问步骤可以分为下面几步：</p><ol><li>GC Roots 根对象会被标记成灰色；</li><li>然后从灰色集合中获取对象，将其标记为黑色，将该对象引用到的对象标记为灰色；</li><li>重复步骤 2，直到没有灰色集合可以标记为止；</li><li>结束后，剩下的没有被标记的白色对象即为 GC Roots 不可达，可以进行回收。<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1654446199885.png"></li></ol><blockquote><h3 id="❓GC-root-节点具体指哪些？"><a href="#❓GC-root-节点具体指哪些？" class="headerlink" title="❓GC root 节点具体指哪些？"></a>❓GC root 节点具体指哪些？</h3><p>说法1，来源： <a href="https://www.bilibili.com/video/BV1n5411H7qS?spm_id_from=333.999.0.0%EF%BC%8C2:30">https://www.bilibili.com/video/BV1n5411H7qS?spm_id_from=333.999.0.0，2:30</a> 秒</p><p>可以把栈、数据段（.data，全局变量）上的数据对象作为 root</p><p>说法 2，来源：<a href="https://www.luozhiyun.com/archives/475">https://www.luozhiyun.com/archives/475</a></p><p>GC 执行根节点的标记，这包括扫描所有的栈、全局对象以及不在堆中的运行时数据结构。</p><p>说法 3，来源：<a href="https://www.bookstack.cn/read/qcrao-Go-Questions/spilt.2.GC-GC.md">https://www.bookstack.cn/read/qcrao-Go-Questions/spilt.2.GC-GC.md</a></p><p>根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：</p><ol><li>全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。</li><li>执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。</li><li>寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。</li></ol></blockquote><p>前面提到过，这类标记清理算法都需要 STW 来保证垃圾回收过程不受影响，那么如果没有 STW 会发生什么问题呢？</p><p><strong>问题1：多标</strong></p><p>通俗的说，就是一个本该被回收的对象（白色），却被错误的标记成了非白色，导致本轮 GC 没有正确回收，导致产生浮动垃圾。</p><p>比如下面这张图：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1654445991637.png"></p><p>在步骤 2 中，GC 将 D 标记为了黑色，将 D 的可达对象 E 标记为了灰色，但在执行步骤 3 前，用户程序断开了 D 到 E 的引用（比如从 D &#x3D; E 变成 D &#x3D; null），此时 E 及其引用的 F，G 都会变为垃圾，因为它们都不再可达了，但是因为本轮扫描已经将 D 标记成黑色，且本轮不会再次对其进行扫描了，这会导致 GC 继续标记，将 E 从灰色变为黑色，E 的引用对象 F 和 G 标记为灰色，最后将 F 和 G 标记为黑色。至此，该轮 GC 结束，E，F，G 都被错误的标记为了黑色而没有被及时回收。</p><blockquote><p>🤔 写屏障可以解决上面这种情况吗？</p></blockquote><p><strong>问题2：漏标</strong></p><p>通俗的说，就是把一个有用的对象给错误的回收掉了，也就是悬挂指针问题。</p><p>比如下面这张图：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1654446000456.png"></p><p>在步骤 2 中，E 已经变为灰色，但在 GC 进一步标记之前，用户程序断开了 E 到 G 的引用，同时已经标记为黑色的 D 新增了对 G 的引用，之后 GC 标记时发现 E 到 G 已经不可达，便不会将 G 标记为灰色，而因为 D 已经是黑色不会再次扫描，所以也不会对 G 进行标记，最终，G 依然保持着白色，导致最后被 GC 清理。</p><p>从上面的示例中可以看到，如果标记清理阶段不使用 STW，也就是让 GC 和用户程序同时运行，就可能存在用户程序修改对象指向，影响 GC 正常工作的现象，所以 STW 是非用不可的。</p><p>但是现在问题来了，用 STW 会导致 GC 过程中整个程序不可用，不用 STW 又会出现内存错误，有没有什么办法可以尽可能的让用户程序和 GC 交替（并发）执行，减少 STW  造成的影响，同时又不会出现内存错误呢？比如 <strong>增量式回收</strong>，就是<strong>将 GC 过程分多次完成，也就是用户程序与垃圾回收交替执行</strong>，如下图：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1654446167140.jpg"></p><p>只要满足以下条件，就可以避免之前的内存问题了：</p><h3 id="强三色不变式"><a href="#强三色不变式" class="headerlink" title="强三色不变式"></a>强三色不变式</h3><p><strong>黑色对象不会引用白色对象</strong>，称为 <strong>强三色不变式</strong>，比如在 <strong>问题2：漏标</strong> 中，如果避免黑色对象 D 到白色对象 G 的引用，就不会出现错误回收的问题了。</p><h3 id="弱三色不变式"><a href="#弱三色不变式" class="headerlink" title="弱三色不变式"></a>弱三色不变式</h3><p><strong>黑色对象可以引用白色对象，前提是可以通过一个灰色对象抵达该白色对象</strong>，比如 A（黑）引用了 B（白色），而 C（灰色） 引用了 D（白色），D （白色）又引用了 B（白色），这种情况可以通过 C -&gt; D -&gt; B 抵达 B，这样 B 虽然被一个黑色对象引用，但是最终还是可达，不会被遗漏，这种情况称为 <strong>弱三色不变性</strong> 。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">A <span class="hljs-comment">(黑)</span> ------&gt; B <span class="hljs-comment">(白)</span><br>               ^<br>               |<br>               |<br>C <span class="hljs-comment">(灰)</span> ------&gt; D <span class="hljs-comment">(白)</span><br></code></pre></td></tr></table></figure><p>实现强弱三色不变式的通常做法是建立 <strong>读&#x2F;写屏障</strong>。</p><h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p><strong>写屏障</strong> 会在写操作中插入指令，目的是把对象的修改通知到垃圾回收器，比如当一个黑色对象尝试引用一个白色对象时，就会触发写屏障，此时为了保证 <strong>强三色不变式</strong>，就会将被引用的白色对象变为灰色，或者将引用白色对象的黑色对象变为灰色，这种写屏障属于 <strong>插入写屏障</strong> ；又或者是一个灰色对象尝试去除对一个白色对象的引用，为了保证 <strong>弱三色不变式</strong>，会将这个白色对象变为灰色，这种写屏障属于 <strong>删除写屏障</strong>。</p><h4 id="插入写屏障的缺点"><a href="#插入写屏障的缺点" class="headerlink" title="插入写屏障的缺点"></a>插入写屏障的缺点</h4><p><strong>插入写屏障</strong> 虽然实现非常简单并且也能保证强三色不变性，但是它也有明显的缺点。因为栈上的对象在垃圾收集中也会被认为是根对象，所以为了保证内存的安全，必须：</p><ul><li><strong>为栈上的对象增加写屏障</strong></li></ul><p> 或者</p><ul><li><strong>在标记阶段完成重新对栈上的对象进行扫描</strong></li></ul><p>这两种方法各有各的缺点，前者会大幅度增加写入指针的额外开销，后者重新扫描栈对象时需要暂停程序，垃圾收集算法的设计者需要在这两者之间做出权衡。</p><p>🤔 为什么为栈上的对象增加写屏障会大幅增加额外开销（感觉有点钻牛角尖的问题）</p><p>🤔 为什么需要重新扫描栈？以及为什么重新扫描栈需要 STW？</p><p>看下面这个例子：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/insert_barrier_1.png"><br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/insert_barrier_2.png"><br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/insert_barrier_3.png"><br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/insert_barrier_4.png"><br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/insert_barrier_5.png"><br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/insert_barrier_6.png"><br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/insert_barrier_7.png"><br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/insert_barrier_8.png"><br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/insert_barrier_9.png"><br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/insert_barrier_10.png"></p><h4 id="删除写屏障的缺点"><a href="#删除写屏障的缺点" class="headerlink" title="删除写屏障的缺点"></a>删除写屏障的缺点</h4><p>而 <strong>删除写屏障</strong> 会存在 <strong>回收效率低</strong> 的问题，因为当删除灰色对象到白色对象的引用时，会直接将白色对象赋为灰色，但是这个白色对象可能本身是垃圾，可以在本轮被清除了，但是却逃过了本轮的清理。比如：</p><p>黑 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 灰 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 白</p><p>如果在扫描到白之前，断开灰到白的连接，此时因为白是整个调用链的最后一个对象，所以将会成为垃圾，但是因为删除写屏障的存在，会将该白色对象变为灰色，导致本轮 GC 未被清理。</p><h3 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h3><p><strong>读屏障</strong> 适用于移动式垃圾回收，非移动式垃圾回收天然的不需要读屏障。像复制式回收这样会移动数据来避免碎片化，那么 GC 和用户程序交替执行时，读数据便也不那么安全了，比如下图：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1654446082893.jpg"></p><p>回收器已经将 A 从 From 复制到 To 空间了，之后交替执行的用户程序却读取了 From 空间中的老对象，并且在对象 B 中引用了这个老对象 A，而后续回收器复制 B 到 To 空间后，B 的新副本持有的依然是 A 的老对象指针，当 From 空间整体被回收时，因为 B 指向的依然是 From 空间的 A，所以访问便会出错。这种情况下，就需要建立读屏障，确保用户程序不会访问到老对象，例如在检测到引用对象已经存在新副本时，转而读取 To 空间的新副本。</p><h1 id="Go-GC"><a href="#Go-GC" class="headerlink" title="Go GC"></a>Go GC</h1><p>Go 的 GC 结合了插入写屏障和删除写屏障的优点，称之为 <strong>混合写屏障</strong>，它的规则如下：</p><ul><li>GC 开始将栈上的对象全部扫描并标记为黑色；</li><li>GC 期间，任何在栈上创建的新对象，均为黑色；</li><li>被删除的堆对象标记为灰色；</li><li>被添加的堆对象标记为灰色；</li></ul><p><del>Go 团队在最终实现时，<strong>没有为所有栈上的指针写操作启用写屏障</strong>，而是当发生栈上的写操作时，将栈标记为灰色，但此举产生了 <strong>灰色赋值器</strong>，将会需要标记终止阶段 STW 时对这些栈进行 <strong>重新扫描</strong>（v1.7 版本之前）。</del></p><p>一些例子：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C1-1.webp"></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C1-2.webp"></p><p>看到这里我有一个疑问，这里就算不把对象 7 变成灰色，貌似也不会影响什么，因为它的上游对象对象 4 依然是灰色而不是黑色，所以会继续扫描到对象 7，然后再继续扫描到对象 6，为什么会说对象 6 被保护呢？</p><p>然后我想了一下，这样做是为了防止这种情况的发生：在对象 4 准备扫描对象 7 之前，用户程序断开了对象 4 到对象 7 的引用，导致此时的对象 7 依然是白色，如果这时黑色对象 10 再引用白色对象 7，为了保证强三色不变性，就需要将对象 7 变为灰色。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C1-3.webp"></p><p>同样的，如果一个灰色对象删除了对白色对象的引用（比如上图对象 4 删除了对对象 7 的引用），就需要将这个白色对象其变为灰色，否则就可能出现这种情况： </p><ol><li><p>灰色对象 4 删除了对白色对象 7 的引用，且对象 7 没有被其他对象引用，那么其颜色将会保持白色，本轮 GC 会将其作为一个垃圾。</p></li><li><p>但是突然有一个已经在本轮变为黑色的对象，引用了该白色对象（即图中的对象 10 引用了对象 7），这意味着本轮 GC 扫描不会通过对象 10 将对象 7 变为灰色，所以此时的对象 7 依然为白色。</p></li><li><p>最终因为对象 7 为白色而被 GC 回收，进而导致对象 10 引用了一个已经被释放的对象。</p></li></ol><h1 id="参考（抄袭）"><a href="#参考（抄袭）" class="headerlink" title="参考（抄袭）"></a>参考（抄袭）</h1><p><a href="https://www.luozhiyun.com/archives/475">Go 语言 GC 实现原理及源码分析</a></p><p><a href="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/">Golang 垃圾回收(GC)介绍</a></p><p><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/">https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/</a></p><p><a href="https://www.bilibili.com/video/BV1n5411H7qS?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1n5411H7qS?spm_id_from=333.999.0.0</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s namespace</title>
    <link href="/2022/05/31/k8s-namespace/"/>
    <url>/2022/05/31/k8s-namespace/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>Namespace</strong> 是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或用户组。常见的 pods, services, replication controllers 和 deployments 等都是属于某一个 namespace 的（默认是default），而 node, persistentVolumes 等则不属于任何 namespace。</p><p>Namespace 常用来隔离不同的用户，比如 Kubernetes 自带的服务一般运行在 kube-system namespace 中。</p><p>Namespace 适用于存在很多跨多个团队或项目的用户的场景。例如，如果使用命名空间来划分应用程序生命周期环境（如开发、测试、生产），则可以在每个环境中维护利用同样的名称维护相同对象的副本。</p><p>同一 namespace 内的资源名称要唯一，但跨 namespace 时没有这个要求，通俗的说，就是两个资源如果名称相同，但是所在的命名空间不同是可以的。</p><p>疑问：</p><p>label（标签）也可以对资源进行分类，它和 namespace 有什么区别？</p><p>由于每个对象都可以有多个标签，因此这些对象组可以重叠。另外，当在集群中工作(例如通过 kubectl )时，如果没有明确指定标签选择器，我们总能看到所有对象。而 namespace 可以将资源分割为完全独立不重叠的组，我个人的理解是，namespace 提供了比 label 更严格的资源分类，其主要针对的是不同用户间的划分，而 label 则倾向于诸如对同一软件不同版本这种情况进行划分。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="查看所有的-namespace"><a href="#查看所有的-namespace" class="headerlink" title="查看所有的 namespace"></a>查看所有的 namespace</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get ns</span><br>NAME              STATUS   AGE<br>default           Active   24d<br>kube-system       Active   24d<br>kube-public       Active   24d<br>kube-node-lease   Active   24d<br></code></pre></td></tr></table></figure><p>Kubernetes 会创建四个初始 namespace：</p><ul><li><code>default</code> 如果资源没有明确指定其所属的 namespace，则会默认使用该 namespace</li><li><code>kube-system</code> Kubernetes 系统创建对象所使用的 namespace</li><li><code>kube-public</code> 这个 namespace 是自动创建的，所有用户（包括未经过身份验证的用户）都可以读取它。 这个 namespace 主要用于集群使用，以防某些资源在整个集群中应该是可见和可读的。 这个 namespace 的公共方面只是一种约定，而不是要求。</li><li><code>kube-node-lease</code> 此 namespace 用于与各个节点相关的 <a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/lease-v1/">租约（Lease）</a>对象。 节点租期允许 kubelet 发送<a href="https://kubernetes.io/zh/docs/concepts/architecture/nodes/#heartbeats">心跳</a>，由此控制面能够检测到节点故障。</li></ul><h2 id="指定-namespace"><a href="#指定-namespace" class="headerlink" title="指定 namespace"></a>指定 namespace</h2><p>可以将 namespace 作为筛选&#x2F;属性，比如下面的查询 pod 操作使用 namespace 作为筛选条件</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po -n kube-system</span><br>NAME                                      READY   STATUS      RESTARTS       AGE<br>helm-install-traefik-crd-q62cm            0/1     Completed   0              24d<br>helm-install-traefik-l2wcr                0/1     Completed   1              24d<br>svclb-traefik-f4w7g                       2/2     Running     12 (50m ago)   24d<br>traefik-df4ff85d6-2rbl2                   1/1     Running     15 (50m ago)   24d<br>coredns-d76bd69b-7bkb4                    1/1     Running     18 (50m ago)   24d<br>local-path-provisioner-6c79684f77-qjq26   1/1     Running     7 (50m ago)    24d<br>metrics-server-7cd5fcb6b7-b72lz           1/1     Running     25 (50m ago)   24d<br></code></pre></td></tr></table></figure><p>也可以使用 –namespace 命令，如果不指定则默认为 default</p><p>也可以在创建资源的时候为其指定 namespace：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f kubia-manual.yam1 -n custom-namespace</span> <br>pod ”kubia-manual&quot; created<br></code></pre></td></tr></table></figure><h2 id="创建-namespace"><a href="#创建-namespace" class="headerlink" title="创建 namespace"></a>创建 namespace</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create ns ns-test</span><br>namespace/ns-test created<br></code></pre></td></tr></table></figure><h2 id="删除-namespace"><a href="#删除-namespace" class="headerlink" title="删除 namespace"></a>删除 namespace</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete ns ns-test</span><br>namespace &quot;ns-test&quot; deleted<br></code></pre></td></tr></table></figure><p><strong>Warning:</strong> 这会删除名字空间下的 <em>所有内容</em> ！</p><h1 id="namespace-与-DNS"><a href="#namespace-与-DNS" class="headerlink" title="namespace 与 DNS"></a>namespace 与 DNS</h1><p>当你创建<a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/">服务</a>时，Kubernetes 会创建相应的 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/dns-pod-service/">DNS 条目</a>。 此条目的格式为 <code>&lt;服务名称&gt;.&lt;名字空间名称&gt;.svc.cluster.local</code>。 这意味着如果容器使用 <code>&lt;服务名称&gt;</code>，它将解析为名字空间本地的服务。 这对于在多个名字空间（如开发、暂存和生产）中使用相同的配置非常有用。 如果要跨名字空间访问，则需要使用完全限定的域名（FQDN）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go errgroup 使用</title>
    <link href="/2022/05/28/errgroup/"/>
    <url>/2022/05/28/errgroup/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>errgroup</strong> 是 WaitGroup 的强化版，其在 WaitGroup 的基础上添加了错误处理的功能：如果一组 goroutine 中的某一个发生了错误，那么后续的所有 gorouine 都不会被执行。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>一共开启 10 个 goroutine 执行任务，其中第三个 goroutine 会出错，使用 errgroup 可以保证第三个之后的所有 goroutine 都不会执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>group, ctx := errgroup.WithContext(context.Background())<br>count := <span class="hljs-number">50</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>i := i <span class="hljs-comment">// 闭包重新捕获变量 i</span><br>group.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>log.Printf(<span class="hljs-string">&quot;[%d] group 里有一个任务失败了，所以这个任务不会执行\n&quot;</span>, i)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">3</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;[%d] error\n&quot;</span>, i)<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;[%d] error&quot;</span>, i)<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;[%d] success\n&quot;</span>, i)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br>time.Sleep(time.Millisecond * <span class="hljs-number">10</span>)<br>&#125;<br><span class="hljs-keyword">if</span> err := group.Wait(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [0] success</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [1] success</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [2] success</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [3] error</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [4] group 里有一个任务失败了，所以这个任务不会执行</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [5] group 里有一个任务失败了，所以这个任务不会执行</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [6] group 里有一个任务失败了，所以这个任务不会执行</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [7] group 里有一个任务失败了，所以这个任务不会执行</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [8] group 里有一个任务失败了，所以这个任务不会执行</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [9] group 里有一个任务失败了，所以这个任务不会执行</span><br><span class="hljs-comment">//2022/05/29 00:02:51 [3] error</span><br></code></pre></td></tr></table></figure><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>来源：<a href="https://lailin.xyz/post/go-training-week3-errgroup.html">https://lailin.xyz/post/go-training-week3-errgroup.html</a></p><p>因为我是跳过文章前面的内容直接看示例的，所以一开始有点看不懂注释写的意思，后来翻了一下源码才明白，对注释针对自己的简介进行了一些修改。</p><p>这个示例的大致意思是：使用 errgroup 开启了 3 个 goroutine，第一个运行 HTTP 服务，第二个监听 shutdown 接口用来关闭 HTTP 服务，第三个监听 ctrl+c 和 kill 这两个信号。这三个中的任何一个发生错误退出，都会让另外两个 goroutine 也退出（准确的说，运行 HTTP 服务的 goroutine 是不会主动退出的，只有第二个能将其结束，另外两个都可以主动结束，第二个执行 curl localhost:8080&#x2F;shutdown 可以触发，第三个使用 ctrl+c 或者 kill 都可以触发）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// WithContext() 里面用 context.Cancel 包装了传入的 context，并返回包装后</span><br><span class="hljs-comment">// 的 ctx，而另一个返回值 cancel 则是放到了 errgroup.Group 里面</span><br><span class="hljs-comment">// 如果 g.Go(func() error) 里面的 func 返回了错误，那么会调用 Group.cancel</span><br><span class="hljs-comment">// 将包装的 ctx 取消</span><br>g, ctx := errgroup.WithContext(context.Background())<br><br>mux := http.NewServeMux()<br>mux.HandleFunc(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;pong&quot;</span>))<br>&#125;)<br><br><span class="hljs-comment">// 模拟单个服务错误退出</span><br>serverOut := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>mux.HandleFunc(<span class="hljs-string">&quot;/shutdown&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>serverOut &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;)<br><br>server := http.Server&#123;<br>Handler: mux,<br>Addr:    <span class="hljs-string">&quot;:8080&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">// g1</span><br><span class="hljs-comment">// g1 退出了所有的协程都能退出么？</span><br><span class="hljs-comment">// g1 退出后, context 将不再阻塞（这话第一眼没看懂，context 还会被阻塞？），g2, g3 都会随之退出</span><br><span class="hljs-comment">// 修改版注释：g1 只有在 g2 调用 Shutdown() 后才会退出，同时返回一个 error</span><br><span class="hljs-comment">// 之后 ctx 被 cancel，其他 goroutine 的 select 都会走 case &lt;-ctx.Done() 分支，</span><br><span class="hljs-comment">// 从而达到退出的目的（因为 select 没有加 default 分支，所以会被阻塞，直到有一个 case</span><br><span class="hljs-comment">// 满足条件，所以上面说的 context 将不再阻塞，实际应该是 select 不再阻塞）</span><br><span class="hljs-comment">// 然后 main 函数中的 g.Wait() 退出，所有协程都会退出</span><br>g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// g2 的 Shutdown 会让这里停止阻塞并返回一个 err</span><br><span class="hljs-comment">// 之后 ctx 会被 cancel 掉，g3 也会停止</span><br><span class="hljs-keyword">if</span> err := server.ListenAndServe(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;g1 error: &quot;</span>, err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><br><span class="hljs-comment">// g2</span><br><span class="hljs-comment">// g2 退出了所有的协程都能退出么？</span><br><span class="hljs-comment">// g2 退出时，调用了 shutdown，g1 会退出</span><br><span class="hljs-comment">// g2 退出后, context 将不再阻塞，g3 会随之退出</span><br><span class="hljs-comment">// 修改：g2 退出后, g1 cancel 掉了 ctx，g3 的 select 将不再阻塞，g3 会随之退出</span><br><span class="hljs-comment">// 然后 main 函数中的 g.Wait() 退出，所有协程都会退出</span><br>g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>log.Println(<span class="hljs-string">&quot;errgroup exit...&quot;</span>)<br><span class="hljs-keyword">case</span> &lt;-serverOut: <span class="hljs-comment">// curl localhost:8080/shutdown</span><br>log.Println(<span class="hljs-string">&quot;server will out...&quot;</span>)<br>&#125;<br><br>cancelCtx, cancel := context.WithCancel(context.Background())<br><span class="hljs-comment">// 这里不是必须的，但是如果使用 _ 的话静态扫描工具会报错，加上也无伤大雅</span><br><span class="hljs-keyword">defer</span> cancel()<br><br>log.Println(<span class="hljs-string">&quot;shutting down server...&quot;</span>)<br><span class="hljs-comment">// Shutdown() 会停止 g1，同时 g1 的 ListenAndServe() 会返回一个 error</span><br><span class="hljs-keyword">if</span> err := server.Shutdown(cancelCtx); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;g2 error: &quot;</span>, err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><br><span class="hljs-comment">// g3</span><br><span class="hljs-comment">// g3 捕获到 os 退出信号将会退出</span><br><span class="hljs-comment">// g3 退出了所有的协程都能退出么？</span><br><span class="hljs-comment">// g3 退出后, context 将不再阻塞，g2 会随之退出</span><br><span class="hljs-comment">// 修改：g3 收到信号返回一个 error 并退出，ctx 会被 cancel 掉，然后 g2 的 select</span><br><span class="hljs-comment">// 停止阻塞，执行下面的流程</span><br><span class="hljs-comment">// g2 退出时，调用了 shutdown，g1 会退出</span><br><span class="hljs-comment">// 然后 main 函数中的 g.Wait() 退出，所有协程都会退出</span><br>g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">0</span>)<br>signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>log.Println(<span class="hljs-string">&quot;g3: ctx is done&quot;</span>)<br><span class="hljs-keyword">return</span> ctx.Err()<br><span class="hljs-keyword">case</span> sig := &lt;-quit:<br><span class="hljs-keyword">return</span> errors.Errorf(<span class="hljs-string">&quot;get os signal: %v&quot;</span>, sig)<br>&#125;<br>&#125;)<br><br>fmt.Printf(<span class="hljs-string">&quot;errgroup exiting: %+v\n&quot;</span>, g.Wait())<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h2><p>errgroup 还可以限制同时开启的 goroutine 数量，其实本质也是使用 WaitGroup + channel 来实现的。</p><p>下面的代码保证最多只开启 2 个 goroutine，其他的都会阻塞等待，值得一提的是，Group 即便是零值也是可以直接使用的，只是没有了 cancel 的能力。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>eg := errgroup.Group&#123;&#125;<br>count := <span class="hljs-number">20</span><br>mostRunning := <span class="hljs-number">2</span><br>eg.SetLimit(mostRunning)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>i := i<br>eg.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>log.Println(i)<br>time.Sleep(<span class="hljs-number">300</span> * time.Millisecond)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br>&#125;<br><br>eg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A Group is a collection of goroutines working on subtasks that are part of</span><br><span class="hljs-comment">// the same overall task.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// A zero Group is valid and does not cancel on error.</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// Group 是一组 goroutines，它们处理属于同一整体任务的子任务。零值是有效的，并且不会因错误而取消。</span><br><span class="hljs-comment">// 因为零值的 cancel 是 nil，所以自然不会被执行</span><br><span class="hljs-keyword">type</span> Group <span class="hljs-keyword">struct</span> &#123;<br>cancel <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><span class="hljs-comment">// 发生错误时会调用该函数，将 WithContext 创建的 ctx 取消</span><br><br>wg sync.WaitGroup<br><br>  sem <span class="hljs-keyword">chan</span> token<span class="hljs-comment">// 带缓存的 chan，用来限制可以创建的 goroutine 数量，token 是 struct&#123;&#125; 的别名</span><br><br>errOnce sync.Once<span class="hljs-comment">// 确保只有第一次发生错误时才执行某些操作</span><br>err     <span class="hljs-type">error</span><span class="hljs-comment">// 记录第一次发生的错误</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="WithContext"><a href="#WithContext" class="headerlink" title="WithContext"></a>WithContext</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WithContext returns a new Group and an associated Context derived from ctx.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The derived Context is canceled the first time a function passed to Go</span><br><span class="hljs-comment">// returns a non-nil error or the first time Wait returns, whichever occurs</span><br><span class="hljs-comment">// first.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// WithContext 返回一个 Group 和一个从 ctx 派生的关联上下文。派生的 Context 在 Go 函数第一次返</span><br><span class="hljs-comment">// 回错误或 Wait 第一次返回时被取消，以先发生者为准。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithContext</span><span class="hljs-params">(ctx context.Context)</span></span> (*Group, context.Context) &#123;<br>  <span class="hljs-comment">// 用 WithCancel 包装了传入的 ctx</span><br>ctx, cancel := context.WithCancel(ctx)<br>  <span class="hljs-comment">// 将 cancel 保存到 Cancel 属性</span><br><span class="hljs-keyword">return</span> &amp;Group&#123;cancel: cancel&#125;, ctx<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Go calls the given function in a new goroutine.</span><br><span class="hljs-comment">// It blocks until the new goroutine can be added without the number of</span><br><span class="hljs-comment">// active goroutines in the group exceeding the configured limit.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The first call to return a non-nil error cancels the group; its error will be</span><br><span class="hljs-comment">// returned by Wait.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Go 在一个新的 goroutine 中调用给定的函数。如果当前运行的 goroutine 数量达到了 limit 的上限，则会阻</span><br><span class="hljs-comment">// 塞，直到可以添加。如果调用 f 返回了错误，则会取消该组（也就是调用 Group.cancel，只有第一次发生错误时</span><br><span class="hljs-comment">// 会执行该操作），Wait 会返回它的错误。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Go(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> g.sem != <span class="hljs-literal">nil</span> &#123;<br>g.sem &lt;- token&#123;&#125;<span class="hljs-comment">// 如果当前开启的 goroutine 数量大于 limit 则会被阻塞</span><br>&#125;<br><br>g.wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> g.done()<br><br><span class="hljs-keyword">if</span> err := f(); err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-comment">// 只执行一次，保证只有第一次发生错误时执行</span><br>g.errOnce.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        g.err = err<span class="hljs-comment">// 保存错误，Wait() 会返回这个错误</span><br><span class="hljs-keyword">if</span> g.cancel != <span class="hljs-literal">nil</span> &#123;<br>          g.cancel()<span class="hljs-comment">// cancel 掉 WithContext() 创建的 ctx</span><br>&#125;<br>&#125;)<br>&#125;<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SetLimit"><a href="#SetLimit" class="headerlink" title="SetLimit"></a>SetLimit</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SetLimit limits the number of active goroutines in this group to at most n.</span><br><span class="hljs-comment">// A negative value indicates no limit.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Any subsequent call to the Go method will block until it can add an active</span><br><span class="hljs-comment">// goroutine without exceeding the configured limit.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The limit must not be modified while any goroutines in the group are active.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// SetLimit 将这个组中的活动 goroutine 的数量限制为最多 n。负值表示没有限制。</span><br><span class="hljs-comment">// 对 Go 方法的任何后续调用都将阻塞，直到它可以添加一个活动的 goroutine 而不会</span><br><span class="hljs-comment">// 超过配置的限制。当组中的任何 goroutine 处于活动状态时，不得修改限制。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> SetLimit(n <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span> &#123;<br>g.sem = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(g.sem) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(fmt.Errorf(<span class="hljs-string">&quot;errgroup: modify limit while %v goroutines in the group are still active&quot;</span>, <span class="hljs-built_in">len</span>(g.sem)))<br>&#125;<br>g.sem = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> token, n)<span class="hljs-comment">// 使用带缓存的 chan</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="TryGo"><a href="#TryGo" class="headerlink" title="TryGo"></a>TryGo</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// TryGo calls the given function in a new goroutine only if the number of</span><br><span class="hljs-comment">// active goroutines in the group is currently below the configured limit.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The return value reports whether the goroutine was started.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 仅当组中当前活动的 goroutine 的数量低于配置的限制时，TryGo 才会在新的 goroutine 中调用给定的函数。</span><br><span class="hljs-comment">// 返回值报告 goroutine 是否已启动。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> TryGo(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> g.sem != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> g.sem &lt;- token&#123;&#125;:<br><span class="hljs-comment">// Note: this allows barging iff channels in general allow barging.</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br>g.wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> g.done()<br><br><span class="hljs-keyword">if</span> err := f(); err != <span class="hljs-literal">nil</span> &#123;<br>g.errOnce.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>g.err = err<br><span class="hljs-keyword">if</span> g.cancel != <span class="hljs-literal">nil</span> &#123;<br>g.cancel()<br>&#125;<br>&#125;)<br>&#125;<br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Wait blocks until all function calls from the Go method have returned, then</span><br><span class="hljs-comment">// returns the first non-nil error (if any) from them.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 阻塞等待，直到来自 Go 方法的所有函数调用都返回，然后从它们返回第一个非零错误（如果有）。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Wait() <span class="hljs-type">error</span> &#123;<br>g.wg.Wait()<br><span class="hljs-keyword">if</span> g.cancel != <span class="hljs-literal">nil</span> &#123;<br>g.cancel()<br>&#125;<br><span class="hljs-keyword">return</span> g.err<br>&#125;<br></code></pre></td></tr></table></figure><p>总的来看，源码还是比较简单的，也比较容易阅读。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kqueue</title>
    <link href="/2022/05/28/kqueue/"/>
    <url>/2022/05/28/kqueue/</url>
    
    <content type="html"><![CDATA[<p>一个 echo server 示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br>. <span class="hljs-string">&quot;syscall&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> eventNum = <span class="hljs-number">10</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>log.SetFlags(log.Lshortfile | log.Ldate)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sfd, err := Socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-comment">//log.Printf(&quot;listen fd: %v\n&quot;, sfd)</span><br><br><span class="hljs-keyword">if</span> err := Bind(sfd, &amp;SockaddrInet4&#123;Port: <span class="hljs-number">8080</span>, Addr: [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">if</span> err := Listen(sfd, <span class="hljs-number">1024</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>kfd, err := Kqueue()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>change := Kevent_t&#123;<br>Ident:  <span class="hljs-type">uint64</span>(sfd),<br>Filter: EVFILT_READ,<br>Flags:  EV_ADD | EV_ENABLE,<br>Fflags: <span class="hljs-number">0</span>,<br>Data:   <span class="hljs-number">0</span>,<br>Udata:  <span class="hljs-literal">nil</span>,<br>&#125;<br>_, err = Kevent(kfd, []Kevent_t&#123;change&#125;, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>)<span class="hljs-comment">// 添加监听事件，第三个参数传空</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br>events := <span class="hljs-built_in">make</span>([]Kevent_t, eventNum)<br>        <span class="hljs-comment">// 获取就绪事件，第二个参数传空</span><br>readyEventNum, err := Kevent(kfd, <span class="hljs-literal">nil</span>, events, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 无限等待直到有事件产生</span><br><span class="hljs-comment">//fmt.Printf(&quot;readyEventNum: %v\n&quot;, readyEventNum)</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &amp;&amp; err != EINTR &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; readyEventNum; i++ &#123;<br>event := events[i]<br>log.Printf(<span class="hljs-string">&quot;event fd: %v \n&quot;</span>, event.Ident)<br>efd := <span class="hljs-type">int</span>(event.Ident)<br><span class="hljs-keyword">if</span> efd == sfd &#123;<br>nfd, _, err := Accept(sfd)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>log.Printf(<span class="hljs-string">&quot;accept event, fd: %v\n&quot;</span>, nfd)<br><span class="hljs-keyword">if</span> err := SetNonblock(nfd, <span class="hljs-literal">true</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br><span class="hljs-comment">//panic(err)</span><br>&#125;<br>change := Kevent_t&#123;<br>Ident:  <span class="hljs-type">uint64</span>(nfd),<br>Filter: EVFILT_READ,<br>Flags:  EV_ADD | EV_ENABLE,<br>Fflags: <span class="hljs-number">0</span>,<br>Data:   <span class="hljs-number">0</span>,<br>Udata:  <span class="hljs-literal">nil</span>,<br>&#125;<br>                <span class="hljs-comment">// 添加监听事件，第三个参数传空</span><br>_, err = Kevent(kfd, []Kevent_t&#123;change&#125;, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;read event\n&quot;</span>)<br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>_, err := Read(efd, b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>Close(efd)<br><span class="hljs-keyword">continue</span><br>&#125;<br>_, err = Write(efd, b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>Close(efd)<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><p>错误版本：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>. <span class="hljs-string">&quot;syscall&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> eventNum = <span class="hljs-number">10</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>log.SetFlags(log.Lshortfile | log.Ldate)<br>&#125;<br><br><span class="hljs-comment">// BUG 记录：</span><br><span class="hljs-comment">// 1. 客户端断开连接后，服务端仍然会产生读事件</span><br><span class="hljs-comment">// 客户端断开连接后，服务端的 Read 会发生 connection reset by peer 错误并进入错误处理分支， Close 掉这</span><br><span class="hljs-comment">// 个连接，但是因为错误处理采用的是 continue 而不是 break（因为可能会同时产生多个事件，也就是 kevent 的返</span><br><span class="hljs-comment">// 回值，如果使用 break，会导致后面的事件全部被放弃处理，因为多个事件中的某一个事件产生错误，而直接跳过后续事</span><br><span class="hljs-comment">// 件的处理，显然是不合理的），会重新进入外层的死循环，又因为会继续产生读事件，导致 Kevent 函数成功返回，进</span><br><span class="hljs-comment">// 入到读事件分支，进行 Read 操作，此时会报错 bad file descriptor，continue 到最外层死循环，如此反复，</span><br><span class="hljs-comment">// 直到循环很多次以后会抛出一个 panic</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sfd, err := Socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;listen fd: %v\n&quot;</span>, sfd)<br><br><span class="hljs-keyword">if</span> err := Bind(sfd, &amp;SockaddrInet4&#123;Port: <span class="hljs-number">8080</span>, Addr: [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">if</span> err := Listen(sfd, <span class="hljs-number">1024</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>changes = <span class="hljs-built_in">make</span>([]Kevent_t, <span class="hljs-number">0</span>) <span class="hljs-comment">// 监听列表</span><br>events  = <span class="hljs-built_in">make</span>([]Kevent_t, eventNum) <span class="hljs-comment">// 发生的事件列表，len 不能为 0</span><br>)<br><br>kfd, err := Kqueue()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>readEvent := Kevent_t&#123;<br>Ident:  <span class="hljs-type">uint64</span>(sfd),<br>Filter: EVFILT_READ,<br>Flags:  EV_ADD | EV_ENABLE,<br>Fflags: <span class="hljs-number">0</span>,<br>Data:   <span class="hljs-number">0</span>,<br>Udata:  <span class="hljs-literal">nil</span>,<br>&#125;<br>changes = <span class="hljs-built_in">append</span>(changes, readEvent)<br><span class="hljs-comment">// BUG1 解决步骤1 ：新增下面这个函数调用</span><br><span class="hljs-comment">// _, err = Kevent(kfd, changes, nil, nil)</span><br><span class="hljs-comment">// if err != nil &#123;</span><br><span class="hljs-comment">// panic(err)</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// BUG1 解决步骤2：</span><br><span class="hljs-comment">// 这里的第二个参数必须传 nil，如果传 changes 就会出现 BUG1 的情况</span><br>readyEventNum, err := Kevent(kfd, changes, events, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 无限等待直到有事件产生</span><br>fmt.Printf(<span class="hljs-string">&quot;readyEventNum: %v\n&quot;</span>, readyEventNum)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &amp;&amp; err != EINTR &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;events: %v \n&quot;</span>, events)<br>log.Printf(<span class="hljs-string">&quot;changes: %v \n&quot;</span>, changes)<br>log.Printf(<span class="hljs-string">&quot;readyEventNum: %v\n&quot;</span>, readyEventNum)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; readyEventNum; i++ &#123;<br>event := events[i]<br>log.Printf(<span class="hljs-string">&quot;event fd: %v \n&quot;</span>, event.Ident)<br>efd := <span class="hljs-type">int</span>(event.Ident)<br><span class="hljs-keyword">if</span> efd == sfd &#123;<br>nfd, _, err := Accept(sfd)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>log.Printf(<span class="hljs-string">&quot;accept event, fd: %v\n&quot;</span>, nfd)<br><span class="hljs-keyword">if</span> err := SetNonblock(nfd, <span class="hljs-literal">true</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br><span class="hljs-comment">//panic(err)</span><br>&#125;<br>changes = <span class="hljs-built_in">append</span>(changes, Kevent_t&#123;<br>Ident:  <span class="hljs-type">uint64</span>(nfd),<br>Filter: EVFILT_READ,<br>Flags:  EV_ADD | EV_ENABLE,<br>Fflags: <span class="hljs-number">0</span>,<br>Data:   <span class="hljs-number">0</span>,<br>Udata:  <span class="hljs-literal">nil</span>,<br>&#125;)<br><span class="hljs-comment">// BUG1 解决步骤3 ：新增下面这个函数调用</span><br><span class="hljs-comment">// _, err = Kevent(kfd, changes, nil, nil)</span><br><span class="hljs-comment">// if err != nil &#123;</span><br><span class="hljs-comment">// panic(err)</span><br><span class="hljs-comment">// &#125;</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-comment">/*if event.Filter == EVFILT_READ*/</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;read event\n&quot;</span>)<br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>_, err := Read(efd, b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>Close(efd)<br><span class="hljs-keyword">continue</span><br>&#125;<br>_, err = Write(efd, b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>Close(efd)<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>正确版本：</p><p>按照注释上的标注进行修改：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>. <span class="hljs-string">&quot;syscall&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> eventNum = <span class="hljs-number">10</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>log.SetFlags(log.Lshortfile | log.Ldate)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sfd, err := Socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;listen fd: %v\n&quot;</span>, sfd)<br><br><span class="hljs-keyword">if</span> err := Bind(sfd, &amp;SockaddrInet4&#123;Port: <span class="hljs-number">8080</span>, Addr: [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">if</span> err := Listen(sfd, <span class="hljs-number">1024</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>changes = <span class="hljs-built_in">make</span>([]Kevent_t, <span class="hljs-number">0</span>) <span class="hljs-comment">// 监听列表</span><br>events  = <span class="hljs-built_in">make</span>([]Kevent_t, eventNum) <span class="hljs-comment">// 发生的事件列表，len 不能为 0</span><br>)<br><br>kfd, err := Kqueue()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>readEvent := Kevent_t&#123;<br>Ident:  <span class="hljs-type">uint64</span>(sfd),<br>Filter: EVFILT_READ,<br>Flags:  EV_ADD | EV_ENABLE,<br>Fflags: <span class="hljs-number">0</span>,<br>Data:   <span class="hljs-number">0</span>,<br>Udata:  <span class="hljs-literal">nil</span>,<br>&#125;<br>changes = <span class="hljs-built_in">append</span>(changes, readEvent)<br><span class="hljs-comment">// BUG1 解决步骤1 ：新增下面这个函数调用</span><br>_, err = Kevent(kfd, changes, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br> <span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// BUG1 解决步骤2：</span><br><span class="hljs-comment">// 这里的第二个参数必须传 nil，如果传 changes 就会出现 BUG1 的情况</span><br>readyEventNum, err := Kevent(kfd, <span class="hljs-literal">nil</span>, events, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 无限等待直到有事件产生</span><br><span class="hljs-comment">//fmt.Printf(&quot;readyEventNum: %v\n&quot;, readyEventNum)</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &amp;&amp; err != EINTR &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-comment">//log.Printf(&quot;events: %v \n&quot;, events)</span><br><span class="hljs-comment">//log.Printf(&quot;changes: %v \n&quot;, changes)</span><br><span class="hljs-comment">//log.Printf(&quot;readyEventNum: %v\n&quot;, readyEventNum)</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; readyEventNum; i++ &#123;<br>event := events[i]<br><span class="hljs-comment">//log.Printf(&quot;event fd: %v \n&quot;, event.Ident)</span><br>efd := <span class="hljs-type">int</span>(event.Ident)<br><span class="hljs-keyword">if</span> efd == sfd &#123;<br>nfd, _, err := Accept(sfd)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>log.Printf(<span class="hljs-string">&quot;accept event, fd: %v\n&quot;</span>, nfd)<br><span class="hljs-keyword">if</span> err := SetNonblock(nfd, <span class="hljs-literal">true</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br><span class="hljs-comment">//panic(err)</span><br>&#125;<br>changes = <span class="hljs-built_in">append</span>(changes, Kevent_t&#123;<br>Ident:  <span class="hljs-type">uint64</span>(nfd),<br>Filter: EVFILT_READ,<br>Flags:  EV_ADD | EV_ENABLE,<br>Fflags: <span class="hljs-number">0</span>,<br>Data:   <span class="hljs-number">0</span>,<br>Udata:  <span class="hljs-literal">nil</span>,<br>&#125;)<br><span class="hljs-comment">// BUG1 解决步骤3 ：新增下面这个函数调用</span><br>_, err = Kevent(kfd, changes, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-comment">/*if event.Filter == EVFILT_READ*/</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;read event\n&quot;</span>)<br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>_, err := Read(efd, b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>Close(efd)<br><span class="hljs-keyword">continue</span><br>&#125;<br>_, err = Write(efd, b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>Close(efd)<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>原因：</p><p>没研究出来</p><p>暂时见解：</p><p>貌似 kqueue 这个函数是 epoll 的 <code>epoll_ctl</code> 和 <code>epoll_wait</code> 的结合体，主要是它的第二个和第三个参数（Go 的系统调用需要的参数和原生 API 略有不同，但影响不大，只是不用提供两个数组的长度而已），第二个参数是<strong>要监听的事件集合</strong>，第三个参数用来<strong>存放已经准备就绪的事件</strong>，所以如果想要添加监听事件，就将第三个参数传 null；如果想获取已经就绪的事件，那么就给第二个参数传 null，具体看开头的 echo server 代码的那几行调用 Kqueue 的注释。看了一些正确的例子，包括官方的 FreeBSD man 文档，基本都是这么写的。</p><p>对比 epoll</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;log&quot;</span><br>   . <span class="hljs-string">&quot;syscall&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>   log.SetFlags(log.Lshortfile | log.Ltime)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   sfd, err := Socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-built_in">panic</span>(err)<br>   &#125;<br>   log.Printf(<span class="hljs-string">&quot;listen fd: %v\n&quot;</span>, sfd)<br><br>   <span class="hljs-keyword">if</span> err := Bind(sfd, &amp;SockaddrInet4&#123;Port: <span class="hljs-number">8080</span>, Addr: [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-built_in">panic</span>(err)<br>   &#125;<br><br>   <span class="hljs-keyword">if</span> err := Listen(sfd, <span class="hljs-number">1024</span>); err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-built_in">panic</span>(err)<br>   &#125;<br><br>   epfd, err := EpollCreate(<span class="hljs-number">10</span>)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-built_in">panic</span>(err)<br>   &#125;<br><br>   <span class="hljs-keyword">if</span> err := EpollCtl(epfd, EPOLL_CTL_ADD, sfd, &amp;EpollEvent&#123;<br>      Events: EPOLLIN,<br>      Fd:     <span class="hljs-type">int32</span>(sfd),<br>      Pad:    <span class="hljs-number">0</span>,<br>   &#125;); err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-built_in">panic</span>(err)<br>   &#125;<br><br>   <span class="hljs-keyword">for</span> &#123;<br>      events := <span class="hljs-built_in">make</span>([]EpollEvent, <span class="hljs-number">20</span>)<br>      n, err := EpollWait(epfd, events, <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         log.Println(err)<br>         <span class="hljs-keyword">continue</span><br>      &#125;<br>      <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>         event := events[i]<br>         <span class="hljs-keyword">if</span> event.Fd == <span class="hljs-type">int32</span>(sfd) &#123;<br>            nfd, _, err := Accept(sfd)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>               log.Println(err)<br>               <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> err := EpollCtl(epfd, EPOLL_CTL_ADD, nfd, &amp;EpollEvent&#123;<br>               Events: EPOLLIN,<br>               Fd:     <span class="hljs-type">int32</span>(nfd),<br>               Pad:    <span class="hljs-number">0</span>,<br>            &#125;); err != <span class="hljs-literal">nil</span> &#123;<br>               log.Println(err)<br>               <span class="hljs-keyword">continue</span><br>            &#125;<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>            b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>            _, err := Read(<span class="hljs-type">int</span>(event.Fd), b)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>               log.Println(err)<br>               Close(<span class="hljs-type">int</span>(event.Fd))<br>               <span class="hljs-keyword">continue</span><br>            &#125;<br>            _, err = Write(<span class="hljs-type">int</span>(event.Fd), b)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>               log.Println(err)<br>               Close(<span class="hljs-type">int</span>(event.Fd))<br>               <span class="hljs-keyword">continue</span><br>            &#125;<br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>多路复用</tag>
      
      <tag>kqueue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s 卷</title>
    <link href="/2022/05/20/k8s-juan/"/>
    <url>/2022/05/20/k8s-juan/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么需要卷"><a href="#为什么需要卷" class="headerlink" title="为什么需要卷"></a>为什么需要卷</h1><p>pod 类似逻辑主机，在逻辑主机中运行的进程共享诸如 CPU、RAM、网络接口等资源。有时候人们会期望进程也能共享磁盘，但是因为 pod 中运行的是一个个容器，而每个容器都有自己独立的文件系统（因为文件系统来自于容器镜像），所以不能共享磁盘。有时候可能存在这样一种需求：<del>pod 中某个容器存储的数据需要持久化，但是因为容器存在挂掉的可能，如果挂掉后会新创建一个 pod 来顶替，但是因为 pod 因为无法共享磁盘，导致无法继承先前 pod 里存储的数据，先前的那部分数据就永久丢失了。</del></p><p>k8s 通过定义 <strong>卷</strong> 这个概念来解决这个问题，<strong>它们不像 pod 这样的顶级资源，而是被定义为了 pod 的一部分</strong>，并和 pod 共享相同的生命周期，也就是说，卷在 pod 启动时创建，在 pod 删除时销毁（书上是这么说的，但是感觉不太准确，不同类型的卷有不同的生命周期，像 emptyDir 就是和 pod 共享生命周期，而 hostPath 则不共享，就算 pod 删除了，这个卷也不会被删除）。</p><h1 id="卷类型"><a href="#卷类型" class="headerlink" title="卷类型"></a>卷类型</h1><h2 id="emptyDir"><a href="#emptyDir" class="headerlink" title="emptyDir"></a>emptyDir</h2><p>顾名思义，这个卷最初是空的，当 Pod 因为某些原因被从节点上删除时，<code>emptyDir</code> 卷中的数据也会被永久删除。运行在 pod 内的应用程序可以写入它需要的任何文件。</p><p>实践：</p><p>yaml 如下：（ ⚠️ 该 yaml 的镜像基于 arm64 架构，如果你的机器是 x86，需要将第一个 -image 更换为 luksa&#x2F;fortune）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fortune</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/fortune-arm64</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">html-generator</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span> <span class="hljs-comment"># 使用 name 为 html 的卷（该卷在 yaml 最后定义）</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/htdocs</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web-server</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>这个 pod 的大致意思是：创建了 2 个容器，一个负责生成随机内容（使用 fortune 随机生成一句谚语）并写入到 &#x2F;var&#x2F;htdocs&#x2F;index.html 文件里，另一个是 nginx 服务，负责将 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html 里的内容显示出来（将第一个容器写入的谚语读取出来），所以这两个容器需要结合使用，一个负责写，另一个负责读，所以需要共用同一个卷来实现。</p><p>为了实现上面的流程，需要创建一个卷，将这个卷分别挂载到两个容器的某个目录下，这样就可以达到共享一个卷的目的，在上面的 yaml 中，将卷挂载到了 fortune 容器的 &#x2F;var&#x2F;htdocs&#x2F; 目录下，然后这个容器会在这个目录下创建一个 index.html 并写入谚语（因为挂载的原因，所以相当在卷中创建了一个 index.html 文件）；同样还会将这个卷挂载到 nginx 容器下的 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 目录下，nginx 默认会读取这个目录下的 index.html 作为显示内容，前面提到过，fortune 容器会创建一个 index.html 文件到卷中，所以这个文件刚好就可以作为 nginx 的默认显示内容，值得注意的是，yaml 里还对 nginx 容器设置了 readOnly: true 属性，表示该容器只能从卷中读取，不能写入。</p><p>以上涉及到 linux 挂载（mount）的知识，这个概念感觉有点绕，（我总是把挂载、被挂载搞混），我也是初学掌握的不是很好，所以上面的内容说的比较绕，也可能不正确，用我个人的理解，简单的用几句话概括就是，将卷挂载到了一个容器的 &#x2F;var&#x2F;htdocs 下和另一个容器的 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 容器下，然后这两个路径就相当于共享了，第一个容器在 &#x2F;var&#x2F;htdocs 中创建一个文件，另一个容器可以同样在 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 目录下读取到。</p><p>因为容器的文件系统是隔离的，正常来说两个容器是不能共享目录的，就相当于两台电脑，如果不通过一些特殊手段肯定是不能共享目录的，所以为了解决这个问题，就需要使用上面的 <strong>卷</strong> 来实现。</p><p>接下来就可以使用 <code>kubectl apply -f </code> 进行创建了，为了测试效果，可以使用端口转发：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl port-forward fortune 8080:80</span><br>Forwarding from 127.0.0.1:8080 -&gt; 80<br>Forwarding from [::1]:8080 -&gt; 80<br></code></pre></td></tr></table></figure><p>然后使用 curl 就可以了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl http://localhost:8080</span><br>Q:How many psychiatrists does it take to change a light bulb?<br>A:Only one, but it takes a long time, and the light bulb has<br>to really want to change.<br></code></pre></td></tr></table></figure><blockquote><p>❓这个 emptyDir 实际路径在哪里？</p></blockquote><p>emptyDir 不仅可以使用常规的硬盘作为存储介质，也可以使用内存作为存储介质（linux 中的 tmpfs 也是类似的东西），只需要在 yaml 中指定 mediun 即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">volumes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br><span class="hljs-attr">emptyDir:</span><br><span class="hljs-attr">medium:</span> <span class="hljs-string">Memory</span> <span class="hljs-comment"># 存储在内存中</span><br></code></pre></td></tr></table></figure><h2 id="hostPath"><a href="#hostPath" class="headerlink" title="hostPath"></a>hostPath</h2><p>这里复用 emptyDir 部分的 yaml，只是将 volume 的类型更换为了 hostPath：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fortune</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/fortune-arm64</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">html-generator</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span> <br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/htdocs</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web-server</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>    <span class="hljs-attr">hostPath:</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/data</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">Directory</span><br></code></pre></td></tr></table></figure><p>执行上面的 yaml，创建 pod，然后看看 hostPath 卷里的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /data/index.html</span><br>Stay away from hurricanes for a while.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /data/index.html</span><br>A vivid and creative mind characterizes you.<br></code></pre></td></tr></table></figure><p>也可以像 emptyDir 中演示的那样，开启端口转发，使用 curl 看看效果，这里就不记录了。</p><p>测试一下 hostPath 类型的卷是否和 pod 共享生命周期：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete po fortune</span><br>pod &quot;fortune&quot; deleted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /data/index.html</span><br>Today&#x27;s weirdness is tomorrow&#x27;s reason why.<br>-- Hunter S. Thompson<br></code></pre></td></tr></table></figure><p>pod 被删除了，但是 &#x2F;data 下的内容依然存在，所以 hostPath 卷不与 pod 共享生命周期，属于持久卷。</p><h1 id="持久卷"><a href="#持久卷" class="headerlink" title="持久卷"></a>持久卷</h1><h2 id="持久卷（pv）和持久卷声明（pvc）"><a href="#持久卷（pv）和持久卷声明（pvc）" class="headerlink" title="持久卷（pv）和持久卷声明（pvc）"></a>持久卷（pv）和持久卷声明（pvc）</h2><p>一般来说，开发者不需要知道持久卷存储的类型和地址，如果开发者定义 pod 时需要手动指定存储地址，那么会导致高耦合，解决方法就是计算机的通用解决方法：套一层中间层，pvc 就是这个中间层，开发者只需要将自己的需求（容量需求、访问模式）定义为 pvc 提交给 k8s，k8s 将找到可匹配的持久卷并将其绑定到 pvc。</p><p><strong>PVC 与 PV 是一一对应关系，不能一个 PVC 挂载多个 PV，也不能一个 PV 挂载多个 PVC</strong>。为应用配置存储时，需要声明一个存储需求声明（PVC），而Kubernetes 会通过最佳匹配的方式选择一个满足 PVC 需求的 PV，并与之绑定。所以从职责上 PVC 是应用所需要的存储对象，属于应用作用域。PV 是存储平面的存储对象，属于整个存储域。</p><p>PVC 只有绑定了 PV 之后才能被 Pod 使用，而 PVC 绑定 PV 的过程即是消费 PV 的过程，这个过程是有一定规则的，以下规则都满足的 PV 才能被 PVC 绑定：</p><ul><li>VolumeMode：被消费 PV 的 VolumeMode 需要和 PVC 一致。</li><li>AccessMode：被消费 PV 的 AccessMode 需要和 PVC 一致。</li><li>StorageClassName：如果 PVC 定义了此参数，PV 必须有相关的参数定义才能进行绑定。</li><li>LabelSelector：通过标签（<strong>labels</strong>）匹配的方式从 PV 列表中选择合适的 PV 绑定。</li><li>Size：被消费 PV 的 <strong>capacity</strong> 必须大于或者等于 PVC 的存储容量需求才能被绑定。</li></ul><h2 id="在-k3s-上实践-pv-和-pvc"><a href="#在-k3s-上实践-pv-和-pvc" class="headerlink" title="在 k3s 上实践 pv 和 pvc"></a>在 k3s 上实践 pv 和 pvc</h2><p>pvc.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">local-path-pvc</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">local-path</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">50Mi</span><br></code></pre></td></tr></table></figure><p>创建并查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f pvc.yaml</span><br>persistentvolumeclaim/local-path-pvc created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pvc</span><br>NAME             STATUS    VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE<br>local-path-pvc   Pending                                      local-path     102s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pv</span><br>No resources found<br></code></pre></td></tr></table></figure><p>发现 pvc 的状态是 pending，查看 describe：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Events:<br>  Type    Reason                Age                 From                         Message<br>  ----    ------                ----                ----                         -------<br>  Normal  WaitForFirstConsumer  11s (x9 over 2m3s)  persistentvolume-controller  waiting for first consumer to be created before binding<br></code></pre></td></tr></table></figure><p>意思是 pvc 创建好了，等待某个消费者来绑定它，所以处于 pending 状态，接下来创建一个 pod 作为消费者，来绑定这个 pvc：</p><p>pvc_consumer_pod.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">volume-test</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volume-test</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:stable-alpine</span><br>    <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volv</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/data</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volv</span><br>    <span class="hljs-attr">persistentVolumeClaim:</span><br>      <span class="hljs-attr">claimName:</span> <span class="hljs-string">local-path-pvc</span><br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f pvc_consumer_pod.yaml</span><br>pod/volume-test created<br></code></pre></td></tr></table></figure><p>此时再查看 pvc 状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pvc</span><br>NAME             STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE<br>local-path-pvc   Bound    pvc-0e7db0b6-fa32-4c2e-ac0c-53a354ead8a4   50Mi       RWO            local-path     5m41s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pv</span><br>NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                    STORAGECLASS   REASON   AGE<br>pvc-0e7db0b6-fa32-4c2e-ac0c-53a354ead8a4   50Mi       RWO            Delete           Bound    default/local-path-pvc   local-path              41m<br></code></pre></td></tr></table></figure><p>发现 pvc 已经处于 Bound 状态了，此外 pv 也已经创建好了</p><p>接下来就可以测试一下效果了，首先需要先进入容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">k3s kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>redis         1/1     Running   0          9h<br>volume-test   1/1     Running   0          5m49s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it volume-test -- /bin/sh</span><br>/ # ls<br>bin                   docker-entrypoint.sh  media                 root                  sys<br>data                  etc                   mnt                   run                   tmp<br>dev                   home                  opt                   sbin                  usr<br>docker-entrypoint.d   lib                   proc                  srv                   var<br></code></pre></td></tr></table></figure><p>因为 pvc_consumer_pod.yaml 中，我们定义的挂载目录的 &#x2F;data，所以我们要 cd 到容器的 &#x2F;data 目录，然后向这个目录中写入一些内容，再看看其 pvc 绑定的 pv 是否会同步拥有该内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 此时接着上面的 exec，也就是在容器内部执行这些命令</span><br>/ <span class="hljs-comment"># cd data</span><br>/data <span class="hljs-comment"># echo &quot;hello, local PV&quot; &gt; pvc-test</span><br>/data <span class="hljs-comment"># cat pvc-test</span><br>hello, <span class="hljs-built_in">local</span> PV<br></code></pre></td></tr></table></figure><p>在 local PV 查看是否同样有此文件，在 k3s 中，pv 存储在 &#x2F;var&#x2F;lib&#x2F;rancher&#x2F;k3s&#x2F;storage 目录下，k3s 的 pv 相关内容可以 <a href="https://www.jianshu.com/p/dd186961e398">参考这篇</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">退出容器内部，回到主机</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /var/lib/rancher/k3s/storage/</span><br>pvc-0e7db0b6-fa32-4c2e-ac0c-53a354ead8a4_default_local-path-pvc<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /var/lib/rancher/k3s/storage/pvc-0e7db0b6-fa32-4c2e-ac0c-53a354ead8a4_default_local-path-pvc</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span></span><br>pvc-test<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在容器内部写入的内容，同步到了这里</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> pvc-test</span><br>hello, local PV<br></code></pre></td></tr></table></figure><p>结果说明测试成功</p><h2 id="如果两个-pod-绑定到同一个-pvc-上会怎样？"><a href="#如果两个-pod-绑定到同一个-pvc-上会怎样？" class="headerlink" title="如果两个 pod 绑定到同一个 pvc 上会怎样？"></a>如果两个 pod 绑定到同一个 pvc 上会怎样？</h2><p>继续沿用之前的 pvc_consumer_pod.yaml，做一些修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span> pvc_consumer_pod.yaml pvc_consumer_pod1.yaml</span><br></code></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">volume-test1</span> <span class="hljs-comment"># 此处修改</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volume-test1</span> <span class="hljs-comment"># 此处修改</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:stable-alpine</span><br>    <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volv</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/data</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volv</span><br>    <span class="hljs-attr">persistentVolumeClaim:</span><br>      <span class="hljs-attr">claimName:</span> <span class="hljs-string">local-path-pvc</span><br></code></pre></td></tr></table></figure><p>创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f pvc_consumer_pod1.yaml</span><br>pod/volume-test1 created<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME           READY   STATUS    RESTARTS   AGE<br>redis          1/1     Running   0          10h<br>volume-test    1/1     Running   0          25m<br>volume-test1   1/1     Running   0          32s<br></code></pre></td></tr></table></figure><p>发现创建成功了</p><p>还是按照之前的流程，先 exec 进容器看看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it volume-test1 -- /bin/sh</span><br>/ # ls<br>bin                   docker-entrypoint.sh  media                 root                  sys<br>data                  etc                   mnt                   run                   tmp<br>dev                   home                  opt                   sbin                  usr<br>docker-entrypoint.d   lib                   proc                  srv                   var<br>/ # cd data/<br>/data # ls<br>pvc-test<br>/data # cat pvc-test<br>hello, local PV<br></code></pre></td></tr></table></figure><p>发现 &#x2F;data 下已经有内容了，而且就是之前 volume-test 这个 pod 写入的内容，尝试向这个文件里新写入一部分内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">/data # echo &quot;hello again&quot; &gt;&gt; pvc-test<br>/data # cat pvc-test<br>hello, local PV<br>hello again<br></code></pre></td></tr></table></figure><p>查看 local PV：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /var/lib/rancher/k3s/storage/pvc-0e7db0b6-fa32-4c2e-ac0c-53a354ead8a4_default_local-path-pvc/pvc-test</span><br>hello, local PV<br>hello again<br></code></pre></td></tr></table></figure><p>查看第一个容器 volume-test :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it volume-test -- /bin/sh</span><br>/ # cat /data/pvc-test<br>hello, local PV<br>hello again<br></code></pre></td></tr></table></figure><p>发现二者的内容都同步了</p><p>如此看来，多个 pod 可以绑定同一个 pvc 来达到共享文件的效果，pv 和 pvc 是一对一绑定的，但是 pod 和 pvc 是可以多对一绑定的。</p><h1 id="删除-pvc"><a href="#删除-pvc" class="headerlink" title="删除 pvc"></a>删除 pvc</h1>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 mac 上制作 windows10 启动盘，亲测可用</title>
    <link href="/2022/05/17/mac-shang-zhi-zuo-windows/"/>
    <url>/2022/05/17/mac-shang-zhi-zuo-windows/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来源：<a href="https://chinese.freecodecamp.org/news/how-make-a-windows-10-usb-using-your-mac-build-a-bootable-iso-from-your-macs-terminal/">https://chinese.freecodecamp.org/news/how-make-a-windows-10-usb-using-your-mac-build-a-bootable-iso-from-your-macs-terminal/</a></p></blockquote><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ol><li>windows iso 文件</li><li>一个大小至少 8G 的 U 盘</li><li>mac 上安装好 homebrew</li></ol><h1 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h1><p>查看 U 盘的名称：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">diskutil list</span><br></code></pre></td></tr></table></figure><p>该命令会列出电脑上所有的磁盘设备，可以通过大小来确认哪个是你插入的 U 盘，比如我的是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">/dev/disk8 (external, physical):<br><span class="hljs-meta prompt_">   #</span><span class="language-bash">:                       TYPE NAME                    SIZE       IDENTIFIER</span><br>   0:     FDisk_partition_scheme                        *31.0 GB    disk8<br>   1:               Windows_NTFS WINDOWS10               31.0 GB    disk8s1<br></code></pre></td></tr></table></figure><p>那么 disk8 就是我的 U 盘的名称了。</p><h1 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h1><p>格式化 U 盘：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">diskutil eraseDisk FAT32 <span class="hljs-string">&quot;WINDOWS10&quot;</span> MBR disk8</span><br></code></pre></td></tr></table></figure><p>这里的 disk8 要替换成你的 u 盘名称，”WINDOWS10” 是格式化后对硬盘的重命名，可以指定为任意值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">Started erase on disk8<br>Unmounting disk<br>Creating the partition map<br>Waiting for partitions to activate<br>Formatting disk8s1 as MS-DOS (FAT32) with name WINDOWS10<br>512 bytes per physical sector<br>/dev/rdisk8s1: 60507232 sectors in 1890851 FAT32 clusters (16384 bytes/cluster)<br>bps=512 spc=32 res=32 nft=2 mid=0xf8 spt=32 hds=255 hid=2048 drv=0x80 bsec=60536832 bspf=14773 rdcl=2 infs=1 bkbs=6<br>Mounting disk<br>Finished erase on disk8<br></code></pre></td></tr></table></figure><p>提示以上信息说明格式化成功。</p><h1 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h1><p>挂载 windows iso 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hdiutil mount /Volumes/c/Win10_2004_Chinese\(Simplified\)_x64.iso</span><br>hdiutil: mount failed - 资源暂时不可用<br></code></pre></td></tr></table></figure><p>mout 后面是你的 iso 所在路径</p><p>也可以双击 iso 文件来进行挂载，因为我之前已经双击挂载过了，所以这里提示“资源暂时不可用”</p><p>挂载完成后，finder 的位置会显示一个名为 <code>CCCOMA_X64FRE_ZH-CN_DV9</code> 的文件（也可能是 <code>CCCOMA_X64FRE_EN-US_DV9</code> ，取决于 iso 文件），也可以在 &#x2F;Volumes 目录下找到，比如我的是 &#x2F;Volumes&#x2F;CCCOMA_X64FRE_ZH-CN_DV9（可以通过 <code>ls /Volumes </code> 查看），这个路径后面会用到</p><h1 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h1><p>复制文件到 u 盘，Windows 10 ISO 中的一个文件 <code>install.wim</code> 现在太大而无法复制到 FAT-32 格式的 USB 驱动器，需要单独复制它。</p><p>首先运行此命令以复制除该文件之外的所有内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">rsync -vha --exclude=sources/install.wim /Volumes/CCCOMA_X64FRE_ZH-CN_DV9/* /Volumes/WINDOWS10</span><br></code></pre></td></tr></table></figure><p>（这里将  &#x2F;Volumes&#x2F;CCCOMA_X64FRE_ZH-CN_DV9&#x2F; 替换为你的目录，参考步骤 3，&#x2F;Volumes&#x2F;WINDOWS10 替换为你的 u 盘名，参考步骤 2）</p><p>然后继续创建你要将文件写入的目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> /Volumes/WINDOWS10/sources</span><br></code></pre></td></tr></table></figure><p>如果提示 <code>File exists</code>  说明该文件夹已存在，可以继续执行下面的步骤。</p><p>使用 Homebrew 使用此终端命令安装名为 wimlib 的工具，该工具用于分割 install.wim 为 2 个小于 4G 的文件，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">brew install wimlib</span><br></code></pre></td></tr></table></figure><p>然后运行这个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wimlib-imagex <span class="hljs-built_in">split</span> /Volumes/CCCOMA_X64FRE_EN-US_DV9/sources/install.wim /Volumes/WIN10/sources/install.swm 3800</span><br></code></pre></td></tr></table></figure><p>同样的，需要将 <code>/Volumes/CCCOMA_X64FRE_EN-US_DV9/</code> 这部分替换为你的路径，以及 <code>/Volumes/WIN10/</code> 这部分。之后需要等待一会，直到提示以下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Splitting WIM: 4193 MiB of 4193 MiB (100%) written, part 2 of 2<br>Finished splitting &quot;/Volumes/CCCOMA_X64FRE_ZH-CN_DV9/sources/install.wim&quot; # 制作完成<br></code></pre></td></tr></table></figure><h1 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h1><p>至此启动盘已经制作完成，弹出 u 盘，插入到要安装 windows 的电脑，并使用 u 盘启动便可以看到 windows 的安装界面了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在 mac 上制作 windows 启动盘还是有点小麻烦的，不像 windows 上直接使用软碟通那么简单方便，网上也有不少教程是过时错误的，比如使用 balenaEtcher ，这个软件自己都会弹出警告，无法刻录 windows，还有使用命令行的，要将 u 盘格式化为 MS-DOS 格式，因为 MS-DOS 格式无法一次写入 4G 以上的文件，会提示 <code>File too large</code> 错误，如果格式化为 ExFAT，虽然可以成功写入，但是 bios 无法识别出 U 盘。其实本文使用的方法也是命令行，只是对 4G 文件进行了特殊处理，总的来看这个方法简单有效，感谢这位大佬的教程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>实用工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux iptables</title>
    <link href="/2022/05/16/iptables/"/>
    <url>/2022/05/16/iptables/</url>
    
    <content type="html"><![CDATA[<blockquote><p>文档状态：Draft</p></blockquote><hr><h1 id="链，表和规则"><a href="#链，表和规则" class="headerlink" title="链，表和规则"></a>链，表和规则</h1><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>顾名思义，规则就是针对网络包的不同 <strong>行为</strong>，做出对应的 <strong>处理操作</strong>，比如如果我收到的网络包的 IP 是 xx.xx.xx.xx，那么我就将其丢弃；如果我收到的包的端口是 8080，我就将其转发给 XXX 之类的，也可以说，<strong>规则就是匹配条件 + 处理操作</strong>。</p><p>动作包括：</p><ol><li><strong>ACCEPT</strong> - 允许数据包通过。</li><li><strong>DROP</strong> - 丢弃数据包，不对发送者进行任何回应。</li><li><strong>REJECT</strong> - 拒绝数据包并向发送者发送错误响应。</li><li><strong>LOG</strong> - 在日志中记录数据包的详细信息（通常是 <code>/var/log/messages</code>），然后数据包继续其他规则的检查。</li><li><strong>RETURN</strong> - 在链中停止当前规则集的处理，并返回到上一规则或链的处理中。</li><li><strong>SNAT</strong> - 源地址转换（Source NAT），用于改变发出数据包的源IP地址。</li><li><strong>DNAT</strong> - 目的地址转换（Destination NAT），用于改变到达数据包的目标IP地址。</li><li><strong>MASQUERADE</strong> - 一种特殊的SNAT，主要用于动态的IP地址，比如拨号或移动的连接。</li><li><strong>REDIRECT</strong> - 将数据包导向本机的另一个端口。</li></ol><h3 id="匹配条件"><a href="#匹配条件" class="headerlink" title="匹配条件"></a>匹配条件</h3><p>匹配条件分为基本匹配条件与扩展匹配条件</p><p><strong>基本匹配条件：</strong></p><p>源地址Source IP，目标地址 Destination IP</p><p>上述内容都可以作为基本匹配条件。</p><p><strong>扩展匹配条件：</strong></p><p>除了上述的条件可以用于匹配，还有很多其他的条件可以用于匹配，这些条件泛称为扩展条件，这些扩展条件其实也是netfilter中的一部分，只是以模块的形式存在，如果想要使用这些条件，则需要依赖对应的扩展模块。</p><p>源端口Source Port, 目标端口Destination Port</p><p>上述内容都可以作为扩展匹配条件</p><h2 id="链"><a href="#链" class="headerlink" title="链"></a>链</h2><p>链是多个规则的集合。</p><p>当报文到达时，它会与这条链上所有的规则逐条进行匹配，看是否满足条件，然后 <strong>执行第一个满足条件</strong> 的规则对应的动作。</p><p>比如 OUTPUT 链上有 a, b, c 三条规则，报文到达时，就会分别和这三条进行匹配，假如其中 a,b 满足，那么只执行 a 对应的动作，而不会执行 b 的动作。</p><p>为什么要这么做？比如我在一条链上设置了两条规则，第一条是拒绝来自 1.1.1.1 的报文，第二条是接收来自 1.1.1.1 的报文，这个时候肯定不能两条都执行，所以按照顺序，只会执行第一条，也就是拒绝操作。</p><blockquote><p>参考：<a href="https://www.zsythink.net/archives/1517">https://www.zsythink.net/archives/1517</a></p></blockquote><p>所以规则的顺序很重要</p><blockquote><p><del>实验：</del></p><p><del>可以在一台机器上运行 3 个 tcp server，分别监听在 8080, 9090, 9091，每个 server 都会向连接写入不同的内容用于辨别。</del></p><p><del>然后设置 iptables，将请求为 8080 和 9090 的 tcp 重定向到 9091</del></p><p><del>iptables -t nat -I OUTPUT -p tcp -s 198.19.249.224 –dport 9090 -j DNAT –to-destination 198.19.249.224:9091</del></p><p><del>iptables -t nat -I OUTPUT -p tcp -s 198.19.249.224 –dport 8080 -j DNAT –to-destination 198.19.249.224:9091</del></p><p><del>然后 nc 198.19.249.224 9090 和 nc 198.19.249.224 8080 看看，它们都会返回 9091 的结果</del></p></blockquote><p>iptables 定义了以下几种链：</p><ul><li><strong>INPUT链</strong>：处理到达本机的数据包。</li><li><strong>OUTPUT链</strong>：处理本机产生的向外发送的数据包。</li><li><strong>FORWARD链</strong>：处理需要穿过本机转发给其他设备的数据包。</li><li><strong>PREROUTING链</strong> 和 <strong>POSTROUTING链</strong>：主要在 nat 表中使用，分别用于处理目标地址转换之前和之后的数据包。</li></ul><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20240502190742.png" alt="image.png"></p><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p>链上可以有多条规则，而表可以对这条链上的这些规则进行分类。</p><p>iptables 已经为我们定义了 4 种表，每种表对应了不同的功能，我们自定义的所有规则都存在于这 4 张表中（用户不能自定义新的表）。</p><ul><li><strong>filter表</strong>：这是默认表，用于决定数据包的基本处理动作（如允许、拒绝或丢弃）。它主要关注数据包的访问控制。</li><li><strong>nat表</strong>：用于网络地址转换（NAT）的设置，如端口转发、地址重写等。</li><li><strong>mangle表</strong>：用于特殊的数据包修改操作，如更改TTL（生存时间）、分片设置等。</li><li><strong>raw表</strong>：用于决定数据包是否被状态跟踪机制处理。</li></ul><p>下面这张图有助于理解：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20240430164119.png" alt="image.png"></p><h2 id="表和链的关系"><a href="#表和链的关系" class="headerlink" title="表和链的关系"></a>表和链的关系</h2><p>每张表可以拥有的链的种类都是规定好的（或者反过来说，每个链可以拥有的表的种类是规定好的）。</p><p>比如上面那张图，它的意思是说，prerouting 链只拥有 nat 表、raw 表和 mangle 表所对应的功能，所以，prerouting 中的规则只能存放于 nat表、raw 表和 mangle 表中。</p><p>如果我尝试给 filter 表添加 PREROUTING 链，会报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t filter -I PREROUTING -s 192.168.64.1 -j DROP</span><br>iptables: No chain/target/match by that name.<br></code></pre></td></tr></table></figure><p>表链关系有点迷惑的地方是，有的图是以表为参照物的，而有的图又是以链为参照物的，</p><p>比如这张图就是以表为参照物的，它列出了哪些表拥有哪些链：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20240502193931.png" alt="image.png"></p><p>然后这张图又是以链为参照物的，它列出了 prerouting 这条链可以拥有哪些表：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20240430164119.png" alt="image.png"></p><p>其实都一样，不过基于 iptables 的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">iptables -t filter -I PREROUTING -s 192.168.64.1 -j DROP<br></code></pre></td></tr></table></figure><p>似乎是以表为参照物更通用一些。</p><p>更新：直接看下面这张图就行了</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20240502222733.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下表链关系：</p><p><strong>以链为参照物</strong></p><p>PREROUTING    的规则可以存在于：raw表，mangle表，nat表。</p><p>INPUT      的规则可以存在于：mangle表，filter表，（centos7中还有nat表，centos6中没有）。</p><p>FORWARD     的规则可以存在于：mangle表，filter表。</p><p>OUTPUT     的规则可以存在于：raw表mangle表，nat表，filter表。</p><p>POSTROUTING    的规则可以存在于：mangle表，nat表。</p><p><strong>以表为参照物</strong></p><p>raw   表中的规则可以被哪些链使用：PREROUTING，OUTPUT</p><p>mangle  表中的规则可以被哪些链使用：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING</p><p>nat   表中的规则可以被哪些链使用：PREROUTING，OUTPUT，POSTROUTING（centos7中还有INPUT，centos6中没有）</p><p>filter  表中的规则可以被哪些链使用：INPUT，FORWARD，OUTPUT</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>iptables为我们定义了4张”表”,当他们处于同一条”链”时，执行的优先级如下。</p><p>优先级次序（由高而低）：</p><p>raw –&gt; mangle –&gt; nat –&gt; filter</p><p>比如：</p><p>prerouting链中的规则存放于三张表中，而这三张表中的规则执行的优先级如下：</p><p>raw –&gt; mangle –&gt; nat</p><h1 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h1><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 filter 表的所有规则，-t 后面跟表名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t filter -L</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 filter 表的 INPUT 链的所有规则</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t filter -L INPUT</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 raw 表的所有规则</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t raw -L</span>    <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 filter 表（-t 缺省时，默认为 filter 表）的 INPUT 链上的所有规则</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -L INPUT</span>     <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">加 -v 可以输出更详细的信息</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -vL INPUT</span>    <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">加 -n 会直接输出 IP 地址，不加的话会继续转换，比如 0.0.0.0 会转换为 anywhere</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -nL INPUT</span>    <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">为输出的规则列表添加序号</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables --line -L INPUT</span> <br></code></pre></td></tr></table></figure><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">iptables -t filter -I INPUT -s 192.168.64.1 -j DROP<br></code></pre></td></tr></table></figure><p>上面的命令表示：在 filter 表的 INPUT 链中添加一条规则：丢弃（DROP）源地址为 192.168.64.1 的报文</p><p>每个参数的意思：</p><p>-t：指定要操作的表，此处指定了操作 filter 表，不使用 -t 选项指定表时，默认为操作 filter 表</p><p>-I：指明将 ”规则” 插入至哪个链中，即添加规则，是插入到头部（也就是第一条）</p><p>-A：也是插入规则，不过是插入到尾部</p><p>-s：指明“匹配条件”中的”源地址”，如果报文的源地址属于-s对应的地址，那么报文则满足匹配条件</p><p>-j：指明当”匹配条件”被满足时，所对应的动作</p><p>测试：</p><p>上面添加的 192.168.64.1是我的宿主机 ip，现在用宿主机来访问一下这台设置了规则的虚拟机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ping 192.168.64.5 <span class="hljs-comment"># ping 虚拟机</span></span><br>PING 192.168.64.5 (192.168.64.5): 56 data bytes<br>Request timeout for icmp_seq 0<br>Request timeout for icmp_seq 1<br>Request timeout for icmp_seq 2<br></code></pre></td></tr></table></figure><p>发现已经无法访问了。（之后发现 ssh 给断了，虚拟机也进不去了，用的是 multipass😅）</p><p>添加规则的同时可以指定其插入的位置，不同的位置会影响规则的执行。具体的例子可以参考 <a href="https://www.zsythink.net/archives/1517%EF%BC%8C%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B%E6%98%AF%EF%BC%9A%E5%B7%B2%E7%BB%8F%E8%AE%BE%E7%BD%AE%E4%BA%86%E4%B8%80%E6%9D%A1">https://www.zsythink.net/archives/1517，大致流程是：已经设置了一条</a> drop 规则，如果追加一条相同 ip，但是 accept 的规则，发现依然无法 ping 通，因为 drop 在前 accept 在后；但是如果将 accept 插入到头部，那么 INPUT 链会先执行 accept 规则，数据包就会被放行，因为报文已经被放行了，所以，即使第二条 drop 规则能够匹配到刚才”放行”的报文，也没有机会再对刚才的报文进行丢弃操作了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-A 追加一条规则（append），也就是添加到末尾</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -A INPUT -s 192.168.64.1 -j ACCEPT</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-I 添加到头部</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -I INPUT -s 192.168.64.1 -j ACCEPT</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">插入到规则的下标 2 处</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -I INPUT 2 -s 192.168.64.1 -j ACCEPT</span><br></code></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><strong>根据规则编号删除</strong>（如果想查看编号，需要在查询时指定 –line 参数，比如 <code>iptables -t filter -L INPUT --line</code>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t filter -D INPUT 3</span><br></code></pre></td></tr></table></figure><p>上面的命令会删除 filter 表的 INPUT 链的第 3 条规则</p><p><strong>根据匹配条件删除</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -D INPUT -s 192.168.64.1 -j ACCEPT</span><br></code></pre></td></tr></table></figure><p>上述命令表示删除 INPUT 链中源地址为 192.168.64.1，动作为 ACCEPT 的规则</p><p><strong>清空链上的规则</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">清空 filter 表 INPUT 链中的规则</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -F INPUT</span><br></code></pre></td></tr></table></figure><p><strong>清空表的所有规则</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">不指定链名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -F</span><br></code></pre></td></tr></table></figure><h1 id="自定义链"><a href="#自定义链" class="headerlink" title="自定义链"></a>自定义链</h1><p>自定义链用于对规则的管理，这里我有一个疑问，iptables 的 <strong>表</strong> 已经是对规则的一种分类管理了，为什么还需要自定义链呢？我暂时的理解是，虽然表已经进行了分类，但是粒度还是比较粗，比如 filter 表只是负责过滤功能，但是过滤功能可能还需要进行进一步分类，比如有针对 HTTP 的过滤规则，有针对 SSH 的过滤规则，</p><p>自定义链不能直接使用，只能被某个默认的链当做动作去调用</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>实验的两台机器 IP 为：192.168.1.110 和 192.168.1.103，在 110 上设置一条自定义链，规则是阻止 103 这台机器来访问 8080 端口，8080 运行了一个 web 程序，访问会返回 “Hello”</p><p>首先创建一条名为 IN_WEB 的自定义链</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t filter -N IN_WEB</span><br></code></pre></td></tr></table></figure><p>为该链设置规则，对 <strong>源地址</strong> 为  192.168.1.103 的连接进行 <strong>REJECT</strong> （拒绝）处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t filter -I IN_WEB -s 192.168.1.103 -j REJECT</span><br></code></pre></td></tr></table></figure><p>查看 filter 中的规则，使用 IN_WEB 进行过滤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t filter --line -nvL IN_WEB</span><br>Chain IN_WEB (0 references)<br>num   pkts bytes target     prot opt in     out     source               destination<br>1        0     0 REJECT     all  --  *      *       192.168.1.103        0.0.0.0/0            reject-with icmp-port-unreachable<br></code></pre></td></tr></table></figure><p>自定义链不能直接使用，需要将其添加到一条 <strong>默认链</strong> 中， 将该链添加到 INPUT 链中，这代表该条链用于接收到数据时</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -I INPUT -p tcp --dport 8080 -j IN_WEB</span><br></code></pre></td></tr></table></figure><p>查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t filter --line -nvL IN_WEB</span><br>Chain IN_WEB (1 references)<br> pkts bytes target     prot opt in     out     source               destination<br>    0     0 REJECT     all  --  *      *       192.168.1.103        0.0.0.0/0            reject-with icmp-port-unreachable<br></code></pre></td></tr></table></figure><p>此时使用 103 的机器访问 110 的 8080 端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 192.168.1.110:8080</span><br>curl: (7) Failed to connect to 192.168.1.110 port 8080 after 37 ms: Connection refused<br></code></pre></td></tr></table></figure><p>报错 “Connection refused”（连接被拒绝），这个错误见得也比较多了，当访问的端口没有被程序监听时，也会报这个错误。此时说明拦截规则已经成功。</p><p>110 的 9090 端口上也运行了一个 web 程序，访问一下看看是不是只拦截了 8080 端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 192.168.1.110:9090</span><br><span class="hljs-meta prompt_">Hello%</span><br></code></pre></td></tr></table></figure><p>9090 可以正常访问，说明拦截规则成功。</p><h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><p>删除自定义链需要满足两个条件</p><p>1、自定义链没有被引用</p><p>2、自定义链中没有任何规则</p><p>自定义链被放置在 INPUT 上，首先查看 INPUT 的所有规则，并删除属于自定义链的规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -nvL INPUT <span class="hljs-comment"># 查看 INPUT 链上的所有规则</span></span><br>Chain INPUT (policy ACCEPT 4397 packets, 972K bytes)<br> pkts bytes target     prot opt in     out     source               destination<br>    0     0 IN_WEB     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:80<br> 7753 1508K KUBE-ROUTER-INPUT  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kube-router netpol - 4IA2OSFRMVNDXBVV */<br>    0     0 IN_WEB     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:80<br>    1    64 IN_WEB     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:5555<br>    <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -D INPUT 7 <span class="hljs-comment"># 删除规则，数字是上面列表的序号，根据自己的实际情况来指定</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables --line-number -vL INPUT <span class="hljs-comment"># 使用 --line-numbers 可以显示规则的编号，这样删除起来更方便</span></span><br>Chain INPUT (policy ACCEPT 2702 packets, 895K bytes)<br>num   pkts bytes target     prot opt in     out     source               destination<br>1     5865 1470K KUBE-ROUTER-INPUT  all  --  any    any     anywhere             anywhere             /* kube-router netpol - 4IA2OSFRMVNDXBVV */<br>2     2702  895K KUBE-FIREWALL  all  --  any    any     anywhere             anywhere<br>3     2702  895K KUBE-NODEPORTS  all  --  any    any     anywhere             anywhere             /* kubernetes health check service ports */<br>4        0     0 KUBE-EXTERNAL-SERVICES  all  --  any    any     anywhere             anywhere             ctstate NEW /* kubernetes externally-visible service portals */<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -F IN_WEB <span class="hljs-comment"># 清空 filter 表上的 IN_WEB 链上的所有规则（不指定 -t 时默认为 filter 表）</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -X IN_WEB <span class="hljs-comment"># 删除链</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t filter --line -nvL IN_WEB <span class="hljs-comment"># 再次查看该链，发现已经无法输出信息了，说明删除成功</span></span><br>iptables v1.8.7 (nf_tables): chain `IN_WEB&#x27; in table `filter&#x27; is incompatible, use &#x27;nft&#x27; tool.<br></code></pre></td></tr></table></figure><h1 id="数据包处理流程"><a href="#数据包处理流程" class="headerlink" title="数据包处理流程"></a>数据包处理流程</h1><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20240502222646.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20240502222733.png" alt="image.png"></p><blockquote><p>我设置了这样两条规则：</p><p>iptables -t nat -I PREROUTING -p tcp -s 198.19.249.224 –dport 9090 -j DNAT –to-destination 198.19.249.224:8080<br>iptables -t nat -I PREROUTING -p tcp -s 198.19.249.224 –dport 8080 -j DNAT –to-destination 198.19.249.224:9090 </p><p>198.19.249.224 就是本机 ip，也就是说我的想法是通过 iptables，让尝试访问本机 8080 端口的连接转而访问 9090，尝试访问 9090 的转而访问 8080，这两个端口都监听了程序，访问 8080 会返回 You Visit 8080，访问 9090 会返回 You Visit 9090 但是现在我执行 nc 198.19.249.224 9090 依然会显示 You Visit 9090，为什么？</p><p>🤖</p><p>当您在同一台机器上设置「iptables」规则时，它不会对本地生成的数据包产生影响。因此，在同一台机器上执行的「nc 198.19.249.224 9090」命令，事实上根本不经过「PREROUTING」链，它直接进入到「INPUT」链。</p><p>如果您想要使这种转发规则对本地生成的数据包产生影响，您需要在「OUTPUT」链中添加相似的规则。但是，很重要的一点是，您需要保证这种设置不会导致无限循环。在这个特定的情况下，将「端口 9090」的流量转发到「端口 8080」，然后又把「端口 8080」的流量再转发回「端口 9090」会导致无限转发循环。</p><p>一个可能的解决方式是使用不同的源地址或其他标准来区分两种不同的转发规则，以防止转发循环的发生。但是，这需要进一步的网络设计和规划，您应该根据具体的需求和网络环境来决定最佳做法。</p><p>PS：试了一下，改成 OUTPUT 链确实可以</p></blockquote><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="DNT-转发"><a href="#DNT-转发" class="headerlink" title="DNT 转发"></a>DNT 转发</h2><p>流程：有两台机器 192.168.64.4 （简称 4）和 192.168.64.1（简称 1），4 上的 8080 和 9090 端口运行了两个 tcp 程序，连接到 8080 时会返回消息： ”8080“，连接到 9090 时会返回消息 ”9090“，这里通过 iptables 设置 nat 转发，将访问 8080 的连接转发到 9090，也就是 DNAT（D 代表 dst，目标），修改报文的目标地址。</p><p>在 1 上添加规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t nat -A PREROUTING -p tcp -d 192.168.64.4 --dport 8080 -j DNAT --to 192.168.64.4:9090</span><br></code></pre></td></tr></table></figure><p>上面命令的意思是，在 nat 表的 PREROUTING 链中添加一条规则，将目标地址为 192.168.64.4，协议为 tcp 的请求转发（DNAT）到 192.168.64.4 （本机）的 9090 端口</p><p>查看规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t nat -nL PREROUTING</span><br>DNAT       tcp  --  0.0.0.0/0            192.168.64.4         tcp dpt:8080 to:192.168.64.4:9090<br></code></pre></td></tr></table></figure><p>在 1 上执行 nc：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">nc 192.168.64.4 8080</span><br>9090<br></code></pre></td></tr></table></figure><p>访问的是 8080 端口，返回的消息是 9090，说明转发成功。</p><p>这两个程序还会记录访问的 IP 地址，查看日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> 8080</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> 9090</span><br>2022/05/19 15:41:44 192.168.64.1:63310<br></code></pre></td></tr></table></figure><p>8080 的日志为空，说明该请求被 iptables <strong>拦截</strong> 后直接转发给了 9090，而不是让 8080 代理访问 9090。</p><p>附代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">&quot;net&quot;</span><br>        <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        l, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8080&quot;</span>)<br>        assert(err)<br><br>        <span class="hljs-keyword">for</span> &#123;<br>                conn, err := l.Accept()<br>                assert(err)<br>                log.Println(conn.RemoteAddr())<br>                conn.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;8080&quot;</span>))<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">&quot;net&quot;</span><br>        <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        l, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:9090&quot;</span>)<br>        assert(err)<br><br>        <span class="hljs-keyword">for</span> &#123;<br>                conn, err := l.Accept()<br>                assert(err)<br>                log.Println(conn.RemoteAddr())<br>                conn.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;9090&quot;</span>))<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 nohup 部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build tcp_8080.go</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build tcp_9090.go</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nohup</span> ./tcp_8080 &gt; 8080 &amp;</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nohup</span> ./tcp_9090 &gt; 9090 &amp;</span><br></code></pre></td></tr></table></figure><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p><a href="https://vflong.github.io/sre/network/2020/02/23/turning-iptables-into-a-tcp-load-balancer.html">https://vflong.github.io/sre/network/2020/02/23/turning-iptables-into-a-tcp-load-balancer.html</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables/page/2">https://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables/page/2</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一段莫名阻塞的 reflect 代码</title>
    <link href="/2022/05/13/block-code/"/>
    <url>/2022/05/13/block-code/</url>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>Do()<br>&#125;<br><br><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *S)</span></span> Do() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">EnforcePtr</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>v := reflect.TypeOf(obj)<br>  fmt.Println(v)<br><span class="hljs-keyword">if</span> v == <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(v.Kind())<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i I<br>EnforcePtr(i)<br><br><span class="hljs-keyword">var</span> ii I = <span class="hljs-built_in">new</span>(S)<br>EnforcePtr(ii)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码运行后会阻塞，阻塞在 <code>fmt.Println(v.Kind()) </code> 这一行，不太清楚原因，暂时作为记录</p><p>ps：阻塞后 shell 窗口无法通过 ctrl+c 强制结束，需要通过下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep &lt;go file name&gt; | grep -v grep | grep run | awk &#123;&#x27;print $2&#x27;&#125; | xargs kill<br></code></pre></td></tr></table></figure><p>只需要将 <code>EnforcePtr</code> 改为如下形式即可正常工作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">EnforcePtr</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>    v := reflect.TypeOf(obj)<br>    fmt.Println(v)<br>    <span class="hljs-keyword">if</span> v == <span class="hljs-literal">nil</span> &#123;<br>        typ := reflect.TypeOf(&amp;v).Elem()<br>        fmt.Println(typ.Kind())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>issue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s Deployment</title>
    <link href="/2022/05/13/k8s-deployment/"/>
    <url>/2022/05/13/k8s-deployment/</url>
    
    <content type="html"><![CDATA[<p><strong>deplopyment</strong> 用于 Pod 的更新相关操作。</p><h1 id="如何更新一组-Pod"><a href="#如何更新一组-Pod" class="headerlink" title="如何更新一组 Pod"></a>如何更新一组 Pod</h1><p>更新是一个非常常见的场景，比如：当前有一组 Pod 运行的是某个 v1 版本的镜像，一个月后该镜像发布了 v2 版本，此时想将所有的 Pod 更新到 v2 版本，该怎么做呢？</p><p>比较容易想到的以下几种方式：</p><h2 id="先删除所有旧版本的-Pod，再创建新版本的-Pod"><a href="#先删除所有旧版本的-Pod，再创建新版本的-Pod" class="headerlink" title="先删除所有旧版本的 Pod，再创建新版本的 Pod"></a><strong>先删除所有旧版本的 Pod，再创建新版本的 Pod</strong></h2><p>实践如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicationController</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia-v1</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">luksa/kubia:v1</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">nodejs</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>创建一个基于 luksa&#x2F;kubia:v1 的镜像的 Pod，同时创建一个 service</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME             READY   STATUS    RESTARTS   AGE<br>kubia-v1-td826   1/1     Running   0          4m16s<br>kubia-v1-k8hz4   1/1     Running   0          4m16s<br>kubia-v1-7kpmg   1/1     Running   0          4m16s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rc</span><br>NAME       DESIRED   CURRENT   READY   AGE<br>kubia-v1   3         3         3       5m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE<br>kubernetes   ClusterIP   10.43.0.1       &lt;none&gt;        443/TCP   37h<br>kubia        ClusterIP   10.43.191.168   &lt;none&gt;        80/TCP    5m3s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl kubia</span><br>This is v1 running in Pod kubia-v1-7kpmg<br></code></pre></td></tr></table></figure><p>测试访问，输出表示当前运行的是 v1 版本</p><p>现在来进行升级操作，将 <code>luksa/kubia:v1</code> 升级为 <code>luksa/kubia:v2</code>。</p><p>修改 yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">luksa/kubia:v2</span><br>      <br></code></pre></td></tr></table></figure><p>执行 yaml：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f kubia-rc-and-service-v1.yaml</span><br>replicationcontroller/kubia-v1 configured<br>service/kubia unchanged<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 10.43.191.168</span><br>This is v1 running in Pod kubia-v1-7kpmg<br></code></pre></td></tr></table></figure><p>发现输出的还是 v1，可能是因为 rc 已经有 3 个 Pod 了，修改 image 不会令其删除旧的并创建新的，那就只好手动删除旧 Pod 了（更新：因为 rc 只保证 replicas 满足需求即可，更新镜像不会让其触发更新，这是 Deployment 做的事）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete po -l app=kubia</span><br>Pod &quot;kubia-v1-td826&quot; deleted<br>Pod &quot;kubia-v1-k8hz4&quot; deleted<br>Pod &quot;kubia-v1-7kpmg&quot; deleted<br></code></pre></td></tr></table></figure><p>此时删除了所有 app&#x3D;kubia 的 Pod（在我的机器上测试时，这个删除操作阻塞了将近 10s），rc 检测到其管理的 Pod 数量不足所需的数量 3，那么就会新创建 3 个 Pod，因为之前改掉了创建 template 中的镜像为 v2，所以现在 rc 创建出来的都是新版本的 Pod 了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME             READY   STATUS    RESTARTS   AGE<br>kubia-v1-b5lkr   1/1     Running   0          37s<br>kubia-v1-tq7nh   1/1     Running   0          37s<br>kubia-v1-w6r6t   1/1     Running   0          37s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 10.43.191.168</span><br>This is v2 running in Pod kubia-v1-w6r6t<br></code></pre></td></tr></table></figure><p>经过上面的一系列操作，终于完成了 Pod 的升级，这种方式有一个问题：<strong>删除旧 Pod 后到新 Pod 起来这段时间，是没有 Pod 能够提供服务的，这就会导致程序在一段时间内不可用，这对于一些应用是无法接受的。此外，新的 Pod 也可能存在无法起来的问题，这个时候我们就需要再次执行类似 “回滚” 的操作，再重新把老版本的 Pod 创起来</strong></p><h2 id="先创建新版本的-Pod，再删除所有旧版本的-Pod"><a href="#先创建新版本的-Pod，再删除所有旧版本的-Pod" class="headerlink" title="先创建新版本的 Pod，再删除所有旧版本的 Pod"></a><strong>先创建新版本的 Pod，再删除所有旧版本的 Pod</strong></h2><p>先将镜像退回至 v1 版本，采用和上面相同的方式，这里就不贴具体操作了。</p><p>复制一份之前的 yaml，在该基础上进行修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span> kubia-rc-and-service-v1.yaml kubia-rc-and-service-v2.yaml</span><br></code></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicationController</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia-v2</span> <span class="hljs-comment"># 修改</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">kubia-v2</span> <span class="hljs-comment"># 修改</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">luksa/kubia:v2</span> <span class="hljs-comment"># 修改</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">nodejs</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">kubia-v2</span> <span class="hljs-comment"># 修改</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>修改之处已经标出，注意这里还更新了 service 的选择器，让其为 app&#x3D;kubia-v2 的 Pod 提供对外服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f kubia-rc-and-service-v2.yaml</span><br>replicationcontroller/kubia-v2 created<br>service/kubia configured<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rs</span><br>No resources found in default namespace.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rc</span><br>NAME       DESIRED   CURRENT   READY   AGE<br>kubia-v1   3         3         3       68m<br>kubia-v2   3         3         3       18s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME             READY   STATUS    RESTARTS   AGE<br>kubia-v1-7pxtm   1/1     Running   0          11m<br>kubia-v1-zt5pg   1/1     Running   0          11m<br>kubia-v1-gnssp   1/1     Running   0          11m<br>kubia-v2-46w9g   1/1     Running   0          20s<br>kubia-v2-66wqr   1/1     Running   0          20s<br>kubia-v2-bvjqc   1/1     Running   0          20s<br></code></pre></td></tr></table></figure><p>此时访问 service：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 10.43.191.168</span><br>This is v2 running in Pod kubia-v2-dj8cf<br></code></pre></td></tr></table></figure><p>发现已经切换到了 v2</p><p>后续再删除 v1 的 Pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rc</span><br>NAME       DESIRED   CURRENT   READY   AGE<br>kubia-v1   3         3         3       76m<br>kubia-v2   3         3         3       98s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete rc kubia-v1</span><br>replicationcontroller &quot;kubia-v1&quot; deleted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME             READY   STATUS        RESTARTS   AGE<br>kubia-v2-dj8cf   1/1     Running       0          2m9s<br>kubia-v2-4q5tv   1/1     Running       0          2m9s<br>kubia-v2-rbbfd   1/1     Running       0          2m9s<br>kubia-v1-gnssp   1/1     Terminating   0          19m<br>kubia-v1-7pxtm   1/1     Terminating   0          19m<br>kubia-v1-zt5pg   1/1     Terminating   0          19m<br></code></pre></td></tr></table></figure><p>等待一会，这些 Terminating 状态的 Pod 就会消失了。</p><p><strong>使用这种方式可以做到不停机更新，但是需要更多的硬件资源，因为在短时间内会同时运行 2 倍的 Pod。</strong></p><h2 id="交替执行，删一个旧的，创建一个新的（滚动更新）"><a href="#交替执行，删一个旧的，创建一个新的（滚动更新）" class="headerlink" title="交替执行，删一个旧的，创建一个新的（滚动更新）"></a>交替执行，删一个旧的，创建一个新的（滚动更新）</h2><p>这种方式比较繁琐，就不演示了，大致的思路是：和 <strong>先创建新版本的 Pod，再删除所有旧版本的 Pod</strong> 中的做法一样，再创建一个用于管理 v2 的 rc（这里称为 rc-v2，之前的称为 rc-v1），但是 replicas 置为 0，此时有两个 rc：rc-v1，replicas 为 3，rc-v2，replicas 为 0，然后开始交替执行，rc-v2 扩容到 1，等这个 Pod 起来以后，再把 rc-v1 缩容为 2，以此类推，来完成滚动升级。</p><p>这种方式避免了前面两种同时创建、同时删除的缺点， 但是其也有自己的缺点：较为繁琐，且容易出错，一套流程下来要敲非常多的命令。</p><p>好在强大的 k8s 提供了指令来完成 Pod 的更新操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rolling-update kubia-v1 kubia-v2 --image=luksa/kubia:v2</span><br></code></pre></td></tr></table></figure><blockquote><p>⚠️ 该命令已经被删除 ：error: unknown command “rolling-update” for “kubectl”</p><p><a href="https://stackoverflow.com/questions/65303683/why-kubectl-removed-command-rolling-update">https://stackoverflow.com/questions/65303683/why-kubectl-removed-command-rolling-update</a></p><p><a href="https://github.com/kubernetes/kubectl/commit/d3af7e08624bfa7c2f52714b47cfe96a52d15fc0">https://github.com/kubernetes/kubectl/commit/d3af7e08624bfa7c2f52714b47cfe96a52d15fc0</a></p><p>大致原因是：该命令是在客户端执行的，而不是在 k8s 内部执行，相比之下客户端更容易遇到一些网络中断、终端异常退出等错误，这会导致 Pod 和 rc 处于中间状态</p></blockquote><h1 id="使用-Deployment-进行更新"><a href="#使用-Deployment-进行更新" class="headerlink" title="使用 Deployment 进行更新"></a>使用 Deployment 进行更新</h1><p>上面已经给出了更新一组 Pod 的几种方式，但是这些方式有一个共同的问题，就是需要我们去手动执行，这显然是非常不方便的，而我们这篇文章的主角 Deployment 正是用来解决这个问题的。</p><p>我们直接通过实践来了解这个资源。</p><p>如下的 yaml 定义了一个 Deployment 以及对应的一个 Service，这个 Deployment 使用了 v1 版本的镜像：</p><p><code>kubia-deployment-and-service-v1.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">luksa/kubia:v1</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">nodejs</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span> <br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span><br><br></code></pre></td></tr></table></figure><p>然后我们创建它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f kubia-deployment-and-service-v1.yaml --record</span><br>Flag --record has been deprecated, --record will be removed in the future<br>deployment.apps/kubia created<br></code></pre></td></tr></table></figure><p>书上着重强调了：<code>确保在创建时使用了 --record 选项。 这个选项会记录下你每次操作所执行的命令， 在之后的操作中非常有用</code>。然而运行后这里直接提示该选项已被废弃（Flag –record has been deprecated, –record will be removed in the future），难道已经默认记录版本号了吗？不过不关键，就算废弃了对我们学习而言也无关紧要。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">k get deploy</span><br>NAME               READY   UP-TO-DATE   AVAILABLE   AGE<br>kubia              3/3     3            3           114s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                     READY   STATUS    RESTARTS   AGE<br>kubia-5f6cdb7bf7-4pn9b   1/1     Running   0          7m26s<br>kubia-5f6cdb7bf7-kt8gp   1/1     Running   0          7m26s<br>kubia-5f6cdb7bf7-f6w5g   1/1     Running   0          7m26s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE<br>kubernetes   ClusterIP   10.43.0.1       &lt;none&gt;        443/TCP   2d<br>kubia        ClusterIP   10.43.191.168   &lt;none&gt;        80/TCP    11h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 10.43.191.168</span><br>This is v1 running in Pod kubia-5f6cdb7bf7-f6w5g<br></code></pre></td></tr></table></figure><p>开始执行滚动升级：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl patch deployment kubia -p <span class="hljs-string">&#x27;&#123;&quot;spec&quot;: &#123;&quot;minReadySeconds&quot;: 10&#125;&#125;&#x27;</span></span><br>deployment.apps/kubia patched<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">set</span> image deployment kubia nodejs=luksa/kubia:v2 <span class="hljs-comment"># 更新镜像</span></span><br></code></pre></td></tr></table></figure><p>这里通过 patch 为 这个 deployment 添加了一条 minReadySeconds: 10 的属性，这个属性的作用是：指定新创建的 Pod 至少要成功运行多久之后，才能将其视为可用，在后面会详细说明这个属性。（PS：执行这条命令不会触发 deployment 的滚动更新）</p><blockquote><p>🤔 为什么执行这个命令不会触发 Deployment 的滚动更新？因为我验证了，执行这条语句是会触发 controller 调协事件的</p><p>这个可能要通过阅读 deployment controller 源码来探明原因了</p></blockquote><p>使用 set image 命令来进行镜像的更新，其中的 nodejs 指的是 template.sepc.containers.name，执行完这条命令后，Deployment 的更新就开始了。</p><p>我们可以先 describe 一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">k get deploy kubia<br>NAME    READY   UP-TO-DATE   AVAILABLE   AGE<br>kubia   4/3     1            3           3h58m<br></code></pre></td></tr></table></figure><p>然后我们可以继续在 describe 的信息中，看一下 events 事件信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">Events:<br>  Type    Reason             Age   From                   Message<br>  ----    ------             ----  ----                   -------<br>  Normal  ScalingReplicaSet  91s   deployment-controller  Scaled up replica set kubia-88894bbd4 to 1<br>  Normal  ScalingReplicaSet  78s   deployment-controller  Scaled down replica set kubia-5f6cdb7bf7 to 2<br>  Normal  ScalingReplicaSet  78s   deployment-controller  Scaled up replica set kubia-88894bbd4 to 2<br>  Normal  ScalingReplicaSet  65s   deployment-controller  Scaled down replica set kubia-5f6cdb7bf7 to 1<br>  Normal  ScalingReplicaSet  65s   deployment-controller  Scaled up replica set kubia-88894bbd4 to 3<br>  Normal  ScalingReplicaSet  53s   deployment-controller  Scaled down replica set kubia-5f6cdb7bf7 to 0<br></code></pre></td></tr></table></figure><p>可以看到，在 Age&#x3D;91s 的位置，Deployment（准确的说是 Deployment Controller，如果你还不了解 k8s Controller，那么可以先忽略括号里的这段话） 将一个名为 kubia-88894bbd4 的 rs 的副本数扩展（Scaled up）为了 1，然后在 Age&#x3D;78s 的位置，又将一个名为 kubia-5f6cdb7bf7 的 rs 的副本数缩减（Scaled down）到了 2，然后如此交替执行，最终 kubia-88894bbd4 的副本数变成了 3，而 kubia-5f6cdb7bf7 的副本数变成了 1。</p><p>等等，这看起来是不是很熟悉？就和我们在 <strong>如何更新一组 Pod</strong> 这一节下的 <strong>滚动更新</strong> 里提到的流程非常类似？实际上正是如此，这也是 Deployment 底层工作机制的原理，Deployment 通过管理 ReplicaSet 来管理一组 Pod 的版本，当我们更新 Deployment 时，它会创建一个新的 ReplicaSet，然后对新的 ReplicaSet 进行扩容，对旧的 ReplicaSet 进行缩容，最终来达到滚动更新的目的。当然，Deployment 的功能不仅仅是这么简单，它还允许对滚动更新进行一些策略配置，这些我们后面再说。</p><p>此外，我还好奇的一点是，滚动更新过程中将会同时存在新旧版本的 Pod，那么访问的流量是不是也会打在新旧 Pod 上呢？下面我们验证一下：</p><p>在更新完 Deployment 的 image 后，立马开一个新的 shell ，执行下面的命令，观察在升级过程，我们的流量访问情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> curl 10.43.191.168; <span class="hljs-built_in">sleep</span> 0.5s;<span class="hljs-keyword">done</span></span><br>This is v1 running in Pod kubia-5f6cdb7bf7-f6w5g<br>This is v2 running in Pod kubia-88894bbd4-pbr5n<br>This is v2 running in Pod kubia-88894bbd4-h8mck<br>This is v1 running in Pod kubia-5f6cdb7bf7-f6w5g<br>This is v1 running in Pod kubia-5f6cdb7bf7-f6w5g<br>This is v2 running in Pod kubia-88894bbd4-w74nb<br>This is v2 running in Pod kubia-88894bbd4-pbr5n<br>This is v1 running in Pod kubia-5f6cdb7bf7-f6w5g<br>This is v2 running in Pod kubia-88894bbd4-h8mck<br>This is v2 running in Pod kubia-88894bbd4-h8mck<br>This is v2 running in Pod kubia-88894bbd4-w74nb<br>This is v2 running in Pod kubia-88894bbd4-h8mck<br>This is v2 running in Pod kubia-88894bbd4-h8mck<br>This is v2 running in Pod kubia-88894bbd4-w74nb<br>This is v2 running in Pod kubia-88894bbd4-pbr5n<br></code></pre></td></tr></table></figure><p>可以看到，刚开始请求会打到 v1 或者 v2，到后面就全部是 v2 了，说明升级已经完成，也就是说，在升级过程中，流量确实会在一段时间内同时打到新旧 Pod 上。</p><p>我们上面提到的更新使用的都是 <strong>滚动更新</strong> 的方式，其实具体使用哪种方式是可以配置的，字段是 spec.strategy.type，默认为 RollingUpdate，也就是滚动更新，还有一种 Recreate，采用的是先删除所有旧的，再创建新 Pod 的方式，这个方式感觉实际用的不会太多，所以暂时就先不太关注了。</p><h1 id="使用-Deployment-进行回滚"><a href="#使用-Deployment-进行回滚" class="headerlink" title="使用 Deployment 进行回滚"></a>使用 Deployment 进行回滚</h1><h2 id="为什么需要回滚"><a href="#为什么需要回滚" class="headerlink" title="为什么需要回滚"></a>为什么需要回滚</h2><p>可能存在这样一种场景：更新后的新版本 Pod 存在一些 bug，此时就需要进行回滚操作，将 Pod 回滚成之前的旧版本了。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>接着之前的实践继续操作，我们已经知道，Deployment 实际是通过控制 ReplicaSet 来进行滚动更新，那我们现在就看一下 ReplicaSet：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rs</span><br>NAME                          DESIRED   CURRENT   READY   AGE<br>kubia-5f6cdb7bf7              0         0         0       4h24m<br>kubia-88894bbd4               3         3         3       25m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe kubia-5f6 <span class="hljs-comment"># 确认一下版本</span></span><br>...<br>Pod Template:<br>  Labels:  app=kubia<br>           Pod-template-hash=5f6cdb7bf7<br>  Containers:<br>   nodejs:<br>    Image:        luksa/kubia:v1<br>...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe rs kubia-888 <span class="hljs-comment"># 确认一下版本</span></span><br>...<br>Pod Template:<br>  Labels:  app=kubia<br>           Pod-template-hash=88894bbd4<br>  Containers:<br>   nodejs:<br>    Image:        luksa/kubia:v2<br>...<br></code></pre></td></tr></table></figure><p>会发现之前的老 rs 没有被删除（也就是全部参数都为 0 的那个名为 kubia-5f6cdb7bf7 的 ReplicaSet）</p><p>为什么要保留旧的 rs 呢？<del>这里先卖个关子</del> 为的是能够完成回滚操作</p><p>下面我们将开始 Deployment 回滚操作的实践。</p><p>我们继续对 Deployment 进行升级，将镜像版本更新到 v3 ，这是一个带有错误的版本，从第 5 次访问开始，接口就会返回一个 500 错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">set</span> image deployment kubia nodejs=luksa/kubia:v3 <span class="hljs-comment"># 更新到 v3</span></span><br>deployment.apps/kubia image updated<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout status deployment kubia <span class="hljs-comment"># 查看更新状态</span></span><br>Waiting for deployment &quot;kubia&quot; rollout to finish: 1 out of 3 new replicas have been updated...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 1 out of 3 new replicas have been updated...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 1 out of 3 new replicas have been updated...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 1 out of 3 new replicas have been updated...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 2 out of 3 new replicas have been updated...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 2 out of 3 new replicas have been updated...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 2 out of 3 new replicas have been updated...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 2 out of 3 new replicas have been updated...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 1 old replicas are pending termination...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 1 old replicas are pending termination...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 1 old replicas are pending termination...<br>deployment &quot;kubia&quot; successfully rolled out<br></code></pre></td></tr></table></figure><p>在另一个终端查看访问 service 的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> curl 10.43.191.168; <span class="hljs-built_in">sleep</span> 0.5s;<span class="hljs-keyword">done</span></span><br>This is v3 running in Pod kubia-56ff78687-kc77b<br>Some internal error has occurred! This is Pod kubia-56ff78687-2b7tz<br>This is v3 running in Pod kubia-56ff78687-kc77b<br>Some internal error has occurred! This is Pod kubia-56ff78687-2b7tz<br>This is v2 running in Pod kubia-88894bbd4-h8mck<br>Some internal error has occurred! This is Pod kubia-56ff78687-2b7tz<br>This is v3 running in Pod kubia-56ff78687-mbqdw<br>This is v3 running in Pod kubia-56ff78687-mbqdw<br>Some internal error has occurred! This is Pod kubia-56ff78687-mbqdw<br>This is v3 running in Pod kubia-56ff78687-kc77b<br>This is v2 running in Pod kubia-88894bbd4-h8mck<br></code></pre></td></tr></table></figure><p>可以看到有一些报错了：Some internal error has occurred! This is Pod kubia-56ff78687-mbqdw</p><p>对外提供一个有 bug 的 Pod 显然是不行的，此时就需要执行回滚操作了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout undo deployment kubia</span><br>deployment.apps/kubia rolled back<br></code></pre></td></tr></table></figure><p>在另一个终端查看访问 service 的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> curl 10.43.191.168; <span class="hljs-built_in">sleep</span> 0.5s;<span class="hljs-keyword">done</span></span><br>This is v2 running in Pod kubia-88894bbd4-rvzvb<br>This is v2 running in Pod kubia-88894bbd4-rvzvb<br>This is v2 running in Pod kubia-88894bbd4-pxxwt<br>This is v2 running in Pod kubia-88894bbd4-pxxwt<br>This is v2 running in Pod kubia-88894bbd4-4wknk<br>This is v2 running in Pod kubia-88894bbd4-4wknk<br></code></pre></td></tr></table></figure><p>发现已经回滚到 v2 版本了。</p><p>查看更新记录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout <span class="hljs-built_in">history</span> deployment kubia</span><br>deployment.apps/kubia<br>REVISION  CHANGE-CAUSE<br>1         kubectl apply --filename=deployment.yaml --record=true<br>3         kubectl apply --filename=deployment.yaml --record=true<br>4         kubectl apply --filename=deployment.yaml --record=true<br></code></pre></td></tr></table></figure><p>这里显示的和书中的有所不同，书中显示的是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout <span class="hljs-built_in">history</span> deployment kubia</span><br>deployments &quot;kubia&quot;:<br>REVISION CHANGE-CAUSE<br>2 kubectl set image deployment kubia nodejs=luksa/kubia:v2 <br>3 kubectl set image deployment kubia nodejs=luksa/kubia:v3<br></code></pre></td></tr></table></figure><p>感觉书上这种显示的友好一些，而且我执行的明明是 kubectl set image deployment kubia nodejs&#x3D;xxx ，为什么这里记录的是 kubectl apply –filename&#x3D;deployment.yaml –record&#x3D;true ？</p><p>前面提到过，–record 已经被废弃，难道新版本对 CHANGE-CAUSE 进行了一些变更吗？暂时还不知道啥情况</p><p>可以通过指定版本来查看详细信息，这样就可以解决上面的问题了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout <span class="hljs-built_in">history</span> deployment/kubia --revision=1</span><br>deployment.apps/kubia with revision #1<br>Pod Template:<br>  Labels:app=kubia<br>Pod-template-hash=5f6cdb7bf7<br>  Annotations:kubernetes.io/change-cause: kubectl apply --filename=deployment.yaml --record=true<br>  Containers:<br>   nodejs:<br>    Image:luksa/kubia:v1<br>    Port:&lt;none&gt;<br>    Host Port:&lt;none&gt;<br>    Environment:&lt;none&gt;<br>    Mounts:&lt;none&gt;<br>  Volumes:&lt;none&gt;<br></code></pre></td></tr></table></figure><p>此时就可以看到该版本对应的镜像了。</p><p>至此已经经历了 v1 - v3 一共 3 个版本的迭代，有更新操作也有回滚操作，此时查看 rs：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rs</span><br>NAME               DESIRED   CURRENT   READY   AGE<br>kubia-5f6cdb7bf7   0         0         0       17h<br>kubia-88894bbd4    3         3         3       16h<br>kubia-56ff78687    0         0         0       15h<br></code></pre></td></tr></table></figure><p>会发现每个版本的 rs 依然存在，为的就是能执行回滚操作，顺带一提，回滚不仅仅是上个版本，还可以是任意一个版本，使用 <code>kubectl rollout undo deployment kubia --to-revision=l</code> 即可。在使用了 deployment 后，系统中的 rs 就不用我们去管理了，所以我们也不需要自己去手动修改、删除 rs 了。</p><h1 id="控制滚动升级速率"><a href="#控制滚动升级速率" class="headerlink" title="控制滚动升级速率"></a>控制滚动升级速率</h1><p>有两个属性可以用来控制升级速率：</p><ul><li>maxSurge：升级过程中最多允许超出 replicas 的 Pod 数量，值可以是一个百分比或者一个数字</li><li>maxUnavailable：升级过程中最多允许的不可用 Pod 数量，值可以是一个百分比或者一个数字</li></ul><p>这两个值定义在 .spec.strategy.rollingUpdate 中，下面对这两个属性进行展开说明。</p><p>前面提到过滚动升级的流程，大致是使用两个 rs，一个管理旧版本 Pod，一个管理新版本 Pod，管理旧版本的 rs 不断缩容，管理新版本的 rs 不断扩容，最终完成更新。通过上面的两个属性就可以对整个流程的速率进行控制，举个例子：现在一共有 3 个 Pod 需要升级，此时将 maxUnavailable 设置为 2，代表最多允许有 2 个 Pod 不可用，那么此时缩容 rs 就可以缩到 1。引用官方的说明：</p><blockquote><p><strong>最大不可用</strong></p><p><code>.spec.strategy.rollingUpdate.maxUnavailable</code> 是一个可选字段，用来指定 更新过程中不可用的 Pod 的个数上限。该值可以是绝对数字（例如，5），也可以是所需 Pods 的百分比（例如，10%）。百分比值会转换成绝对数并去除小数部分。 如果 <code>.spec.strategy.rollingUpdate.maxSurge</code> 为 0，则此值不能为 0。 默认值为 25%。</p><p>例如，当此值设置为 30% 时，滚动更新开始时会立即将旧 ReplicaSet 缩容到期望 Pod 个数的70%。 新 Pod 准备就绪后，可以继续缩容旧有的 ReplicaSet，然后对新的 ReplicaSet 扩容， 确保在更新期间可用的 Pods 总数在任何时候都至少为所需的 Pod 个数的 70%。</p><p><strong>最大峰值</strong></p><p><code>.spec.strategy.rollingUpdate.maxSurge</code> 是一个可选字段，用来指定可以创建的超出期望 Pod 个数的 Pod 数量。此值可以是绝对数（例如，5）或所需 Pods 的百分比（例如，10%）。 如果 <code>MaxUnavailable</code> 为 0，则此值不能为 0。百分比值会通过向上取整转换为绝对数。 此字段的默认值为 25%。</p><p>例如，当此值为 30% 时，启动滚动更新后，会立即对新的 ReplicaSet 扩容，同时保证新旧 Pod 的总数不超过所需 Pod 总数的 130%。一旦旧 Pods 被杀死，新的 ReplicaSet 可以进一步扩容， 同时确保更新期间的任何时候运行中的 Pods 总数最多为所需 Pods 总数的 130%。</p></blockquote><p>对于书上的表 9.2 我有点疑问，对这两个属性的描述都是：<code>当把百分数转换成绝对值时，会将数字四舍五入</code>，但是后面又举了个例子：</p><blockquote><p>由于在之前场景中，设置的期望副本数为 3，上述的两个属性都设置为 25%, maxSurge 允许最多 Pod 数量达到 4， 同时 maxUnavailable 不允许出现任何不可用的 Pod (也就是说三个 Pod 必须一直处于可运行状态)</p></blockquote><p>副本数为 3，maxUnavailable 设置为 25%，3*25% &#x3D; 0.75，四舍五入等于 1，那么应该允许有 1 个 Pod 不可用，为什么书上说的是不允许任何 Pod 不可用？</p><p>再看官方的文档：</p><p>maxUnavailable 说的是：百分比值会转换成绝对数并去除小数部分</p><p>maxSurge 说的是：百分比值会通过向上取整转换为绝对数</p><p>这显然和书上说的四舍五入有出入，那么到底实际情况如何呢？只有源码能揭晓答案了。</p><p>对应的函数在 kubernetes&#x2F;pkg&#x2F;controller&#x2F;deployment&#x2F;util&#x2F;deployment_util.go 下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// desired 代表副本数量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ResolveFenceposts</span><span class="hljs-params">(maxSurge, maxUnavailable *intstrutil.IntOrString, desired <span class="hljs-type">int32</span>)</span></span> (<span class="hljs-type">int32</span>, <span class="hljs-type">int32</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// maxSurge 没有设置，则使用默认值 0</span><br><span class="hljs-comment">// roundUp 设置为 true，代表向上取整</span><br>surge, err := intstrutil.GetScaledValueFromIntOrPercent(intstrutil.ValueOrDefault(maxSurge, intstrutil.FromInt(<span class="hljs-number">0</span>)), <span class="hljs-type">int</span>(desired), <span class="hljs-literal">true</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, err<br>&#125;<br><span class="hljs-comment">// maxUnavailable 没有设置，则使用默认值 0</span><br><span class="hljs-comment">// roundUp 设置为 false，代表向下取整</span><br>unavailable, err := intstrutil.GetScaledValueFromIntOrPercent(intstrutil.ValueOrDefault(maxUnavailable, intstrutil.FromInt(<span class="hljs-number">0</span>)), <span class="hljs-type">int</span>(desired), <span class="hljs-literal">false</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, err<br>&#125;<br><span class="hljs-comment">// 所以 surge 和 unavailable 采用的策略是不同的</span><br><span class="hljs-comment">// 比如 replicas 为 3，maxSurge 和 maxUnavailable 都设置为 25%，</span><br><span class="hljs-comment">// 3 * 25 / 100 = 0.75，surge 采用向上取整，所以为 1，而 unavailable</span><br><span class="hljs-comment">// 采用向下取整, 所以为 0</span><br><br><span class="hljs-keyword">if</span> surge == <span class="hljs-number">0</span> &amp;&amp; unavailable == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Validation should never allow the user to explicitly use zero values for both maxSurge</span><br><span class="hljs-comment">// maxUnavailable. Due to rounding down maxUnavailable though, it may resolve to zero.</span><br><span class="hljs-comment">// If both fenceposts resolve to zero, then we should set maxUnavailable to 1 on the</span><br><span class="hljs-comment">// theory that surge might not work due to quota.</span><br>unavailable = <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-type">int32</span>(surge), <span class="hljs-type">int32</span>(unavailable), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>调用的 GetScaledValueFromIntOrPercent 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// intOrPercent 代表一个整数或者百分比字符串，total 代表总数量，roundUp 代表向上取整还是向下取整，</span><br><span class="hljs-comment">// 如果 intOrPercent 是 int，那么直接返回，如果是百分比，则返回 total*百分比后的值（还需要进行取整处理）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetScaledValueFromIntOrPercent</span><span class="hljs-params">(intOrPercent *IntOrString, total <span class="hljs-type">int</span>, roundUp <span class="hljs-type">bool</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> intOrPercent == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;nil value for IntOrString&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 获取 intOrPercent 的值，该值可能是一个数字或者百分比</span><br>value, isPercent, err := getIntOrPercentValueSafely(intOrPercent)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.Errorf(<span class="hljs-string">&quot;invalid value for IntOrString: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 如果该值是百分比</span><br><span class="hljs-keyword">if</span> isPercent &#123;<br><span class="hljs-comment">// 如果设置了 roundUp（不知道咋翻译），则向上取整，比如 1.2 =&gt; 2（不是四舍五入）</span><br><span class="hljs-keyword">if</span> roundUp &#123;<br>value = <span class="hljs-type">int</span>(math.Ceil(<span class="hljs-type">float64</span>(value) * (<span class="hljs-type">float64</span>(total)) / <span class="hljs-number">100</span>))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 否则向下取整，比如 1.5 =&gt; 1</span><br>value = <span class="hljs-type">int</span>(math.Floor(<span class="hljs-type">float64</span>(value) * (<span class="hljs-type">float64</span>(total)) / <span class="hljs-number">100</span>))<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> value, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestResolveFenceposts1</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>maxSurge := intstr.FromString(<span class="hljs-string">&quot;25%&quot;</span>)<br>maxUnavailable := intstr.FromString(<span class="hljs-string">&quot;25%&quot;</span>)<br><span class="hljs-keyword">var</span> replicas <span class="hljs-type">int32</span> = <span class="hljs-number">3</span><br>s, u, err := ResolveFenceposts(&amp;maxSurge, &amp;maxUnavailable, replicas)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>t.Error(err)<br>&#125;<br>t.Log(s, u)<br>&#125;<br><br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// 1 0 </span><br><span class="hljs-comment">// 代表两个值都设置为 25% 的情况下，允许多出 1 个 Pod，允许有 0 个 Pod 不可用</span><br></code></pre></td></tr></table></figure><p>所以书上说的四舍五入并不准确，官方文档才是正确的，不过最靠谱的还是看源码 （狗头）。</p><h2 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h2><p>该 yaml 用来创建一个 replicas 为 3 的 deployment：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f nginx-deployment.yaml --record</span><br>deployment.apps/nginx-deployment created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rs</span>                                    <br>NAME                          DESIRED   CURRENT   READY   AGE<br>nginx-deployment-7848d4b86f   3         3         3       6m57s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新 deployment 的镜像版本，1.91 是一个不存在的版本</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">set</span> image deployment/nginx-deployment nginx=nginx:1.91</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看该 deployment 管理的 rs，发现多出来了一个 rs，其期望的 Pod 数量为 1，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">但是因为 1.91 版本不存在，所以 READY 为 0，这个多出来的 rs 就是用来做滚动更新的</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rs</span>                                                <br>NAME                          DESIRED   CURRENT   READY   AGE<br>nginx-deployment-7848d4b86f   3         3         3       6h54m<br>nginx-deployment-b475d749b    1         1         0       7m8s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看更新后的 deployment</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get deploy</span>                                            <br>NAME               READY   UP-TO-DATE   AVAILABLE   AGE<br>nginx-deployment   3/3     1            3           6h59m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 deployment 的详细信息，发现滚动策略为 25% max unavailable, 25% max surge，也就是允许多出 1 个 Pod，允许</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">有 0 个 Pod 不可用，所以会创建一个新的 Pod，所以那个新创建出来的 rs 的 replicas 为 1</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe deploy nginx-deployment</span>        <br>Name:                   nginx-deployment<br>Namespace:              default<br>CreationTimestamp:      Tue, 11 Oct 2022 17:21:35 +0800<br>Labels:                 app=nginx<br>Annotations:            deployment.kubernetes.io/revision: 4<br>                        kubernetes.io/change-cause: kubectl apply --filename=nginx-deployment.yaml --record=true<br>Selector:               app=nginx<br>Replicas:               3 desired | 1 updated | 4 total | 3 available | 1 unavailable<br>StrategyType:           RollingUpdate<br>MinReadySeconds:        0<br>RollingUpdateStrategy:  25% max unavailable, 25% max surge<br>Pod Template:<br>  Labels:  app=nginx<br>  Containers:<br>   nginx:<br>    Image:        nginx:1.91<br>    Port:         80/TCP<br>    Host Port:    0/TCP<br>    Environment:  &lt;none&gt;<br>    Mounts:       &lt;none&gt;<br>  Volumes:        &lt;none&gt;<br>Conditions:<br>  Type           Status  Reason<br>  ----           ------  ------<br>  Available      True    MinimumReplicasAvailable<br>  Progressing    True    ReplicaSetUpdated<br>OldReplicaSets:  nginx-deployment-7848d4b86f (3/3 replicas created)<br>NewReplicaSet:   nginx-deployment-b475d749b (1/1 replicas created)<br>Events:<br>  Type    Reason             Age                 From                   Message<br>  ----    ------             ----                ----                   -------<br>  Normal  ScalingReplicaSet  9m9s                deployment-controller  Scaled down replica set nginx-deployment-b475d749b to 0<br>  Normal  ScalingReplicaSet  6m9s (x2 over 13m)  deployment-controller  Scaled up replica set nginx-deployment-b475d749b to 1<br></code></pre></td></tr></table></figure><h1 id="升级过程中检测新版本是否可用"><a href="#升级过程中检测新版本是否可用" class="headerlink" title="升级过程中检测新版本是否可用"></a>升级过程中检测新版本是否可用</h1><p>在回滚一节中说过，更新的新版本可能是一个无法工作的版本，此时需要回滚操作，那么有没有一种方法可以边更新边检测，发现不可用就停止更新呢？当然可以，使用一个额外的 minReadySeconds 属性 + 就绪探针就可以实现。</p><p>minReadySeconds 属性指定新创建的 Pod 至少要成功运行多久之后，才能将其视为可用。在 Pod 可用之前，滚动升级的过程不会继续。当所有容器的就绪探针返回成功时，Pod 就被标记为就绪状态。</p><p>如果一个新的 Pod 运行出错，就绪探针返回失败，或者在 minReadySeconds 时间内它的就绪探针出现了失败， 那么新版本的滚动升级将被阻止。</p><p>之前的笔记有写过存活探针，这里的是就绪探针，二者有所区别，但区别不是特别大，这里简单摘要一下官方的文档：</p><blockquote><p>livenessProbe（存活探针）</p><p>指示容器是否正在运行。如果存活态探测失败，则 kubelet 会杀死容器， 并且容器将根据其<a href="https://kubernetes.io/zh/docs/concepts/workloads/Pods/Pod-lifecycle/#restart-policy">重启策略</a>决定未来。如果容器不提供存活探针， 则默认状态为 <code>Success</code>。</p><p>readinessProbe（就绪探针）</p><p>指示容器是否准备好为请求提供服务。如果就绪态探测失败， 端点控制器将从与 Pod 匹配的所有服务的端点列表中删除该 Pod 的 IP 地址。 初始延迟之前的就绪态的状态值默认为 <code>Failure</code>。 如果容器不提供就绪态探针，则默认状态为 <code>Success</code>。</p><p>startupProbe（启动探针）</p><p>指示容器中的应用是否已经启动。如果提供了启动探针，则所有其他探针都会被 禁用，直到此探针成功为止。如果启动探测失败，<code>kubelet</code> 将杀死容器，而容器依其 <a href="https://kubernetes.io/zh/docs/concepts/workloads/Pods/Pod-lifecycle/#restart-policy">重启策略</a>进行重启。 如果容器没有提供启动探测，则默认状态为 <code>Success</code>。</p></blockquote><h2 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h2><p>yaml 如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">minReadySeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># Pod 就绪后继续等待 10 秒</span><br>  <span class="hljs-attr">strategy:</span><br>    <span class="hljs-attr">rollingUpdate:</span><br>      <span class="hljs-attr">maxSurge:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 确保升级过程中 Pod 被挨个替换</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">RollingUpdate</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">luksa/kubia:v3</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">nodejs</span><br>          <span class="hljs-attr">readinessProbe:</span> <span class="hljs-comment"># 就绪探针</span><br>            <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 探针每隔 1 秒执行一次</span><br>            <span class="hljs-attr">httpGet:</span><br>              <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>              <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br><br></code></pre></td></tr></table></figure><p>这是一个“坏掉”的镜像：就绪探针检测不会成功，下面来执行 yaml：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f kubia-deployment-v3-with-readinesscheck.yaml</span><br>deployment.apps/kubia configured<br></code></pre></td></tr></table></figure><p>apply 命令可以用 YAML 文件中声明的字段来更新 Deployment。不仅更新镜像，而且还添加了就绪探针，以及在 YAML 中添加或修改的其他声明。 如果新的 YAML 也包含 replicas 字段，当它与现有 Deployment 中的数量不一 致时，那么 apply 操作也会对 Dpeloymnet 进行扩容。</p><p>此时查看升级过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout status deployment kubia</span><br>Waiting for deployment &quot;kubia&quot; rollout to finish: 1 out of 3 new replicas have been updated...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">很久以后...</span><br>error: deployment &quot;kubia&quot; exceeded its progress deadline<br></code></pre></td></tr></table></figure><p>整个流程卡在了更新第一个 Pod，说明更新失败了，使用 curl 请求 service 看看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> curl 10.43.191.168; <span class="hljs-built_in">sleep</span> 0.5s;<span class="hljs-keyword">done</span></span><br>This is v2 running in Pod kubia-88894bbd4-4wknk<br>This is v2 running in Pod kubia-88894bbd4-pxxwt<br>This is v2 running in Pod kubia-88894bbd4-rvzvb<br>This is v2 running in Pod kubia-88894bbd4-4wknk<br>This is v2 running in Pod kubia-88894bbd4-pxxwt<br>This is v2 running in Pod kubia-88894bbd4-pxxwt<br>This is v2 running in Pod kubia-88894bbd4-pxxwt<br></code></pre></td></tr></table></figure><p>发现请求全部打在了 v2 Pod 上，没有 v3 版本，这是符合需求的，请求不应该落到一个有问题的 Pod 上</p><p>查看 Pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                     READY   STATUS    RESTARTS   AGE<br>kubia-88894bbd4-rvzvb    1/1     Running   0          23h<br>kubia-88894bbd4-4wknk    1/1     Running   0          23h<br>kubia-88894bbd4-pxxwt    1/1     Running   0          23h<br>kubia-74c44776ff-rm4xw   0/1     Running   0          98s<br></code></pre></td></tr></table></figure><p>发现有一个 Pod 没有处于 READY 状态，因为我们设置了 maxSurge 为 1，所以一共有 replicas + 1 个 Pod，多出来就是这个没有 READY 的 v3 Pod，因为它的探针检测失败了。通过 <code>kubectl describe po kubia-74c44776ff-rm4xw</code> 也可以看到，最后一行的事件显示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Warning  Unhealthy  2m25s (x22 over 2m45s)  kubelet            Readiness probe failed: HTTP probe failed with statuscode: 500<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh 输入卡顿</title>
    <link href="/2022/05/11/ssh-shu-ru-qia-dun/"/>
    <url>/2022/05/11/ssh-shu-ru-qia-dun/</url>
    
    <content type="html"><![CDATA[<p>ssh 到家里的另外一台电脑，发现输入延迟比较严重，体验不是很好，ping 发现延迟普遍在 100 -200 之间，有几次甚至超过了 400，在网上找到了一个解决方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo vim /etc/ssh/sshd_config</span><br></code></pre></td></tr></table></figure><p>输入 &#x2F;UseDNS 查找这一行，找到后发现这行 UseDNS no 是被注释的，去掉注释，然后 <code>service sshd restart</code> 即可，修改之后卡顿问题缓解了不少，基本可以正常使用了。</p><p>更新：其实有时候还是卡的一 b，看来该方法用处不是特别大</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux clone() 的坑</title>
    <link href="/2022/05/11/linux-clone-de-keng/"/>
    <url>/2022/05/11/linux-clone-de-keng/</url>
    
    <content type="html"><![CDATA[<p>环境：</p><p>MacBook m1</p><p>Ubuntu 20.04.4 LTS（使用 cat &#x2F;etc&#x2F;issue 查看），基于 multipass 创建</p><p>在阅读<strong>《深入剖析Kubernetes》-张磊——白话容器基础（三）：深入理解容器镜像</strong>，文中提供了一个 namespace 的示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mount.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_SIZE (1024 * 1024)</span><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> container_stack[STACK_SIZE];<br><span class="hljs-type">char</span>* <span class="hljs-type">const</span> container_args[] = &#123;<br>  <span class="hljs-string">&quot;/bin/bash&quot;</span>,<br>  <span class="hljs-literal">NULL</span><br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">container_main</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span><br>&#123;  <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Container - inside the container!\n&quot;</span>);<br>  execv(container_args[<span class="hljs-number">0</span>], container_args);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Something&#x27;s wrong!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent - start a container!\n&quot;</span>);<br>  <span class="hljs-type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWNS | SIGCHLD , <span class="hljs-literal">NULL</span>);<br>  waitpid(container_pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent - container stopped!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但是在我的机器上无法运行，输出为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Parent - start a container!<br>Parent - container stopped!<br></code></pre></td></tr></table></figure><p>可以看到，传入 clone 的回调函数没有被执行， 因为 Container - inside the container! 没有被输出。</p><p>在main 函数的 waitpid调用后面添加一下错误信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (WIFEXITED(status) != <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 子进程非正常退出</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error!&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, WTERMSIG(status)); <span class="hljs-comment">// 输出信号类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>WTERMSIG 会输出信号类型，输出为 7，查了一下，意思是 SIGBUS，这是个什么玩意呢？查了一下资料，大概是内存错误、对齐错误什么的，完全看不懂，也不知道如何解决。。。</p><p>注：使用 gdb 进行调试也可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gdb ns_err</span><br>GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2<br>(gdb) set follow-fork-mode child<br>(gdb) r<br>Starting program: /home/ubuntu/codetest/ns_err<br>Parent - start a container!<br>[Attaching after process 192301 fork to child process 192304]<br>[New inferior 2 (process 192304)]<br>[Detaching after fork from parent process 192301]<br>containerPid: 192304<br>[Inferior 1 (process 192301) detached]<br><br>Thread 2.1 &quot;ns_err&quot; received signal SIGBUS, Bus error.<br>[Switching to process 192304]<br>0x0000000000400738 in container_main ()<br></code></pre></td></tr></table></figure><p>也可以看到 <code>&quot;ns_err&quot; received signal SIGBUS, Bus error.</code> 这句话</p><p>最后还是从官方文档查到了答案，不得不说还是官方文档最为靠谱</p><p><a href="https://man7.org/linux/man-pages/man2/clone.2.html">https://man7.org/linux/man-pages/man2/clone.2.html</a></p><p>最下面有一个 example，把这段代码 copy 到本地，发现居然可以成功运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/utsname.h&gt;</span></span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br>       <span class="hljs-meta">#<span class="hljs-keyword">define</span> errExit(msg)    do &#123; perror(msg); exit(EXIT_FAILURE); \</span><br><span class="hljs-meta">                               &#125; while (0)</span><br><br>       <span class="hljs-type">static</span> <span class="hljs-type">int</span>              <span class="hljs-comment">/* Start function for cloned child */</span><br>       childFunc(<span class="hljs-type">void</span> *arg)<br>       &#123;<br>           <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">utsname</span> <span class="hljs-title">uts</span>;</span><br><br>           <span class="hljs-comment">/* Change hostname in UTS namespace of child. */</span><br><br>           <span class="hljs-keyword">if</span> (sethostname(arg, <span class="hljs-built_in">strlen</span>(arg)) == <span class="hljs-number">-1</span>)<br>               errExit(<span class="hljs-string">&quot;sethostname&quot;</span>);<br><br>           <span class="hljs-comment">/* Retrieve and display hostname. */</span><br><br>           <span class="hljs-keyword">if</span> (uname(&amp;uts) == <span class="hljs-number">-1</span>)<br>               errExit(<span class="hljs-string">&quot;uname&quot;</span>);<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;uts.nodename in child:  %s\n&quot;</span>, uts.nodename);<br><br>           <span class="hljs-comment">/* Keep the namespace open for a while, by sleeping.</span><br><span class="hljs-comment">              This allows some experimentation--for example, another</span><br><span class="hljs-comment">              process might join the namespace. */</span><br><br>           sleep(<span class="hljs-number">200</span>);<br><br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;           <span class="hljs-comment">/* Child terminates now */</span><br>       &#125;<br><br>       <span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_SIZE (1024 * 1024)    <span class="hljs-comment">/* Stack size for cloned child */</span></span><br><br>       <span class="hljs-type">int</span><br>       <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>       &#123;<br>           <span class="hljs-type">char</span> *<span class="hljs-built_in">stack</span>;                    <span class="hljs-comment">/* Start of stack buffer */</span><br>           <span class="hljs-type">char</span> *stackTop;                 <span class="hljs-comment">/* End of stack buffer */</span><br>           <span class="hljs-type">pid_t</span> pid;<br>           <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">utsname</span> <span class="hljs-title">uts</span>;</span><br><br>           <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>               <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s &lt;child-hostname&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>               <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>           &#125;<br><br>           <span class="hljs-comment">/* Allocate memory to be used for the stack of the child. */</span><br><br>           <span class="hljs-built_in">stack</span> = mmap(<span class="hljs-literal">NULL</span>, STACK_SIZE, PROT_READ | PROT_WRITE,<br>                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>           <span class="hljs-keyword">if</span> (<span class="hljs-built_in">stack</span> == MAP_FAILED)<br>               errExit(<span class="hljs-string">&quot;mmap&quot;</span>);<br><br>           stackTop = <span class="hljs-built_in">stack</span> + STACK_SIZE;  <span class="hljs-comment">/* Assume stack grows downward */</span><br><br>           <span class="hljs-comment">/* Create child that has its own UTS namespace;</span><br><span class="hljs-comment">              child commences execution in childFunc(). */</span><br><br>           pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[<span class="hljs-number">1</span>]);<br>           <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>)<br>               errExit(<span class="hljs-string">&quot;clone&quot;</span>);<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;clone() returned %jd\n&quot;</span>, (<span class="hljs-type">intmax_t</span>) pid);<br><br>           <span class="hljs-comment">/* Parent falls through to here */</span><br><br>           sleep(<span class="hljs-number">1</span>);           <span class="hljs-comment">/* Give child time to change its hostname */</span><br><br>           <span class="hljs-comment">/* Display hostname in parent&#x27;s UTS namespace. This will be</span><br><span class="hljs-comment">              different from hostname in child&#x27;s UTS namespace. */</span><br><br>           <span class="hljs-keyword">if</span> (uname(&amp;uts) == <span class="hljs-number">-1</span>)<br>               errExit(<span class="hljs-string">&quot;uname&quot;</span>);<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;uts.nodename in parent: %s\n&quot;</span>, uts.nodename);<br><br>           <span class="hljs-keyword">if</span> (waitpid(pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>)    <span class="hljs-comment">/* Wait for child */</span><br>               errExit(<span class="hljs-string">&quot;waitpid&quot;</span>);<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child has terminated\n&quot;</span>);<br><br>           <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>       &#125;<br></code></pre></td></tr></table></figure><p>不同之处在于这几句话：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">stack</span> = mmap(<span class="hljs-literal">NULL</span>, STACK_SIZE, PROT_READ | PROT_WRITE,<br>                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>           <span class="hljs-keyword">if</span> (<span class="hljs-built_in">stack</span> == MAP_FAILED)<br>               errExit(<span class="hljs-string">&quot;mmap&quot;</span>);<br><br>           stackTop = <span class="hljs-built_in">stack</span> + STACK_SIZE;  <span class="hljs-comment">/* Assume stack grows downward */</span><br><br>           <span class="hljs-comment">/* Create child that has its own UTS namespace;</span><br><span class="hljs-comment">              child commences execution in childFunc(). */</span><br><br>           pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><p>它是通过 mmap 申请的内存</p><p>现在使用相同的方式，修改一下之前的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_SIZE (1024 * 1024)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> errExit(msg)    do &#123; perror(msg); exit(EXIT_FAILURE); \</span><br><span class="hljs-meta">                               &#125; while (0)</span><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> container_stack[STACK_SIZE];<br><span class="hljs-type">char</span>* <span class="hljs-type">const</span> container_args[] = &#123;<br>  <span class="hljs-string">&quot;/bin/bash&quot;</span>,<br>  <span class="hljs-literal">NULL</span><br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">container_main</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Container - inside the container!\n&quot;</span>);<br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">//mount(&quot;&quot;, &quot;/&quot;, NULL, MS_PRIVATE, &quot;&quot;);</span><br>  <span class="hljs-comment">//mount(&quot;none&quot;, &quot;/tmp&quot;, &quot;tmpfs&quot;, 0, &quot;&quot;);</span><br>  execv(container_args[<span class="hljs-number">0</span>], container_args);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Something&#x27;s wrong!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">char</span> *<span class="hljs-built_in">stack</span>;                    <span class="hljs-comment">/* Start of stack buffer */</span><br>  <span class="hljs-type">char</span> *stackTop;                 <span class="hljs-comment">/* End of stack buffer */</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent - start a container!\n&quot;</span>);<br>  <span class="hljs-built_in">stack</span> = mmap(<span class="hljs-literal">NULL</span>, STACK_SIZE, PROT_READ | PROT_WRITE,<br>                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">stack</span> == MAP_FAILED)<br>               errExit(<span class="hljs-string">&quot;mmap&quot;</span>);<br><br>  stackTop = <span class="hljs-built_in">stack</span> + STACK_SIZE;<br>  <span class="hljs-type">int</span> container_pid = clone(container_main, stackTop, CLONE_NEWNS|SIGCHLD , <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;containerPid: %d\n&quot;</span>, container_pid);<br>  <span class="hljs-type">int</span> status;<br>  waitpid(container_pid, &amp;status, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (WIFEXITED(status) != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error!&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, WTERMSIG(status));<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent - container stopped!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是见证奇迹的时刻了！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./a.out</span><br>Parent - start a container!<br>containerPid: 192918<br>Container - inside the container!<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">exit</span></span><br>Parent - container stopped!<br></code></pre></td></tr></table></figure><p>没有报错了，成功进入容器，问题终于解决了。</p><p>至于为什么需要使用 mmap，作为一个菜鸡目前还没有头绪，后续再进行研究</p>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP MIME 嗅探 [待完善]</title>
    <link href="/2022/05/08/http_mime_sniff/"/>
    <url>/2022/05/08/http_mime_sniff/</url>
    
    <content type="html"><![CDATA[<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>定义一个未知后缀名的文件（这个后缀名起的得随意一点，像 xyz 这种是不行的，会被 chrome 识别为 chemical&#x2F;x-xyz 类型），但是文件里的内容是 HTML：</p><p><strong>demo.lubenwei</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>HelloWorld<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后写一个 http file server，将文件内容作为 response 返回：</p><p><strong>mime_sniffing.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>http.ServeFile(w, r, <span class="hljs-string">&quot;./demo.lubenwei&quot;</span>)<br>&#125;)<br><br>log.Println(<span class="hljs-string">&quot;listen in 8080&quot;</span>)<br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里没有指定 Content-Type</p><p>接下来运行这个 http server：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run mime_sniffing.go</span><br></code></pre></td></tr></table></figure><p>然后在浏览器中访问 <a href="http://localhost:8080，会发现显示的内容是">http://localhost:8080，会发现显示的内容是</a> h2 标题的 HelloWorld</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/79d6e00a6af31a6e75ee69a2bbb98db04077808d/img/http_sniff.jpg"></p><p>这里就比较疑惑了，我既没有指定 Content-Type 响应头，也没有将文件后缀名定义为 html，那浏览器是如何知道其内容是 html，同时解析出来的呢？查了一下，这就是所谓的 <strong>MIME 嗅探</strong>，大致意思就是如果没有定义 Content-Type，那么浏览器会读取文件内容，推断这是个什么类型的文件，进而采取不同的处理方式，比如这里就会读取我这个后缀名为 lubenwei 的文件，发现里面有 html 标签，然后将其作为 html 解析</p><p>可以通过设置响应头 <strong>X-Content-Type-Options: nosniff</strong>  来禁止客户端嗅探文件内容，修改后代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>w.Header().Set(<span class="hljs-string">&quot;X-Content-Type-Options&quot;</span>, <span class="hljs-string">&quot;nosniff&quot;</span>)<br>http.ServeFile(w, r, <span class="hljs-string">&quot;./demo.lubenwei&quot;</span>)<br>&#125;)<br><br>log.Println(<span class="hljs-string">&quot;listen in 8080&quot;</span>)<br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是我这边访问 <a href="http://localhost:8080/">http://localhost:8080</a> 依然会显示 h2 格式的 HelloWorld（使用 chrome、edge、safari 分别测试，结果相同）</p><p>貌似是因为 <strong>X-Content-Type-Options: nosniff</strong> 需要和 <strong>Content-Type</strong> 搭配使用才行，这里我给指定一个错误的 Content-Type：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;json&quot;</span>)<br>w.Header().Set(<span class="hljs-string">&quot;X-Content-Type-Options&quot;</span>, <span class="hljs-string">&quot;nosniff&quot;</span>)<br>http.ServeFile(w, r, <span class="hljs-string">&quot;./demo.lubenwei&quot;</span>)<br>&#125;)<br><br>log.Println(<span class="hljs-string">&quot;listen in 8080&quot;</span>)<br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用浏览器（safari）访问，会发现此时不会显示 HelloWorld 了，而是会下载这个文件，不同的浏览器会有不同的策略，chrome 和 edge 的话是会直接显示出文件的内容，这里需要注意的是浏览器可能会走缓存，导致还是显示 h2 格式的 HelloWorld，可以开一个隐身窗口访问：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/450b24efcb799fb18039ebb6ed302a441bfb1bc2/img/http_nosniff.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K8s Service</title>
    <link href="/2022/05/08/k8s-service/"/>
    <url>/2022/05/08/k8s-service/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Service"><a href="#什么是-Service" class="headerlink" title="什么是 Service"></a>什么是 Service</h1><p>多数情况下，Pod 都需要与集群内的其他 Pod 进行通信，或者与集群外进行通信（比如被外部访问），如果需要管理员手动将 Pod 的地址提供给访问者，显然太麻烦了，不适合作为解决方案，而且在 k8s 中 Pod 的地址是不确定的，它是由 k8s 自动分配的；此外，Pod 的地址也是随时可能变动的，这是因为 Pod 可能会在节点之间移动或者被重新创建。例如，当一个 Pod 从一个节点迁移到另一个节点时，它的 IP 地址也会随之改变。此外，当一个 Pod 被删除后，其 IP 地址也会随之消失。所以 k8s 需要提供一种稳定的资源类型来解决 Pod 间通信的问题，避免直接使用 Pod IP 地址来访问 Pod。这个资源就是就是 Service。</p><p>Service 为 <strong>一组功能相同</strong>（逻辑意义上的，例如使用相同的标签）的 Pod 提供单一不变的接入点，Service 的 IP 和端口不会改变，所以访问者可以统一连接到 Service，Service 再将请求转发给其代理的某一个 Pod（会负载均衡的访问），这样，无论 Pod IP 是否变化，都能保证对 Service 的访问不会受到影响，就可以解决上面的 Pod 地址变动问题。</p><h1 id="创建-Service"><a href="#创建-Service" class="headerlink" title="创建 Service"></a>创建 Service</h1><p>下面的 yaml 可以创建一个 Service：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 该 Service 的端口</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 转发到 Pod 的 80 端口</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span> <span class="hljs-comment"># 具有 app=kubia 标签的 Pod 都属于该 Service</span><br></code></pre></td></tr></table></figure><blockquote><p> ⚠️ targetPort 必须指向一个有效的、被监听的 port，否则之后访问该 Service 会报错 Connection refused</p></blockquote><p>创建完成后，可以使用下面的命令进行查看，获取 Service 的 IP 地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE<br>kubernetes   ClusterIP   10.43.0.1      &lt;none&gt;        443/TCP   23h<br>kubia        ClusterIP   10.43.87.107   &lt;none&gt;        80/TCP    23h<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h2><p>知道 Service 的 IP 地址后就可以进行测试了，有以下几种方式</p><ol><li><p>在 node 执行 curl ServiceIP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 10.43.87.107</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">省略 ...</span><br></code></pre></td></tr></table></figure><p>因为我转发的容器是 nginx，所以会输出 nginx 的 index.html，这里 curl 的地址没有写端口号，是因为不写端口号会默认走 80 端口，然后这个 svc 的 port 刚好也是 80，所以可以省略。</p></li><li><p>进入一个容器内部执行 curl</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>kubia-2qkls   1/1     Running   0          24h<br>kubia-qgtjw   1/1     Running   0          24h<br>kubia-mbghg   1/1     Running   0          24h<br>nginx         1/1     Running   0          20h<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it kubia-2qkls -- curl 10.43.87.107</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">省略 ...</span><br></code></pre></td></tr></table></figure><p>如果用过 docker，那么 exec 命令应该已经非常熟悉了</p></li></ol><h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><p>虽然 Service 提供了一个统一访问的 Pod 的途径，但是还存在一个问题：访问者又如何知道 Service 的 IP 地址？难道还是需要管理员手动执行命令查看 Service 的 IP 然后告诉访问者吗？那这不是搞了个寂寞吗，不过不用着急，你想到的 k8s 都想到了，并且给出了解决方案： Service 服务发现。</p><p>k8s 提供的服务发现有以下几种类型：</p><h2 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a>使用环境变量</h2><p>k8s 可以为每个容器设置环境变量，其中包括其他 Pod、Service 和 Kubernetes API Server 的地址信息，通过环境变量服务发现，服务消费者可以通过访问容器的环境变量来发现和访问其他 Pod 和 Service。</p><blockquote><p> ⚠️ 这种方式需要 <strong>Service 先于 Pod 创建</strong>，这样在 Pod 创建过程中，k8s 会将其<br> 所属的 Service 地址写入到其环境变量中，Pod 通过环境变量就可以知道 Service 的地<br> 址了。</p></blockquote><p>Service 的环境变量名格式是 <code>&lt;Service_NAME&gt;_Service_HOST</code> 和 <code>&lt;Service_NAME&gt;_Service_PORT</code>，其中 <code>&lt;Service_NAME&gt;</code> 是 Service 的名称，<code>Service_HOST</code> 和 <code>Service_PORT</code> 是固定的后缀。Service name 会转换为全大写，并且其中的 - 会转换为下划线。</p><p>例如，如果有一个名为 <code>my-Service</code> 的 Service，它的 Cluster IP 为 <code>10.0.0.1</code>，端口为 <code>8080</code>，则 k8s 会在 Pod 中为其创建两个环境变量：</p><ul><li><code>MY_Service_Service_HOST</code>：值为 <code>10.0.0.1</code>。</li><li><code>MY_Service_Service_PORT</code>：值为 <code>8080</code>。</li></ul><p><strong>实践</strong></p><p>Service.yaml 如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 该 Service 的端口</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 转发到 Pod 的 80 端口</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span> <span class="hljs-comment"># 具有 app=nginx 标签的 Pod 都属于该 Service</span><br></code></pre></td></tr></table></figure><p>deploy.yaml，用于创建 nginx Pod：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>访问者的 Pod yaml，使用的镜像是一个 go 程序，需要传递两个参数，分别是 <code>Service host</code> 的环境变量名和 <code>port</code> 的环境变量名，前面提到过这两个环境变量的命名规则，因为我创建的 Service name 是 kubia，所以两个环境变量名分别是：KUBIA_Service_HOST 和 KUBIA_Service_PORT。然后这个程序会拿到这两个环境变量的 value，再通过这两个 value 拼接成 URL，最后通过 http 来访问 nginx，期望结果会输出 nginx 的 index.html，也就是欢迎页面。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">http-get</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http-get</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/Service-env-test</span><br>    <span class="hljs-attr">args:</span> [<span class="hljs-string">&quot;-hostEnv&quot;</span>, <span class="hljs-string">&quot;KUBIA_Service_HOST&quot;</span>, <span class="hljs-string">&quot;-portEnv&quot;</span>, <span class="hljs-string">&quot;KUBIA_Service_PORT&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>注意这里需要先创建 Service，再创建 deploy，最后再创建 http-get Pod。</strong></p><p>创建客户端 Pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f http-get.yaml</span><br>Pod/http-get created<br></code></pre></td></tr></table></figure><p>查看 Pod 日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl logs http-get</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">程序会打印出两个环境变量</span><br>KUBIA_Service_HOST:10.43.65.224<br>KUBIA_Service_PORT:80<br>url: http://10.43.65.224:80<br><span class="hljs-meta prompt_"># </span><span class="language-bash">nginx index.html 成功输出了</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br></code></pre></td></tr></table></figure><p>通过日志内容，说明 Pod 成功通过环境变量获取到了 Service 的地址，并通过 Service 访问到了 Pod。</p><blockquote><p>附：</p><p> <code>http-get</code> 对应镜像 <code>stdoutt/Service-env-test</code> 的源码和 Dockerfile：</p><p>go 源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> hostServiceEnvName = flag.String(<span class="hljs-string">&quot;hostEnv&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;k8s Service host env name&quot;</span>)<br><span class="hljs-keyword">var</span> portServiceEnvName = flag.String(<span class="hljs-string">&quot;portEnv&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;k8s Service port env name&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br>host := os.Getenv(*hostServiceEnvName)<br>port := os.Getenv(*portServiceEnvName)<br>url_ := fmt.Sprintf(<span class="hljs-string">&quot;http://%v:%v&quot;</span>, host, port)<br>fmt.Printf(<span class="hljs-string">&quot;%v:%v\n&quot;</span>, *hostServiceEnvName, host)<br>fmt.Printf(<span class="hljs-string">&quot;%v:%v\n&quot;</span>, *portServiceEnvName, port)<br>fmt.Printf(<span class="hljs-string">&quot;url: %v\n&quot;</span>, url_)<br>resp, err := http.Get(url_)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>b, err := io.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-type">string</span>(b))<br>&#125;<br></code></pre></td></tr></table></figure><p>Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> golang:alpine AS builder<br><br><span class="hljs-comment"># 移动到工作目录：/build</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /build</span><br><br><span class="hljs-comment"># 将代码复制到容器中</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><br><span class="hljs-comment"># 将我们的代码编译成二进制可执行文件 app</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build -o app .</span><br><br><span class="hljs-comment">###################</span><br><span class="hljs-comment"># 接下来创建一个小镜像</span><br><span class="hljs-comment">###################</span><br><span class="hljs-keyword">FROM</span> scratch<br><br><span class="hljs-comment"># 从builder镜像中把/dist/app 拷贝到当前目录</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /build/app /</span><br><br><span class="hljs-comment"># 需要运行的命令</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/app&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>如果你想构建多架构镜像，可以使用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker buildx create --name mybuilder --use<br>docker buildx build -t &lt;repo/imagename&gt; --platform=linux/arm64,linux/amd64 . --push<br></code></pre></td></tr></table></figure></blockquote><h2 id="使用-DNS"><a href="#使用-DNS" class="headerlink" title="使用 DNS"></a>使用 DNS</h2><p>除了环境变量外，还有一种更简单的方式：通过 DNS 发现服务，之后便可以通过 FQDN 进行访问，格式类似于：<code>backend-database.default.svc.cluster.local</code>，其中 <code>backend-database</code> 是 <strong>Service 的名字</strong>，<strong>default 是 Service 所在的命名空间</strong>，<strong>svc.cluster.local 是在所有集群本地服务名称中使用的可配置集群域后缀（这里不懂）</strong>。</p><blockquote><p>⚠️ 客户端仍然需要知道服务的端口号。如果服务使用标准端口号(例如，HTTP 的 80 端口或 Postgres 的 5432 端口)，这样是没问题的。 如果并不是标准端口， 客户端可以从环境变量中获取端口号 。</p><p>（摘抄自书上）</p><p><del>这里没看懂，都直接通过域名访问了，为什么客户端还需要知道端口号？</del></p><p>初学时的一个比较 2 的问题，说明基础不牢，域名只负责解析出 IP ，而只有 IP 没有端口号显然是不能访问服务的。</p></blockquote><p>如果访问 Pod 和被访问 Pod 在同一个命名空间，那么可以直接用 Service.name 进行访问，后面的可以全部省略，比如下面的例子，直接使用 Service 的名字 kubia 进行访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 Service，获取 Service 的名字</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE<br>kubernetes   ClusterIP   10.43.0.1      &lt;none&gt;        443/TCP   33h<br>kubia        ClusterIP   10.43.65.224   &lt;none&gt;        80/TCP    8h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看所有的 Pod</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS      RESTARTS         AGE<br>kubia-msv7g   1/1     Running     0                8h<br>kubia-8d2gm   1/1     Running     0                8h<br>kubia-r4fcs   1/1     Running     0                8h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">选择 1 个容器，在内部执行 curl 域名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> kubia-msv79 -- curl kubia</span><br><span class="hljs-meta prompt_">  % </span><span class="language-bash">Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br>                                 Dload  Upload   Total   Spent    Left  Speed<br>  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br>&lt;style&gt;<br>html &#123; color-scheme: light dark; &#125;<br>body &#123; width: 35em; margin: 0 auto;<br>font-family: Tahoma, Verdana, Arial, sans-serif; &#125;<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">curl 完整域名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it kubia-msv79 -- curl kubia.default.svc.cluster.local</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br></code></pre></td></tr></table></figure><p><strong>实践</strong></p><p>需要先准备 Service 和 deploy，可以直接沿用 <strong>使用环境变量</strong> 这一节实践里的 yaml，另外准备一个 yaml 用来通过 dns 和 port 访问 k8s Service：</p><p><strong>httpget_dns.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">http-get</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http-get</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/Service-dns-test</span><br>    <span class="hljs-attr">args:</span> [<span class="hljs-string">&quot;-dns&quot;</span>, <span class="hljs-string">&quot;kubia.default.svc.cluster.local&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;80&quot;</span>]<br></code></pre></td></tr></table></figure><p>这个镜像需要提供两个参数 <code>-dns</code> 和 <code>-p</code>，顾名思义，分别对应 dns 和 port，然后程序会根据 dns 解析出对应的 IP，并将 IP 和 port 拼接成一个 HTTP URL，并通过 HTTP 访问。</p><p>运行并查看效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f httpget_dns.yaml</span><br>Pod/http-get created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                               READY   STATUS              RESTARTS      AGE<br>http-get                           0/1     ContainerCreating   0             11s<br>nginx-deployment-ff6774dc6-4nz9z   1/1     Running             2 (51m ago)   23h<br>nginx-deployment-ff6774dc6-cwn7p   1/1     Running             2 (51m ago)   23h<br>nginx-deployment-ff6774dc6-pjxhk   1/1     Running             2 (51m ago)   23h<br>http-get                           0/1     Completed           0             21s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过 <span class="hljs-built_in">log</span> 查看效果</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl logs http-get</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里会输出通过 dns 解析到的 ip</span><br>http://10.110.49.109:80<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出了 nginx 的欢迎页面</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br></code></pre></td></tr></table></figure><blockquote><p>附：</p><p><code>http-get</code> 对应镜像 <code>stdoutt/Service-dns-test</code> 的源码和 Dockerfile：</p><p>go 源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>dns  <span class="hljs-type">string</span><br>port <span class="hljs-type">string</span><br>)<br><br>flag.StringVar(&amp;dns, <span class="hljs-string">&quot;dns&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;dns&quot;</span>)<br>flag.StringVar(&amp;port, <span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>)<br>flag.Parse()<br><br><span class="hljs-keyword">if</span> dns == <span class="hljs-string">&quot;&quot;</span> || port == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;dns must not null&quot;</span>)<br>&#125;<br><br>addrs, err := net.LookupIP(dns)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">var</span> httpGet = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>b, err := io.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-type">string</span>(b))<br>&#125;<br><br><span class="hljs-keyword">for</span> _, addr := <span class="hljs-keyword">range</span> addrs &#123;<br>url := fmt.Sprintf(<span class="hljs-string">&quot;http://%v:%v&quot;</span>, addr, port)<br>fmt.Println(url)<br>httpGet(url)<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> golang:alpine AS builder<br><br><span class="hljs-comment"># 移动到工作目录：/build</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /build</span><br><br><span class="hljs-comment"># 将代码复制到容器中</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><br><span class="hljs-comment"># 将我们的代码编译成二进制可执行文件 app</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build -o app .</span><br><br><span class="hljs-comment"># 接下来创建一个小镜像</span><br><span class="hljs-keyword">FROM</span> scratch<br><br><span class="hljs-comment"># 从 builder 镜像中把 /dist/app 拷贝到当前目录</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /build/app /</span><br><br><span class="hljs-comment"># 需要运行的命令</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/app&quot;</span>]</span><br><br></code></pre></td></tr></table></figure><p>build</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker buildx create --name mybuilder --use</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker buildx build -t &lt;repo/imagename&gt; --platform=linux/arm64,linux/amd64 . --push</span><br></code></pre></td></tr></table></figure></blockquote><h1 id="Service-的几种类型"><a href="#Service-的几种类型" class="headerlink" title="Service 的几种类型"></a>Service 的几种类型</h1><h2 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h2><p>通过集群内部 IP 地址暴露服务，但该地址 <strong>仅在集群内部</strong> 可见、可达，它无法被集群外部的客户端访问，是 Service 的默认访问类型。如果不明确指定 clusterIP，则由 K8S 动态指定一个，也支持用户手动明确指定。</p><p>下面这个 yaml 创建了一个没有明确指定 clusterIP 的 Service，以及一个创建 nginx 的 rs：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 该 Service 的端口</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-rs</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>运行后查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME                     TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE<br>kubernetes               ClusterIP   10.43.0.1      &lt;none&gt;        443/TCP   31h<br>nginx-service            ClusterIP   10.43.27.242   &lt;none&gt;        80/TCP    7h9m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe svc nginx-service</span><br>Name:              nginx-service<br>Namespace:         default<br>Labels:            &lt;none&gt;<br>Annotations:       &lt;none&gt;<br>Selector:          app=nginx<br>Type:              ClusterIP<br>IP Family Policy:  SingleStack<br>IP Families:       IPv4<br>IP:                10.43.27.242<br>IPs:               10.43.27.242<br>Port:              &lt;unset&gt;  80/TCP<br>TargetPort:        80/TCP<br>Endpoints:         10.42.0.30:80,10.42.0.32:80,10.42.0.36:80<br>Session Affinity:  None<br>Events:            &lt;none&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">因为 ClusterIP 只可以在集群内访问，所以需要 <span class="hljs-built_in">exec</span> 到某个容器内执行</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it nginx-rs-7bvr8 -- curl 10.43.27.242</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br></code></pre></td></tr></table></figure><p>发现这个 Service 是 ClusterIP 类型的，且 k8s 自动指定了一个地址，并且可以成功访问。</p><p>也可以手动指定一个 clusterIP，在上面的 yaml 的 Service 部分中修改一下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-service1</span> <span class="hljs-comment"># 起个新名字</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 该 Service 的端口</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-number">10.43</span><span class="hljs-number">.27</span><span class="hljs-number">.66</span> <span class="hljs-comment"># 手动指定 ip</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f svc_clusterip.yaml</span><br>service/nginx-service1 created<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME                     TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE<br>kubernetes               ClusterIP   10.43.0.1      &lt;none&gt;        443/TCP   32h<br>nginx-service            ClusterIP   10.43.27.242   &lt;none&gt;        80/TCP    7h16m<br>nginx-service1           ClusterIP   10.43.27.66    &lt;none&gt;        80/TCP    10s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it nginx-rs-7bvr8 curl 10.43.27.66 <span class="hljs-comment"># 可以成功访问</span></span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br></code></pre></td></tr></table></figure><p>但是不推荐手动指定 clusterIP，可能会造成 IP 冲突。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/k8s_service_clusterip.webp"></p><p><strong>使用 kube-proxy 让外部访问 ClusterIP Service</strong></p><p>正常来说 ClusterIP 类型的 Service 是无法从外部访问的，但是有种特殊的方法可以打破这个限制，让我们在集群外部访问——即使用 kube-proxy，也就是上图中的 proxy 部分。</p><p>具体的流程：</p><p>首先在集群内节点执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl proxy --address=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>  --accept-hosts=<span class="hljs-string">&#x27;^*$&#x27;</span> --port=8081</span><br></code></pre></td></tr></table></figure><p>注意要加上 <code>--address</code> 和 <code>--accept-hosts</code>，否则访问会返回 <code>Forbidden</code>。</p><p>然后在外部机器执行以下格式语句进行访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl http://[nodeIP]:[port]/api/v1/namespaces/[namespace-name]/Services/[Service-name]/proxy</span><br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -X GET -L http://192.168.31.50:8081/api/v1/namespaces/default/Services/nginx/proxy</span><br></code></pre></td></tr></table></figure><p>PS: “curl -L” 中的 “-L” 是 curl 命令中的选项，它的含义是 “Follow any redirections”. 也就是说，如果服务器返回了一个重定向响应，那么 curl 命令就会自动跟随重定向并请求重定向的地址。</p><p>在我的机器上测试，-X GET 可以不指定，但是 -L 一定要指定，否则返回结果为空</p><p>感觉有点类似 NodePort，也是使用节点 IP + proxy 开启的端口进行访问，不过前提是你的外部机器可以通过 IP 访问到这个节点</p><blockquote><p>参考：</p><p><a href="https://www.do1618.com/archives/1235/kubernetes-nodeport-vs-loadbalancer-vs-ingress%EF%BC%9F-%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%EF%BC%9F/">Kubernetes NodePort vs LoadBalancer vs Ingress？ 我们应该什么时候使用？</a></p><p><a href="https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0">Kubernetes NodePort vs LoadBalancer vs Ingress？ 我们应该什么时候使用？（原文）</a></p></blockquote><p>前面提到的这些都仅限于集群的内部访问，集群外是无法访问的，比如上面的 Service IP 是 10.43.65.224，这只在集群内可以 curl ，集群外是不行的，而且这个 IP 即便是在集群内也是无法 ping 通的，因为这是一个<strong>虚拟 IP 地址</strong>。</p><p>有以下几种方式可以将 Service 暴露给集群外部：</p><h2 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h2><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/k8s_service_nodeport.webp"></p><p>NodePort 会在 <strong>每个 node 上开启一个端口</strong> 用来访问 Service，这个端口定义在 spec.ports[0].nodePort，用户可以使用 <strong>节点IP:nodePort</strong> 进行访问，也可以使用 <strong>ServiceIP:port</strong> 访问（这种方式其实就是前面介绍的常规 Service 访问方式，只能在集群内部使用），nodePort 也可以不指定，会随机从 30000-32767 中选择一个。</p><p>实践：</p><p>需要准备以下 yaml：</p><ul><li>用来创建 nginx deployment 的 yaml：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-comment"># manage Pods with the label app: nginx</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><ul><li>创建 NodePort 类型的 Service，用来访问 nginx Pod：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia-node-port</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 该 Service 的端口</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 转发到 Pod 的 80 端口</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30123</span> <span class="hljs-comment"># 30000-32767 之间</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure><p>之后使用 apply -f 执行上面的两个 yaml（这里就不展示了）</p><p>查看 Service：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME              TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)        AGE<br>kubernetes        ClusterIP   10.43.0.1     &lt;none&gt;        443/TCP        13d<br>kubia-node-port   NodePort    10.43.21.78   &lt;none&gt;        80:30123/TCP   6m12s<br></code></pre></td></tr></table></figure><p>此时就可以使用集群中的任意一个节点的 IP 加 30123 端口进行访问了，比如我的是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ifconfig | grep 192</span><br>inet 192.168.64.4  netmask 255.255.255.0  broadcast 192.168.64.255<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 192.168.64.4:30123</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br></code></pre></td></tr></table></figure><h2 id="LoadBalance"><a href="#LoadBalance" class="headerlink" title="LoadBalance"></a>LoadBalance</h2><p>TODO：这个还没完全理解</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/k8s_service_lb.webp"></p><p>LoadBalance（负载均衡），大致流程是：对外提供一个统一的 IP，这个 IP 就是负载均衡器，它会将用户请求负载均衡的分发给 Pod，我个人的理解是，它在 NodePort 的基础上又添加了一层类似代理层的东西，让客户端访问更加方便。</p><p>举个例子：假设此时有 2 个工作节点 1.1.1.1 和 2.2.2.2，每个节点上运行 3 个 nginx Pod，nodePort 为 30000，那么在 NodePort 下，客户端访问需要指定某个 node 的具体 IP，比如 1.1.1.1:30000 或者 2.2.2.2:30000；如果使用 loadBalance 的话，则会提供一个统一的公网 IP（比如 180.1.1.1）作为负载均衡器，用户只要访问这个 IP 就可以（当然还要添加端口号），负载均衡器会负载均衡的把请求分发到 1.1.1.1:30000 或者 2.2.2.2:30000，比如如下的 loadBalance yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">vl</span> <br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span> <br><span class="hljs-attr">metadata:</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">kubia-loadbalancer</span><br><span class="hljs-attr">spec:</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">LoadBalancer</span> <br><span class="hljs-attr">ports:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># loadBalance 的端口</span><br><span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span> <span class="hljs-comment"># 转发到 Pod 的 8080 端口</span><br><span class="hljs-attr">nodePort:</span> <span class="hljs-number">30000</span><br><span class="hljs-attr">selector:</span><br><span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br></code></pre></td></tr></table></figure><p>LoadBalance 通常由云服务商提供，所以实践起来可能麻烦一些，需要在腾讯云这种平台上实践，好像也有一些组件可以提供本地的使用，这部分我还没有去了解。</p><h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/k8s_service_ingress.webp"></p><blockquote><p><del>个人吐槽（请忽视）：</del></p><p><del>这个玩意是我目前为止用的最蛋疼的一个功能，不是不好用，而是连用都用不上，我在 minikube 上使用的 ingress-nginx 因为拉取的镜像地址被墙，导致根本无法开启 ingress 服务，又因为我的 minikube 是跑在 multipass 虚拟机上的，不知道如何共享宿主机的 vpn，导致这个问题一直无法解决，不得不吐槽一下，m1 的生态还是有点问题，就虚拟机这块，我找了半天，基本能用的只有这个简陋的 multipass （收费的 parallels 没有尝试），vmware 直接无法运行（提示什么该软件基于 Intel 但却尝试使用 rosetta2 运行），还有一个 virtualBox ，这个我直接懒得下了，据说都不支持 m1，而且这种网络问题搞得我真的很头大，不得不吐槽一下天朝的网络，花费大把时间去解决网络问题，还有看见某个流程一直卡在 pull 上，让人有一种想砸掉电脑的冲动，最蛋疼的是这个问题还没有什么靠谱的解决方式，在 minikube 和 ingress-nginx 的 github 上找到了关于国内拉取的 issue，但是基本也没什么有用的答案，还有一些网上的教程，给的修改版 yaml 直接跑都跑不起来。</del></p><p><del>在 mac 上跑 minikube 可以成功开启 ingress 插件，但是又会报 <code>Because you are using a Docker driver on darwin, the terminal needs to be open to run it</code> 错误，网上找了半天也没看见一个能用的解决方法</del></p><p><del>折腾了一天都没把 ingress 给跑起来，感觉是在纯纯的浪费时间</del></p></blockquote><p>LoadBalance 的方式存在一个缺点：只能为一种类型的 Service 提供服务，比如上面的介绍的 loadbalance 只是用来访问 nginx 的，如果现在集群添加了一些 redis Pod，那么又要新创建一个 LoadBalance 来提供对外服务（比如 spec.ports[0].port&#x3D;6379, target&#x3D;6379, nodePort&#x3D;30001），客户端通过 <strong>LoadBalanceIP:30000</strong> 这个地址来完成对 nginx Pod 的访问，通过 <strong>LoadBalanceIP:30001</strong> 来完成对 redis Pod 的访问，因为 LoadBalanceIP 是公网 IP，所以这么搞无疑有点浪费。</p><p>为了解决上面的问题，ingress 这个玩意就应运而生了，这个东西其实说白了就是 Service 的 Service（无限套娃？），类似于 web 路由的功能，通过访问不同的域名来完成对不同 Service 的访问，就比如这张图：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1654445796590.jpg"></p><p>而且 ingress 工作在应用层，所以可以提供一些 Service 不能实现的功能，比如基于 cookie 的会话亲和性 (session affinity) 等</p><p>Ingress 需要配合 Ingress Controller 使用</p><p><strong>基于 minikube nginx ingress 的实践</strong></p><blockquote><p>该实践基于 minikube</p></blockquote><p>all.yaml</p><p>包含了三个 Pod 和三个对应的 Service</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-app</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">hello-app</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hello-app</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/hello-app-arm64</span> <span class="hljs-comment"># 注意这里使用的镜像仅适用于 arm64 机器</span><br>    <span class="hljs-comment"># image: gcr.io/google-samples/hello-app:2.0 # 如果你的机器是 amd64 的可以使用这个</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-app-Service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">81</span> <span class="hljs-comment"># 该 Service 的端口</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span> <span class="hljs-comment"># 转发到 Pod 的 8080 端口</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30111</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">hello-app</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-Service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 该 Service 的端口</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 转发到 Pod 的 80 端口</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30222</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">redis</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">redis</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">6379</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">redis-Service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">82</span> <span class="hljs-comment"># 该 Service 的端口</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">6379</span> <span class="hljs-comment"># 转发到 Pod 的 8080 端口</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30333</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">redis</span><br></code></pre></td></tr></table></figure><p>ingress.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-ingress</span><br><span class="hljs-attr">spec:</span><br><span class="hljs-comment"># ingressClassName: nginx # 如果你使用的不是 minikube，需要加上这行</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">ingress.example.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/redis</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">Service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">redis-Service</span><br>            <span class="hljs-attr">port:</span><br>              <span class="hljs-attr">number:</span> <span class="hljs-number">82</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/hello-app</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">Service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">hello-app-Service</span><br>            <span class="hljs-attr">port:</span><br>              <span class="hljs-attr">number:</span> <span class="hljs-number">81</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/nginx</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">Service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-Service</span><br>            <span class="hljs-attr">port:</span><br>              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>运行上面的 2 个 yaml</p><p>查看 ingress 的 ip：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get ingress</span><br>NAME              CLASS   HOSTS                 ADDRESS        PORTS   AGE<br>example-ingress   nginx   ingress.example.com   192.168.49.2   80      9h<br></code></pre></td></tr></table></figure><p>将 ingress ip 写入到 &#x2F;etc&#x2F;hosts：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim /etc/hosts</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入这一条：192.168.49.2 ingress.example.com</span><br></code></pre></td></tr></table></figure><p>问题：</p><p>访问 &#x2F;hello-app 可以正常显示结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">curl ingress.example.com/hello-app</span><br>Hello, world!<br>Version: 1.0.0<br>Hostname: hello-app<br></code></pre></td></tr></table></figure><p>但是 &#x2F;nginx 和 &#x2F;redis 都显示 404：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl ingress.example.com/nginx</span><br>&lt;html&gt;<br>&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;<br>&lt;body&gt;<br>&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;<br>&lt;hr&gt;&lt;center&gt;nginx/1.23.1&lt;/center&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>但是直接访问 Service 又是通的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME                TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE<br>hello-app-Service   NodePort    10.103.218.83   &lt;none&gt;        81:30111/TCP   9h<br>kubernetes          ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP        14h<br>nginx-Service       NodePort    10.99.214.102   &lt;none&gt;        80:30222/TCP   9h<br>redis-Service       NodePort    10.104.106.67   &lt;none&gt;        82:30333/TCP   9h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">minikube ip</span><br>192.168.49.2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 192.168.49.2:30222</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br>&lt;style&gt;<br>html &#123; color-scheme: light dark; &#125;<br>body &#123; width: 35em; margin: 0 auto;<br>font-family: Tahoma, Verdana, Arial, sans-serif; &#125;<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br>&lt;p&gt;If you see this page, the nginx web server is successfully installed and<br>working. Further configuration is required.&lt;/p&gt;<br><br>&lt;p&gt;For online documentation and support please refer to<br>&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;<br>Commercial support is available at<br>&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;<br><br>&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><blockquote><p>ps: minikube 如果想访问 Service，需要将 Service 定义为 nodePort 类型，然后通过 <code>minikube ip</code> 命令来获取 minikube 的 ip，然后用 <code>&lt;minikube_IP:nodePort&gt;</code> 的方式进行访问。似乎不能直接在集群内通过  <code>curl ClusterIP</code> 的方式来访问 Service。</p></blockquote><p>解决方法：</p><p>在 ingress.yaml 中添加 <code>nginx.ingress.kubernetes.io/rewrite-target: /</code> 注解</p><p>修改后的 metadata：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-ingress</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="hljs-string">/</span><br></code></pre></td></tr></table></figure><p>现在试试访问 &#x2F;nginx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl ingress.example.com/nginx</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br>&lt;style&gt;<br>html &#123; color-scheme: light dark; &#125;<br>body &#123; width: 35em; margin: 0 auto;<br>font-family: Tahoma, Verdana, Arial, sans-serif; &#125;<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br>&lt;p&gt;If you see this page, the nginx web server is successfully installed and<br>working. Further configuration is required.&lt;/p&gt;<br><br>&lt;p&gt;For online documentation and support please refer to<br>&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;<br>Commercial support is available at<br>&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;<br><br>&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>可以看到成功使用 ingress 访问了 nginx ，而不是之前的 404。</p><p>但是访问 &#x2F;redis 会报 502 错误（可能对于 ingress 而言，redis 不是一个好的例子）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl ingress.example.com/redis</span><br>&lt;html&gt;<br>&lt;head&gt;&lt;title&gt;502 Bad Gateway&lt;/title&gt;&lt;/head&gt;<br>&lt;body&gt;<br>&lt;center&gt;&lt;h1&gt;502 Bad Gateway&lt;/h1&gt;&lt;/center&gt;<br>&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>这里暂时不知道什么原因，感觉这里用 redis 来做实践本身也不太合理，毕竟 curl redis 本来就不会正常工作，但是用 redis-cli 通过访问 Service 的方式可以正常工作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME                TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE<br>hello-app-Service   NodePort    10.103.218.83   &lt;none&gt;        81:30111/TCP   12h<br>kubernetes          ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP        17h<br>nginx-Service       NodePort    10.99.214.102   &lt;none&gt;        80:30222/TCP   12h<br>redis-Service       NodePort    10.104.106.67   &lt;none&gt;        82:30333/TCP   12h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">k8s minikube ip</span><br>192.168.49.2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">redis-cli -h 192.168.49.2 -p 30333</span><br>192.168.49.2:30333&gt; keys *<br>1) &quot;1&quot;<br>192.168.49.2:30333&gt;<br></code></pre></td></tr></table></figure><p>但是用 ingress 的地址访问是不行的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">redis-cli -h ingress.example.com/redis -p 82</span><br>Could not connect to Redis at ingress.example.com/redis:82: Name or Service not known<br>not connected&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">redis-cli -h ingress.example.com/redis -p 30333</span><br>Could not connect to Redis at ingress.example.com/redis:30333: Name or Service not known<br>not connected&gt;<br></code></pre></td></tr></table></figure><p>这个问题暂时将其搁置，毕竟这里主要还是以学习 ingress 为主。</p><h1 id="特殊的-headless-Service"><a href="#特殊的-headless-Service" class="headerlink" title="特殊的 headless Service"></a>特殊的 headless Service</h1><p>Service 提供了稳定的对外访问服务，同时还提供了负载均衡的能力，每次访问 Service，都会将其转发到该 Service selector 对应的 Pod 中的某一个，具体转发给哪个是由 Service 决定的，访问者没有自主选择权，但是如果访问者想自主选择访问哪个 Pod，或者想访问该 Service 下的所有 Pod，此时该如何处理呢？为了解决这类问题，就需要 Headless Service 闪亮登场了。</p><p>顾名思义，headless Service 一种特殊的 Service，它是没有 IP 的，想要访问它，只能通过 DNS 的方式访问，DNS 的固定格式是 <code>&lt;Service_name&gt;.&lt;namespace&gt;.svc.cluster.local</code>。而访问 headless Service 也不同于普通 Service ，它不会随机访问其代理的某个 Pod，而是直接将其代理的所有 Pod 的 address 提供给你。</p><p>除此以外，它还会为 <strong>其代理的每个 Pod</strong> 的 IP 地址绑定一个如下格式的 DNS 记录：</p><p><code>&lt;Pod_name&gt;.&lt;Service_name&gt;.&lt;namespace&gt;.svc.cluster.local</code></p><p>通过上面这种格式的 DNS 记录，就可以获取 headless Service 下的某个 Pod 的 IP 地址了。</p><div class="note note-warning">            <p>更新：</p><p>感觉 headless Service 会为其代理的 Pod 生成 DNS 不太准确？因为我实践了一下，用 headless Service + 由 rs 创建出来的 Pod，然后 exec 到随便一个 Pod 执行 <code>nslookup &lt;Pod_name&gt;.&lt;Service_name&gt;.&lt;namespace&gt;.svc.cluster.local</code> 是无法解析到地址的，报错 <code>server can&#39;t find nginx-rs-wzc4r.nginx-service-headless.default.svc.cluster.local: NXDOMAIN</code>，而用 headless Service + 由 StatefulSet 创建出来的 Pod 则可以成功解析到地址。</p><p>2023.8.25 再次验证，确定就是上面这种情况。可能是因为普通的 pod 是无状态的，所以统一通过 Service 访问即可，无需为每个 Pod 生成一个固定的 DNS？而 Statefulset 创建出来的 Pod 都是有状态的，可能每个 Pod 存储的内容不一样，所以存在访问指定 Pod 的需求，所以才会为每个 Pod 生成一个固定的 DNS？</p><p>更新（2024.2.23）：</p><p>关于上面 Pod Dns 的疑问，可以参考 <a href="https://www.qikqiak.com/post/add-dns-record-for-pod/">这篇文章</a>。</p>          </div><blockquote><p>🤔 疑问：用户自行选择 Pod 的场景有哪些？用户需要访问 Service 下所有 Pod 的场景有哪些？</p><p> 用户自行选择 Pod 的场景可能包括：</p><ol><li>特定的服务需要访问特定的 Pod，例如需要使用某个 Pod 上特定的配置或者数据。</li><li>测试或者调试需要针对特定的 Pod 进行操作，例如分析特定 Pod 的日志或者性能数据。</li></ol><p> 需要访问 Service 下所有 Pod 的场景可能包括：</p><ol><li>执行批量操作，例如向 Service 下所有 Pod 发送某个指令或者获取所有 Pod 的状态信息。</li><li>在服务发现场景下，需要获取 Service 下所有可用的 Pod 列表。</li></ol><p> 需要注意的是，在 k8s 中，用户一般不需要直接访问 Pod，而是通过 Service 提供的稳定的对外访问服务来访问应用程序。只有在特定的情况下，才需要直接访问 Pod。</p><p>🤔 疑问：使用 headless Service 后，是否代表负载均衡已经失效，需要用户自行实现？</p></blockquote><h2 id="实践-1"><a href="#实践-1" class="headerlink" title="实践  1"></a>实践  1</h2><p><strong>这个实践将会测试 headless Service 的特性，并且会和普通的 Service 进行对比，加深理解。</strong></p><p>下面这个 yaml 会创建一个 nginx rs，以及两个对应的 Service，一个是正常的 Service，还有一个是 headless 类型的 Service：</p><p>（ps：好像如果 Pod 指定了 containerPort，那么 Service 这边可以不指定 targetPort）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-service-headless</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 该 Service 的端口</span><br>    <span class="hljs-comment">#targetPort: 8080 # 转发到 Pod 的 8080 端口</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 该 Service 的端口</span><br>    <span class="hljs-comment">#targetPort: 8080 # 转发到 Pod 的 8080 端口</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-rs</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f headless_service_test.yaml</span><br>Service/nginx-service-headless unchanged<br>Service/nginx-service created<br>replicaset.apps/nginx-rs unchanged<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME             READY   STATUS    RESTARTS   AGE<br>nginx-rs-f2b4j   1/1     Running   1 (33m ago)   47m<br>nginx-rs-dhxz7   1/1     Running   1 (33m ago)   47m<br>nginx-rs-sn8wk   1/1     Running   1 (33m ago)   47m<br>dnsutils         1/1     Running   1 (33m ago)   36m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME                     TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE<br>kubernetes               ClusterIP   10.43.0.1      &lt;none&gt;        443/TCP   24h<br>nginx-service-headless   ClusterIP   None           &lt;none&gt;        80/TCP    48s<br>nginx-service            ClusterIP   10.43.27.242   &lt;none&gt;        80/TCP    29s<br></code></pre></td></tr></table></figure><p>测试一下普通的 Service 能否访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 10.43.27.242</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br></code></pre></td></tr></table></figure><p>可以看到，普通的 Service 是可以正常访问的，但是 headless Service 是不可以访问的，因为 headless Service 明确指定了 clusterIP 为 None，所以不会给它分配一个集群内 IP，所以无法通过 curl 的方式访问。</p><p>使用 nslookup 查看二者的 dns 解析，看看他们两的区别，Service 的 dns 格式是 <code>&lt;Service_name&gt;.&lt;namespace&gt;.svc.cluster.local</code>，注意这里需要在容器内部执行。</p><blockquote><p>Tips: nginx 容器默认应该是没有安装 nsloopup 的，你需要执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">apt update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">apt install dnsutils</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it nginx-rs-dhxz7 -- nslookup nginx-service.default.svc.cluster.local</span><br>Server:10.43.0.10<br>Address:10.43.0.10:53<br><br>Name:nginx-service.default.svc.cluster.local<br>Address: 10.43.27.242<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it nginx-rs-dhxz7 -- nslookup nginx-service-headless.default.svc.cluster.local</span><br>Server:10.43.0.10<br>Address:10.43.0.10:53<br><br>Name:nginx-service-headless.default.svc.cluster.local<br>Address: 10.42.0.36<br>Name:nginx-service-headless.default.svc.cluster.local<br>Address: 10.42.0.32<br>Name:nginx-service-headless.default.svc.cluster.local<br>Address: 10.42.0.30<br></code></pre></td></tr></table></figure><p>发现区别了吗？普通的 Service 只返回了一条地址，这条地址正是 Service 自身的 ip，而 headless Service 返回了 3 条地址，这 3 条地址正是 Service 代理的几个 Pod 的地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po -o wide</span><br>NAME             READY   STATUS    RESTARTS      AGE   IP           NODE     NOMINATED NODE   READINESS GATES<br>nginx-rs-f2b4j   1/1     Running   1 (40m ago)   54m   10.42.0.36   ubuntu   &lt;none&gt;           &lt;none&gt;<br>nginx-rs-dhxz7   1/1     Running   1 (40m ago)   54m   10.42.0.30   ubuntu   &lt;none&gt;           &lt;none&gt;<br>nginx-rs-sn8wk   1/1     Running   1 (40m ago)   54m   10.42.0.32   ubuntu   &lt;none&gt;           &lt;none&gt;<br>dnsutils         1/1     Running   1 (40m ago)   43m   10.42.0.31   ubuntu   &lt;none&gt;           &lt;none&gt;<br></code></pre></td></tr></table></figure><p><del>此外，我们还可以验证一下 headless 为其代理的 Pod 生成的 DNS 记录：</del></p><p><del>待完成，不知道为什么解析不出 IP，报错：&#96;server can’t find nginx-rs-wzc4r.nginx-Service-headless.default.svc.cluster.local: NXDOMAIN</del></p><h2 id="实践-2"><a href="#实践-2" class="headerlink" title="实践 2"></a>实践 2</h2><p>这个实践会用通过代码的方式，从 headless Service 中获取 Pod 地址，然后访问这些 Pod。</p><p>首先需要准备下面的几个 yaml。</p><p><strong>Deployment.yaml</strong></p><p>这个 deploy 将会创建 3 个 Pod，每个 Pod 都是一个 http server ，通过 -h 来指定地址，-p 来指定监听端口，访问该 server 会返回包括主机名等基本信息。注意这里的 -h 需要指定为 0.0.0.0 而不是 localhost，指定为 localhost 的话其他 Pod 将无法访问。（为什么呢？）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-app</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">hello-app</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">hello-app</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">hello-app</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hello-app</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/hello-app</span><br>        <span class="hljs-attr">args:</span> [<span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>Service.yaml</strong></p><p>这是一个 headless Service。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-app</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 该 Service 的端口</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span> <span class="hljs-comment"># 转发到 Pod 的 80 端口</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">hello-app</span> <span class="hljs-comment"># 具有 app=hello-app 标签的 Pod 都属于该 Service</span><br></code></pre></td></tr></table></figure><p><strong>httpget.yaml</strong></p><p>这个 Pod 通过 -s 来指定 headless Service 的 FQDN，最终这个镜像内部的程序会调用 net.LookupSRV 解析出每个 Pod 对应的 SRV 记录，然后通过 SRV 记录进行访问。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">http-get</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http-get</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/Service-headless-test</span><br>    <span class="hljs-attr">args:</span> [<span class="hljs-string">&quot;-s&quot;</span>, <span class="hljs-string">&quot;hello-app.default.svc.cluster.local&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>]<br></code></pre></td></tr></table></figure><p>然后依次创建 Deployment，headless Service：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get deploy</span><br>NAME               READY   UP-TO-DATE   AVAILABLE   AGE<br>hello-app          3/3     3            3           130m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE<br>hello-app    ClusterIP   None            &lt;none&gt;        80/TCP    119m<br>kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP   80d<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                               READY   STATUS    RESTARTS      AGE<br>hello-app-7b5f4475c8-bv8lz         1/1     Running   0             131m<br>hello-app-7b5f4475c8-pcrv8         1/1     Running   0             131m<br>hello-app-7b5f4475c8-wm528         1/1     Running   0             131m<br></code></pre></td></tr></table></figure><p>最后创建 httpget，然后等待一会，等 Pod 起来后，通过 logs 查看输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f httpget_headless.yaml</span><br>Pod/http-get created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 <span class="hljs-built_in">log</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl logs http-get</span><br>url: http://10-1-0-117.hello-app.default.svc.cluster.local.:8080<br>Hello, world!<br>Version: 1.0.0<br>Hostname: hello-app-7b5f4475c8-pcrv8<br><br>url: http://10-1-0-118.hello-app.default.svc.cluster.local.:8080<br>Hello, world!<br>Version: 1.0.0<br>Hostname: hello-app-7b5f4475c8-bv8lz<br><br>url: http://10-1-0-116.hello-app.default.svc.cluster.local.:8080<br>Hello, world!<br>Version: 1.0.0<br>Hostname: hello-app-7b5f4475c8-wm528<br></code></pre></td></tr></table></figure><p>从 log 可以看到，我们成功访问到了每一个 Pod，日志里的 3 个 Hostname 和 Pod name 相符。</p><blockquote><p>附：</p><p>http-get 镜像的 go 源码：</p><p>通过 net.LookupSRV 解析出 SRV 记录，从 SRV 里可以拿到 taget 和 port，将这个两个参数拼接成一个完整的 HTTP URL 进行访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>HeadlessServiceName <span class="hljs-type">string</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.StringVar(&amp;HeadlessServiceName, <span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;headless Service name&quot;</span>)<br>flag.Parse()<br><br>_, addrs, err := net.LookupSRV(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, HeadlessServiceName)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>b, err := io.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-type">string</span>(b))<br>&#125;<br><br><span class="hljs-keyword">for</span> _, addr := <span class="hljs-keyword">range</span> addrs &#123;<br>url := fmt.Sprintf(<span class="hljs-string">&quot;http://%v:%v&quot;</span>, addr.Target, addr.Port)<br>fmt.Printf(<span class="hljs-string">&quot;url: %v\n&quot;</span>, url)<br>fn(url)<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>待补充&#x2F;疑问：</p><p>SRV 记录是什么？</p><p>为什么 net.LookupSRV 返回的 SRV.Target 是 <code>10-1-0-117.hello-app.default.svc.cluster.local. </code>这样的，而不是像 nslookup 那样直接返回 IP？</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>multipass 修改配置（内存、硬盘、CPU 等）适用于 m1 mac</title>
    <link href="/2022/05/08/multipass-xiu-gai-pei-zhi/"/>
    <url>/2022/05/08/multipass-xiu-gai-pei-zhi/</url>
    
    <content type="html"><![CDATA[<p><strong>multipass</strong> 是一款比较轻量级的虚拟机方案，使用起来也比较方便，操作方式与容器类似，但是使用过程中发现没有直接提供修改配置的简单方法，比如默认创建的虚拟机硬盘大小只会分配 5G，如果要跑 k8s 之类的显然是不够用的（k3s 都不够），而且默认创建的 CPU 只有 1 核，连 minikube 都跑不起来（最低需要 2 核），所以就需要修改配置。</p><p>在 github 上找到的解决方案（适用于 m1 mac）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">停止 multipass</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo launchctl unload /Library/LaunchDaemons/com.canonical.multipassd.plist</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改配置文件（CPU 对应 num_cores）</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo vim /var/root/Library/Application\ Support/multipassd/qemu/multipassd-vm-instances.json</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动 multipass</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo launchctl load /Library/LaunchDaemons/com.canonical.multipassd.plist</span><br></code></pre></td></tr></table></figure><p>参考：</p><p><a href="https://github.com/canonical/multipass/issues/1158">https://github.com/canonical/multipass/issues/1158</a></p><p>更新：</p><p>CPU 能更改成功，但是修改内存无法生效，这玩意还是不太好用</p>]]></content>
    
    
    
    <tags>
      
      <tag>multipass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s nginx pod 的 containerPort 问题</title>
    <link href="/2022/05/08/k8s-nginx-pod-de-containerport-wen-ti/"/>
    <url>/2022/05/08/k8s-nginx-pod-de-containerport-wen-ti/</url>
    
    <content type="html"><![CDATA[<h1 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h1><p>有如下 yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br>      <span class="hljs-attr">hostPort:</span> <span class="hljs-number">9527</span><br></code></pre></td></tr></table></figure><p>此时 curl nodeIP:9527 会发现报 Connection refused 错误，使用 <code>kubectl exec -it nginx -- curl localhost:8080</code> 也是如此</p><h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">hostPort:</span> <span class="hljs-number">9527</span><br></code></pre></td></tr></table></figure><p>将 containerPort 改为 80，这是 nginx 的默认监听端口。</p><p>此时从浏览器访问 NodeIP:9527 发现可以显示 nginx 的主页，使用 <code>kubectl exec -it nginx -- curl localhost:80</code> 也可以正常工作，<code>curl localhost:9527</code> 也同样可以正常工作。但是 <code>kubectl exec -it nginx -- curl localhost:9527</code> 会报 Connection refused 错误。</p><h1 id="🤔"><a href="#🤔" class="headerlink" title="🤔"></a>🤔</h1><p>从上面的例子中可以得出：hostPort 是主机对外暴露的 IP 地址，其指向容器内部的 containerPort，在 <strong>修改</strong> 的例子中，意义为：对外暴露 9527 端口，该端口指向 nginx 容器内部的 80 端口，所以访问主机的 9527 相当于访问 nginx 容器的 80 端口，从 <code>kubectl exec -it nginx -- curl localhost:9527</code> 报 Connection refused 可以得出，容器内部是没有监听 9527 这个端口的。</p><p>在 stackoverflow 上找到了两个同样的问题：</p><p><a href="https://stackoverflow.com/questions/69282237/nginx-pod-not-taking-specified-port">https://stackoverflow.com/questions/69282237/nginx-pod-not-taking-specified-port</a></p><p>回答：</p><blockquote><p>NGINX Docker image uses port 80 to listen for HTTP connections by default. containerPort is the port which you expose your application to external traffic.</p><p>NGINX Docker 镜像默认使用 80 端口来监听 HTTP 连接。容器端口是您将应用程序公开给外部流量的端口。</p></blockquote><p><a href="https://stackoverflow.com/questions/66526811/unable-to-curl-pod-ip-using-containerport">https://stackoverflow.com/questions/66526811/unable-to-curl-pod-ip-using-containerport</a></p><p>回答：</p><blockquote><p>By default, <code>nginx</code> server listen to the port 80. You can see it in their docker image <a href="https://hub.docker.com/layers/nginx/library/nginx/1.18.0-alpine/images/sha256-d7038eae37cfa36cd8e286f6d6daf0df7a445a2da327517b3cde4ba1833adc0c?context=explore">ref</a>.</p><p>With <code>kubectl run nginx --image=nginx --port=8888</code> what you have done here is you have expose another port along with 80. But the server is still listening on the <code>80</code> port.</p><p>So, try with target port <code>80</code>. For this reason when you tried with other than port <code>80</code> it’s not working. Try with set <code>--target-port=8888</code> to <code>--target-port=80</code>.</p><p>Or, If you want to change the server port you need to use configmap along with pod to pass custom config to the server.</p><p>默认情况下，<code>nginx</code> 服务器监听 80 端口。你可以在他们的 docker 镜像中看到它 [ref](<a href="https://hub.docker.com/layers/nginx/library/nginx/1.18.0">https://hub.docker.com/layers/nginx/library/nginx/1.18.0</a> - alpine&#x2F;images &#x2F;sha256 - d7038eae37cfa36cd8e286f6d6daf0df7a445a2da327517b3cde4ba1833adc0c?context&#x3D;explore)。<br>使用 <code>kubectl run nginx - image=nginx - port=8888</code> 你在这里所做的是你已经暴露了另一个端口以及 80。但是服务器仍在监听 <code>80</code> 端口。<br>因此，请尝试使用目标端口“80”。因此，当您尝试使用端口“80”以外的其他端口时，它不起作用。尝试将<code>-target-port=8888</code>设置为<code>-target-port=80</code>。<br>或者，如果要更改服务器端口，则需要使用 configmap 和 pod 将自定义配置传递给服务器。</p></blockquote><p>那么 containerPort 这个参数到底是什么作用呢？</p><p>查阅资料，有这几种说法：</p><ol><li><p>containerPort 是 pod 中的容器需要暴露的端口</p></li><li><p>containerPort 是容器内部的 port</p></li><li><blockquote><p><strong>ports</strong> <em>:</em> <strong>containerPort</strong> List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses,<strong>but is primarily informational</strong>. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default “0.0.0.0” address inside a container will be accessible from the network. Cannot be updated.</p><p><em>containerPort</em> 是要从容器公开的端口列表。在此处公开端口可为系统提供有关容器使用的网络连接的附加信息，<strong>但主要是信息性</strong>的。此处不指定端口不会阻止该端口被暴露。任何侦听容器内默认“0.0.0.0”地址的端口都可以从网络访问。无法更新。（机翻，来自 <a href="https://faun.pub/should-i-configure-the-ports-in-kubernetes-deployment-c6b3817e495%EF%BC%89">https://faun.pub/should-i-configure-the-ports-in-kubernetes-deployment-c6b3817e495）</a></p></blockquote></li></ol><p>从上面这些说法大致了解了，nginx 容器会默认监听 80 端口，而我指定的 containerPort 实际上不会改变 nginx 监听的端口，所以如果将其指定为非 80 端口，比如 8080，那么 hostPort 会访问容器内的 8080 端口，但 8080 没有被任何程序监听，所以会产生 Connection refused 错误。就和上面所说的，containerPort 主要是信息性的，它只是<strong>注明</strong>了容器对外暴露的端口，不会实际对容器造成影响。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s DaemonSet</title>
    <link href="/2022/05/07/k8s-daemonset/"/>
    <url>/2022/05/07/k8s-daemonset/</url>
    
    <content type="html"><![CDATA[<p>顾名思义，daemon 代表守护程序，所以 DaemonSet （简称 ds）会在每个节点上运行一个专门的 pod，这个 pod 是特殊的，比如资源监控器或者日志收集器，或者 k8s 自己的 kube-proxy。与 rc 或者 rs 不同，这两个会随机地分布在整个集群中，比如副本数量为 5，一共有 4 个节点，可能会在节点 1 创建两个副本，节点 2 创建 1 个副本，节点 4 创建 2 个副本，但 DaemonSet 会保证这 4 个节点各自都有一个副本。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ssd-monitor</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span> <span class="hljs-comment"># DaemonSet 会对标签为 app=ssd-monitor 的 pod 进行管理</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">ssd-monitor</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span> <span class="hljs-comment"># 这个标签不能省略，且必须与上面的 matchLabels 相同，否则 create 会报错</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">ssd-monitor</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">main</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br></code></pre></td></tr></table></figure><p>ps：因为书上提供的镜像都是 x86 的，在我的机器上无法运行，所以把镜像替换为了 nginx，反正只是学习，也无所谓了</p><p>书上的 template.spec 下其实还有一个 nodeSelector，值为 disk&#x3D;ssd，代表该 ds 只会在标签为 disk&#x3D;ssd 的节点上创建、管理 pod，这里偷懒了没写，不然还要给节点添加标签。</p><p>如果将一个已经运行 ds 创建的 pod 的节点的标签改掉，比如上面的例子中，将节点的标签 disk&#x3D;ssd 改为 dsik&#x3D;hdd，那么先前已经创建好的 ds pod 会被终止。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s ReplicaSet</title>
    <link href="/2022/05/07/k8s-replicaset/"/>
    <url>/2022/05/07/k8s-replicaset/</url>
    
    <content type="html"><![CDATA[<blockquote><p> 本篇笔记摘自 《Kubernetes in Aciton 》</p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>ReplicaSet（简称 rs） 是 ReplicationController （简称 rc）的升级版，它的标签选择器功能更加强大。</p><h1 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h1><p>使用 selector.matchExpressions 进行标签选择，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">selector:</span><br><span class="hljs-attr">matchExpressions:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">app</span><span class="hljs-comment"># 此选择器要求该 pod 包含名为 “app” 的标签</span><br><span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br><span class="hljs-attr">values:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">kubia</span><span class="hljs-comment"># 标签的值必须是 &quot;kubia&quot;</span><br></code></pre></td></tr></table></figure><p>其中，key 和 operator 是必须的，values 可能为空，也可能为多个值，运算符有以下几个：</p><ul><li>In : Label 的值必须与其中一个指定的 values 匹配。</li><li>Notln : Label 的值与任何指定的 values 不匹配。</li><li>Exists : pod 必须包含一个指定名称的标签(值不重要)。使用此运算符时，不应该指定 values 字段。</li><li>DoesNotExist : pod 不得包含有指定名称的标签。values 属性不得指定 。不应指定 values字段。</li><li>DoesNotExist : pod不得包含有指定名称的标签。values属性不得指定 。</li></ul><p>如果你指定了多个表达式，则所有这些表达式都必须为 true 才能使选择器与 pod 匹配。如果同时指定matchLabels 和 matchExpressions，则所有标签都必须匹配，并且所有表达式必须计算为 true 以使该 pod 与选择器匹配。</p><p>例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">selector:</span><br>  <span class="hljs-attr">matchLabels:</span><br>    <span class="hljs-attr">component:</span> <span class="hljs-string">redis</span><br>  <span class="hljs-attr">matchExpressions:</span><br>    <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-string">tier</span>, <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span>, <span class="hljs-attr">values:</span> [<span class="hljs-string">cache</span>]&#125;<br>    <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-string">environment</span>, <span class="hljs-attr">operator:</span> <span class="hljs-string">NotIn</span>, <span class="hljs-attr">values:</span> [<span class="hljs-string">dev</span>]&#125;<br></code></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="rs-是否会抢占-rc-的-pod"><a href="#rs-是否会抢占-rc-的-pod" class="headerlink" title="rs 是否会抢占 rc 的 pod"></a>rs 是否会抢占 rc 的 pod</h2><p>现在有 3 个 rc 创建的 pod，标签都为 app&#x3D;kubia，容器为 nginx、数量为 3 ，如果此时使用 rs 创建条件相同的 pod 会怎样？会直接将 rc 的 3 个容器抢过来吗？</p><p>rs 的 yaml 如下：</p><p>kubia-replicaset.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>创建 rs：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f kubia-replicaset.yaml</span><br></code></pre></td></tr></table></figure><p>查看 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>kubia-qb26r   1/1     Running   0          13h<br>kubia-d9xc6   1/1     Running   0          13h<br>kubia-dg2j8   1/1     Running   0          17m<br>kubia-vdrf6   1/1     Running   0          10m<br>kubia-cq4wt   1/1     Running   0          10m<br>kubia-qx467   1/1     Running   0          10m<br></code></pre></td></tr></table></figure><p>发现 k8s 又新创建了 3 个 pod，通过 kubectl describe 可以看到每个 pod 的管理者，<code>kubia-qb26r</code> 显示的是：<code>Controlled By:  ReplicationController/kubia</code>，<code>kubia-qx467</code> 显示的是：<code>Controlled By:  ReplicaSet/kubia</code>，说明 rs 不会抢占 rc 的 pod。</p><h2 id="脱离-rc-管理的-pod-会被-rs-接管吗"><a href="#脱离-rc-管理的-pod-会被-rs-接管吗" class="headerlink" title="脱离 rc 管理的 pod 会被 rs 接管吗"></a>脱离 rc 管理的 pod 会被 rs 接管吗</h2><p>还是和上面的条件一样，有 3 个 rc 创建的 pod，并且标签都为 app&#x3D;kubia，先删除之前创建的 rs，这会一并删除其创建的 3 个 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete rs kubia</span><br>replicaset.apps &quot;kubia&quot; deleted<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>kubia-qb26r   1/1     Running   0          13h<br>kubia-d9xc6   1/1     Running   0          13h<br>kubia-dg2j8   1/1     Running   0          20m<br></code></pre></td></tr></table></figure><p>删除之前的 rc，注意添加 –cascade&#x3D; false 来避免删除 pod（有个警告，意思 –cascade&#x3D;false 被废弃了，应该替换为 cascade&#x3D;orphan，查了下 orphan 是孤儿的意思，挺贴切的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete rc kubia --cascade=<span class="hljs-literal">false</span></span><br>warning: --cascade=false is deprecated (boolean value) and can be replaced with --cascade=orphan.<br>replicationcontroller &quot;kubia&quot; deleted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>kubia-d9xc6   1/1     Running   0          13h<br>kubia-dg2j8   1/1     Running   0          28m<br>kubia-qb26r   1/1     Running   0          13h<br></code></pre></td></tr></table></figure><p>再创建之前的 rs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f kubia-replicaset.yaml</span><br>replicaset.apps/kubia created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>nginx         1/1     Running   0          20h<br>kubia-dg2j8   1/1     Running   0          30m<br>kubia-d9xc6   1/1     Running   0          13h<br>kubia-qb26r   1/1     Running   0          13h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe pod kubia-dg2j8</span><br>Name:         kubia-dg2j8<br>Labels:       app=kubia<br><span class="hljs-meta prompt_"># </span><span class="language-bash">省略</span><br>Controlled By:  ReplicaSet/kubia<br><span class="hljs-meta prompt_"># </span><span class="language-bash">省略</span><br></code></pre></td></tr></table></figure><p>可以看到 rs 会直接接管这 3 个脱离 rc 管理的 pod。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s ReplicationController</title>
    <link href="/2022/05/06/k8s-replicationcontroller/"/>
    <url>/2022/05/06/k8s-replicationcontroller/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇笔记摘自 《Kubernetes in Aciton 》</p></blockquote><p>ReplicationController 通过标签选择器（selector）与 pod 相关联。可以通过修改一个 pod 的标签将其移出 ReplicationController 的管理，或者移入到另一个 ReplicationController。</p><p><strong>查看所有的 ReplicationController</strong>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rc</span><br>NAME    DESIRED   CURRENT   READY   AGE<br>kubia   2         2         2       39m<br></code></pre></td></tr></table></figure><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>按照书上的 yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicationController</span><br><span class="hljs-attr">metadata:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>        <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>        <span class="hljs-attr">selector:</span><br>                <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>        <span class="hljs-attr">template:</span><br>                <span class="hljs-attr">metadata:</span><br>                        <span class="hljs-attr">labels:</span><br>                                <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><span class="hljs-comment"># 这里需要与 selectro 中的标签保持一致</span><br>                <span class="hljs-attr">spec:</span><br>                        <span class="hljs-attr">containers:</span><br>                        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br>                          <span class="hljs-attr">image:</span> <span class="hljs-string">luksa/kubia</span><br>                          <span class="hljs-attr">ports:</span><br>                          <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>发现无法运行 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods</span><br>NAME          READY   STATUS             RESTARTS         AGE<br>kubia-25mrj   0/1     CrashLoopBackOff   22 (3m22s ago)   92m<br>kubia-x4dd8   0/1     CrashLoopBackOff   22 (3m11s ago)   92m<br>kubia-8gdfz   0/1     CrashLoopBackOff   22 (2m45s ago)   92m<br></code></pre></td></tr></table></figure><p>打印一下日志看看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl logs kubia-25mrj</span><br>standard_init_linux.go:228: exec user process caused: exec format error<br></code></pre></td></tr></table></figure><p>查了一下，貌似是因为 luksa&#x2F;kubia 这个镜像是 x86 的，而我的电脑是 arm 的，所以导致容器无法运行</p><p>可以将其换成 nginx:alpine</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get po<br>NAME          READY   STATUS        RESTARTS   AGE<br>kubia-fcf4d   1/1     Running       0          16s<br>kubia-d9xc6   1/1     Running       0          16s<br>kubia-qb26r   1/1     Running       0          16s<br></code></pre></td></tr></table></figure><p>尝试删除一个 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete pod kubia-fcf4d</span><br>pod &quot;kubia-fcf4d&quot; deleted<br></code></pre></td></tr></table></figure><p>再次查看 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS        RESTARTS   AGE<br>nginx         1/1     Running       0          7h12m<br>kubia-d9xc6   1/1     Running       0          3m6s<br>kubia-qb26r   1/1     Running       0          3m6s<br>kubia-6lp8k   1/1     Running       0          23s<br></code></pre></td></tr></table></figure><p>发现 ReplicationController 又新创建了一个 pod，在最下方的 kubia-6lp8k</p><h2 id="修改标签实验"><a href="#修改标签实验" class="headerlink" title="修改标签实验"></a>修改标签实验</h2><p>先看一下当前的 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>kubia-d9xc6   1/1     Running   0          20m<br>kubia-qb26r   1/1     Running   0          20m<br>kubia-6lp8k   1/1     Running   0          17m<br></code></pre></td></tr></table></figure><p>修改一个 pod 的 label：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl label po kubia-d9xc6 app=kubia1 --overwrite</span><br>pod/kubia-d9xc6 labeled<br></code></pre></td></tr></table></figure><p>再次查看 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>kubia-qb26r   1/1     Running   0          21m<br>kubia-6lp8k   1/1     Running   0          18m<br>kubia-d9xc6   1/1     Running   0          21m<br>kubia-mnfft   1/1     Running   0          4s<br></code></pre></td></tr></table></figure><p>发现此时又新创建了一个 pod</p><p>使用 kubectl describe 查看 kubia-d9xc6，发现 Controlled By:  ReplicationController&#x2F;kubia 这句话消失了，说明该 pod 当前已经不由任何 ReplicationController 管理了。</p><p><strong>问题来了</strong>，如果把 kubia-d9xc6 的标签再改回去会怎么样？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl label po kubia-d9xc6 app=kubia --overwrite</span><br>pod/kubia-d9xc6 unlabeled<br></code></pre></td></tr></table></figure><p>这个 unlabeled 没太搞懂，但是 describe 查看发现还是更改成功了。</p><p>此时再查看 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>kubia-qb26r   1/1     Running   0          26m<br>kubia-6lp8k   1/1     Running   0          24m<br>kubia-d9xc6   1/1     Running   0          26m<br></code></pre></td></tr></table></figure><p>发现先前新创建的 pod 又被删除了。</p><p>看来 ReplicationController 会始终保证 pod 符合指定数量，多删少补。</p><h1 id="水平缩放"><a href="#水平缩放" class="headerlink" title="水平缩放"></a>水平缩放</h1><p>可以改变 spec.replicas 来变更 pod 的数量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl edit rc kubia</span><br></code></pre></td></tr></table></figure><p>此时会打开一个 vim，将 spec.replicas 修改为 2，esc + :wq 退出，退出后 k8s 会自动更新，输出：<code>replicationcontroller/kubia edited</code>，此时再查看 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>kubia-qb26r   1/1     Running   0          37m<br>kubia-d9xc6   1/1     Running   0          37m<br></code></pre></td></tr></table></figure><p>可以看到 pod 的数量已经缩减到 2 个了</p><p>同样也可以用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl scale rc kubia --replicas=2</span><br></code></pre></td></tr></table></figure><h1 id="删除-rc"><a href="#删除-rc" class="headerlink" title="删除 rc"></a>删除 rc</h1><p>使用下面的命令进行删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete rc [rcName]</span><br></code></pre></td></tr></table></figure><p>删除 rc 会一并删除其所管理的 pod，不过不想这么做，则需要添加 <code>--cascade=false</code> 选项。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s 存活探针</title>
    <link href="/2022/05/06/k8s-cun-huo-tan-zhen/"/>
    <url>/2022/05/06/k8s-cun-huo-tan-zhen/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇笔记摘自 《Kubernetes in Aciton 》4.1 保持 pod 健康</p></blockquote><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>k8s 会 <strong>检测 pod 中的容器</strong> 是否正常工作，如果容器的主线程奔溃，那么 k8s 会自动重启该容器，对于开发者而言，无需对应用程序任何额外操作便获得了自动修复的能力，但有时容器没有奔溃也不一定就代表正常，比如遇到了死锁问题，此时虽然容器不会奔溃，但是整个程序已经完全卡死无法继续工作了，针对这种情况，k8s 提供了一个 <strong>存活探针</strong> 功能。</p><p><strong>存活探针</strong> 会检查容器是否正常工作，如果探测失败， k8s 将定期执行探针并重新启动容器。</p><p><strong>存活探针</strong> 有以下几种机制：</p><ol><li><p>HTTP，对容器进行 HTTP 访问（端口和路由需要自己指定），根据返回码来判断是否正常工作（2xx，3xx代表正常，其他代表错误），如果长时间未响应也同样代表无法正常工作。</p></li><li><p>TCP socket，对容器的指定端口建立 TCP 连接，如果建立成功则代表存活，否则容器重新启动。</p></li><li><p>Exec，在容器内部执行任意命令，并检查命令的退出状态码。如果状态码是 0, 则探测成功。所有其他状态码都被认为失败。</p></li></ol><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="使用-http-方式"><a href="#使用-http-方式" class="headerlink" title="使用 http 方式"></a>使用 http 方式</h2><p>实践会创建一个基于 HTTP 的存活探针。</p><p>yaml 文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">kubia-liveness</span><br><span class="hljs-attr">spec:</span><br>        <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">luksa/kubia-unhealthy</span> <span class="hljs-comment"># 这个镜像包含了不知道怎么坏掉的应用</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br>          <span class="hljs-attr">livenessProbe:</span><br>                  <span class="hljs-attr">httpGet:</span>      <span class="hljs-comment"># 一个 HTTP GET 存活探针</span><br>                          <span class="hljs-attr">path:</span> <span class="hljs-string">/</span>       <span class="hljs-comment"># HTTP 请求的路径</span><br>                          <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>    <span class="hljs-comment"># 探针连接的网络端口</span><br></code></pre></td></tr></table></figure><p>创建后，查看 pod 状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">kubectl get pods</span><br>NAME             READY   STATUS             RESTARTS       AGE<br>kubia-liveness   0/1     CrashLoopBackOff   16 (21s ago)   60m<br></code></pre></td></tr></table></figure><p>RESTARTS 代表重启次数，上面重启了 16 次，说明 k8s 一直在尝试自动修复，只是这个镜像会在重启后不久坏掉，导致一直在重启（为了演示刻意而为之，这个镜像会正确处理前 5 个 HTTP 请求，之后每个请求都会返回 500，导致探针检测失败而重启）</p><blockquote><p>注意：当容器被强行终止时，会创建一个全新的容器——而不是重启原来的容器。</p></blockquote><blockquote><h2 id="疑问："><a href="#疑问：" class="headerlink" title="疑问："></a>疑问：</h2><p>官方文档里说，http 存活指针的判断依据是：返回大于或等于 200 并且小于 400 的任何代码都标示成功，其它返回代码都标示失败。那如果整个容器都挂掉了，不会返回任何状态码，此时会如何处理呢？是超时未收到回复后就自动判定为未存活吗？这个需要自己实践一下（ps：官方文档包括一些书籍里面提供了现成的镜像，但是这些镜像基本都是 amd64 的，在我的 m1 上无法成功运行，所以有点麻烦，需要自己写代码，然后 docker build，再 push 到 hub，）</p></blockquote><h2 id="如果-pod-中有多个容器，如何检测"><a href="#如果-pod-中有多个容器，如何检测" class="headerlink" title="如果 pod 中有多个容器，如何检测"></a>如果 pod 中有多个容器，如何检测</h2><p>可以使用存活探针，为每个容器设置不同的探测方案，比如可以使用 tcp 探针，让 pod 中的每个容器暴露一个端口，然后存活探针分别尝试与这些端口建立连接，如果其中有一个端口建立连接失败，则说明容器出现了问题，然后 k8s 就会删除这个有问题的 pod，并新建一个相同的 pod 替代。</p><p><strong>待实践</strong></p><h1 id="查看-pod-探针"><a href="#查看-pod-探针" class="headerlink" title="查看 pod 探针"></a>查看 pod 探针</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe pod kubia-liveness</span><br>Liveness:       http-get http://:8080/ delay=0s timeout=1s period=10s #success=1 #failure=3<br></code></pre></td></tr></table></figure><p>delay&#x3D;0s 表示在容器启动后立即开始探测，timeout&#x3D;1s 表示容器必须在 1s 内对探针做出响应，period&#x3D;10s 代表每 10s 进行一次探测，failure&#x3D;3 表示累计失败 3 次则视为容器无法正常工作。success&#x3D;1 书中没有说明，不过应该可以猜到是代表探针成功一次便视为容器可以正常工作。</p><p>对于一些比较重的应用，启动可能需要较长的时间，此时将 delay 设置为 0 就不太合适了，可能程序都还没跑起来，探针却已经探测过好几次了，导致错误的重启当前容器。通过 livenessProbe 下的 initialDelaySeconds 进行设置。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s pod</title>
    <link href="/2022/05/04/k8s-pod-bi-ji/"/>
    <url>/2022/05/04/k8s-pod-bi-ji/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇笔记摘自 《Kubernetes in Aciton 》第三章：<code>pod：运行于 Kubernetes 中的容器</code></p></blockquote><h1 id="什么是-Pod"><a href="#什么是-Pod" class="headerlink" title="什么是 Pod"></a>什么是 Pod</h1><p>K8s 中的 Pod 是 <strong>最小的可调度和管理单元</strong>，它可以 <strong>包含一个或多个容器</strong>。Pod 是 K8s 中部署和运行应用程序的基本单位，它提供了一个共享的网络命名空间、存储卷和容器之间的共享环境。</p><p>一个 Pod 可以包含多个容器，这些容器 <strong>共享相同的网络和存储</strong>，可以在同一个 Pod 内紧密协作，例如一个应用容器和一个辅助容器（如日志收集器、辅助任务）。这种设计允许容器之间能够通过 <code>localhost</code> 进行通信，从而更紧密地协同工作。</p><p>Pod 还可以包含一些元数据，如标签、注解等，用于标识和描述 Pod。这些元数据可以用于标记 Pod 的用途、版本、环境等信息，便于后续的管理和监控。</p><p>Pod 在 K8s 集群中的生命周期由 K8s 控制器负责管理。当需要调度新的 Pod 实例时，K8s 控制器会将 Pod 分配到适合的节点上，并监控 Pod 的运行状态。如果一个 Pod 中的所有容器都终止了，K8s 控制器会根据定义的重启策略（如 Always、OnFailure、Never）来决定是否重新启动这个 Pod。</p><p>总之，Pod 是 Kubernetes 中的基本调度和管理单元，它提供了容器之间共享环境和协作的能力，同时也是构建应用程序的最小单元。</p><p><del>pod 是 k8s 的最基本构建模块，它是多个容器的集合（当然也可以只有1个容器），一个 pod 里的所有容器都会运行在同一个节点上，不存在一个 pod 中的容器 A 在节点 1 运行，容器 B 在节点 2 运行这种情况。</del></p><blockquote><p><del><strong>为何不将所有进程放到一个容器中？</strong></del></p><p><del>容器被设计为每个容器只运行一个进程(除非进程本身产生子进程)。 如果在单个容器中运行多个不相关的进程，那么保持所有进程运行、管理它们的日志等将会是我们的责任。 例如，我们需要包含一种在进程崩溃时能够自动重启的机制。同时这些进程都将记录到相同的标准输出中，而此时我们将很难确定每个进程分别记录了什么。</del></p><p><del>综上所述， 我们需要让每个进程运行在自己的容器中， 而这就是 Docker 和 Kubernetes 期望使用的方式。</del></p></blockquote><p><del><strong>隔离性</strong>：pod 中的容器互相之间并不是完全隔离的，它们共享相同的主机名和网络接口，也能使用 ipc 进行通信。进程和文件系统也可以共享，但这两个需要做一些额外的操作。因为共享网络接口，所以也共享相同的 IP 地址和端口，这代表一个 pod 中不同容器的进程不能绑定到同一个端口号，此外容器可以通过 localhost 与同一 pod 中的其他容器进行通信。</del></p><p><del><strong>pod 间通信</strong>：k8s 集群中的所有 pod 都在同一个共享网络地址空间中，所以 pod 间可以通过 IP 进行相互访问</del></p><p><del><strong>总结</strong>：pod 类似于一台物理机或者虚拟机，只是其每个进程都封装在一个容器中，同时比较轻量，开销小</del></p><h1 id="为什么需要-Pod"><a href="#为什么需要-Pod" class="headerlink" title="为什么需要 Pod"></a>为什么需要 Pod</h1><p>Pod 可以说是每个 K8s 初学者最先接触到的概念了，它使用起来足够简单，即便是一个 K8s 新手，也可以很容易的编写出一个 Pod yaml，并且通过 kubectl 将其创建出来，当然，像更新、删除、exec、log 这些操作也不在话下，但是我们显然不能一直停留在简单使用这一层面上，这会导致我们忽视一些更深层次的东西，比如你去参加了一场面试，面试官问你：为什么 K8s 要设计 Pod 这样一种概念？你该怎么回答呢？</p><p>很不巧，前几天去面试，面试官就问了我这样一个问题，虽然接触 k8s 也有快一年时间了，但是对于这个问题竟一时语塞，只能随口说了说自己一些浅薄的理解：Pod 里面跑的是一组容器，这些容器间可以共享 namespace，这样它们相互之间的通信、协作会变得简单方便，比如 Istio 就会给 Pod 中注入一个 sidecar 容器，然后接管其他容器的流量来做一些微服务相关的操作。。。但是面试官看起来对这个回答并不太满意，后来他提醒了我，Pod 有一个重要特性我没提到，就是其在调度时会作为一个整体，老实说这一点我还真没体会到，因为平时没接触过这种场景，所以对这个特性完全没有体会，只记得好像在书上看到过，看来实践才是最好的学习方式。。</p><p>结合网上博客以及一些书籍，结合自己的理解，暂时先整理出了一版答案：</p><h2 id="共享-namespace"><a href="#共享-namespace" class="headerlink" title="共享 namespace"></a>共享 namespace</h2><p>Pod 其实是一组共享了某些资源的容器，具体的说，Pod 里的所有容器都共享一个 Network Naemspace，并且可以声明同一个 Volume，这样可以使得一些彼此之间具有 “亲密” 关系的容器得以更方便的配合工作，比如彼此之间需要使用 localhost 或者 Socket 文件进行通信、会发生直接的文件交换等等。</p><h2 id="成组调度"><a href="#成组调度" class="headerlink" title="成组调度"></a>成组调度</h2><p>为了让某些彼此之间有亲密关系的容器更好的工作，就需要让这些容器在同一台机器上执行，也就是被调度到同一个节点，而 K8s 的调度正是以 Pod 为单位的，这样就可以让一个 Pod 内的所有容器都调度到一台机器上。</p><p>举个例子，比如现在有 3 个容器以及各自所需要的资源 A（1c1g），B（1c1g），C（1c1.5g），如果不将其作为一个整体调度，那么可能存在一种情况：有一台 3c3g 的机器，然后 A 调度过去了，B 也调度过去了，等到 C 调度的时候，它发现这台机器只剩 1g 内存了，而 C 需要 1.5g 内存，这就会导致 C 无法调度到这台机器上，此时就出现了容器不在同一节点的问题。</p><p>而有了 K8s 定义的 Pod 后，我们将这 3 个容器作为一个整体，K8s 在调度时，就会直接选择一台配置大于等于 3c3.5g 的机器，这样就可以保证 3 个容器运行在同一节点上。</p><p>最后还是问一下 ChatGPT：</p><blockquote><p>K8s 引入 Pod 的设计理念是为了提供一种抽象层级，用于包装一个或多个容器，以便更好地管理容器之间的协作和资源共享。Pod 在 K8s 中具有多种好处和用途：</p><ol><li><strong>共享网络和存储</strong>： 在同一个 Pod 内的容器共享相同的网络命名空间和存储卷。这意味着容器之间可以通过 <code>localhost</code> 进行通信，并且可以共享数据，从而支持微服务之间的协作。</li><li><strong>紧密关联的容器</strong>： 有些应用需要多个容器协同工作，例如一个应用容器和一个辅助容器（如日志收集器、辅助任务）。将它们放在同一个 Pod 中，能够更紧密地协同工作，同时也可以共享相同的网络和存储。</li><li><strong>共享环境变量</strong>： 在同一个 Pod 内的容器可以共享环境变量，这可以用于传递配置信息、秘钥等。这种共享简化了容器间的通信和配置管理。</li><li><strong>扩展性和资源分配</strong>： Pod 是 K8s 调度的最小单元，可以通过水平扩展副本数来实现负载均衡和自动伸缩。这使得系统管理者可以根据需求动态调整资源分配。</li><li><strong>生命周期管理</strong>： Pod 可以在创建、更新和删除时执行预定义的生命周期操作。例如，在启动前或关闭后运行初始化脚本、执行清理操作等。</li><li><strong>多容器通信和依赖关系</strong>： 将多个容器放入同一个 Pod 中，可以通过共享 <code>localhost</code> 进行通信，这对于具有紧密耦合的容器很有用。同时，K8s 还可以在一个 Pod 中的容器之间创建依赖关系，确保它们按正确的顺序启动和终止。</li></ol><p>总的来说，Pod 提供了一种更高级别的抽象，能够更好地支持多个容器之间的协作、资源共享和管理。在 Kubernetes 中，Pod 是构建应用程序的基本单位，使得容器化应用可以更有效地运行和扩展。</p></blockquote><h1 id="通过-pod-合理管理容器"><a href="#通过-pod-合理管理容器" class="headerlink" title="通过 pod 合理管理容器"></a>通过 pod 合理管理容器</h1><h2 id="每个-pod-只包含紧密相关的组件或进程"><a href="#每个-pod-只包含紧密相关的组件或进程" class="headerlink" title="每个 pod 只包含紧密相关的组件或进程"></a>每个 pod 只包含紧密相关的组件或进程</h2><p>pod 有一条总的原则：应该将应用程序组织到多个 pod 中， 而 <strong>每个 pod 只包含紧密相关的组件或进程</strong>，而不是将所有程序都放到一个 pod。</p><p>原因有几下几点：</p><ol><li><strong>最大程度利用节点</strong>，比如现在有一个前端应用和一个后端应用，以及一个双节点的 k8s 集群，此时应该将前端 pod 放到一个节点，后端 pod 放到另一个节点，而不是将前后端放到一个 pod 中。</li><li><strong>方便扩缩容</strong>，pod 是 k8s 的扩缩容基本单位，它只能扩缩整个 pod，不能扩缩某个容器，如果一个 pod 中同时存放了前后端程序，那么如果发生扩容，会导致前后端同时扩容，但可能我只想让后端进行扩容（这是很正常的，毕竟前后端的需求不同）。</li></ol><h2 id="何时在-pod-中使用多个容器"><a href="#何时在-pod-中使用多个容器" class="headerlink" title="何时在 pod 中使用多个容器"></a><strong>何时在 pod 中使用多个容器</strong></h2><p>举个例子：有两个容器，一个负责对外提供文件访问服务，一个负责从外部下载资源到文件（sidecar容器），这两个容器间是紧密关联的，此时便可以放到一个 pod 中。</p><h1 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h1><p><strong>查看一个 pod 的 yaml 定义</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po [pod name] -o [yaml|json]</span><br></code></pre></td></tr></table></figure><p>-o 可以输入 yaml 或者 json</p><p><strong>查看 pod yaml 的字段含义</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl explain pods</span><br></code></pre></td></tr></table></figure><p><strong>创建 pod</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl [create|apply] -f [srcFile]</span><br></code></pre></td></tr></table></figure><p>通过 srcFile 来创建 pod，该文件可以是 yaml 或者 json</p><p>**查看当前的 pod **</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods</span><br></code></pre></td></tr></table></figure><p><strong>获取 pod 日志</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl logs [podName]</span><br></code></pre></td></tr></table></figure><p>获取指定容器的日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl logs [podName] -c [containerName]</span><br></code></pre></td></tr></table></figure><p><strong>更新 pod</strong></p><p>修改 yaml 后重新执行 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f [srcFile]</span><br></code></pre></td></tr></table></figure><p>这只适用于更改 Pod 中容器（包括工作容器与初始化容器）的镜像，以及 activeDeadlineSeconds （对 Job 类型的 Pod 定义失败重试的最大时间）， tolerations （Pod 对污点的容忍）</p><p>如果是其他情况，则需要删除后重新创建容器</p><blockquote><p>Kubernetes 对 Pod 的更新做了限制，除了更改 Pod 中容器（包括工作容器与初始化容器）的镜像，以及 activeDeadlineSeconds （对 Job 类型的 Pod 定义失败重试的最大时间）， tolerations （Pod 对污点的容忍），修改其它部分将不会产生作用，如我们可以尝试在前面 Pod 定义文档 pod-test.yaml 中将宿主机端口 8081 改为 8082，重新执行 <code>kubectl apply</code>， 将提示如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">The Pod &quot;nginx&quot; is invalid: spec: Forbidden: pod updates may not change fields other than `spec.containers[*].image`, `spec.initContainers[*].image`, `spec.activeDeadlineSeconds`, `spec.tolerations` (only additions to existing tolerations) or `spec.terminationGracePeriodSeconds` (allow it to be set to 1 if it was previously negative)<br></code></pre></td></tr></table></figure></blockquote><p><strong>删除 pod</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete [podName]</span><br></code></pre></td></tr></table></figure><h1 id="pod-提供对外访问"><a href="#pod-提供对外访问" class="headerlink" title="pod 提供对外访问"></a>pod 提供对外访问</h1><p>对外访问 pod 的最普遍方式是使用 service，但 service 是一个相当重要的内容，所以会另起一篇笔记，在本篇笔记中只会记录除 service 外的方式，这些方式并不常用，仅作为记录。</p><h2 id="hostNetwork"><a href="#hostNetwork" class="headerlink" title="hostNetwork"></a>hostNetwork</h2><p>在 yaml 中添加 hostNetwork: true 字段：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure><p>执行 yaml：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f hostnetwork.yaml</span><br></code></pre></td></tr></table></figure><p>查看 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po -o wide</span><br>NAME      READY   STATUS    RESTARTS   AGE   IP             NODE       NOMINATED NODE   READINESS GATES<br>nginx     1/1     Running   0          18m   192.168.49.2   minikube   &lt;none&gt;           &lt;none&gt;<br></code></pre></td></tr></table></figure><p>此时通过 pod IP 就可以进行访问了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 192.168.49.2</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br>&lt;style&gt;<br>html &#123; color-scheme: light dark; &#125;<br>body &#123; width: 35em; margin: 0 auto;<br>font-family: Tahoma, Verdana, Arial, sans-serif; &#125;<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br></code></pre></td></tr></table></figure><h2 id="HostPort"><a href="#HostPort" class="headerlink" title="HostPort"></a>HostPort</h2><p>参考 <strong>pod 实战</strong> 部分</p><h2 id="port-forward"><a href="#port-forward" class="headerlink" title="port-forward"></a>port-forward</h2><p>使用 kubectl 自带的端口转发命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl port-forward [podName] [对外暴露的端口]:[pod内部端口]</span><br></code></pre></td></tr></table></figure><p>比如在我的电脑上实践（访问这个 pod 会输出一句谚语，参考书上的 p168）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl port-forward fortune 8080:80</span><br>Forwarding from 127.0.0.1:8080 -&gt; 80<br>Forwarding from [::1]:8080 -&gt; 80<br></code></pre></td></tr></table></figure><p>此时上面的 shell 会阻塞，新开一个 shell，执行 curl：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl http://localhost:8080</span><br>Q:How many psychiatrists does it take to change a light bulb?<br>A:Only one, but it takes a long time, and the light bulb has<br>to really want to change.<br></code></pre></td></tr></table></figure><blockquote><p>🤔️ 疑问：</p><p>1）curl 必须要添加 http 协议才行，如果只是 curl localhost 8080 会报错：curl: (7) Failed to connect to localhost port 80: Connection refused，这是为什么？</p><p>😅 格式错误，应该是 curl localhost:8080，curl <a href="http://localhost:8080/">http://localhost:8080</a> 和 curl localhost:8080 实际是一样的</p><p>2）此外，我在宿主机用 curl 虚拟机IP:8080 也无法成功访问，只有在虚拟机内部才行</p></blockquote><h1 id="pod-实战"><a href="#pod-实战" class="headerlink" title="pod 实战"></a>pod 实战</h1><p>通过实战创建一个 nginx pod</p><p>nginx yaml 如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">hostPort:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>创建 pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f nginx_pod.yaml</span><br></code></pre></td></tr></table></figure><p>等待一会，直到创建完成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods</span><br>NAME    READY   STATUS              RESTARTS   AGE<br>nginx   0/1     ContainerCreating   0          2s<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">NAME    READY   STATUS    RESTARTS   AGE<br>nginx   1/1     Running   0          2m17s<br></code></pre></td></tr></table></figure><p>在 yaml 中设置了 <code>hostPort</code> 为 8080，代表对外暴露 8080 端口，映射到容器内部的 80 端口，此时便可以通过 IP:8080 进行访问了，如果不设置 <code>hostPort</code>，那么需要使用 <code> kubectl exec -it nginx sh</code>  进入容器内部，执行 <code> curl localhost</code>，可以看到 nginx 欢迎页的 HTML 代码。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1651804699715.jpg"></p><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>标签用来为 pod 进行分类。</p><p>有几种方式可以为 pod 创建标签：</p><ol><li>在 yaml 中的 metadata labels 中指定，标签是 key:value 的方式，key 需要全局唯一，比如在上面 nginx yaml 中，添加了一个 app: nginx 标签。</li><li>使用 <code>kubectl label po nginx key=value</code> 添加标签</li></ol><p>pod 的 key 必须唯一，否则报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl label po nginx key=value1</span><br>error: &#x27;key&#x27; already has a value (value), and --overwrite is false<br></code></pre></td></tr></table></figure><p>查看 pod 的所有标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po --show-labels</span><br>NAME    READY   STATUS    RESTARTS   AGE    LABELS<br>nginx   1/1     Running   0          118m   app=nginx,key=value<br></code></pre></td></tr></table></figure><p>查看 pod 的某个标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po -L app,key</span><br>NAME    READY   STATUS    RESTARTS   AGE    APP     KEY<br>nginx   1/1     Running   0          120m   nginx   value<br></code></pre></td></tr></table></figure><p>修改 pod 的标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl label po nginx key=value1 --overwrite</span><br>pod/nginx labeled<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po --show-labels</span><br>NAME    READY   STATUS    RESTARTS   AGE    LABELS<br>nginx   1/1     Running   0          122m   app=nginx,key=value1<br></code></pre></td></tr></table></figure><p>指定 <code>--overwrite</code> 进行修改</p><h1 id="将-Pod-调度到特定节点"><a href="#将-Pod-调度到特定节点" class="headerlink" title="将 Pod 调度到特定节点"></a>将 Pod 调度到特定节点</h1><p>可以为某个 Node 设置一个标签，然后在 Pod yaml 中指定 spec.nodeSelector ，保证 Pod 被调度到符合其需求的节点。</p><p>通过以下命令为 Node 设置标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl label node [nodeName] [key=value]</span><br></code></pre></td></tr></table></figure><p>然后在 Pod yaml 中的 <code>spec.nodeSelector</code> 中指定被调度节点，比如下面的例子中，指定了该 Pod 将调度到包含 “gpu: true” 标签的 Node：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">vl</span> <br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span> <br><span class="hljs-attr">metadata:</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">kubia-gpu</span> <br><span class="hljs-attr">spec:</span><br><span class="hljs-attr">nodeSelector:</span><br><span class="hljs-attr">gpu:</span> <span class="hljs-string">&quot;true&quot;</span> <br><span class="hljs-attr">containers:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">luksa/kubia</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br></code></pre></td></tr></table></figure><h1 id="Pod-如何调度"><a href="#Pod-如何调度" class="headerlink" title="Pod 如何调度"></a>Pod 如何调度</h1><p>之前实验使用的都是单节点方式，所以没在意 pod 是如何调度的，后来用 kind 搭建了一个 3 节点的 k8s 集群后才意识到这个问题，所以做了一个实验：</p><p>当前集群的 node：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get node -o wide | awk <span class="hljs-string">&#x27;&#123;printf &quot;%-30s%-15s\n&quot;, $1, $6&#125;&#x27;</span></span><br>NAME                          INTERNAL-IP<br>kind-control-plane            172.18.0.2<br>kind-worker                   172.18.0.4<br>kind-worker2                  172.18.0.3<br></code></pre></td></tr></table></figure><p>创建 3 个 nginx pod（使用 deployment）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure><p>查看 po：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po -o wide | awk <span class="hljs-string">&#x27;&#123;printf &quot;%-30s%-15s\n&quot;, $1,$9&#125;&#x27;</span></span><br>NAME                          NODE<br>nginx-66b9cc684d-8l7hg        kind-worker2<br>nginx-66b9cc684d-flj48        kind-worker<br>nginx-66b9cc684d-hxzc9        kind-worker<br></code></pre></td></tr></table></figure><p>发现这三个 pod 都被调度到 worker 节点，没有被调度到 <code>kind-control-plane</code> 节点，网上查阅资料，得知 pod 的调度是由 kube-scheduler 来执行的，有一系列规则来完成这件事，比如官方文档里所描述的：</p><blockquote><p>kube-scheduler 给一个 pod 做调度选择包含两个步骤：</p><ol><li>过滤</li><li>打分</li></ol><p>过滤阶段会将所有满足 Pod 调度需求的 Node 选出来。 例如，PodFitsResources 过滤函数会检查候选 Node 的可用资源能否满足 Pod 的资源请求。 在过滤之后，得出一个 Node 列表，里面包含了所有可调度节点；通常情况下， 这个 Node 列表包含不止一个 Node。如果这个列表是空的，代表这个 Pod 不可调度。</p><p>在打分阶段，调度器会为 Pod 从所有可调度节点中选取一个最合适的 Node。 根据当前启用的打分规则，调度器会给每一个可调度节点进行打分。</p><p>最后，kube-scheduler 会将 Pod 调度到得分最高的 Node 上。 如果存在多个得分最高的 Node，kube-scheduler 会从中随机选取一个。</p></blockquote><p>鉴于目前实力有限，无法摸清具体的流程，待我日后研究再详细展开（）</p><h1 id="infra-容器"><a href="#infra-容器" class="headerlink" title="infra 容器"></a>infra 容器</h1><p>TODO</p><h1 id="给-Pod-内的容器注入环境变量"><a href="#给-Pod-内的容器注入环境变量" class="headerlink" title="给 Pod 内的容器注入环境变量"></a>给 Pod 内的容器注入环境变量</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">MY_ENV_VAR:</span> <span class="hljs-string">my-config-value</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>      <span class="hljs-attr">env:</span><br>      <span class="hljs-comment"># 直接以 key/value 的形式引入</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">MY_ENV_VAR1</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">my-value</span><br>        <span class="hljs-comment"># 从 configmap 中引入，并且引入的是 configmap 中的某个 key</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">MY_ENV_VAR2</span><br>          <span class="hljs-attr">valueFrom:</span><br>            <span class="hljs-attr">configMapKeyRef:</span><br>              <span class="hljs-attr">name:</span> <span class="hljs-string">test</span><br>              <span class="hljs-attr">key:</span> <span class="hljs-string">MY_ENV_VAR</span><br><br></code></pre></td></tr></table></figure><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><h2 id="如果一个-pod-中存在多个容器，而其中有一个容器挂掉了，此时会如何处理？"><a href="#如果一个-pod-中存在多个容器，而其中有一个容器挂掉了，此时会如何处理？" class="headerlink" title="如果一个 pod 中存在多个容器，而其中有一个容器挂掉了，此时会如何处理？"></a>如果一个 pod 中存在多个容器，而其中有一个容器挂掉了，此时会如何处理？</h2><p>可以使用存活探针，为每个容器设置不同的探测方案，比如可以使用 tcp 探针，让 pod 中的每个容器暴露一个端口，然后存活探针分别尝试与这些端口建立连接，如果其中有一个端口建立连接失败，则说明容器出现了问题，然后 k8s 就会删除这个有问题的 pod，并新建一个相同的 pod 替代。</p><blockquote><p>From ChatGPT</p><p>🤖</p><p>当一个 Pod 中存在多个容器，其中一个容器挂掉时，Kubernetes 会根据定义的容器重启策略和容器的健康检查来处理。以下是可能的情况和处理方式：</p><ol><li><strong>容器重启策略</strong>： 在定义 Pod 时，可以指定容器的重启策略。有三种重启策略可选：<ul><li><code>Always</code>：始终重启容器，无论它是如何终止的。</li><li><code>OnFailure</code>：只在容器非正常终止时重启，例如退出状态码不为0。</li><li><code>Never</code>：不重启容器，即使它终止。</li></ul></li><li><strong>容器的健康检查</strong>： 容器重启策略与容器的健康检查相关。健康检查可确保容器在正常工作，以便及早检测到容器问题。Kubernetes 支持三种健康检查：<ul><li><code>livenessProbe</code>：检查容器是否在运行，如果不健康，则会触发重启。</li><li><code>readinessProbe</code>：检查容器是否已准备好处理流量，如果不健康，则容器将被从服务端点中移除，但不会重启容器。</li><li><code>startupProbe</code>：检查容器是否已启动，适用于检测长时间启动的容器。</li></ul></li><li><strong>处理方式</strong>： 当一个容器挂掉时，具体的处理方式取决于容器的重启策略和健康检查设置：<ul><li>如果容器的重启策略是 <code>Always</code>，Kubernetes 将会自动重启容器。</li><li>如果容器的重启策略是 <code>OnFailure</code>，且容器非正常终止，Kubernetes 会自动重启容器。</li><li>如果容器的重启策略是 <code>Never</code>，或者容器正常终止（退出状态码为0），则不会触发重启。</li></ul></li></ol><p>总的来说，Kubernetes 会根据容器的重启策略和健康检查设置来处理容器挂掉的情况。重启策略定义了是否重启容器，而健康检查可以帮助及早发现容器问题，从而实现更好的容器管理和容错能力。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode 选中文本时滑动速度过快</title>
    <link href="/2022/04/10/vscode-xuan-zhong-wen-ben-shi-hua-dong-su-du-guo-kuai/"/>
    <url>/2022/04/10/vscode-xuan-zhong-wen-ben-shi-hua-dong-su-du-guo-kuai/</url>
    
    <content type="html"><![CDATA[<p>这是一个困扰我已久的问题，当选中一段代码并继续向下滑动时，滑动速度会非常快，导致无法准确选中我想要的部分，比如我的屏幕能显示200行代码，我想选中1-250行的代码，这就需要我向下滑动来选中剩余的50行，但是因为速度太快，导致我轻轻一滑就会瞬间跑到第800行代码的位置，于是我又要向上滑动，结果又瞬间到了第150行，非常令人蛋疼。</p><p>在网上用中文搜索不到相关的问题，没办法只能用我蹩脚的英文搜索 vscode scroll too fast selecting，没想到还找出来不少，看来有时候还是得用英文搜索才能解决问题。<a href="https://github.com/microsoft/vscode/issues/40890">https://github.com/microsoft/vscode/issues/40890</a> 这里描述了同样的问题，但是里面的解决方案都对我无效，像 <code>&quot;editor.smoothScrolling&quot;: true</code>，<code>editor.mouseWheelScrollSensitivity:0.1</code> 这些都不行，似乎 vscode 本身也没有提供一个专门针对选中后滑动速度的选项。</p><p>最后在 <a href="https://stackoverflow.com/questions/44374762/visual-studio-code-scroll-speed-too-fast-for-selecting-with-mouse">https://stackoverflow.com/questions/44374762/visual-studio-code-scroll-speed-too-fast-for-selecting-with-mouse</a> 这里找到了一个将将就的解决方案:</p><blockquote><p>While not a solution to the scroll speed issue, there is a rather trivial<br>workaround. Select part of the region you want selected, scroll down to the point<br>the region to select ends and Shift-Click. Voila, whole region selected.</p></blockquote><p>意思就是先选中一小部分文字，然后松开鼠标&#x2F;触控板，然后向下滑动到要选择内容的末尾，再 shift + 左键点击此处，即可完成区域选择。</p>]]></content>
    
    
    
    <tags>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k3s 踩坑记录</title>
    <link href="/2022/04/08/k3s/"/>
    <url>/2022/04/08/k3s/</url>
    
    <content type="html"><![CDATA[<h1 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh -s - --write-kubeconfig-mode 666<br></code></pre></td></tr></table></figure><p>–write-kubeconfig-mode设置读写权限，否则每次 kubectl 都要 sudo，同时使用国内镜像进行下载</p><h1 id="设置镜像"><a href="#设置镜像" class="headerlink" title="设置镜像"></a>设置镜像</h1><p>参考 <a href="https://blog.csdn.net/xs20691718/article/details/106515605">https://blog.csdn.net/xs20691718/article/details/106515605</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1</span><br>cp /var/lib/rancher/k3s/agent/etc/containerd/config.toml /var/lib/rancher/k3s/agent/etc/containerd/config.toml.tmpl # 拷贝一份配置文件<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2</span><br>sudo vim /var/lib/rancher/k3s/agent/etc/containerd/config.toml.tmpl <br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 config.toml.tmpl 文件中添加</span><br>[plugins.cri.registry.mirrors]<br>  [plugins.cri.registry.mirrors.&quot;docker.io&quot;]<br>    endpoint = [&quot;https://docker.mirrors.ustc.edu.cn&quot;]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3 重启服务</span><br>systemctl restart k3s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4 查看修改是否成功</span><br>sudo crictl info | grep mirror<br><br><br></code></pre></td></tr></table></figure><h1 id="创建-pod-一直处于-pending-状态"><a href="#创建-pod-一直处于-pending-状态" class="headerlink" title="创建 pod 一直处于 pending 状态"></a>创建 pod 一直处于 pending 状态</h1><p>一开始以为是污点问题，因为 pod 描述中有 warning 警告：0&#x2F;1 nodes are available: 1 node(s) had taint {node.kubernetes.io&#x2F;not-ready: }, that the pod didn’t tolerate.，使用 <code> kubectl describe node [nodename]</code> 查看，发现节点的污点为 <code>:NoSchedule</code>，而 pod 的 Tolerations 是 <code>:NoExecute</code>，先尝试移除节点的污点，使用 <code>kubectl taint nodes node1 key1:NoSchedule-</code> 进行移除，但是移除后执行 <code>kubectl get no -o yaml | grep taint -A 5</code> 发现依然显示有污点（正常应该输出为空），难道是移除污点失效了吗？网上也查不到任何相关资料，于是又尝试更改 pod 的容忍度，修改 yaml 文件，添加如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">tolerations:<br>      - key: &quot;node.kubernetes.io/disk-pressure&quot;<br>        operator: &quot;Exists&quot;<br>        effect: &quot;NoSchedule&quot;<br></code></pre></td></tr></table></figure><p>之后再重新执行 <code>kubectl apply -f </code>  重新创建 pod，发现还是无效。最后重启了一下 k3s ，然后莫名其妙的发现 pod 创建成功了，此时再查看 node 描述信息，发现 taint 为 none 了。</p><p>一开始的 pod 描述信息中还有一条错误信息： kubernetes The node was low on resource: ephemeral-storage.” Evicted ，网上找了半天资料，也没有看到很好的解决方法（其实是我看不懂😅）</p><p>​&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 更新 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>破案了，注意 node 的污点 key 是 <code>node.kubernetes.io/disk-pressure</code>，查了一下这表示当前节点的磁盘容量不足，该污点会阻止 pod 被调度到该节点，且无法去除，这就是 pod 一直 pending 的原因，因为我使用的是 multipass 创建的虚拟机，默认只分配的 5G 的磁盘，所以很容易就满了，导致 k3s 出现这一污点，只要重新创建一个虚拟机并分配大一些的磁盘空间即可（也可以调整现有虚拟机的磁盘空间，但是有些麻烦，尝试无果后放弃了）</p><p>老实说第一次用这个 k3s，<del>感觉比 minikube 要难用很多，发生了不少莫名其妙的问题，不过</del>内存占用确实要低得多，暂且先摸索一下吧，刚好还学到了污点这个新知识。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k3s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 索引</title>
    <link href="/2022/03/26/mysql-suo-yin/"/>
    <url>/2022/03/26/mysql-suo-yin/</url>
    
    <content type="html"><![CDATA[<h1 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h1><p>索引类型分为主键索引和非主键索引。</p><p>主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。</p><p>非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1648609254561.webp"></p><p>比如在上图中，ID 就是聚簇索引，K 是非聚簇索引</p><p>根据上面的索引结构说明，我们来讨论一个问题：<strong>基于主键索引和普通索引的查询有什么区别？</strong></p><ul><li>如果语句是 select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索ID这棵B+树；</li><li>如果语句是 select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><h1 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h1><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1648609254561.webp"></p><p>在上图中，如果执行 <code>select * from T where k between 3 and 5</code>，需要执行几次树的搜索操作，会扫描多少行？</p><ol><li><p>在 k 索引树上找到 k&#x3D;3 的记录，取得 ID &#x3D; 300；</p></li><li><p>再到 ID 索引树查到 ID&#x3D;300 对应的 R3；（因为查询的是 *，所以需要去主键索引处拿到整行的值）</p></li><li><p>在 k 索引树取下一个值 k&#x3D;5，取得 ID&#x3D;500；</p></li><li><p>再回到 ID 索引树查到 ID&#x3D;500 对应的 R4；</p></li><li><p>在 k 索引树取下一个值 k&#x3D;6，不满足条件，循环结束。</p></li></ol><p>在这个过程中，回到主键索引树搜索的过程，我们称为回表。可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。</p><h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。<br>如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。</p><p>比如上面的例子中，如果执行的语句是 <code>select ID from T where k between 3 and 5</code>，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql Buffer Pool 的一些疑问记录</title>
    <link href="/2022/03/16/mysql-buffer-pool-de-yi-xie-yi-wen-ji-lu/"/>
    <url>/2022/03/16/mysql-buffer-pool-de-yi-xie-yi-wen-ji-lu/</url>
    
    <content type="html"><![CDATA[<p>这是我在看 Mysql <code>Buffer Pool</code> 时的一个疑问，先说说 Buffer Pool，为了提高性能，Mysql 为读写操作添加了一层缓存，这样就可以直接从内存中操作，速度相比操作硬盘要快很多，只要之后再将内存中的数据定期写入到磁盘中即可保证数据一致。但是这样就产生了一个问题：如果在内存写入到磁盘之前，Mysql 进程挂掉了，这样岂不是就丢失数据了？</p><p>通过网上查阅资料，了解了 Mysql 对于这种情况的解决方法：<code>redo log</code>，对内存中的数据进行的操作，会同步把对应的日志写入到 redo log 中，如果发生了上面的情况，可以通过查看 redo log 进行恢复，但是此时我又产生了几个疑问：</p><ol><li>这样不是还会发生上面的问题吗？如果内存中操作了，然后数据库进程挂掉了，没来得及写入到 redo log，那不是一样也发生丢失了吗？</li><li>引入 buffer pool 就是为了防止直接操作硬盘，现在又要同步写入到 redo log 中，等于还是要操作硬盘，那还有什么意义呢？</li></ol><p>查找的一些说法（不确定正不正确）：</p><ol><li><p>通过 WAL(Write Ahead Log，预写日志) 机制来保证不会发生上面的情况，即：写入日志一定发生在更新内存之前（关于 WAL 暂时也没有完全理解，所以这里标记为<strong>存疑</strong>）</p><p>看 MySQL 45 讲里面有提到：</p><blockquote><p>具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。</p></blockquote><p>这里的更新内存不知道是不是 Buffer Pool，如果是的话就可以解决疑问 1 了，因为 Mysql 是先写 redo log 再写内存的，那就不存在写完内存后挂掉没写到 redo log 的情况了。</p></li><li><p>写入 redo log 的方式使用了追加操作， 所以磁盘操作是 <strong>顺序写</strong>，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是 <strong>随机写</strong>（具体可以参见硬盘的顺序读写和随机读写），磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go slice append 的坑 [存疑]</title>
    <link href="/2022/03/10/go-slice-append-de-keng-cun-yi/"/>
    <url>/2022/03/10/go-slice-append-de-keng-cun-yi/</url>
    
    <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>使用过 Go 的小伙伴应该都遇到过这样一个坑：当使用 slice 作为参数传递时，如果调用方函数内部发生了 append 操作，那么对应的改变不会在实参处体现出来，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>slice = fn(slice)<br>fmt.Println(<span class="hljs-string">&quot;[main] slice: &quot;</span>, slice)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>)</span></span> (s []<span class="hljs-type">int</span>) &#123;<br>  s = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">1</span>)<br>    fmt.Println(<span class="hljs-string">&quot;[func] slice: &quot;</span>, s)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[func]</span> slice:  <span class="hljs-comment">[1]</span><br><span class="hljs-comment">[main]</span> slice:  <span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p>看过一些博客，里面阐述的原因是：slice 的底层数据结构是一个名为 <code>SliceHeader</code> 的结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SliceHeader <span class="hljs-keyword">struct</span> &#123;<br>Data <span class="hljs-type">uintptr</span><br>Len  <span class="hljs-type">int</span><br>Cap  <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中的 Data 指向底层数组，将 slice 作为函数参数传递，实际上传递的就是这样一个结构体，而 append 可能会导致扩容，也就是重新分配一个更大的数组，将之前的数据拷贝过去，并且重新将 Data 指向这个新数组，因为传入的参数不是指针类型而是值类型，所以 Data 的改变不能体现在实参中。</p><p>听起来有些道理，那么就动手实践一下，看看实际情况如何：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;reflect&quot;</span><br><span class="hljs-string">&quot;unsafe&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// 通过反射来获取 slice 对应的底层 SliceHeader 结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getSliceHeader</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>)</span></span> &#123;<br>struc := (*reflect.SliceHeader)(unsafe.Pointer(&amp;slice))<br>fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, struc)<br><br>dataPtr := unsafe.Pointer(struc.Data)<br>fmt.Println(dataPtr)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sliceAppend</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>)</span></span> &#123;<br>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>fmt.Println(<span class="hljs-string">&quot;[func] sliceHeader info: &quot;</span>)<br>getSliceHeader(slice)<br>fmt.Println(<span class="hljs-string">&quot;========================&quot;</span>)<br><br>struc := (*reflect.SliceHeader)(unsafe.Pointer(&amp;slice))<br>dataPtr := unsafe.Pointer(struc.Data)<br>data := *(*[<span class="hljs-number">4</span>]<span class="hljs-type">int</span>)(dataPtr)<br>fmt.Println(<span class="hljs-string">&quot;[func] after append, sliceHeader.data: &quot;</span>, data)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>n := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>fmt.Println(<span class="hljs-string">&quot;[main] sliceHeader info: &quot;</span>)<br>getSliceHeader(n)<br>fmt.Println(<span class="hljs-string">&quot;========================&quot;</span>)<br><br>sliceAppend(n)<br>fmt.Println(<span class="hljs-string">&quot;[main] after call, slice data: &quot;</span>, n)<br>struc := (*reflect.SliceHeader)(unsafe.Pointer(&amp;n))<br>dataPtr := unsafe.Pointer(struc.Data)<br>data := *(*[<span class="hljs-number">4</span>]<span class="hljs-type">int</span>)(dataPtr)<br>fmt.Println(<span class="hljs-string">&quot;[main] sliceHeader.data&quot;</span>, data)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码看起来有些长，实际只是通过反射去拿到 slice 对应的 SliceHeader，并通过 unsafe 来获取 data 对应的底层数组，无需过多关注。</p><p>输出结果：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">[main] sliceHeader info: <br>&amp;&#123;Data:4336299344 Len:0 Cap:0&#125;<br><span class="hljs-section">0x10276ad50</span><br><span class="hljs-section">========================</span><br>[func] sliceHeader info: <br>&amp;&#123;Data:1374390272064 Len:4 Cap:4&#125;<br><span class="hljs-section">0x140000b4040</span><br><span class="hljs-section">========================</span><br><span class="hljs-meta">[func] after append, sliceHeader.data:  [1 2 3 4]</span><br><span class="hljs-meta">[main] after call, slice data:  []</span><br><span class="hljs-meta">[main] sliceHeader.data [0 0 0 0]</span><br></code></pre></td></tr></table></figure><p>main 里的 slice 是一个 len 和 cap 都为 0 的 slice，而函数内部需要 append 4 个元素，这势必会发生扩容，从上面的输出信息中也可以看出，data 指向的地址确实发生了改变，main 中 data 指向 0x10276ad50，而 func 中 data 指向了 0x140000b4040。</p><h1 id="新的疑问"><a href="#新的疑问" class="headerlink" title="新的疑问"></a>新的疑问</h1><p>在了解原因后，我又突发奇想，既然是因为扩容才导致的丢失，那我不让他扩容不就好了吗？在 make 时直接指定 cap 为 20，而函数内只 append 4 个元素，这样就不会扩容了，此时结果会如何？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;reflect&quot;</span><br><span class="hljs-string">&quot;unsafe&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getSliceHeader</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>)</span></span> &#123;<br>struc := (*reflect.SliceHeader)(unsafe.Pointer(&amp;slice))<br>fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, struc)<br><br>dataPtr := unsafe.Pointer(struc.Data)<br>fmt.Println(dataPtr)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sliceAppend</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>)</span></span> &#123;<br>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>fmt.Println(<span class="hljs-string">&quot;[func] sliceHeader info: &quot;</span>)<br>getSliceHeader(slice)<br>fmt.Println(<span class="hljs-string">&quot;========================&quot;</span>)<br><br>struc := (*reflect.SliceHeader)(unsafe.Pointer(&amp;slice))<br>dataPtr := unsafe.Pointer(struc.Data)<br>data := *(*[<span class="hljs-number">4</span>]<span class="hljs-type">int</span>)(dataPtr)<br>fmt.Println(<span class="hljs-string">&quot;[func] after append, sliceHeader.data: &quot;</span>, data)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>n := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>)<br>fmt.Println(<span class="hljs-string">&quot;[main] sliceHeader info: &quot;</span>)<br>getSliceHeader(n)<br>fmt.Println(<span class="hljs-string">&quot;========================&quot;</span>)<br><br>sliceAppend(n)<br>fmt.Println(<span class="hljs-string">&quot;[main] after call, slice data: &quot;</span>, n)<br>struc := (*reflect.SliceHeader)(unsafe.Pointer(&amp;n))<br>dataPtr := unsafe.Pointer(struc.Data)<br>data := *(*[<span class="hljs-number">4</span>]<span class="hljs-type">int</span>)(dataPtr)<br>fmt.Println(<span class="hljs-string">&quot;[main] sliceHeader.data&quot;</span>, data)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[main] sliceHeader info: <br>&amp;&#123;Data:1374390001664 Len:0 Cap:20&#125;<br>0x14000072000<br>========================<br>[func] sliceHeader info: <br>&amp;&#123;Data:1374390001664 Len:4 Cap:20&#125; # 注意这里的 Len<br>0x14000072000<br>========================<br>[func] after append, sliceHeader.data:  [1 2 3 4]<br>[main] after call, slice data:  []<br>[main] sliceHeader.data [1 2 3 4]<br></code></pre></td></tr></table></figure><p>可以看到，SliceHeader.Data 的指向确实没有发生改变，都是 0x14000072000，并且通过最后一句输出 <code>[main] sliceHeader.data [1 2 3 4]</code> 可以得知，底层的数组确实已经发生了改变，但是最终 main 的 slice 输出还是为空，这是为什么呢？</p><p>一个猜测：</p><p>我们在 main 函数调用 sliceAppend 之后在加入一段话：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">sliceAppend(n)<br>fmt.Println(<span class="hljs-string">&quot;[main] after call, slice data: &quot;</span>, n)<br>struc := (*reflect.SliceHeader)(unsafe.Pointer(&amp;n))<br>dataPtr := unsafe.Pointer(struc.Data)<br>data := *(*[<span class="hljs-number">4</span>]<span class="hljs-type">int</span>)(dataPtr)<br>fmt.Println(<span class="hljs-string">&quot;after call, sliceHeader info: &quot;</span>) <span class="hljs-comment">// 新增</span><br>getSliceHeader(n)<span class="hljs-comment">// 新增</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">after call, sliceHeader info:<br>&amp;&#123;Data:1374390730752 Len:0 Cap:20&#125;<br>data address: 0x14000124000<br></code></pre></td></tr></table></figure><p>发现在 append 之后，Len 依然为 0，难道这就是问题所在？fmt.Println 可能是检测到 slice 的 Len 为 0，所以即便底层数组发生了改变，但还是打印出了空切片？（具体还是得看 Println 的源码才能真正知道原因）</p><p>因为传的不是指针类型，所以 Len 的变化不能反映到实参，在之前的输出可以看到，形参的 Len 已经发生了改变：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[func] sliceHeader info: <br>&amp;&#123;Data:1374390001664 Len:4 Cap:20&#125;<br></code></pre></td></tr></table></figure><p>综上所述，以后如果要把 slice 作为参数传递，且调用方要执行 append 操作，直接统一传递指针就好了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统面试题</title>
    <link href="/2022/02/15/cao-zuo-xi-tong-mian-shi-ti/"/>
    <url>/2022/02/15/cao-zuo-xi-tong-mian-shi-ti/</url>
    
    <content type="html"><![CDATA[<h1 id="页的概念"><a href="#页的概念" class="headerlink" title="页的概念"></a>页的概念</h1><h1 id="线程怎么调度的"><a href="#线程怎么调度的" class="headerlink" title="线程怎么调度的"></a>线程怎么调度的</h1><h1 id="进程间通信有哪几种方式，哪种方式最快？"><a href="#进程间通信有哪几种方式，哪种方式最快？" class="headerlink" title="进程间通信有哪几种方式，哪种方式最快？"></a>进程间通信有哪几种方式，哪种方式最快？</h1><p>1.无名管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p><p>2.高级管道(popen)：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。</p><p>3.有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><p>4.消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><p>5.信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p>6.信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p>7.共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。<strong>共享内存是最快的 IPC 方式</strong>，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p><p>8.套接字( socket ) ： 套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVCC 与事务隔离</title>
    <link href="/2022/02/14/mvcc-yu-shi-wu-ge-chi/"/>
    <url>/2022/02/14/mvcc-yu-shi-wu-ge-chi/</url>
    
    <content type="html"><![CDATA[<blockquote><p> 申明：以下内容来自网上的博客、课程，通过自己的理解进行一下转述，可能存在一些错误和纰漏</p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>MySQL 的 <strong>可重复读</strong> 和 <strong>读已提交</strong> 是基于 <strong>MVCC</strong> 实现的，它的最大优点是读不加锁，因此读写不冲突，并发性能好，其实现主要基于以下技术及数据结构：</p><p>首先，InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。</p><p>同一行记录可能被不同的事务进行操作，这样同一行记录就可能会有多个版本，每个记录都会有以下内容：</p><p>1）隐藏列：InnoDB 中每行数据都有隐藏列，隐藏列中包含了本行数据的事务 id（就是上面提到的 row trx_id）、指向 undo log 的指针等。</p><p>2）基于 undo log 的版本链：前面说到每行数据的隐藏列中包含了指向 undo log 的指针，而每条 undo log 也会指向更早版本的 undo log，从而形成一条版本链。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1644829927173.webp"><br>比如在上图中，id 为 15 的事务将 k 更新为 10，此时该版本的 row_trx_id 为当前事务 15，undo log 指针指向之前的版本，以此类推，id 为 17 的事务将 k 更新为 11，并重复上面的操作。这样，同一个记录就有了多个版本，并且通过指针形成了一条版本链。</p><p>此外还有一个 <code>Read View</code> 的概念，可以将其理解为一个数据快照，就像相机拍照那样，定格某一时刻的风景。在 <strong>读已提交</strong> 和 <strong>可重复读</strong> 这两个隔离级别中就用到了 <code>Read View</code> 这个东西，<strong>读提交</strong> 隔离级别是在 <strong>每次读操作执行前</strong> 都会重新生成一个 Read View，而 <strong>可重复读</strong> 隔离级别是 <strong>启动事务时</strong> 生成一个 Read View，然后整个事务期间都在用这个 Read View。</p><div class="note note-success">            <p>📒 Note</p><p>读已提交和可重复读在 mvcc 的使用上有些区别，读已提交是在 <strong>每次读操作执行前</strong> 都会重新生成一个 Read View，而可重复读是 <strong>启动事务时</strong> 生成一个 Read View，然后整个事务期间都在用这个 Read View。</p>          </div><p>Read View 有四个重要的字段：</p><ul><li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的 <strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li><li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值，可以称为 <strong>低水位</strong>。</li><li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1，可以称为 <strong>高水位</strong>；</li><li>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1644832266992.webp"></p><p>当创建出一个 Read View 时，它会根据 select 条件，找到某一行（或者多行）记录，首先找到的是这行的最新版本（如果这里理解不了，请看后面的示例），看一下这个版本的 row trx_id，有以下几种可能：</p><p>如果落在 <strong>绿色部分</strong>（小于低水位），表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是 <strong>可见</strong> 的；</p><p>如果落在 <strong>红色部分</strong>（大于等于高水位），表示这个版本是由将来启动的事务生成的，是肯定是 <strong>不可见</strong> 的；</p><p>如果落在黄色部分，那就包括两种情况<br>a. 若 row trx_id <strong>在数组中</strong>，表示这个版本是由还 <strong>没提交</strong> 的事务生成的，不可见；<br>b. 若 row trx_id <strong>不在数组中</strong>，表示这个版本是 **已经提交 **了的事务生成的，可见。</p><p>如果该版本不可见，那么会通过 undolog 指针，继续查看上个版本，重复上面的流程，直到找到一个可见的版本。</p><h1 id="mvcc-示例"><a href="#mvcc-示例" class="headerlink" title="mvcc 示例"></a>mvcc 示例</h1><p>举个例子：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1644832501001.webp"></p><p>这个例子开启了三个事务 A，B，C，假设这三个事务开始前，系统里面还有一个活跃事务， ID 是 99，然后事务 A、B、C 的事务 ID 分别是 100、101、102（事务 ID 按照事务开始时间递增，A 最先执行，所以事务 ID 在三者中最小），且当前系统里只有这四个事务，三个事务开始前，k (1,1）这一行数据的 row trx_id 是 90。</p><p>这样，事务 A 的视图数组就是 [99,100], 事务 B 的视图数组是 [99,100,101], 事务 C 的视图数组是 [99,100,101,102]。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1644832593647.webp"></p><p>事务 C 最先将 k 更新为 (1, 2)，此时便产生了一个新的版本，该版本的 row_trx_id 为事务 C 的 id，也就是 102，之后 C 便提交了（事务 C 没有显式地使用 begin&#x2F;commit，表示这个 update 语句本身就是一个事务，语句执行完成的时候会自动提交）。</p><p>之后，B 进行了更新，此时又产生了一个新的版本，row_trx_id 为 101，但此时 B 还没有 commit。</p><p>之后，A 尝试获取 k 的值，它将从当前版本开始读（也就是这一行的最新值，即 B 更新后的版本），此时 A 的视图数组为 [99, 100]，低水位是数组中的最小值 99，高水位是给下一个事务分配的 ID，也就是 101，查找流程如下：</p><ol><li>找到 (1,3) 的时候，判断出 row trx_id&#x3D;101，等于高水位<del>大（疑问：如果高水位是数组最大+1，也就是 101，那此时 row trx_id 是等于高水位而不是大于啊？）</del>，处于红色区域，不可见；</li><li>接着，找到上一个历史版本，一看 row trx_id&#x3D;102，比高水位大，处于红色区域，不可见；</li><li>再往前找，终于找到了（1,1)，它的 row trx_id&#x3D;90，比低水位小，处于绿色区域，可见。</li></ol><p>这样执行下来，虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。</p><h1 id="再次理解视图数组的作用"><a href="#再次理解视图数组的作用" class="headerlink" title="再次理解视图数组的作用"></a><strong>再次理解视图数组的作用</strong></h1><p>假设有事务 A，id 为 90，事务 B，id 为 91，在 A，B 之前还有一个活跃事务，id 为 80，k 这一行的当前版本事务 id 为 30</p><table><thead><tr><th>事务 A [80, 90]</th><th>事务 B [80, 90, 91]</th></tr></thead><tbody><tr><td>begin</td><td></td></tr><tr><td>set k &#x3D; k+1</td><td>begin</td></tr><tr><td></td><td>get k</td></tr></tbody></table><p>前面说到，视图数组保存的是该事务一启动时，当前活跃的事务，事务 A 的 set 操作会产生一个新版本，该版本的 row_trx_id 为 90，当 B 要查询 k 时，先查询当前版本，也就是 A set 后的版本，发现 row_trx_id 为 90，此时事务 B 的低水位是 80（视图数组里的最小值），高水位是 92（91+1，此处存疑），而 row_trx_id 在低水位和高水位之间，那么就进一步查看 B 的视图数组中是否有 90，如果有则说明该事务还未 commit，不能被查看，此时 B 的数组里有 90，所以该版本不能查看，继续通过 undo log指针找到之前的版本，也就是 row_trx_id 为 30 的版本，此时 30 低于低水位，可以查看。这样一套流程下来，就避免了 <strong>读未提交</strong> 的发生。</p><h1 id="可重复读-和-读已提交-在-MVCC-下实现的区别"><a href="#可重复读-和-读已提交-在-MVCC-下实现的区别" class="headerlink" title="可重复读 和 读已提交 在 MVCC 下实现的区别"></a><strong>可重复读</strong> 和 <strong>读已提交</strong> 在 MVCC 下实现的区别</h1><p><strong>可重复读</strong> 和 <strong>读已提交</strong> 都是使用 MVCC 实现的，那么他们有什么区别？<br>RC（读已提交）与 RR（可重复读） 一样，都使用了 MVCC，其主要区别在于：</p><p>RR 是在事务开始后第一次执行 select 前创建 ReadView，直到事务提交都不会再创建。根据前面的介绍，RR 可以避免脏读、不可重复读和幻读。（这里有点疑惑，RR 到底能不能解决幻读问题？看不少博客有说能的，也有说不能的，貌似是在 sql 标准下的 RR 是不能解决幻读的，但是 Innodb 的 RR 使用了 next-key，可以防止幻读）</p><p>RC 每次执行 select 前都会重新建立一个新的 ReadView，因此如果事务 A 第一次 select 之后，事务 B 对数据进行了修改并提交，那么事务 A 第二次 select 时会重新建立新的 ReadView，因此此时事务 B 的修改对事务 A 是可见的。因此 RC 隔离级别可以避免脏读，但是无法避免不可重复读和幻读。</p><h1 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a><strong>更新逻辑</strong></h1><p>对于更新语句，使用的是 <strong>当前读</strong>（读取该行的最新值），而不是上面的 <strong>快照读</strong>（ReadView），此外如果 select 语句如果加锁（for update）的话也会是当前读。顾名思义，当前读就是获取该值的最新值，比如在下图中，事务 B 执行 update 操作时，读出来的 k 为 2（k 的初值为 1），也就是事务 C 更新后的值，然后它再将其 + 1 变为 3，这样就保证了本次更新的正确性。<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1644846234451.webp"></p><p>如果不使用当前读，那会就会发生更新覆盖的情况。</p><p>此外，当前读意味着当前线程会进行加锁操作，看下面的示例：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1644846401589.webp"><br>对于这种情况，事务 C 执行了 update 操作，那么它会持有锁，并且该锁直到该事务执行 commit 后才会释放，而在事务 C commit 之前，B 尝试去更新同一行，但是因为拿不到锁，所以 B 就会阻塞，直到 C commit。</p><p>事务 A 执行的 select 操作不会被阻塞，并且查询出的 k 的值是初值（事务 C 还没提交，所以看不到它更新后的新值，而事务 B 还被阻塞着，也看不到)，原理正是我们前面提到的 MVCC。这也说明了，普通的 select 使用的是快照读，而不是当前读，因为其不会被阻塞。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>极客时间——MySQL 实战45讲</p><p><a href="https://www.cnblogs.com/kismetv/p/10331633.html">https://www.cnblogs.com/kismetv/p/10331633.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SO_REUSEADDR 和 SO_REUSEPORT 实践</title>
    <link href="/2022/02/10/so_reuseaddr-he-so_reuseport-shi-jian/"/>
    <url>/2022/02/10/so_reuseaddr-he-so_reuseport-shi-jian/</url>
    
    <content type="html"><![CDATA[<h1 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h1><p>该选项可以绑定处于 <code>TIME_WAIT</code> 状态的地址，实践：<br>server 端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestServer</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>fd, err := Socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>t.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> err := SetsockoptInt(fd, SOL_SOCKET, SO_REUSEADDR, <span class="hljs-number">1</span>); err != <span class="hljs-literal">nil</span> &#123;<br>t.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> err := Bind(fd, &amp;SockaddrInet4&#123;Port: <span class="hljs-number">9999</span>, Addr: [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br>t.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> err := Listen(fd, <span class="hljs-number">1024</span>); err != <span class="hljs-literal">nil</span> &#123;<br>t.Fatal(err)<br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>connfd, _, err := Accept(fd)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>t.Log(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>_, err = Read(connfd, buf)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>t.Log(err)<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> _, err := Write(connfd, buf); err != <span class="hljs-literal">nil</span> &#123;<br>t.Log(err)<br><span class="hljs-keyword">break</span><br>&#125;<br>Close(connfd)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>client 端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestClient</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>fd, err := Socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>t.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> err := Connect(fd, &amp;SockaddrInet4&#123;Port: <span class="hljs-number">9999</span>, Addr: [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br>t.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> _, err := Write(fd, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;123&quot;</span>)); err != <span class="hljs-literal">nil</span> &#123;<br>Close(fd)<br>t.Fatal(err)<br>&#125;<br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br><span class="hljs-keyword">if</span> _, err := Read(fd, buf); err != <span class="hljs-literal">nil</span> &#123;<br>Close(fd)<br>t.Fatal(err)<br>&#125;<br>t.Log(<span class="hljs-type">string</span>(buf))<br>time.Sleep(time.Second * <span class="hljs-number">5</span>) <span class="hljs-comment">// client 端不会先退出</span><br>Close(fd)<br>&#125;<br></code></pre></td></tr></table></figure><p>先运行 server 再运行 client，之后迅速关闭 server，此时因为 server 是主动关闭方，所以状态为 <code>TIME_WAIT</code>，此时再次运行 server，发现可以运行成功，如果去掉 <code>SetsockoptInt(fd, SOL_SOCKET, SO_REUSEADDR, 1)</code> ，那么再次运行会报错：address already in use</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP CLOSE_WAIT 和 FIN_WAIT_2</title>
    <link href="/2022/02/02/close_wait-he-fin_wait_2/"/>
    <url>/2022/02/02/close_wait-he-fin_wait_2/</url>
    
    <content type="html"><![CDATA[<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><p>最近写了一个普通的 tcp demo，发现 server 的状态处于 <code>CLOSE_WAIT</code>，而 client 的状态处于 <code>FIN_WAIT_2</code>，为了排查这个问题，特此写了这篇文章作为记录。</p><p>没有 close 的服务端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(conn net.Conn)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>_, err := conn.Read(b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>_, err = conn.Write(b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>addr := <span class="hljs-string">&quot;:8080&quot;</span><br>l, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, addr)<br>log.Printf(<span class="hljs-string">&quot;listen in %v \n&quot;</span>, addr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br>conn, err := l.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">break</span><br>&#125;<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := handler(conn); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;handler error: &quot;</span>, err)<br>&#125;<br>&#125;()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>没有 close 的客户端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8080&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">var</span> input <span class="hljs-type">string</span><br>fmt.Scan(&amp;input)<br>n, err := c.Write([]<span class="hljs-type">byte</span>(input))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;write error: &quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>log.Println(<span class="hljs-string">&quot;write byte size: &quot;</span>, n)<br><br>output := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">4096</span>)<br>n, err = c.Read(output)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;read error: &quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;read byte size %v, content: %v \n&quot;</span>, n, <span class="hljs-type">string</span>(output))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实验步骤：<br>打开两个终端分别运行 server 和 client，先运行 server，再运行 client，client 连接后立马 ctrl + c 退出，输入 <code>netstat -an | awk &#39;/^tcp/&#39; | grep 8080</code> 查看连接状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">tcp4       0      0  127.0.0.1.8080         127.0.0.1.57785        CLOSE_WAIT <br>tcp4       0      0  127.0.0.1.57785        127.0.0.1.8080         FIN_WAIT_2 <br>tcp46      0      0  *.8080                 *.*                    LISTEN  <br></code></pre></td></tr></table></figure><p>发现此时 server 的状态是 <code>CLOSE_WAIT</code>，而 client 的状态是 <code>FIN_WAIT_2</code>，这是为什么呢？分析代码发现，server 端没有对连接进行关闭处理，那么根据四次挥手的状态变化可知：</p><ol><li>第一次挥手，主动关闭方（client）发送 FIN，并进入 <code>FIN_WAIT_1</code> 状态</li><li>第二次挥手，被动关闭方（server）收到 FIN 后，回复一个 ACK，同时进入 <code>CLOSE_WAIT</code> 状态，主动（client）关闭方收到 ACK 后，进入 <code>FIN_WAIT_2</code></li><li>第三次挥手，被动关闭方（server）发送一个 FIN，并进入 <code>LAST_ACK</code>，<strong>问题来了，该 FIN 是调用 close 函数后才会发送的</strong>，而上面的代码没有调用 close，所以不会发送 <code>FIN</code></li></ol><p>一切都明了了，此时因为 server 这边没有没有调用 close 导致无法发出第三次挥手，所以整个挥手流程被卡住，server 的状态停留在 <code>CLOSE_WAIT</code>，而 client 的状态停留在 <code>FIN_WAIT_2</code></p><p>一小段时间后（大约几分钟），<code>CLOSE_WAIT</code> 和 <code>FIN_WAIT_2</code> 状态都会自动消失</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>修改 server 的代码，添加 close：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 省略 </span><br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := handler(conn); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;handler error: &quot;</span>, err)<br>                <span class="hljs-comment">// 新添加的关闭连接函数</span><br>                conn.Close()<br>&#125;<br>&#125;()<br><br><span class="hljs-comment">// 省略</span><br></code></pre></td></tr></table></figure><p>重复之前的步骤，再次输入 <code>netstat -an | awk &#39;/^tcp/&#39; | grep 8080</code> 查看连接状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tcp46      0      0  *.8080                 *.*                    LISTEN     <br>tcp4       0      0  127.0.0.1.57896        127.0.0.1.8080         TIME_WAIT  <br></code></pre></td></tr></table></figure><p>可以看到此时直接进入到了 TIME_WAIT 状态了。</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>通过此次实验，明白了 <code>CLOSE_WAIT</code> 出现的原因，平时写代码比较疏忽，对这些关闭连接的小细节不够重视，如果在上线环境，高并发下可能会导致出现大量的 CLOSE_WAIT，就因为这么一个小小的细节可能导致严重的后果，同时也深刻认识到了基础的重要性。</p><h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><h2 id="CLOSE-WAIT-的危害"><a href="#CLOSE-WAIT-的危害" class="headerlink" title="CLOSE_WAIT 的危害"></a>CLOSE_WAIT 的危害</h2><p>处于 CLOSE_WAIT 状态的 TCP 连接会一直占用端口号、socket fd 等资源，造成资源浪费，如果主机存在大量的 CLOSE_WAIT 状态的连接，甚至可能会导致无法建立新连接，从而整个服务不可用。</p><h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/tcp%20%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p><ol><li>第一次挥手，主动关闭方（client）发送 FIN，并进入 <code>FIN_WAIT_1</code> 状态</li><li>第二次挥手，被动关闭方（server）收到 FIN 后，回复一个 ACK，同时进入 <code>CLOSE_WAIT</code> 状态，主动（client）关闭方收到 ACK 后，进入 <code>FIN_WAIT_2</code></li><li>第三次挥手，被动关闭方（server）发送一个 FIN，并进入 <code>LAST_ACK</code>，主动关闭方（client）收到 FIN 后，进入 TIME_WAIT 状态</li><li>第四次挥手，主动关闭方（client）发送 ACK，被动关闭方（server）收到 ACK 后，进入 CLOSED 状态</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络面试题</title>
    <link href="/2022/01/28/ji-suan-ji-wang-luo-mian-shi-ti/"/>
    <url>/2022/01/28/ji-suan-ji-wang-luo-mian-shi-ti/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-相关"><a href="#TCP-相关" class="headerlink" title="TCP 相关"></a>TCP 相关</h1><h2 id="1-说说-TIME-WAIT-及其作用"><a href="#1-说说-TIME-WAIT-及其作用" class="headerlink" title="1. 说说 TIME_WAIT 及其作用"></a>1. 说说 TIME_WAIT 及其作用</h2><p>当一端 <strong>主动</strong> 断开连接并发送最后一次挥手后，该端状态变为 <code>TIME_WAIT</code> ，此时会等待 2 MSL （MSL 是  Maximum Segment Lifetime，译为“报文最大生存时间”，可为 30s，1min 或 2min。）<br>作用：</p><ol><li><strong>避免新旧连接混淆</strong></li></ol><p>  如果一个 tcp 连接被关闭了，紧接着马上又有一个相同四元组的 tcp 连接建立了，且此时刚好旧连接中有一个延迟的报文到达了，那么这个旧报文就会错误的被新连接接收（seq 对新连接恰好有效），进而可能会产生一些诡异或者错误的现象。TIME_WAIT 可以在一定程度确保这些延迟的旧报文在网络中消失。</p><ol start="2"><li><strong>确保双方的连接都可以正常关闭</strong></li></ol><p>  假设 A 主动关闭，那么根据四次挥手可知，最后一次挥手，A 需要发送一个 ACK 给 B，如果发送之后没有 <code>TIME_WAIT</code>，而是直接 <code>CLOSED</code>，那么如果该 ACK 丢失，B 会因为超时而重发 FIN，但是因为 A 已经关闭了，所以会回复一个 RST，B 就会认为发生了错误，实际上并没有。如果 A 在发送最后一个 ACK 后进入 <code>TIME_WAIT</code> 等待一段时间，那么 B 的重传 FIN 就可以被正常接收了。</p><p>也有一些博客说，客户端四次挥手的最后一个 ACK 报文如果在网络中被丢失了，此时如果客户端 <code>TIME_WAIT</code> 过短或没有，则就直接进入了 <code>CLOSED</code> 状态了，那么服务端则会一直处在 <code>LASE_ACK</code> 状态。<br>当客户端发起建立连接的 SYN 请求报文后，服务端会发送 RST 报文给客户端，连接建立的过程就会被终止。</p><h2 id="2-TCP-如何保证可靠性"><a href="#2-TCP-如何保证可靠性" class="headerlink" title="2. TCP 如何保证可靠性"></a>2. TCP 如何保证可靠性</h2><p>TCP (Transmission Control Protocol) 通过以下机制来保证数据传输的可靠性：</p><ol><li>应答机制：TCP 采用应答机制确认数据是否被成功接收。接收方会向发送方发送一个 ACK (Acknowledgment) 确认报文，告诉发送方已经成功接收到数据。如果发送方在一个特定时间内没有收到 ACK，就会重新发送数据。</li><li>超时重传：如果发送方没有收到 ACK，它就会重新发送数据。如果发送方连续多次没有收到 ACK，就会认为这个连接已经失效，并关闭这个连接。</li><li>滑动窗口：TCP 使用滑动窗口机制来控制发送方和接收方之间的数据传输速度。发送方会将多个数据包打包成一个窗口，接收方会告诉发送方它可以接收的最大窗口大小。这样发送方就可以控制它发送的数据包数量，确保不会造成网络拥塞。</li><li>重传机制：如果发送方发送的数据包在网络中丢失或损坏，接收方会发送一个 SACK (Selective Acknowledgment) 报文告诉发送方哪些数据包没有接收到。发送方会根据 SACK 报文重传这些数据包。</li></ol><p>综上所述，TCP 通过这些机制来保证数据传输的可靠性，确保数据能够在网络中成功传输并被正确接收。</p><h2 id="3-三次握手对应到-socket-函数"><a href="#3-三次握手对应到-socket-函数" class="headerlink" title="3. 三次握手对应到 socket 函数"></a>3. 三次握手对应到 socket 函数</h2><h2 id="4-四次挥手对应到-socket-函数"><a href="#4-四次挥手对应到-socket-函数" class="headerlink" title="4. 四次挥手对应到 socket 函数"></a>4. 四次挥手对应到 socket 函数</h2><p>主动关闭方调用 close 发送第一次挥手<br>被动关闭方调用 close 发送第三次挥手<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1643911879647.png"></p><h2 id="5-为什么断开连接需要四次挥手"><a href="#5-为什么断开连接需要四次挥手" class="headerlink" title="5. 为什么断开连接需要四次挥手"></a>5. 为什么断开连接需要四次挥手</h2><h2 id="6-三次握手为什么需要-3-次？2-次或者-4-次不行吗"><a href="#6-三次握手为什么需要-3-次？2-次或者-4-次不行吗" class="headerlink" title="6. 三次握手为什么需要 3 次？2 次或者 4 次不行吗"></a>6. 三次握手为什么需要 3 次？2 次或者 4 次不行吗</h2><p><strong>2 次：无法阻止历史连接，造成资源浪费，比如<a href="https://blog.csdn.net/qq_34827674/article/details/122040501">下图</a>：</strong></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1643774767968.png"></p><p>在上面的图片中，服务端一收到 SYN 就建立连接，但是却无法辨认该 SYN 是否是旧连接，只有在收到客户端的 RST 后才能知道，这导致白白创建了一条连接。</p><p>而使用 3 次握手就可以避免上面的情况，如<a href="https://blog.csdn.net/qq_34827674/article/details/122040501">下图所示</a></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1643775093372.png"></p><p>可以看到，在三次握手的情况下， 可以在服务端建立连接之前，阻止掉历史连接，从而保证建立的连接不是历史连接。</p><p><strong>4 次：既然 3 次已经可以保证连接正常建立了，就没必要再多加一次了</strong></p><h2 id="7-TCP-的拥塞控制"><a href="#7-TCP-的拥塞控制" class="headerlink" title="7. TCP 的拥塞控制"></a>7. TCP 的拥塞控制</h2><h1 id="HTTP-相关"><a href="#HTTP-相关" class="headerlink" title="HTTP 相关"></a>HTTP 相关</h1><h2 id="1-HTTP-1-0，1-1，2-0，3-0"><a href="#1-HTTP-1-0，1-1，2-0，3-0" class="headerlink" title="1.  HTTP 1.0，1.1，2.0，3.0"></a>1.  HTTP 1.0，1.1，2.0，3.0</h2><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h3><p>采用短连接，也就是每次请求都需要与服务器建立一次连接，服务器处理完成后便断开连接。无状态：即每次请求完成后就会断开连接，每个连接断开后都无法获取上次连接的状态和信息。<br>存在的问题：</p><ol><li><p>无法复用连接，每次发送请求，都需要进行一次 TCP 连接，而 TCP 的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。</p></li><li><p>队头阻塞(head of line blocking)，由于 HTTP1.0 规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。</p></li><li><p>不支持断点续传，也就是说，每次都会传送全部的页面和数据。</p></li></ol><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><ol><li><p>长连接：HTTP 1.1 默认支持 keep-alive 的长连接模式，解决了 1.0 中无法复用 TCP 连接的问题，当本次请求结束后不会断开连接并保持本次连接的状态与信息，客户端与服务端都有权取消该模式。</p></li><li><p>管道化：多个请求不用排队发送，但是服务端必须按照发送的顺序进行相应，所以并没有完全解决 HTTP 1.0 的队头阻塞问题。举例：假设文件 A 中有三个静态文件D，E 和 F，虽然管道化技术使 E 不需要等待 D 请求完成并接收到响应后再开始请求，F 也同理，但是最后服务端还是需要按照发送请求时的顺序来依次给出响应，这时候依旧会发生阻塞。 原因是 HTTP1.1 的请求和响应并没有序号标识，所以无法将乱序的响应与请求对应起来。</p></li><li><p>基于长连接的模式就可以实现断点续传的功能了，这样对大文件的传输和下载会更加友好，同时 HTTP1.1 在请求头中引入了 range 头域，它允许只请求资源的某部分，此时的返回码是 206</p></li></ol><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP 2"></a>HTTP 2</h3><p>（参考 <a href="https://blog.csdn.net/qq_34827674/article/details/115188949%EF%BC%89">https://blog.csdn.net/qq_34827674/article/details/115188949）</a></p><h4 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h4><p>在 HTTP 1&#x2F;1.1 中，可以通过指定 <code>Content-Encoding</code> 来设置 body 的压缩方式，比如 gzip，但是 header 部分不能进行压缩，且 header 部分存在几个问题：1. 使用 ASCII 码，效率低 2. 可能很多请求的 header 的字段值都是相同的，比较冗余 3. 存在一些固定字段，比如 Cookie</p><p>解决方式：<br><strong>静态编码表</strong><br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1644679813525.png"><br>静态编码表为一些常见的 Header 进行了映射，用一个 index 来标识，比如在上图中，:method GET 使用 2 来代替，这样传输就会节省很多字节，服务器在接收到报文后，通过静态编码表就可以获取到相应的信息。<br>但是也会发现一个问题，一些 index 是没有 header value 的，这是因为这些 Value 并不是固定的而是变化的，这些 Value 都会经过 Huffman 编码后，才会发送出去。具体的编码方式参考上面给出来的原文链接。</p><p><strong>动态编码表</strong><br>静态表只包含了 61 种高频出现在头部的字符串，不在静态表范围内的头部字符串就要自行构建动态表，它的 Index 从 62 起步，会在编码解码的时候随时更新。</p><p>比如发送的报文包含这样一个头部：XXX: YYY，那么客户端和服务端都会在各自的动态编码表中添加这一 header，并且用一个 index 标识，如果客户端之后要再次发送该头部，那么只需要发送对应得 index 即可。</p><p>使得动态表生效有一个前提：<strong>必须同一个连接上，重复传输完全相同的 HTTP 头部。</strong> 如果消息字段在 1 个连接上只发送了 1 次，或者重复传输时，字段总是略有变化，动态表就无法被充分利用了。</p><p>因此，随着在同一 HTTP&#x2F;2 连接上发送的报文越来越多，客户端和服务器双方的「字典」积累的越来越多，理论上最终每个头部字段都会变成 1 个字节的 Index，这样便避免了大量的冗余数据的传输，大大节约了带宽。</p><p>动态表的弊端是：随着表字段的增长，占用的内存也会越来越大，为了解决该问题，Web 服务器都会提供类似 http2_max_requests 的配置，用于限制一个连接上能够传输的请求数量，避免动态表无限增大，请求数量到达上限后，就会关闭 HTTP&#x2F;2 连接来释放内存。</p><h4 id="二进制帧"><a href="#二进制帧" class="headerlink" title="二进制帧"></a>二进制帧</h4><p>TODO</p><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>为了解决 HTTP 1&#x2F;1.1 中的队头阻塞问题，HTTP 2 使用了 <strong>流 (stream)</strong> 的概念，每一次请求对应一个流，有一个唯一的 ID，用来区分不同的请求，多个 stream 复用一条 TCP 连接，达到并发的效果。在每个 stream 中还有多个 <strong>message</strong>，<strong>message</strong> 对应 HTTP1 中的请求或响应，由 header 和 body 组成。message 中有一个或多个 <strong>frame</strong>（帧），frame 是 HTTP2 的最小单位，以二进制压缩格式存放 HTTP1 中的内容。一个请求的数据会被分成多个帧，方便进行数据分割传输，每个帧都唯一属于某一个流 ID，将帧按照流 ID进行分组，即可分离出不同的请求。这样同一个TCP连接中就可以同时并发多个请求，不同请求的帧数据可穿插在一起，根据流 ID 分组即可。</p><p>HTTP2 依然存在的问题：TCP 的队头阻塞<br>如果 HTTP&#x2F;2 连接双方的网络中有一个数据包丢失，或者任何一方的网络出现中断，整个 TCP 连接就会暂停，丢失的数据包需要被重新传输。 因为 TCP 是一个按序传输的链条，因此如果其中一个点丢失了，链路上之后的内容就都需要等待。 这种单个数据包造成的阻塞，就是 TCP 上的队头阻塞（head of line blocking）。</p><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP 3"></a>HTTP 3</h3><p>TODO</p><h2 id="HTTP-状态码，1xx-5xx"><a href="#HTTP-状态码，1xx-5xx" class="headerlink" title="HTTP 状态码，1xx-5xx"></a>HTTP 状态码，1xx-5xx</h2><p>1xx：表示已接收请求，需要继续发送请求<br>2xx：表示成功处理了请求<br>3xx：表示需要进行重定向<br>4xx：表示请求不能被理解、处理<br>5xx：表示服务器在处理请求时发生了内部错误，这些错误可能是服务器本身的错误，而不是请求出错</p><h2 id="HTTP-2-的多路复用和-HTTP-1-1-的-KeepAlive-有什么区别？"><a href="#HTTP-2-的多路复用和-HTTP-1-1-的-KeepAlive-有什么区别？" class="headerlink" title="HTTP 2 的多路复用和 HTTP 1.1 的 KeepAlive 有什么区别？"></a>HTTP 2 的多路复用和 HTTP 1.1 的 KeepAlive 有什么区别？</h2><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/http_keepalive_diff_http2_multip.png"></p><p>keep-alive ：</p><ol><li>请求 a.html</li><li>响应 a.html</li><li>请求 b.css</li><li>响应 b.css</li></ol><p>必须等到服务端响应了前一次请求，才能发起第二次请求 -&gt; 阻塞。 按顺序发送请求，按顺序接收请求，这样接收端才不会乱掉。</p><p>而 http2 的多路复用可以同时发送多个请求，不一定要按照顺序，也不用等上一个请求响应。这些请求都有唯一标识，所以可以无序。</p><p><strong>回答 2</strong></p><p>HTTP&#x2F;1.x 是基于文本的，只能整体去传；HTTP&#x2F;2 是基于二进制流的，可以分解为独立的帧，交错发送</p><p>HTTP&#x2F;1.x keep-alive 必须按照请求发送的顺序返回响应；HTTP&#x2F;2 多路复用不按序响应</p><p>HTTP&#x2F;1.x keep-alive 为了解决队头阻塞，将同一个页面的资源分散到不同域名下，开启了多个 TCP 连接；HTTP&#x2F;2 同域名下所有通信都在单个连接上完成</p><p>HTTP&#x2F;1.x keep-alive 单个 TCP 连接在同一时刻只能处理一个请求（两个请求的生命周期不能重叠）；HTTP&#x2F;2 单个 TCP 同一时刻可以发送多个请求和响应</p><h2 id="http1-1-keepalive-说的是开启一个长连接，多个请求可以在一条连接上完成；而-http2-的多路复用，貌似也是多个请求在一条连接上完成，这样的话有什么区别？"><a href="#http1-1-keepalive-说的是开启一个长连接，多个请求可以在一条连接上完成；而-http2-的多路复用，貌似也是多个请求在一条连接上完成，这样的话有什么区别？" class="headerlink" title="http1.1 keepalive 说的是开启一个长连接，多个请求可以在一条连接上完成；而 http2 的多路复用，貌似也是多个请求在一条连接上完成，这样的话有什么区别？"></a>http1.1 keepalive 说的是开启一个长连接，多个请求可以在一条连接上完成；而 http2 的多路复用，貌似也是多个请求在一条连接上完成，这样的话有什么区别？</h2><p>HTTP&#x2F;1.x 是基于文本的，因为是文本，就导致了它必须是个整体，在传输是不可切割的，只能整体去传，这就导致了，如果某个报文特别大，发送需要一定的时间，后面的报文就全部被阻塞了（不开启 pipelining 的情况下？），这就是 <strong>队头阻塞</strong> 问题。</p><p>http2 引入了 帧（frame）和流（stream）， 是基于二进制流的，它就可以 HTTP 消息分解为独立的帧，交错发送，然后在另一端通过帧中的标识重新组装，这就是多路复用。</p><p>这就实现了在同一个 TCP 连接中，同一时刻可以发送多个请求和响应，且不用按照顺序一一对应，即使某个 <strong>请求任务耗时严重</strong> ，也不会影响到其它连接的正常执行，所以可以说，http2 解决了应用层的队头阻塞问题，但因为 http2 是基于 tcp 的，而 tcp 依然存在队头阻塞问题，所以 http2 又并没有完全解决队头阻塞。</p><h2 id="既然-http1-1-keepalive-可以在一条连接上完成多个请求，那为什么还有浏览器的并发限制之类的东西？直接开一条连接不就好了吗？"><a href="#既然-http1-1-keepalive-可以在一条连接上完成多个请求，那为什么还有浏览器的并发限制之类的东西？直接开一条连接不就好了吗？" class="headerlink" title="既然 http1.1 keepalive 可以在一条连接上完成多个请求，那为什么还有浏览器的并发限制之类的东西？直接开一条连接不就好了吗？"></a>既然 http1.1 keepalive 可以在一条连接上完成多个请求，那为什么还有浏览器的并发限制之类的东西？直接开一条连接不就好了吗？</h2><p>说到这个就不得不谈谈臭名昭著的 <strong>http 队头阻塞</strong> 问题了。</p><p>队头阻塞基于 HTTP 管道技术，也就是 HTTP Pipelining，它是这样一种技术：把多个 HTTP 请求放到一个 TCP 连接中一一发送，而在发送过程中不需要等待服务器对前一个请求的响应；只不过，客户端还是要按照发送请求的顺序来接收响应。</p><p>比如有 A，B，C 三个请求，如果开启了 http pipelining ，那么就可以一口气将这三个请求全部发送出去，但是因为 <strong>HTTP 请求和响应并没有序号标识，所以要求返回的响应顺序和请求顺序相同</strong>，所以服务端必须依次发送 A、B、C 的响应包，这样才能一一对应起来，如果 A 的响应包发送延迟了，那么 B、C 也会被阻塞。</p><p>如果 A 的响应包有 1m，而 B，C 的响应包只有 1kb，那这样的阻塞是非常影响效率的，完全可以先将 B，C 这两个小包先发出去。就像在超市排队结账一样，队头的人买了特别多的东西，以至于他装袋都需要花费不少时间，而后面的人只能干等着，直到他装完东西走人，收银员才会对下一个人进行结账处理，效率更高的做法是：在第一个人装袋的时候，收银员就可以开始对第二个人进行结账处理了。</p><p>如果没有开启 pipelining，那么一条连接里面的所有请求都是串行化的，也就是第二个请求会阻塞，直到第一个请求得到了响应，虽然一条连接可以处理多个请求，但串行化的方式会导致效率低下。</p><p>回到这个问题，如果一个网页有几十张图片，那么只开一条连接，加上队头阻塞的问题，会导致响应延迟过高，影响用户体验，那么就只能多开几条连接来并发处理了，但是对于开启的连接数量也需要做一些限制，防止占用大量资源，不同的浏览器有不同的限制策略。此外，如果每个 TCP 连接中的头资源文件很大，则依然会发生 HTTP&#x2F;1.1 队头阻塞问题。</p><h2 id="HTTPS-握手流程"><a href="#HTTPS-握手流程" class="headerlink" title="HTTPS 握手流程"></a>HTTPS 握手流程</h2><p>TLS 握手是由客户端和服务器交换的一系列数据报或消息。TLS 握手涉及多个步骤，因为客户端和服务器要交换完成握手和进行进一步对话所需的信息。</p><p>TLS 握手的确切步骤将根据所使用的密钥交换算法的类型以及双方支持的密码套件而有所不同。RSA 密钥交换算法最为常用。具体如下：</p><ol><li><p><strong>“客户端问候（client hello）” 消息：</strong> 客户端通过向服务器发送“问候”消息来开始握手。该消息将包含 <strong>客户端支持的 TLS 版本，支持的密码套件</strong>，以及称为一串称为“<strong>客户端随机数（client random）</strong>”的随机字节。</p></li><li><p><strong>“服务器问候（server hello）”消息：</strong> 作为对 client hello 消息的回复，服务器发送一条消息，内含 <strong>服务器的 <a href="https://www.cloudflare.com/learning/ssl/what-is-an-ssl-certificate/">SSL 证书</a><strong>、</strong>服务器选择的密码套件（从客户端支持的套件中选择）</strong>，以及“<strong>服务器随机数</strong>（server random）”，即由服务器生成的另一串随机字节。</p></li><li><p><strong>身份验证：</strong> 客户端使用颁发该证书的证书颁发机构验证服务器的 SSL 证书。此举确认服务器是其声称的身份，且客户端正在与该域的实际所有者进行交互。</p></li><li><p><strong>预主密钥：</strong> 客户端再发送一串随机字节，即“<strong>预主密钥（premaster secret）</strong>”。预主密钥是使用公钥加密的，只能使用服务器的私钥解密。（客户端从服务器的 SSL 证书中获得<a href="https://www.cloudflare.com/learning/ssl/how-does-public-key-encryption-work/">公钥</a>。），也就是说，客户端将使用公钥加密预主密钥，然后发送给服务端。</p></li><li><p><strong>私钥被使用</strong>：服务器使用自己的 <strong>私钥</strong> 对预主密钥进行解密。</p></li><li><p><strong>生成会话密钥</strong>：至此，客户端和服务端经过一系列信息交换后，各自都拥有了以下数据：</p><ol><li><p>客户端生成的随机数</p></li><li><p>服务端生成的随机数 </p></li><li><p>预主密钥</p></li></ol><p>然后，客户端和服务器均使用客户端随机数、服务器随机数和预主密钥生成 <strong>会话密钥</strong>。双方应得到相同的结果。</p></li><li><p><strong>客户端就绪</strong>：客户端发送一条“已完成”消息，该消息用会话密钥加密。</p></li><li><p><strong>服务器就绪</strong>：服务器发送一条“已完成”消息，该消息用会话密钥加密。</p></li><li><p><strong>实现安全对称加密</strong>：已完成握手，并使用 <strong>会话密钥</strong> 继续进行通信，之后的通信都会使用该密钥，以 <strong>对称加密</strong> 的方式进行通信。</p></li></ol><p>具体的流程可以用下面这张图来概括：</p><blockquote><p>图片来源：<a href="https://segmentfault.com/a/1190000021559557">https://segmentfault.com/a/1190000021559557</a></p></blockquote><p><img src="https://raw.githubusercontent.com/autsu/diagrams/2d20c2027f78f57ae0087ea3b33de34456234cbf/img/tls%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B.png"></p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><ol><li><p>为什么不直接使用非对称加密进行通信？</p><p>非对称加密的计算量比较大，加解密速度较慢，因此在数据量较大的情况下，使用非对称加密进行加解密会比较耗时，不利于高效的通信。而对称加密的计算量较小，加解密速度较快，可以很好地满足数据传输的需求。因此，<strong>TLS 在握手阶段使用非对称加密来协商对称密钥</strong>，并且之后的通信过程中使用对称加密方式，以保证通信的安全性和高效性。</p></li></ol><h1 id="输入-url-到浏览器的过程"><a href="#输入-url-到浏览器的过程" class="headerlink" title="输入 url 到浏览器的过程"></a>输入 url 到浏览器的过程</h1><p>比较长，单独记录到 <a href="https://autsu.github.io/2022/07/14/url_dao_xian_shi_wang_ye_fa_shen_le_shen_me/">这篇文章</a> 了</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac环境下， VMware Fusion下的虚拟机（ CentOS 7/Ubuntu20）的 NAT网络配置</title>
    <link href="/2022/01/17/mac-huan-jing-xia-vmware-fusion-xia-de-xu-ni-ji-centos-7de-nat-wang-luo-pei-zhi/"/>
    <url>/2022/01/17/mac-huan-jing-xia-vmware-fusion-xia-de-xu-ni-ji-centos-7de-nat-wang-luo-pei-zhi/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://blog.csdn.net/u010476994/article/details/104001848">https://blog.csdn.net/u010476994/article/details/104001848</a> （Centos 7 部分）<br><a href="https://blog.csdn.net/u014630144/article/details/108129079">https://blog.csdn.net/u014630144/article/details/108129079</a> （Ubuntu 20 部分）</p></blockquote><p>本帖子能够实现的效果：<br>    1、虚拟机能访问外网、虚拟机能访问Mac本机；<br>    2、Mac本机可以连接虚拟机。</p><h1 id="Mac-前提步骤"><a href="#Mac-前提步骤" class="headerlink" title="Mac 前提步骤"></a>Mac 前提步骤</h1><h2 id="1、配置-VMware-Fusion-虚拟网络配置"><a href="#1、配置-VMware-Fusion-虚拟网络配置" class="headerlink" title="1、配置 VMware Fusion 虚拟网络配置"></a>1、配置 VMware Fusion 虚拟网络配置</h2><p>VMware Fusion 安装完成后，会在Mac OS中新建两个网卡：  vmnet1以及vmnet8（在 &#x2F;Library&#x2F;Preferences&#x2F;VMware Fusion 下可以看到），其中 vmnet1 是Host-only模式， vmnet8是NAT模式。此处仅对网卡vmnet8 进行修改（ 修改过程中需关闭VMWare Fusion）。</p><h3 id="1-1-修改-x2F-Library-x2F-Preferences-x2F-VMware-Fusion-x2F-networking-。"><a href="#1-1-修改-x2F-Library-x2F-Preferences-x2F-VMware-Fusion-x2F-networking-。" class="headerlink" title="1.1   修改 &#x2F;Library&#x2F;Preferences&#x2F;VMware\ Fusion&#x2F;networking 。"></a>1.1   修改 &#x2F;Library&#x2F;Preferences&#x2F;VMware\ Fusion&#x2F;networking 。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vi /Library/Preferences/VMware\ Fusion/networking<br></code></pre></td></tr></table></figure><p><img src="https://youseebiggirl.github.io/post-images/1642402883661.png"></p><p>将 DHCP 设置为 no， 即使用静态IP。 将 SUBNET 修改为自己想用的网段，此处我填的是 192.168.111.0 网段。 </p><p>保存退出。<br>注意：只修改 vmnet8 的配置， 不要修改 vmnet1 的配置。</p><h3 id="1-2-修改-x2F-Library-x2F-Preferences-x2F-VMware-Fusion-x2F-vmnet8-x2F-nat-conf-。"><a href="#1-2-修改-x2F-Library-x2F-Preferences-x2F-VMware-Fusion-x2F-vmnet8-x2F-nat-conf-。" class="headerlink" title="1.2    修改 &#x2F;Library&#x2F;Preferences&#x2F;VMware\ Fusion&#x2F;vmnet8&#x2F;nat.conf 。"></a>1.2    修改 &#x2F;Library&#x2F;Preferences&#x2F;VMware\ Fusion&#x2F;vmnet8&#x2F;nat.conf 。</h3><p><img src="https://youseebiggirl.github.io/post-images/1642402997231.png"><br>设置网关为 192.168.111.2 ， 网关的IP要和上一步中的IP 保持网关一致。<br>至此，VMware   Fusion的配置完毕。</p><h3 id="1-3-将虚拟机网络切换到NAT模式。"><a href="#1-3-将虚拟机网络切换到NAT模式。" class="headerlink" title="1.3    将虚拟机网络切换到NAT模式。"></a>1.3    将虚拟机网络切换到NAT模式。</h3><p><img src="https://youseebiggirl.github.io/post-images/1642403059793.png"></p><h1 id="CentOS-7"><a href="#CentOS-7" class="headerlink" title="CentOS 7"></a>CentOS 7</h1><p>步骤如下：</p><h2 id="1、打开虚拟机，配置虚拟机网络配置信息"><a href="#1、打开虚拟机，配置虚拟机网络配置信息" class="headerlink" title="1、打开虚拟机，配置虚拟机网络配置信息"></a>1、打开虚拟机，配置虚拟机网络配置信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/sysconfig/network-scripts/ifcfg-ens33<br></code></pre></td></tr></table></figure><p>可按如下格式配置网络信息（部分信息需按照自己的情况配置）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">TYPE=Ethernet<br>PROXY_METHOD=none<br>BROWSER_ONLY=no<br>BOOTPROTO=static<br>DEFROUTE=yes<br>IPV4_FAILURE_FATAL=no<br>IPV6INIT=yes<br>IPV6_AUTOCONF=yes<br>IPV6_DEFROUTE=yes<br>IPV6_FAILURE_FATAL=no<br>IPV6_ADDR_GEN_MODE=stable-privacy<br>NAME=ens33<br>UUID=405afcb9-08fe-4507-8775-232604d2e819<br>DEVICE=ens33<br>ONBOOT=yes<br>IPADDR=192.168.110.14 # 自定义的虚拟机IP， 需与VMware Fusion配置的IP在同一个网段上<br>GATEWAY=192.168.110.2 # 网关。1.2中配置的网关地址<br>NETMASK=255.255.255.0 # 掩码。1.2中配置的掩码<br>DNS1=192.168.1.1 # Mac本机的DNS地址。 系统偏好设置-&gt; 网络 -&gt; 在左侧选择当前使用的网络，点击右下角的“高级”按钮 -&gt; 切换Tab页，可找到DNS地址。<br>DNS2=192.168.1.1 # 同上<br></code></pre></td></tr></table></figure><p>保存退出，重启网络服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart network<br></code></pre></td></tr></table></figure><p>至此。所有网络配置完成。</p><p>注意：修改完 DNS 后需要重启 VMware 才能生效 （貌似只需要重启一次，后续再更改 DNS 不需要重启了）</p><h1 id="Ubuntu-20"><a href="#Ubuntu-20" class="headerlink" title="Ubuntu 20"></a>Ubuntu 20</h1><h2 id="1-编辑网络配置文件："><a href="#1-编辑网络配置文件：" class="headerlink" title="1. 编辑网络配置文件："></a>1. 编辑网络配置文件：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vi /etc/netplan/00-installer-config.yaml<br></code></pre></td></tr></table></figure><p>编辑文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">This is the network config written by <span class="hljs-string">&#x27;subiquity&#x27;</span></span><br>network:<br>  ethernets:<br>    ens33:<br>      dhcp4: no<br>      addresses: [192.168.110.10/24] # 确保该值在前提步骤 1.1 中设置的 ip 段内，且子网掩码相同<br>      gateway4: 192.168.110.2 # 与前提步骤 1.2 中网管 ip 相同<br>      nameservers:<br>              addresses: [114.114.114.114]<br>  version: 2<br></code></pre></td></tr></table></figure><p>使配置的ip地址生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo netplan apply<br></code></pre></td></tr></table></figure><p>重启 VMware Fusion 生效。</p>]]></content>
    
    
    
    <tags>
      
      <tag>虚拟机</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 间隙锁实践</title>
    <link href="/2021/10/19/mysql-jian-xi-suo-shi-jian/"/>
    <url>/2021/10/19/mysql-jian-xi-suo-shi-jian/</url>
    
    <content type="html"><![CDATA[<p>测试数据如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `c` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `d` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `c` (`c`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB;<br><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> c    <span class="hljs-operator">|</span> d    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">0</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span>    <span class="hljs-number">5</span> <span class="hljs-operator">|</span>    <span class="hljs-number">5</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">10</span> <span class="hljs-operator">|</span>   <span class="hljs-number">10</span> <span class="hljs-operator">|</span>   <span class="hljs-number">10</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">15</span> <span class="hljs-operator">|</span>   <span class="hljs-number">15</span> <span class="hljs-operator">|</span>   <span class="hljs-number">15</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">20</span> <span class="hljs-operator">|</span>   <span class="hljs-number">20</span> <span class="hljs-operator">|</span>   <span class="hljs-number">20</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">25</span> <span class="hljs-operator">|</span>   <span class="hljs-number">25</span> <span class="hljs-operator">|</span>   <span class="hljs-number">25</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+------+</span><br></code></pre></td></tr></table></figure><h2 id="测试情景-1-不存在的主键，select-是否会加间隙锁"><a href="#测试情景-1-不存在的主键，select-是否会加间隙锁" class="headerlink" title="测试情景 1 不存在的主键，select 是否会加间隙锁"></a>测试情景 1 不存在的主键，select 是否会加间隙锁</h2><table><thead><tr><th align="center"></th><th align="center">session A</th><th align="center">session B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">begin</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center"></td><td align="center">begin</td></tr><tr><td align="center">3</td><td align="center">select * from t where id &#x3D; 9 for update;</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center"></td><td align="center">insert into t values(11,5,5);</td></tr><tr><td align="center">5</td><td align="center"></td><td align="center">insert into t values(6,5,5);</td></tr><tr><td align="center">6</td><td align="center"></td><td align="center">insert into t values(10,5,5);</td></tr><tr><td align="center">7</td><td align="center"></td><td align="center">insert into t values(4,5,5);</td></tr><tr><td align="center">8</td><td align="center"></td><td align="center">select * from t where id &#x3D; 9 for update;</td></tr></tbody></table><p>结果：</p><p>B1：成功执行，输出 Empty set</p><p>B4：成功执行</p><p>B5：被阻塞</p><p>B6：Duplicate entry ‘10’ for key ‘t.PRIMARY’ 主键不能重复</p><p>B7：成功执行</p><p>B8：成功执行，输出 Empty set</p><p>说明：</p><p>因为 id &#x3D; 9 这一行不存在，所以会加间隙锁，区间为 (5, 10]，左开右闭。所以所有尝试在 [5, 10) 区间 insert 数据的 sql 都被阻塞了，但是区间外不会被阻塞，比如 id&#x3D;11 和 id &#x3D; 4 就成功执行了。</p><p>关于 B8 为什么没有被阻塞，可能是因为因为 id&#x3D;9 不存在，所以 A3 处的 for update 并没有生效加锁。</p><h2 id="测试情景-2"><a href="#测试情景-2" class="headerlink" title="测试情景 2"></a>测试情景 2</h2><table><thead><tr><th align="center"></th><th align="center">session A</th><th align="center">session B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">begin</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center"></td><td align="center">begin</td></tr><tr><td align="center">3</td><td align="center">select * from t where id &#x3D; 9 for update;</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center">insert into t values(9,9,9);</td><td align="center"></td></tr><tr><td align="center">5</td><td align="center"></td><td align="center">select * from t where id &#x3D; 9 for update;</td></tr><tr><td align="center">6</td><td align="center"></td><td align="center">select * from t where id &#x3D; 7 for update;</td></tr><tr><td align="center">7</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">8</td><td align="center"></td><td align="center"></td></tr></tbody></table><p>A3：成功执行，输出 Empty set</p><p>A4：成功执行</p><p>B5：被阻塞</p><p>B6：成功执行，输出 Empty set</p><p>为什么 B5 会被阻塞呢？似乎除了 id&#x3D;9 以外，其他的查询都不会被阻塞</p><p>破案了，insert 会加排它锁</p><h2 id="测试情景-3-已经存在的主键，select-是否会加间隙锁"><a href="#测试情景-3-已经存在的主键，select-是否会加间隙锁" class="headerlink" title="测试情景 3 已经存在的主键，select 是否会加间隙锁"></a>测试情景 3 已经存在的主键，select 是否会加间隙锁</h2><table><thead><tr><th align="center"></th><th align="center">session A</th><th align="center">session B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">begin</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center"></td><td align="center">begin</td></tr><tr><td align="center">3</td><td align="center">select * from t where id &#x3D; 10 for update;</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center"></td><td align="center">insert into t values(11,5,5);</td></tr><tr><td align="center">5</td><td align="center"></td><td align="center">insert into t values(9,5,5);</td></tr><tr><td align="center">6</td><td align="center"></td><td align="center">select * from t where id &#x3D; 10 for update;</td></tr><tr><td align="center">7</td><td align="center">select * from t where id &#x3D; 9 for update;</td><td align="center"></td></tr><tr><td align="center">8</td><td align="center">select * from t where id &#x3D; 11 for update;</td><td align="center"></td></tr><tr><td align="center">9</td><td align="center">select * from t where id &#x3D; 8 for update;</td><td align="center"></td></tr></tbody></table><p>A3：成功执行</p><p>B4：成功执行</p><p>B5：成功执行</p><p>B6：被阻塞</p><p>A7：被阻塞</p><p>A8：被阻塞</p><p>A9：成功执行</p><p>因为 id&#x3D;10 存在且 id 为主键，所以只加了排他锁，没有加间隙锁，所以 B4，B5 的插入都成功了，B6 被阻塞了，因为 id&#x3D;10 这一行已经上锁了。</p><p>由于主键是唯一索引，而且是只使用一个索引查询，并且只锁定一条记录，所以以上的例子，只会对 id &#x3D; 10 的数据加上记录锁，而不会产生间隙锁。</p><p>比较怪异的是 A7、A8 这两个地方，居然被阻塞了，观察发现，这两个 sql 查询的 id 是 9 和 10，刚好是 B 中插入的两个 id，而 A9 处的 id&#x3D;8 没有被阻塞，难道在 insert 之后会给新插入的行加锁吗？</p><p>破案了，insert 会加排它锁</p><h2 id="测试情景-4-已经存在的非索引列（可能查出多条数据），select-是否会加间隙锁"><a href="#测试情景-4-已经存在的非索引列（可能查出多条数据），select-是否会加间隙锁" class="headerlink" title="测试情景 4 已经存在的非索引列（可能查出多条数据），select 是否会加间隙锁"></a>测试情景 4 已经存在的非索引列（可能查出多条数据），select 是否会加间隙锁</h2><table><thead><tr><th align="center"></th><th align="center">session A</th><th align="center">session B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">begin</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center"></td><td align="center">begin</td></tr><tr><td align="center">3</td><td align="center">select * from t where d&#x3D;5 for update;</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center"></td><td align="center">insert into t values(26,26,5);</td></tr><tr><td align="center">5</td><td align="center"></td><td align="center">insert into t values(26,26,4);</td></tr><tr><td align="center">6</td><td align="center"></td><td align="center">insert into t values(100,100,100);</td></tr></tbody></table><p>A3：成功执行</p><p>B4：被阻塞</p><p>B5：被阻塞</p><p>B6：被阻塞</p><p>因为 A3 查询条件是 d&#x3D;5，而 d 既不是主键也没有索引，所以会加间隙锁，防止幻读出现，间隙锁的范围是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +suprenum]，所有的 insert 全部被阻塞了，</p><h2 id="测试情景-5-不存在的非索引列（可能查出多条数据），select-是否会加间隙锁"><a href="#测试情景-5-不存在的非索引列（可能查出多条数据），select-是否会加间隙锁" class="headerlink" title="测试情景 5 不存在的非索引列（可能查出多条数据），select 是否会加间隙锁"></a>测试情景 5 不存在的非索引列（可能查出多条数据），select 是否会加间隙锁</h2><table><thead><tr><th align="center"></th><th align="center">session A</th><th align="center">session B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">begin</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center"></td><td align="center">begin</td></tr><tr><td align="center">3</td><td align="center">select * from t where d&#x3D;100 for update;</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center"></td><td align="center">insert into t values(26,26,5);</td></tr><tr><td align="center">5</td><td align="center"></td><td align="center">insert into t values(26,26,4);</td></tr><tr><td align="center">6</td><td align="center"></td><td align="center">insert into t values(100,100,100);</td></tr></tbody></table><p>结论：session B 的 insert 全部被阻塞，由此可见，即便 d&#x3D;100 这一行不存在，依然会加间隙锁</p><h2 id="测试场景-6-不存在的普通索引列，select-是否会加间隙锁"><a href="#测试场景-6-不存在的普通索引列，select-是否会加间隙锁" class="headerlink" title="测试场景 6 不存在的普通索引列，select 是否会加间隙锁"></a>测试场景 6 不存在的普通索引列，select 是否会加间隙锁</h2><table><thead><tr><th align="center"></th><th align="center">session A</th><th align="center">session B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">begin</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center"></td><td align="center">begin</td></tr><tr><td align="center">3</td><td align="center">select * from t where c&#x3D;9 for update;</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center"></td><td align="center">insert into t values(11,11,11);</td></tr><tr><td align="center">5</td><td align="center"></td><td align="center">insert into t values(100,8,100);</td></tr><tr><td align="center">6</td><td align="center"></td><td align="center">insert into t values(100,10,100);</td></tr><tr><td align="center">7</td><td align="center"></td><td align="center">insert into t values(101,5,100);</td></tr><tr><td align="center">8</td><td align="center"></td><td align="center">insert into t values(102,4,100);</td></tr></tbody></table><p>B4：成功执行</p><p>B5：被阻塞</p><p>B6：成功执行</p><p>B7：被阻塞</p><p>B8：成功执行</p><p>对于列 c 而言，有这些间隙： (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +suprenum]</p><p>因为查询的是 c&#x3D;9 ，所以间隙锁范围是 (5,10]，但是我没有太明白这个范围的意思，按照数学来说，应该是不包含 5，但是包含 10 的意思，也就是 c&#x3D;5 不加锁，c&#x3D;10 加锁，但是从上面的测试来看，insert c&#x3D;5 被阻塞，而 insert c&#x3D;10 没有被阻塞，完全相反，这是为什么？</p><h2 id="测试情景-6"><a href="#测试情景-6" class="headerlink" title="测试情景 6"></a>测试情景 6</h2><table><thead><tr><th align="center"></th><th align="center">session A</th><th align="center">session B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">begin</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center"></td><td align="center">begin</td></tr><tr><td align="center">3</td><td align="center">insert into t values(9,9,9);</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center"></td><td align="center">select * from t where id&#x3D;9 for update;</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>A3：执行成功</p><p>B4：阻塞</p><p>可以参考 <a href="https://zhuanlan.zhihu.com/p/48269420">https://zhuanlan.zhihu.com/p/48269420</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL实战笔记 20讲幻读是什么</title>
    <link href="/2021/10/19/mysql-shi-zhan-bi-ji-20-jiang-huan-du-shi-shi-me/"/>
    <url>/2021/10/19/mysql-shi-zhan-bi-ji-20-jiang-huan-du-shi-shi-me/</url>
    
    <content type="html"><![CDATA[<p>全文基于此表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `c` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `d` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `c` (`c`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),<br>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>),(<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>),(<span class="hljs-number">20</span>,<span class="hljs-number">20</span>,<span class="hljs-number">20</span>),(<span class="hljs-number">25</span>,<span class="hljs-number">25</span>,<span class="hljs-number">25</span>);<br></code></pre></td></tr></table></figure><h1 id="1-什么是幻读"><a href="#1-什么是幻读" class="headerlink" title="1. 什么是幻读"></a>1. 什么是幻读</h1><p>如下是文章中的图，需要注意的是，这里的 result 是基于 <strong>如果只在id&#x3D;5这一行加锁，而其他行的不加锁</strong> （也就是行锁）这一基础上的，当时没注意这句话，导致自己用 Mysql 做实验时出现了不一样的结果：session A 的 T1 执行完成后，session B 的 T2 被阻塞，直到 A 事务结束，因为 B 被阻塞了，所以 A 的 T3 查询结果依然是 (5,5,5) 而不是图中的 (0,0,5)(5,5,5)<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1634646186038.webp"></p><p><strong>幻读</strong> 指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。比如在上图中，Q3 读到了 (1,1,5) ，便是幻读。</p><p><strong>幻读</strong> 在 <strong>当前读</strong> 下才会出现，图中的 <code>select</code> 都加了 <code>for update</code>，代表当前读。（当前读：读取的是记录数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录），在<strong>快照读</strong>下不会出现（可重复读隔离级别下），因为快照读看不到别的事务插入的数据。</p><p><strong>幻读</strong> 仅专指 <strong>新插入的行</strong>，所以 session B T2 的 update 操作，导致的 A T3 结果不算是幻读。比如在上图中，Q2 读到了 (0,0,5) ，但不是幻读。</p><h1 id="2-幻读有什么问题"><a href="#2-幻读有什么问题" class="headerlink" title="2. 幻读有什么问题"></a>2. 幻读有什么问题</h1><p>这是原文中的标题，但是我不是很理解之后举的例子和幻读有什么关系，倒是换成 <strong>只加行锁有什么问题</strong> 更贴切（个人拙见）。</p><h2 id="2-1-语义被破坏"><a href="#2-1-语义被破坏" class="headerlink" title="2.1 语义被破坏"></a>2.1 语义被破坏</h2><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1634648873422.webp"></p><p>session A 里 Q1 语句，表示要锁住所有 d&#x3D;5 的行，阻塞其他事务的读写操作。但是在 session B T2 中找个了漏洞，先将 id&#x3D;0 这一行的 d 改成 5，再对这一行进行更改，这样就破坏了 A 中锁住所有 d&#x3D;5 这一语句进行了破坏，session C 也是一样的道理。</p><h2 id="2-2-数据一致性的问题"><a href="#2-2-数据一致性的问题" class="headerlink" title="2.2 数据一致性的问题"></a>2.2 数据一致性的问题</h2><p>锁的设计是为了保证数据的一致性。而这个一致性，不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1634649601817.webp"></p><p>看看 binlog 里面的内容：</p><ol><li><p>T2 时刻，session B 事务提交，写入了两条语句；</p></li><li><p>T4 时刻，session C 事务提交，写入了两条语句；</p></li><li><p>T6 时刻，session A 事务提交，写入了update t set d&#x3D;100 where d&#x3D;5 这条语句。</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> session B<br><span class="hljs-keyword">update</span> t <span class="hljs-keyword">set</span> d<span class="hljs-operator">=</span><span class="hljs-number">5</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">0</span>; <span class="hljs-comment">/*(0,0,5)*/</span><br><span class="hljs-keyword">update</span> t <span class="hljs-keyword">set</span> c<span class="hljs-operator">=</span><span class="hljs-number">5</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">0</span>; <span class="hljs-comment">/*(0,5,5)*/</span><br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> session C<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">/*(1,1,5)*/</span><br><span class="hljs-keyword">update</span> t <span class="hljs-keyword">set</span> c<span class="hljs-operator">=</span><span class="hljs-number">5</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>; <span class="hljs-comment">/*(1,5,5)*/</span><br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> session A<br><span class="hljs-keyword">update</span> t <span class="hljs-keyword">set</span> d<span class="hljs-operator">=</span><span class="hljs-number">100</span> <span class="hljs-keyword">where</span> d<span class="hljs-operator">=</span><span class="hljs-number">5</span>;<span class="hljs-comment">/*所有d=5的行，d改成100*/</span><br></code></pre></td></tr></table></figure><p>因为 binlog 是按照 commit 的先后顺序记录的，而不是按 update 的执行顺序记录的（上图中 A 最先执行 update，然后是 B，最后是 C），所以会导致错误的结果，如果以后用 binlog 来克隆一个库，这三行的结果变成了 (0,5,100)、(1,5,100) 和 (5,5,100)，与实际的 (0,5,5)、(1,5,5) 和 (5,5,100) 不符，因为 A 被记录到了最后。</p><p>如何让 binlog 按 update 的执行顺序记录呢？按照文中的说法是，<strong>把扫描过程中碰到的行，也都加上写锁</strong>，（这里没太明白，意思是把 session A 中的 select 语句扫描到的行全部加锁吗？如果是这样的话，因为 d 没有索引，所以会扫描全表，也就是把整张表都加锁吗？暂时先这么理解吧）A select for update 时直接将所有行锁起来，这样后续的 B C 都会被阻塞，直到 A commit，这样 binlog 中，最先记录的就是 A，此时的 binlog：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">/*(1,1,5)*/</span><br><span class="hljs-keyword">update</span> t <span class="hljs-keyword">set</span> c<span class="hljs-operator">=</span><span class="hljs-number">5</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>; <span class="hljs-comment">/*(1,5,5)*/</span><br><br><span class="hljs-keyword">update</span> t <span class="hljs-keyword">set</span> d<span class="hljs-operator">=</span><span class="hljs-number">100</span> <span class="hljs-keyword">where</span> d<span class="hljs-operator">=</span><span class="hljs-number">5</span>;<span class="hljs-comment">/*所有d=5的行，d改成100*/</span><br><br><span class="hljs-keyword">update</span> t <span class="hljs-keyword">set</span> d<span class="hljs-operator">=</span><span class="hljs-number">5</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">0</span>; <span class="hljs-comment">/*(0,0,5)*/</span><br><span class="hljs-keyword">update</span> t <span class="hljs-keyword">set</span> c<span class="hljs-operator">=</span><span class="hljs-number">5</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">0</span>; <span class="hljs-comment">/*(0,5,5)*/</span><br></code></pre></td></tr></table></figure><p>可以看到上面的记录依然存在问题，最先记录的不是预想中的 A，而是 C，这是为什么呢？明明都已经把整张表都锁起来了，还是阻止不了id&#x3D;1这一行的插入和更新呢？</p><p>原因很简单。在T3时刻，我们给所有行加锁的时候，id&#x3D;1这一行还不存在，不存在也就加不上锁。</p><p>也就是说，<strong>即使把所有的记录都加上锁，还是阻止不了新插入的记录</strong>，这也是为什么“幻读”会被单独拿出来解决的原因。</p><h1 id="3-如何解决幻读"><a href="#3-如何解决幻读" class="headerlink" title="3. 如何解决幻读"></a>3. 如何解决幻读</h1><h2 id="3-1-间隙锁"><a href="#3-1-间隙锁" class="headerlink" title="3.1 间隙锁"></a>3.1 间隙锁</h2><p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的<strong>间隙</strong>。</p><p>何为间隙？比如 (0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25) 这六条记录中，便存在以下 7 个间隙：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1634652727224.webp"></p><p>这样，当你执行 select * from t where d&#x3D;5 for update 的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。</p><p>跟 <strong>间隙锁</strong> 存在冲突关系的，是“往这个间隙中<strong>插入一个记录</strong>”这个操作。间隙锁之间都不存在冲突关系。</p><p>对于指定<strong>查询某一条记录</strong>的加锁语句，如果该记录<strong>不存在，会产生记录锁和间隙锁</strong>，如果记录存在，则只会产生记录锁。（注意这里的查询一条记录，如果是范围查询，或者查询出多条结果，那么不管存不存在，都会加间隙锁）</p><p>对于查找某一范围内的查询语句，会产生间隙锁，如：WHERE <code>id</code> BETWEEN 5 AND 7 FOR UPDATE。</p><p>间隙锁是在可重复读隔离级别下才会生效的。</p><p>间隙锁和行锁合称 <code>next-key lock</code>，每个 <code>next-key lock</code> 是<strong>前开后闭</strong>区间。</p><h2 id="3-2-间隙锁导致的死锁案例"><a href="#3-2-间隙锁导致的死锁案例" class="headerlink" title="3.2 间隙锁导致的死锁案例"></a>3.2 间隙锁导致的死锁案例</h2><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1634653283134.webp"></p><ol><li><p>session A 执行select … for update语句，由于id&#x3D;9这一行并不存在，因此会加上间隙锁(5,10);</p></li><li><p>session B 执行select … for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；</p></li><li><p>session B 试图插入一行(9,9,9)，被session A的间隙锁挡住了，只好进入等待；</p></li><li><p>session A试图插入一行(9,9,9)，被session B的间隙锁挡住了。</p></li></ol><p>至此，两个 session 进入互相等待状态，形成死锁。当然，InnoDB 的死锁检测马上就发现了这对死锁关系，让 session A 的 insert 语句报错返回了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[转载] 进程的虚拟地址空间分布</title>
    <link href="/2021/10/04/zhuan-zai-jin-cheng-de-xu-ni-di-zhi-kong-jian-fen-bu/"/>
    <url>/2021/10/04/zhuan-zai-jin-cheng-de-xu-ni-di-zhi-kong-jian-fen-bu/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/Joezzz/p/9803344.html">https://www.cnblogs.com/Joezzz/p/9803344.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[转载] Mac 通过DOSBox搭建汇编环境（附编译、链接、执行、调试详细过程）</title>
    <link href="/2021/10/04/mac-tong-guo-dosbox-da-jian-hui-bian-huan-jing-fu-bian-yi-lian-jie-zhi-xing-diao-shi-xiang-xi-guo-cheng/"/>
    <url>/2021/10/04/mac-tong-guo-dosbox-da-jian-hui-bian-huan-jing-fu-bian-yi-lian-jie-zhi-xing-diao-shi-xiang-xi-guo-cheng/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_41855420/article/details/103746234">https://blog.csdn.net/qq_41855420/article/details/103746234</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>39. 组合总和</title>
    <link href="/2021/09/25/39-zu-he-zong-he/"/>
    <url>/2021/09/25/39-zu-he-zong-he/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。</p><p>candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 </p><p>对于给定的输入，保证和为 target 的唯一组合数少于 150 个。</p><p>示例 1：<br>输入: candidates &#x3D; [2,3,6,7], target &#x3D; 7<br>输出: [[7],[2,2,3]]</p><p>示例 2：<br>输入: candidates &#x3D; [2,3,5], target &#x3D; 8<br>输出: [[2,2,2,2],[2,3,3],[3,5]]</p><p>示例 3：<br>输入: candidates &#x3D; [2], target &#x3D; 1<br>输出: []</p><p>示例 4：<br>输入: candidates &#x3D; [1], target &#x3D; 1<br>输出: [[1]]</p><p>示例 5：<br>输入: candidates &#x3D; [1], target &#x3D; 2<br>输出: [[1,1]]</p><p>提示：<br>1 &lt;&#x3D; candidates.length &lt;&#x3D; 30<br>1 &lt;&#x3D; candidates[i] &lt;&#x3D; 200<br>candidate 中的每个元素都是独一无二的。<br>1 &lt;&#x3D; target &lt;&#x3D; 500</p></blockquote><h1 id="方法-1-回溯"><a href="#方法-1-回溯" class="headerlink" title="方法 1 回溯"></a>方法 1 回溯</h1><p>递归树如下：（以 candidates &#x3D; [2,3,6,7], target &#x3D; 7 为例）<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1632580624361.png"> </p><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> tmp []<span class="hljs-type">int</span><br>    backtrack(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, tmp, &amp;res)<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(c []<span class="hljs-type">int</span>, t, sum, start <span class="hljs-type">int</span>, tmp []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> sum == t &#123;<br>        tmpp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(tmp))<br>        <span class="hljs-built_in">copy</span>(tmpp, tmp)<br>        *res = <span class="hljs-built_in">append</span>(*res, tmpp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> sum &gt; t &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(c); i++ &#123;<br>        tmp = <span class="hljs-built_in">append</span>(tmp, c[i])<br>        sum += c[i]<br>        fmt.Println(tmp)<br>        backtrack(c, t, sum, i, tmp, res)<br>        tmp = tmp[:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]<br>        sum -= c[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 批量 kill 进程</title>
    <link href="/2021/09/21/linux-pi-liang-kill-jin-cheng/"/>
    <url>/2021/09/21/linux-pi-liang-kill-jin-cheng/</url>
    
    <content type="html"><![CDATA[<h1 id="命令："><a href="#命令：" class="headerlink" title="命令："></a>命令：</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep name | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill<br></code></pre></td></tr></table></figure><h1 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h1><p><code>ps -ef</code>：查看全格式的全部进程</p><p><code>grep name</code>：将 ps -ef 的输出作为输入，过滤出其中包含 ”name“ 的结果</p><p><code>grep -v grep</code>：-v 代表反向选择，这条是比较迷惑的，为什么要加这条语句呢？因为之前的 <code>grep name</code> 这句话本身也会创建一个进程，并且该进程中也会包含 “name” 这个字段，所以 <code>grep name</code> 输出的列表中也会包含其自身的进程，但是该进程在 grep 执行之后就会退出，如果此时再将其 kill，会产生 <code>kill: 32169: No such process</code> 错误。所以这里需要使用 -v grep，反向选择，选择出不包含 grep 的条目</p><p><code>awk</code>：ps 输出的命令包含了 root、pid 等多个字段，但是 kill 只需要 pid 字段，通过该命令，可以筛选出需要的 pid，$2 表示每行第二个变量，在这个例子中就是进程号</p><p><code>xargs</code>：表示用前面命令的输出结果（也就是一系列的进程号）作为 kill 命令的参数</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>使用 go 进行实践<br>首先创建出任意一个二进制文件，这里使用 go 编写一个简单程序，并编译出来，文件名为 sleep.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(time.Hour)<br>&#125;<br></code></pre></td></tr></table></figure><p>编译为二进制：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go build sleep.go<br></code></pre></td></tr></table></figure><p>编译出来的二进制文件名为 sleep</p><p>再创建一个 go 程序，用来创建多个进程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os/exec&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-number">100</span>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>cmd := exec.Command(<span class="hljs-string">&quot;./sleep&quot;</span>)<br>_, err := cmd.CombinedOutput()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalln(err)<br>&#125;<br>&#125;()<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>此时执行 <code>ps -ef | grep sleep</code>，终端输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">501 32764  1880   0 10:16下午 ttys000    0:00.01 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox sleep<br>501 32660 32659   0 10:16下午 ttys009    0:00.01 ./sleep<br>501 32661 32659   0 10:16下午 ttys009    0:00.01 ./sleep<br>501 32662 32659   0 10:16下午 ttys009    0:00.01 ./sleep<br>501 32663 32659   0 10:16下午 ttys009    0:00.01 ./sleep<br>.... 省略<br></code></pre></td></tr></table></figure><p>注意，这里的第一条就是 grep 自身的进程</p><p>我们尝试一下，不加 <code>grep -v grep</code> 会怎么样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep sleep | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill: 32772: No such process<br></code></pre></td></tr></table></figure><p>运行出错了（这里比较疑惑的是，为什么不是 32764？）</p><p>此时再执行 <code>ps -ef | grep sleep</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">501 32784  1880   0 10:17下午 ttys000    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox sleep<br></code></pre></td></tr></table></figure><p>发现还有一条没被 kill 掉</p><p>而如果使用 <code>ps -ef | grep name | grep -v grep | awk &#39;&#123;print $2&#125;&#39; | xargs kill</code>，则不会产生错误，并且所有带有 ”sleep“ 的进程都被 kill 掉了</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 为什么使用 B+ 树</title>
    <link href="/2021/09/11/mysql-wei-shi-me-shi-yong-b-shu/"/>
    <url>/2021/09/11/mysql-wei-shi-me-shi-yong-b-shu/</url>
    
    <content type="html"><![CDATA[<h1 id="B-树和-B-树的区别"><a href="#B-树和-B-树的区别" class="headerlink" title="B 树和 B+ 树的区别"></a>B 树和 B+ 树的区别</h1><p><strong>来源：<a href="https://draveness.me/whys-the-design-mysql-b-plus-tree/">https://draveness.me/whys-the-design-mysql-b-plus-tree/</a></strong></p><p>B 树与 B+ 树的最大区别就是，B 树可以在非叶结点中存储数据，但是 B+ 树的 <strong>所有数据其实都存储在叶子节点中</strong>，当一个表底层的数据结构是 B 树时，假设我们需要访问所有『大于 4，并且小于 9 的数据』：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1631366394543.png"></p><p>如果不考虑任何优化，在上面的简单 B 树中我们需要进行 4 次磁盘的随机 I&#x2F;O 才能找到所有满足条件的数据行：</p><ol><li>加载根节点所在的页，发现根节点的第一个元素是 6，大于 4；</li><li>通过根节点的指针加载左子节点所在的页，遍历页面中的数据，找到 5；</li><li>重新加载根节点所在的页，发现根节点不包含第二个元素；</li><li>通过根节点的指针加载右子节点所在的页，遍历页面中的数据，找到 7 和 8；</li></ol><p>当然我们可以通过各种方式来对上述的过程进行优化，不过 B 树能做的优化 B+ 树基本都可以，所以我们不需要考虑优化 B 树而带来的收益，直接来看看什么样的优化 B+ 树可以做，而 B 树不行。</p><p>由于 <strong>所有的节点都可能包含目标数据</strong>，我们总是要 <strong>从根节点向下遍历子树</strong> 查找满足条件的数据行，这个特点带来了大量的 <strong>随机 I&#x2F;O</strong>，也是 B 树最大的性能问题。</p><p>B+ 树中就不存在这个问题了，因为 <strong>所有的数据行都存储在叶节点中</strong>，而这些叶节点可以 <strong>通过『指针』依次按顺序连接</strong>，当我们在如下所示的 B+ 树 <strong>遍历数据时可以直接在多个子节点之间进行跳转</strong>，这样能够节省大量的磁盘 I&#x2F;O 时间，也不需要在不同层级的节点之间对数据进行拼接和排序；通过一个 B+ 树最左侧的叶子节点，我们可以像链表一样遍历整个树中的全部数据，我们也可以引入双向链表保证倒序遍历时的性能。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1631366964858.png"></p><p>我的理解：因为 B+ 树把所有数据存储在了叶节点，并且叶节点全部连接起来形成了一个 <strong>双向链表</strong>，所以在 <strong>范围查找</strong> 时特别高效，只需要通过指针前后移动即可，这也是其相对于 B 树而言最大的优势，不再需要像 B 树那样进行回溯操作了</p><blockquote><p>疑问：</p><p>叶子结点用类似链表的方式通过指针连接起来，那叶子结点也是一个磁盘页吗？如果是的话，通过指针移动不也是在做 IO 操作吗？（对存储的知识不懂）</p><p>貌似是这样的，指针移动也是在做 IO 操作，但是相比 B 树的回溯操作来说，指针移动的次数更稳定，通常也更少</p></blockquote><p><strong>补充一点</strong></p><p>B+ 树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确</p><p>这个很好理解，由于 B 树节点内部每个 key 都带着 data 域，而 B+ 树节点只存储 key 的副本，真实的 key 和 data 域都在叶子节点存储。前面说过磁盘是分 block 的，一次磁盘 IO 会读取若干个 block，具体和操作系统有关，那么由于磁盘 IO 数据大小是固定的，在一次 IO 中，单个元素越小，量就越大。这就意味着 B+ 树单次磁盘 IO 的信息量大于 B- 树，从这点来看 B+ 树相对 B- 树磁盘 IO 次数少。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>来源：<a href="https://leetcode-cn.com/circle/discuss/F7bKlM/">https://leetcode-cn.com/circle/discuss/F7bKlM/</a></strong></p><p><strong>1. B+ 树和 B 树的区别？</strong><br>B 树非叶子结点和叶子结点都存储数据，因此查询数据时，时间复杂度最好为 O(1)，最坏为 O(log n)。<br>B+ 树只在叶子结点存储数据，非叶子结点存储关键字，且不同非叶子结点的关键字可能重复，因此查询数据时，时间复杂度固定为 O(log n)。</p><p>B+ 树叶子结点之间用链表相互连接，因而只需扫描叶子结点的链表就可以完成一次遍历操作，B 树只能通过中序遍历。</p><p><strong>2. 为什么 B+ 树比 B 树更适合应用于数据库索引？</strong><br>B+ 树更加适应磁盘的特性，相比 B 树减少了 I&#x2F;O 读写的次数。由于索引文件很大因此索引文件存储在磁盘上，B+ 树的非叶子结点只存关键字不存数据，因而<strong>单个页可以存储更多的关键字</strong>，即<strong>一次性读入内存的需要查找的关键字也就越多</strong>，磁盘的随机 I&#x2F;O 读取次数相对就减少了。</p><p>B+ 树的查询效率相比 B树 更加稳定，由于数据只存在在叶子结点上，所以查找效率固定为 O(log n)。</p><p>B+ 树叶子结点之间用链表有序连接，所以扫描全部数据只需扫描一遍叶子结点，<strong>利于扫库和范围查询</strong>；B 树由于非叶子结点也存数据，所以只能通过中序遍历按序来扫。也就是说，对于范围查询和有序遍历而言，B+ 树的效率更高。</p><h1 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h1><h2 id="为什么不使用二叉搜索树？"><a href="#为什么不使用二叉搜索树？" class="headerlink" title="为什么不使用二叉搜索树？"></a>为什么不使用二叉搜索树？</h2><p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树，其原因是，<strong>索引不止存在内存中，还要写到磁盘上</strong>。</p><p>你可以想象一下一棵 100 万节点的平衡二叉树，树高 20（2^20 &#x3D; 1048576）。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。</p><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用 N 叉树。这里，N 叉树中的 N 取决于数据块的大小。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac 下构建基于 C++ 的 gRPC</title>
    <link href="/2021/08/31/mac-xia-gou-jian-ji-yu-c-de-grpc/"/>
    <url>/2021/08/31/mac-xia-gou-jian-ji-yu-c-de-grpc/</url>
    
    <content type="html"><![CDATA[<p>来源于官方文档（<a href="https://grpc.io/docs/languages/cpp/quickstart/%EF%BC%89%EF%BC%8C%E4%BD%86%E6%98%AF%E5%85%B6%E4%B8%AD%E6%9C%89%E4%B8%80%E4%BA%9B%E5%9D%91%EF%BC%8C%E7%89%B9%E6%AD%A4%E8%AE%B0%E5%BD%95%EF%BC%8C%E7%B3%BB%E7%BB%9F%E4%B8%BA">https://grpc.io/docs/languages/cpp/quickstart/），但是其中有一些坑，特此记录，系统为</a> macOS 11.0.1 (20B29)：</p><h1 id="1-设置目录（很重要，必须执行该步骤）"><a href="#1-设置目录（很重要，必须执行该步骤）" class="headerlink" title="1. 设置目录（很重要，必须执行该步骤）"></a>1. 设置目录（很重要，必须执行该步骤）</h1><p>选择一个目录来保存本地安装的软件包。此页面假定环境变量MY_INSTALL_DIR包含此目录路径。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">export MY_INSTALL_DIR=$HOME/.local<br>mkdir -p $MY_INSTALL_DIR<br>export PATH=&quot;$MY_INSTALL_DIR/bin:$PATH&quot;<br></code></pre></td></tr></table></figure><p>这一步没什么好说的，照着文档做就好。</p><h1 id="2-安装-cmake"><a href="#2-安装-cmake" class="headerlink" title="2. 安装 cmake"></a>2. 安装 cmake</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew install cmake<br></code></pre></td></tr></table></figure><h1 id="3-安装构建-gRPC-所需的基本工具"><a href="#3-安装构建-gRPC-所需的基本工具" class="headerlink" title="3. 安装构建 gRPC 所需的基本工具"></a>3. 安装构建 gRPC 所需的基本工具</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew install autoconf automake libtool pkg-config<br></code></pre></td></tr></table></figure><h1 id="4-从-GitHub-上-clone-gRPC-源码"><a href="#4-从-GitHub-上-clone-gRPC-源码" class="headerlink" title="4. 从 GitHub 上 clone gRPC 源码"></a>4. 从 GitHub 上 clone gRPC 源码</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone --recurse-submodules -b v1.38.0 https://github.com/grpc/grpc<br></code></pre></td></tr></table></figure><h1 id="5-构建和安装-gRPC、Protocol-Buffers-和-Abseil"><a href="#5-构建和安装-gRPC、Protocol-Buffers-和-Abseil" class="headerlink" title="5. 构建和安装 gRPC、Protocol Buffers 和 Abseil"></a>5. 构建和安装 gRPC、Protocol Buffers 和 Abseil</h1><p>以下来自官方，但是需要修改一些内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> grpc</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> -p cmake/build</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">pushd</span> cmake/build</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmake -DgRPC_INSTALL=ON \</span><br><span class="language-bash">      -DgRPC_BUILD_TESTS=OFF \</span><br><span class="language-bash">      -DCMAKE_INSTALL_PREFIX=<span class="hljs-variable">$MY_INSTALL_DIR</span> \</span><br><span class="language-bash">      ../..</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make -j</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make install</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">popd</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> -p third_party/abseil-cpp/cmake/build</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">pushd</span> third_party/abseil-cpp/cmake/build</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmake -DCMAKE_INSTALL_PREFIX=<span class="hljs-variable">$MY_INSTALL_DIR</span> \</span><br><span class="language-bash">      -DCMAKE_POSITION_INDEPENDENT_CODE=TRUE \</span><br><span class="language-bash">      ../..</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make -j</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make install</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">popd</span></span><br></code></pre></td></tr></table></figure><p>这一步遇到的问题比较多。<br>问题 1：<br>执行第一个 <code>make install</code> 后产生如下错误：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment">-- Install configuration: &quot;&quot;</span><br>CMake Error <span class="hljs-keyword">at</span> cmake_install.cmake:<span class="hljs-number">41</span> (<span class="hljs-built_in">file</span>):<br>  <span class="hljs-built_in">file</span> cannot <span class="hljs-built_in">create</span> <span class="hljs-built_in">directory</span>: /lib.  Maybe need administrative privileges.<br></code></pre></td></tr></table></figure><p>在网上查了下，是因为 macOS 从 big sur 开始就不允许对根目录进行读写操作了，一开始还以为要解决根目录的读写问题，后来在 GitHub 上找到了对应的 issues（<a href="https://github.com/grpc/grpc/issues/24660%EF%BC%89%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%98%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E8%BF%B0%E6%96%87%E7%AB%A0%E4%B8%80%E5%BC%80%E5%A7%8B%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF**%E8%AE%BE%E7%BD%AE%E7%9B%AE%E5%BD%95**%E3%80%82%EF%BC%88%E8%BF%98%E5%A5%BD%E6%B2%A1%E6%8A%98%E8%85%BE%E7%B3%BB%E7%BB%9F%EF%BC%89">https://github.com/grpc/grpc/issues/24660），解决方法是执行上述文章一开始的第一步，也就是**设置目录**。（还好没折腾系统）</a></p><p>问题 2:<br><code>make -j</code> 电脑直接卡死<br>还没找到原因，不过找到了解决方法：<code>make -j 4</code> ，即在 j 的后面指定一个数字即可，这个数字貌似代表的意思是开启多个线程，并发的进行编译。（难道不加数字的话默认开启最大线程？）</p><p>问题 3：<br>执行第二个 <code>make install</code> 后产生如下错误：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">3</span> warnings and <span class="hljs-number">9</span> errors generated.<br>make[<span class="hljs-number">2</span>]: *** [absl<span class="hljs-regexp">/base/</span>CMakeFiles<span class="hljs-regexp">/log_severity.dir/</span>log_severity.cc.o] Error <span class="hljs-number">1</span><br>make[<span class="hljs-number">1</span>]: *** [absl<span class="hljs-regexp">/base/</span>CMakeFiles<span class="hljs-regexp">/log_severity.dir/</span>all] Error <span class="hljs-number">2</span><br><span class="hljs-number">15</span> warnings and <span class="hljs-number">20</span> errors generated.<br><span class="hljs-number">15</span> warnings and <span class="hljs-number">20</span> errors generated.<br>make[<span class="hljs-number">2</span>]: *** [absl<span class="hljs-regexp">/time/</span>CMakeFiles<span class="hljs-regexp">/civil_time.dir/i</span>nternal<span class="hljs-regexp">/cctz/</span>src/civil_time_detail.cc.o] Error <span class="hljs-number">1</span><br>make[<span class="hljs-number">2</span>]: *** [absl<span class="hljs-regexp">/time/</span>CMakeFiles<span class="hljs-regexp">/time_zone.dir/i</span>nternal<span class="hljs-regexp">/cctz/</span>src/time_zone_format.cc.o] Error <span class="hljs-number">1</span><br>make[<span class="hljs-number">1</span>]: *** [absl<span class="hljs-regexp">/time/</span>CMakeFiles<span class="hljs-regexp">/civil_time.dir/</span>all] Error <span class="hljs-number">2</span><br><span class="hljs-number">15</span> warnings and <span class="hljs-number">20</span> errors generated.<br><span class="hljs-number">15</span> warnings and <span class="hljs-number">20</span> errors generated.<br><span class="hljs-number">15</span> warnings and <span class="hljs-number">20</span> errors generated.<br>make[<span class="hljs-number">2</span>]: *** [absl<span class="hljs-regexp">/time/</span>CMakeFiles<span class="hljs-regexp">/time_zone.dir/i</span>nternal<span class="hljs-regexp">/cctz/</span>src/time_zone_if.cc.o] Error <span class="hljs-number">1</span><br>make[<span class="hljs-number">2</span>]: *** [absl<span class="hljs-regexp">/time/</span>CMakeFiles<span class="hljs-regexp">/time_zone.dir/i</span>nternal<span class="hljs-regexp">/cctz/</span>src/time_zone_lookup.cc.o] Error <span class="hljs-number">1</span><br>make[<span class="hljs-number">2</span>]: *** [absl<span class="hljs-regexp">/time/</span>CMakeFiles<span class="hljs-regexp">/time_zone.dir/i</span>nternal<span class="hljs-regexp">/cctz/</span>src/time_zone_info.cc.o] Error <span class="hljs-number">1</span><br><span class="hljs-number">15</span> warnings and <span class="hljs-number">20</span> errors generated.<br>make[<span class="hljs-number">2</span>]: *** [absl<span class="hljs-regexp">/time/</span>CMakeFiles<span class="hljs-regexp">/time_zone.dir/i</span>nternal<span class="hljs-regexp">/cctz/</span>src/time_zone_impl.cc.o] Error <span class="hljs-number">1</span><br>make[<span class="hljs-number">1</span>]: *** [absl<span class="hljs-regexp">/time/</span>CMakeFiles<span class="hljs-regexp">/time_zone.dir/</span>all] Error <span class="hljs-number">2</span><br>make: *** [all] Error <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>总而言之就是编译失败，解决方法是：<br>将第二个 cmake 替换为如下语句，就是多加了一行 <code>-DCMAKE_CXX_STANDARD=11 </code>，指定使用 c++ 11 进行编译。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake -DCMAKE_INSTALL_PREFIX=$MY_INSTALL_DIR \<br>      -DCMAKE_POSITION_INDEPENDENT_CODE=TRUE \<br>      -DCMAKE_CXX_STANDARD=11 \<br>      ../..<br></code></pre></td></tr></table></figure><p>记得如果之前已经执行过 cmake，则需要先清除（<code>rm -rf third_party/abseil-cpp/cmake/build</code>，再执行 <code>mkdir -p third_party/abseil-cpp/cmake/build</code>），再重新执行上面的 cmake 语句。之后就可以正确的 make install 了。</p><p>之后就可以愉快的开始构建示例了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd examples/cpp/helloworld<br>mkdir -p cmake/build<br>pushd cmake/build<br>cmake -DCMAKE_PREFIX_PATH=$MY_INSTALL_DIR ../..<br>make -j<br></code></pre></td></tr></table></figure><p>构建完成后，运行服务端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">运行服务器：</span><br>./greeter_server<br></code></pre></td></tr></table></figure><p>新创建一个终端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./greeter_client<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">Greeter received</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Hello world</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>grpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 锁</title>
    <link href="/2021/08/29/mysql-suo/"/>
    <url>/2021/08/29/mysql-suo/</url>
    
    <content type="html"><![CDATA[<h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>语法：</p><ul><li><p>加锁：</p><p>  加读锁<br>  <code>LOCK TABLES [tablename] READ;</code>  </p><p>  加写锁<br>  <code>LOCK TABLES [tablename] WRITE;</code>  </p></li><li><p>释放锁：<br><code>UNLOCK TABLES;</code></p></li></ul><p>加锁后会阻塞其他线程的部分操作，同时也会对加锁线程进行一些限制，直到加锁的线程释放锁。</p><p>读锁和写锁的区别：<br>当加 <strong>读锁</strong> 后，其他线程的 <code>SELECT</code> 语句不会被阻塞，但是 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 这些写语句都会被阻塞。此外，加锁线程只能执行读语句，不能执行写语句， 否则会产生错误 <code>Table &#39;sort_demo&#39; was locked with a READ lock and can&#39;t be updated</code>。</p><p>当加 <strong>写锁</strong> 后，其他线程的读写语句都会被阻塞，但是加锁线程的读写语句都可以正常执行。</p><p>可以用 <code>unlock tables</code> 主动释放锁，也可以在客户端断开的时候自动释放。</p><p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 <strong>InnoDB</strong> 这种支持行锁的引擎，一般不使用 <code>lock tables</code> 命令来控制并发，毕竟锁住整个表的影响面还是太大。</p><h1 id="MDL-锁（元数据锁）"><a href="#MDL-锁（元数据锁）" class="headerlink" title="MDL 锁（元数据锁）"></a>MDL 锁（元数据锁）</h1><p><code>MDL</code> 不需要显式使用，在访问一个表的时候会被自动加上。<code>MDL</code> 的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，在 MySQL 5.5 版本中引入了 <code>MDL</code>，当对一个表做增删改查操作的时候，加 <code>MDL</code> 读锁；当要对表做结构变更操作的时候，加 <code>MDL</code> 写锁。</p><ul><li><p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</p></li><li><p>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p></li></ul><p>虽然 <code>MDL</code> 锁是系统默认会加的，但却是你不能忽略的一个机制。比如下面这个例子，我经常看到有人掉到这个坑里：给一个小表加个字段，导致整个库挂了。<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1630250653743.webp"></p><p>我们可以看到 <code>session A</code> 先启动，这时候会对表 t 加一个 MDL 读锁。由于 <code>session B </code> 需要的也是 MDL 读锁，因此可以正常执行。</p><p>之后 <code>session C</code> 会被 blocked，是因为 <code>session A</code> 的 MDL 读锁还没有释放，而 <code>session C</code> 需要 MDL 写锁，因此只能被阻塞。</p><p>如果只有 <code>session C</code> 自己被阻塞还没什么关系，但是之后 <strong>所有要在表 t 上新申请 MDL 读锁的请求</strong> 也会被 <code>session C</code> <strong>阻塞</strong>。前面我们说了，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。</p><p>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。</p><p>你现在应该知道了，事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到 <strong>整个事务提交后再释放</strong>。</p><blockquote><p>划重点：一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。事务一旦申请到 MDL 锁后，直到事务执行完才会将锁释放。</p></blockquote><p>基于上面的分析，我们来讨论一个问题，如何安全地给小表加字段？</p><p>首先我们要解决长事务，事务不提交，就会一直占着 <code>MDL</code> 锁。在 <code>MySQL</code> 的 <code>information_schema </code> 库的 <code>innodb_trx</code>  表中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 <code>DDL</code>，或者 <code>kill</code> 掉这个长事务。</p><p>但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</p><p>这时候 <code>kill</code> 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 <code>alter table</code> 语句里面<strong>设定等待时间</strong>，如果在这个指定的等待时间里面能够拿到 <code>MDL写锁</code> 最好，<strong>拿不到也不要阻塞后面的业务语句</strong>，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。</p><p><code>MariaDB</code> 已经合并了 <code>AliSQL</code> 的这个功能，所以这两个开源分支目前都支持 <code>DDL NOWAIT/WAIT n</code> 这个语法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tbl_name NOWAIT <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> ...<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tbl_name WAIT N <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> ... <br></code></pre></td></tr></table></figure><h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><p>顾名思义，全局锁就是对整个数据库实例加锁。<code>MySQL</code> 提供了一个加全局读锁的方法，命令是 <code>Flush tables with read lock (FTWRL)</code>。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：<strong>数据更新语句（数据的增删改）</strong>、<strong>数据定义语句（包括建表、修改表结构等）</strong> 和 <strong>更新类事务的提交语句</strong>。</p><p>如果要释放全局锁，则要执行这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlock tables<br></code></pre></td></tr></table></figure><p><strong>全局锁的典型使用场景是，做全库逻辑备份</strong>，也就是把整库每个表都 <code>select</code> 出来存成文本。</p><h1 id="记录锁-x2F-行锁"><a href="#记录锁-x2F-行锁" class="headerlink" title="记录锁&#x2F;行锁"></a>记录锁&#x2F;行锁</h1><h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version 字段的值一同读出，数据每更新一次，对此version值加 1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p><p>举例</p><p>1、数据库表设计</p><p>三个字段，分别是id, value, version</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,<span class="hljs-keyword">value</span>,version <span class="hljs-keyword">from</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>#&#123;id&#125;<br></code></pre></td></tr></table></figure><p>2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> <span class="hljs-keyword">TABLE</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">value</span><span class="hljs-operator">=</span><span class="hljs-number">2</span>,version<span class="hljs-operator">=</span>version<span class="hljs-operator">+</span><span class="hljs-number">1</span><br><span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>#&#123;id&#125; <span class="hljs-keyword">and</span> version<span class="hljs-operator">=</span>#&#123;version&#125;;<br></code></pre></td></tr></table></figure><p>举个例子，比如有下面两个事务：</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>select id,value,version from TABLE where id&#x3D;1，结果：version &#x3D; 1</td><td></td></tr><tr><td></td><td>select id,value,version from TABLE where id&#x3D;1，结果：version&#x3D;1</td></tr><tr><td>拿上面查询出来的 version 进行更新，update set version&#x3D;version+1 where version&#x3D;1，结果：version &#x3D; 2</td><td></td></tr><tr><td></td><td>update set version&#x3D;version+1 where version&#x3D;1，此时version已经被 A 更新成了 2，所以这条 sql 语句不会执行成功，从而避免旧数据覆盖新数据</td></tr></tbody></table><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1648548013859.webp"><br>这时候，事务A在等待事务B释放id&#x3D;2的行锁，而事务B在等待事务A释放id&#x3D;1的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。</p><h1 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h1><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="for-update-加行锁还是表锁？"><a href="#for-update-加行锁还是表锁？" class="headerlink" title="for update 加行锁还是表锁？"></a>for update 加行锁还是表锁？</h2><p>实验：<br>有如下表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> for_update_is_lock_row_or_lock_table(<br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>    d <span class="hljs-type">int</span>,<br>    c <span class="hljs-type">int</span>,<br>    key(c)c<br>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> for_update_is_lock_row_or_lock_table(d, c) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> for_update_is_lock_row_or_lock_table(d, c) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> for_update_is_lock_row_or_lock_table(d, c) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h3 id="实验-1-使用索引列作为条件查询"><a href="#实验-1-使用索引列作为条件查询" class="headerlink" title="实验 1 使用索引列作为条件查询"></a>实验 1 使用索引列作为条件查询</h3><p>事务1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> for_update_is_lock_row_or_lock_table <span class="hljs-keyword">set</span> d<span class="hljs-operator">=</span><span class="hljs-number">11</span> <span class="hljs-keyword">where</span> c<span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>事务2，更新同一列数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> for_update_is_lock_row_or_lock_table <span class="hljs-keyword">set</span> d<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">where</span> c<span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>结果上面（事务 2）的语句被阻塞</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> for_update_is_lock_row_or_lock_table <span class="hljs-keyword">set</span> d<span class="hljs-operator">=</span><span class="hljs-number">22</span> <span class="hljs-keyword">where</span> c<span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>但是这条语句不会被阻塞，说明此时加的是行锁。</p><h3 id="实验2-使用非索引列作为条件查询"><a href="#实验2-使用非索引列作为条件查询" class="headerlink" title="实验2 使用非索引列作为条件查询"></a>实验2 使用非索引列作为条件查询</h3><p>事务1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> for_update_is_lock_row_or_lock_table <span class="hljs-keyword">set</span> c<span class="hljs-operator">=</span><span class="hljs-number">11</span> <span class="hljs-keyword">where</span> d<span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>事务2:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> for_update_is_lock_row_or_lock_table <span class="hljs-keyword">set</span> c<span class="hljs-operator">=</span><span class="hljs-number">22</span> <span class="hljs-keyword">where</span> d<span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>被阻塞，此时不是同一行但却被阻塞，说明此时加的是表锁。</p><h3 id="TODO：如果是范围更新呢？"><a href="#TODO：如果是范围更新呢？" class="headerlink" title="TODO：如果是范围更新呢？"></a>TODO：如果是范围更新呢？</h3><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>如果查询条件涉及的列用了索引（或者是主键，主键当然也存在索引），那么 select ….. for update 就会加行锁。</p><p>如果是查询条件是普通字段（即没有索引&#x2F;不是主键），那么 select ….. for update 就会加表锁。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 的事务隔离级别</title>
    <link href="/2021/08/27/mysql-de-shi-wu-ge-chi-ji-bie/"/>
    <url>/2021/08/27/mysql-de-shi-wu-ge-chi-ji-bie/</url>
    
    <content type="html"><![CDATA[<h1 id="1-未提交读（脏读）"><a href="#1-未提交读（脏读）" class="headerlink" title="1. 未提交读（脏读）"></a>1. 未提交读（脏读）</h1><p>事务的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，称之为 <strong>脏读</strong>。它存在 4 个常见问题（脏读、不可重复读、幻读、丢失更新）。<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1630079564434.png"></p><h1 id="2-提交读（不可重复读）"><a href="#2-提交读（不可重复读）" class="headerlink" title="2. 提交读（不可重复读）"></a>2. 提交读（不可重复读）</h1><p>就是一个事务要等另一个事务提交后才能读取数据。 它解决了脏读问题，存在 3 个常见问题（不可重复读、幻读、丢失更新）。<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1630079641737.png"></p><p>新的问题：更新丢失（提交覆盖）<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1630079512354.png"></p><p>新的问题：不可重复读<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1630080187823.png"></p><p>新的问题：回滚丢失（回滚覆盖）<br>和 <strong>更新丢失</strong> 一样，撤消一个事务时，在该事务内的写操作要回滚，把其它已提交的事务写入的数据覆盖了。</p><h1 id="3-可重复读"><a href="#3-可重复读" class="headerlink" title="3. 可重复读"></a>3. 可重复读</h1><p>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。<br>就是在开始读取数据（事务开启）时，不再允许修改操作 。它解决了脏读和不可重复读，还存在2个常见问题（幻读、丢失更新）。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1630296234940.png"></p><p>实现原理：<br>数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</p><p>适用场景：<br>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><p>这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p><blockquote><p>Tips： 幻读和不可重复读的区别<br>摘自网上：<br>(1)<br><strong>不可重复读</strong> 主要是说多次读取一条记录, 发现该记录中某些列值被修改过<br> <strong>幻读</strong> 主要是说多次读取一个范围内的记录(包括直接查询所有记录结果或者做聚合统计), 发现结果<br>不一致(标准档案一般指记录增多, 记录的减少应该也算是幻读)。<br>(2)<br>幻读问题对应的是插入 <code>INSERT</code> 操作<br>“幻读”是指读的过程中，某些元组被增加或删除，这样进行一些集合操作，比如算总数，平均值等等，就<br>会每次算出不一样的数。所以“不可重复读”和“幻读”都是读的过程中数据前后不一致，只是前者侧重于修<br>改，后者侧重于增删。个人认为，严格来讲“幻读”可以被称为“不可重复读”的一种特殊情况，没错的。但<br>是从数据库管理的角度来看二者是有区别的。解决“不可重复读”只要加行级锁就可以了。而解决“幻读”则<br>需要加表级锁，或者采用其他更复杂的技术，总之代价要大许多。这是搞数据库的那帮家伙非要把这两者<br>区分开的动机吧。</p></blockquote><h1 id="4-可串行化"><a href="#4-可串行化" class="headerlink" title="4. 可串行化"></a>4. 可串行化</h1><p>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p><p>串行化是最高的隔离级别，会强制事务串行执行，它将隔离问题全部解决，但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1630293732934.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[牛客][笔试题] 兔子繁衍</title>
    <link href="/2021/08/21/niu-ke-bi-shi-ti-tu-zi-fan-yan/"/>
    <url>/2021/08/21/niu-ke-bi-shi-ti-tu-zi-fan-yan/</url>
    
    <content type="html"><![CDATA[<p>有一对兔子，从出生后的第五个月起每月生出一对小兔子（即满4月就开始生小兔），小兔子也会出生从第五个月起每月生一对小免子。假如兔子不会死，第n个月时，兔群有多少对兔子。</p><p>输入描述:<br>第n月（n为自然数，n&lt;101）</p><p>输出描述:<br>第 n 个月时，兔子的对数（免群的兔子有多少对兔子）。<br>示例 1<br>输入<br>5<br>输出<br>2<br>说明<br>第五个月时，有两对兔子</p><h1 id="方法1-动态规划"><a href="#方法1-动态规划" class="headerlink" title="方法1 动态规划"></a>方法1 动态规划</h1><p>ACM 模式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rabbit</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span><br>    dp[<span class="hljs-number">3</span>] = <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">4</span>; i &lt; n; i++ &#123;<br>        dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-4</span>]<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> input <span class="hljs-type">int</span><br>    fmt.Scan(&amp;input)<br>    v := rabbit(input)<br>    fmt.Println(v)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis zset 源码阅读</title>
    <link href="/2021/08/17/redis-zset-yuan-ma-yue-du/"/>
    <url>/2021/08/17/redis-zset-yuan-ma-yue-du/</url>
    
    <content type="html"><![CDATA[<h1 id="types"><a href="#types" class="headerlink" title="types"></a>types</h1><h2 id="zskiplistNode"><a href="#zskiplistNode" class="headerlink" title="zskiplistNode"></a>zskiplistNode</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span><br>    sds ele;    <span class="hljs-comment">// 成员</span><br>    <span class="hljs-type">double</span> score;   <span class="hljs-comment">// 分值</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span> <span class="hljs-comment">// 后退指针</span><br>    <span class="hljs-comment">// 层</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span>  <span class="hljs-comment">// 前进指针</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> span; <span class="hljs-comment">// 跨度</span><br>    &#125; level[];<br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><h2 id="zskiplist"><a href="#zskiplist" class="headerlink" title="zskiplist"></a>zskiplist</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br>    <span class="hljs-type">int</span> level;  <span class="hljs-comment">// 当前跳跃表内，层数最大的那个节点的层数</span><br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zset</span> &#123;</span><br>    dict *dict;<br>    zskiplist *zsl;<br>&#125; zset;<br></code></pre></td></tr></table></figure><h1 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h1><h2 id="zslCreate"><a href="#zslCreate" class="headerlink" title="zslCreate"></a>zslCreate</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create a new skiplist. */</span><br>zskiplist *<span class="hljs-title function_">zslCreate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> j;<br>    zskiplist *zsl;<br><br>    zsl = zmalloc(<span class="hljs-keyword">sizeof</span>(*zsl));<br>    zsl-&gt;level = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始最高层数为 1</span><br>    zsl-&gt;length = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 不包含任何节点</span><br>    <span class="hljs-comment">// header 指向一个空节点，该节点的有 32 层（即 level[] 的长度为 32）</span><br>    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="hljs-number">0</span>,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 为头结点每层的属性进行初始化</span><br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;<br>        zsl-&gt;header-&gt;level[j].forward = <span class="hljs-literal">NULL</span>;<br>        zsl-&gt;header-&gt;level[j].span = <span class="hljs-number">0</span>;<br>    &#125;<br>    zsl-&gt;header-&gt;backward = <span class="hljs-literal">NULL</span>;<br>    zsl-&gt;tail = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> zsl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="zslInsert"><a href="#zslInsert" class="headerlink" title="zslInsert"></a>zslInsert</h2><p>向 <code>skiplist</code> 中插入一个节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Insert a new node in the skiplist. Assumes the element does not already</span><br><span class="hljs-comment"> * exist (up to the caller to enforce that). The skiplist takes ownership</span><br><span class="hljs-comment"> * of the passed SDS string &#x27;ele&#x27;. */</span><br><span class="hljs-comment">// score: 分数</span><br><span class="hljs-comment">// ele: 成员，是一个 sds 字符串类型</span><br>zskiplistNode *<span class="hljs-title function_">zslInsert</span><span class="hljs-params">(zskiplist *zsl, <span class="hljs-type">double</span> score, sds ele)</span> &#123;<br>    <span class="hljs-comment">// update 用来保存每层的某个节点，该节点是待插入节点的前一个节点，例如：</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// head</span><br>    <span class="hljs-comment">// level[2] ---- 1---------- 6 ----- 10</span><br>    <span class="hljs-comment">// level[1] ---- 1 ----- 4 - 6 ----- 10    插入一个 7</span><br>    <span class="hljs-comment">// level[0] ---- 1 - 2 - 4 - 6 - 8 - 10</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 这里先不说明插入的详细过程，只通过上面的跳表就可以知道，7 会被插入到 6 的后面，</span><br>    <span class="hljs-comment">// 并且假设 7 的高度为 3，此时的 update 数组内容如下所示：</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// update[2] = 6，代表第三层的 6 是待插入节点 7 的前一个节点。</span><br>    <span class="hljs-comment">// update[1] = 6, update[0] = 6，同理。之后会遍历 update 数组，并将数组中每个元素</span><br>    <span class="hljs-comment">// 的 forward 指向新节点。</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 最终结果为：</span><br>    <span class="hljs-comment">// head</span><br>    <span class="hljs-comment">// level[2] ---- 1 --------- 6 - 7 ----- 10</span><br>    <span class="hljs-comment">// level[1] ---- 1 ----- 4 - 6 - 7 ----- 10    插入一个 7</span><br>    <span class="hljs-comment">// level[0] ---- 1 - 2 - 4 - 6 - 7 - 8 - 10</span><br>    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rank[ZSKIPLIST_MAXLEVEL];<br>    <span class="hljs-type">int</span> i, level;<br><br>    serverAssert(!isnan(score));<br>    x = zsl-&gt;header;<br>    <span class="hljs-comment">// 从 zsl 的最高层开始查找，并不断下降，直到最后到达第 1 层</span><br>    <span class="hljs-comment">// Tips: 什么是最高层？</span><br>    <span class="hljs-comment">// 比如 zsl 当前有 3 个节点（不算头结点），每个节点的层数</span><br>    <span class="hljs-comment">// 分别为 4，2，5，那么 zsl-&gt;level 就是节点中层数最高的 5</span><br>    <span class="hljs-keyword">for</span> (i = zsl-&gt;level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">/* store rank that is crossed to reach the insert position */</span><br>        rank[i] = i == (zsl-&gt;level<span class="hljs-number">-1</span>) ? <span class="hljs-number">0</span> : rank[i+<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 循环需要满足的条件如下：</span><br>        <span class="hljs-comment">// 1. level[i] 前进指针指向一个非 null 节点，且前进指针指向的节点的分值</span><br>        <span class="hljs-comment">// 小于当前插入值的分值，那么就可以向前移动，继续查找，例如有如下跳表：</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// head</span><br>        <span class="hljs-comment">// level[2] ---- 1---------- 4 ----- 6</span><br>        <span class="hljs-comment">// level[1] ---- 1 ----- 3 - 4 ----- 6    插入一个 8</span><br>        <span class="hljs-comment">// level[0] ---- 1 - 2 - 3 - 4 - 5 - 6</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 此时跳表的 level 为 3（此时外层的 for 循环中的 i = 3-1 = 2），</span><br>        <span class="hljs-comment">// 从 head 的 level[3-1] 开始找起，level[2] 的前进指针指向了 1，不为空，</span><br>        <span class="hljs-comment">// 且要插入的节点分值为 8，大于 1，所以可以将 x 移动到当前节点的 forward 节点，</span><br>        <span class="hljs-comment">// 即移动到 4。</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 4 还是小于 8，继续向前移动，移动到 6，此时 6 的前进指针为 null，所以不会进入</span><br>        <span class="hljs-comment">// while 循环了，继续向下执行，update[2] = x = 当前节点 6。至此，此轮 for 循环</span><br>        <span class="hljs-comment">// 结束。</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 继续进行第二轮 for 循环，此时 i = 1，这代表着现在降到了跳表的第二层。第二层的</span><br>        <span class="hljs-comment">// 6 依然指向 null，所以不进入 while，update[1] = 当前节点 6。</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 第三轮 for 循环，此时 i = 0，这代表已经来到了跳表的第一层，此时的 6 依然指向</span><br>        <span class="hljs-comment">// null，update[0] = 6。</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 2. level[i] 前进指针指向一个非 null 节点，且前进指针指向的节点的分值</span><br>        <span class="hljs-comment">// 等于当前插入值的分值，也就是遇到了分值一样的情况了，此时会继续判断二者的</span><br>        <span class="hljs-comment">// 成员值，因为成员值是一个字符串，所以会根据字典顺序进行比较，如果 forward</span><br>        <span class="hljs-comment">// 的成员值小于要插入的成员值，则继续向前移动。</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 简单的说，如果分值相同，会继续根据成员值进行判断。</span><br>        <span class="hljs-comment">// 比如：</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//   节点 1           节点 2     （省略头结点，头节点指向节点 1）</span><br>        <span class="hljs-comment">// +--------+       +--------+</span><br>        <span class="hljs-comment">// +   l3   + ----&gt; +   l3   +</span><br>        <span class="hljs-comment">// +   l2   + ----&gt; +   l2   +</span><br>        <span class="hljs-comment">// +   l1   + ----&gt; +   l1   +      添加一个新节点，成员值为 bbbbb，</span><br>        <span class="hljs-comment">// +  30.0  + ----&gt; +  50.0  +      分值为 30.0</span><br>        <span class="hljs-comment">// +  aaaaa + ----&gt; + ccccc  +</span><br>        <span class="hljs-comment">// +--------+       +--------+</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 开始会从头结点开始查找，找到节点 1，发现节点 1 的 score 为 30.0，继续判断成员值，</span><br>        <span class="hljs-comment">// 因为 bbbbb &gt; aaaaa，所以移动到节点 1，看后一个节点 节点 2 的 score 值，因为</span><br>        <span class="hljs-comment">// 50 &gt; 30，所以停止移动，新节点将插入到节点 1 的后面</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//   节点 1           新节点</span><br>        <span class="hljs-comment">// +--------+       +--------+</span><br>        <span class="hljs-comment">// +   l3   + ----&gt; +   l3   +</span><br>        <span class="hljs-comment">// +   l2   + ----&gt; +   l2   +</span><br>        <span class="hljs-comment">// +   l1   + ----&gt; +   l1   +</span><br>        <span class="hljs-comment">// +  30.0  + ----&gt; +  30.0  +</span><br>        <span class="hljs-comment">// +  aaaaa + ----&gt; + bbbbb  +</span><br>        <span class="hljs-comment">// +--------+       +--------+</span><br>        <span class="hljs-keyword">while</span> (x-&gt;level[i].forward &amp;&amp;   <span class="hljs-comment">// level[i] 的前进指针指向非 null 节点</span><br>                <span class="hljs-comment">// 如果插入节点的分值大于 level[i] 指向节点的分值</span><br>                (x-&gt;level[i].forward-&gt;score &lt; score ||<br>                    <span class="hljs-comment">// 插入节点分值等于 level[i] 指向节点的分值</span><br>                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;<br>                    <span class="hljs-comment">// level[i] 指向节点的 ele 小于插入节点的 ele</span><br>                    <span class="hljs-comment">// Tips: sdscmp(x, y), 当 x &lt; y 时，返回一个负数</span><br>                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="hljs-number">0</span>)))<br>        &#123;<br>            <span class="hljs-comment">//</span><br>            rank[i] += x-&gt;level[i].span;<br>            <span class="hljs-comment">// 移动到下一个节点</span><br>            x = x-&gt;level[i].forward;<br>        &#125;<br>        <span class="hljs-comment">// 记录当前层的待插入节点的前一个节点</span><br>        update[i] = x;<br>    &#125;<br>    <span class="hljs-comment">/* we assume the element is not already inside, since we allow duplicated</span><br><span class="hljs-comment">     * scores, reinserting the same element should never happen since the</span><br><span class="hljs-comment">     * caller of zslInsert() should test in the hash table if the element is</span><br><span class="hljs-comment">     * already inside or not. */</span><br>    level = zslRandomLevel();<br>    <span class="hljs-comment">// 如果随机生成的高度大于当前 zsl 的最大高度，那么会多出来独立的几层，需要连接起来，</span><br>    <span class="hljs-comment">// 例如下面这个例子，新插入一个 8，且 8 的随机层数为 5，那么就会多出来 2 层，这两</span><br>    <span class="hljs-comment">// 层是独立的，需要将其与 head 连接起来。</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//  head                                   8 （独立）</span><br>    <span class="hljs-comment">//                                         8 （独立）</span><br>    <span class="hljs-comment">// level[2] ---- 1---------- 4 ----- 6 --- 8</span><br>    <span class="hljs-comment">// level[1] ---- 1 ----- 3 - 4 ----- 6 --- 8</span><br>    <span class="hljs-comment">// level[0] ---- 1 - 2 - 3 - 4 - 5 - 6 --- 8</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 连接后：</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// head</span><br>    <span class="hljs-comment">// level[4] ------------------------------ 8</span><br>    <span class="hljs-comment">// level[3] ------------------------------ 8</span><br>    <span class="hljs-comment">// level[2] ---- 1---------- 4 ----- 6 --- 8</span><br>    <span class="hljs-comment">// level[1] ---- 1 ----- 3 - 4 ----- 6 --- 8</span><br>    <span class="hljs-comment">// level[0] ---- 1 - 2 - 3 - 4 - 5 - 6 --- 8</span><br>    <span class="hljs-keyword">if</span> (level &gt; zsl-&gt;level) &#123;<br>        <span class="hljs-comment">// 为多出的这几层进行连接</span><br>        <span class="hljs-keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;<br>            rank[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 独立的节点，那么需要用头结点作为 update</span><br>            update[i] = zsl-&gt;header;<br>            update[i]-&gt;level[i].span = zsl-&gt;length;<br>        &#125;<br>        <span class="hljs-comment">// 更新最大高度</span><br>        zsl-&gt;level = level;<br>    &#125;<br>    <span class="hljs-comment">// 创建一个节点</span><br>    x = zslCreateNode(level,score,ele);<br>    <span class="hljs-comment">// 将新节点的每一层与跳表中对应的那一层关联起来</span><br>    <span class="hljs-comment">// 比如：update[0] 指向 x[0]，update[1] 指向 x[1]</span><br>    <span class="hljs-comment">// 文字不好理解，看下面的图示：</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// head</span><br>    <span class="hljs-comment">// level[2] ---- 1---------- 4 ----- 8</span><br>    <span class="hljs-comment">// level[1] ---- 1 ----- 3 - 4 ----- 8    插入一个 7, 假设层数为 2</span><br>    <span class="hljs-comment">// level[0] ---- 1 - 2 - 3 - 4 - 5 - 8</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 因为层数为 2，所以 for 2 次，每次都会将 7 的层数关联起来</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// head</span><br>    <span class="hljs-comment">// level[2] ---- 1---------- 4 --------- 8</span><br>    <span class="hljs-comment">// level[1] ---- 1 ----- 3 - 4 ----- 7 - 8  第二次：4 指向 7，7 指向 8</span><br>    <span class="hljs-comment">// level[0] ---- 1 - 2 - 3 - 4 - 5 - 7 - 8  第一次循环，将 7 的第一层关联起来</span><br>    <span class="hljs-comment">//                                          5 指向 7，7 指向 8</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; level; i++) &#123;<br>        <span class="hljs-comment">// 就和链表的添加操作一样，要将 x 添加到 update 的后面，</span><br>        <span class="hljs-comment">// 需要先将 x 指向 update 的后一个节点，再将 update 指向 x</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// update -&gt; update.next, 要将 x 添加到 update 后面</span><br>        <span class="hljs-comment">// 1. x -&gt; update.next</span><br>        <span class="hljs-comment">// 2. update -&gt; x</span><br>        <span class="hljs-comment">// 结果：update -&gt; x -&gt; update.next</span><br>        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;<br>        update[i]-&gt;level[i].forward = x;<br><br>        <span class="hljs-comment">/* update span covered by update[i] as x is inserted here */</span><br>        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="hljs-number">0</span>] - rank[i]);<br>        update[i]-&gt;level[i].span = (rank[<span class="hljs-number">0</span>] - rank[i]) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* increment span for untouched levels */</span><br>    <span class="hljs-keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;<br>        update[i]-&gt;level[i].span++;<br>    &#125;<br><br>    <span class="hljs-comment">// 更新新添加节点的回退指针，如果 update[0] 是 header，那么就将回退指针设置为 null，</span><br>    <span class="hljs-comment">// 不是 header，则设置为 update[0]</span><br>    <span class="hljs-comment">// 这里为什么只有 update[0] 呢？因为每个节点只有一个后退指针，</span><br>    <span class="hljs-comment">// 所以这里只需为第 1 层设置后退节点</span><br>    x-&gt;backward = (update[<span class="hljs-number">0</span>] == zsl-&gt;header) ? <span class="hljs-literal">NULL</span> : update[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 将新节点的下一节点的 backward 指向新节点（如果有下一个节点的话）</span><br>    <span class="hljs-comment">// 就和双链表的添加操作一样</span><br>    <span class="hljs-keyword">if</span> (x-&gt;level[<span class="hljs-number">0</span>].forward)<br>        x-&gt;level[<span class="hljs-number">0</span>].forward-&gt;backward = x;<br>    <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 否则说明新节点是最后一个节点，此时更新 tail 为新节点</span><br>        zsl-&gt;tail = x;<br>    zsl-&gt;length++;  <span class="hljs-comment">// 节点数量 + 1</span><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="zslDeleteNode"><a href="#zslDeleteNode" class="headerlink" title="zslDeleteNode"></a>zslDeleteNode</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Internal function used by zslDelete, zslDeleteRangeByScore and</span><br><span class="hljs-comment"> * zslDeleteRangeByRank. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">zslDeleteNode</span><span class="hljs-params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">// 删除每层中的 x</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; zsl-&gt;level; i++) &#123;<br>        <span class="hljs-comment">// 如果 update 的下一个节点是 x </span><br>        <span class="hljs-keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;<br>            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 和链表的删除操作一样，将被删除的前一个节点指向要删除的后一个节点</span><br>            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            update[i]-&gt;level[i].span -= <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果被删除节点有下一个节点，将下一个节点的后退指针指向被删除节点的前一个节点</span><br>    <span class="hljs-keyword">if</span> (x-&gt;level[<span class="hljs-number">0</span>].forward) &#123;<br>        x-&gt;level[<span class="hljs-number">0</span>].forward-&gt;backward = x-&gt;backward;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 否则说明被删除节点是跳表中的最后一个节点，更新 tail 为被删除</span><br>        <span class="hljs-comment">// 节点的前一个</span><br>        zsl-&gt;tail = x-&gt;backward;<br>    &#125;<br>    <span class="hljs-comment">// 更新跳表的最大高度字段</span><br>    <span class="hljs-comment">// 从最高层开始，如果头结点在该层没有下一个节点，那么说明该层为空，level--，</span><br>    <span class="hljs-comment">// 循环删除所有空层</span><br>    <span class="hljs-keyword">while</span>(zsl-&gt;level &gt; <span class="hljs-number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="hljs-number">-1</span>].forward == <span class="hljs-literal">NULL</span>)<br>        zsl-&gt;level--;<br>    <span class="hljs-comment">// 更新跳表的节点数量    </span><br>    zsl-&gt;length--;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="zslDelete"><a href="#zslDelete" class="headerlink" title="zslDelete"></a>zslDelete</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Delete an element with matching score/element from the skiplist.</span><br><span class="hljs-comment"> * The function returns 1 if the node was found and deleted, otherwise</span><br><span class="hljs-comment"> * 0 is returned.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If &#x27;node&#x27; is NULL the deleted node is freed by zslFreeNode(), otherwise</span><br><span class="hljs-comment"> * it is not freed (but just unlinked) and *node is set to the node pointer,</span><br><span class="hljs-comment"> * so that it is possible for the caller to reuse the node (including the</span><br><span class="hljs-comment"> * referenced SDS string at node-&gt;ele). */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">zslDelete</span><span class="hljs-params">(zskiplist *zsl, <span class="hljs-type">double</span> score, sds ele, zskiplistNode **node)</span> &#123;<br>    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-comment">// 整体流程：</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// head</span><br>    <span class="hljs-comment">// level[4] ------------------------------ 8</span><br>    <span class="hljs-comment">// level[3] ------------------------------ 8</span><br>    <span class="hljs-comment">// level[2] ---- 1---------- 4 ----- 6 --- 8    删除 6</span><br>    <span class="hljs-comment">// level[1] ---- 1 ----- 3 - 4 ----- 6 --- 8</span><br>    <span class="hljs-comment">// level[0] ---- 1 - 2 - 3 - 4 - 5 - 6 --- 8</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 1. 先从最高处 level[4] 开始，下一个节点为 8，比 6 大，不满足 while 条件，</span><br>    <span class="hljs-comment">// x = head.level[4], update[4] = x，降到 level[3]</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 2. level[3] 和 [4] 情况一样，</span><br>    <span class="hljs-comment">// x = head.level[3], update[3] = x</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 3. level[2] 会从头结点前进到节点 4，</span><br>    <span class="hljs-comment">// x = 4, update[2] = x（其实当 score 相同时，还会继续比较 ele，这里省略）</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 4. level[1] =&gt; x = 4, update[1] = x</span><br>    <span class="hljs-comment">// 5. level[0] =&gt; x = 5, update[0] = x</span><br>    <span class="hljs-comment">// 至此，update 记录了被删除在每层的前一个节点，x 是第一层的被删除节点的前一个</span><br>    <span class="hljs-comment">// 节点</span><br><br>    <span class="hljs-comment">// 和插入操作一样，先查找跳表，找到被删除节点在每层的前一个节点</span><br>    x = zsl-&gt;header;<br>    <span class="hljs-keyword">for</span> (i = zsl-&gt;level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (x-&gt;level[i].forward &amp;&amp;<br>                (x-&gt;level[i].forward-&gt;score &lt; score ||<br>                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;<br>                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="hljs-number">0</span>)))<br>        &#123;<br>            x = x-&gt;level[i].forward;<br>        &#125;<br>        update[i] = x;<br>    &#125;<br><br>    <span class="hljs-comment">/* We may have multiple elements with the same score, what we need</span><br><span class="hljs-comment">     * is to find the element with both the right score and object. */</span><br>    <span class="hljs-comment">// 此时的 x 是被删除节点在第一层的前一个节点，获取 x 的下一个节点</span><br>    x = x-&gt;level[<span class="hljs-number">0</span>].forward;<br>    <span class="hljs-comment">// 如果 x 存在，且 score 和 ele 都相同，调用删除节点函数进行删除</span><br>    <span class="hljs-keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="hljs-number">0</span>) &#123;<br>        zslDeleteNode(zsl, x, update);<br>        <span class="hljs-keyword">if</span> (!node)<br>            zslFreeNode(x);<br>        <span class="hljs-keyword">else</span><br>            *node = x;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* not found */</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>数据结构</tag>
      
      <tag>跳表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1493. 删掉一个元素以后全为 1 的最长子数组</title>
    <link href="/2021/08/12/leetcode-1493-shan-diao-yi-ge-yuan-su-yi-hou-quan-wei-1-de-zui-chang-zi-shu-zu/"/>
    <url>/2021/08/12/leetcode-1493-shan-diao-yi-ge-yuan-su-yi-hou-quan-wei-1-de-zui-chang-zi-shu-zu/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给你一个二进制数组 nums ，你需要从中删掉一个元素。</p><p>请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。</p><p>如果不存在这样的子数组，请返回 0 。</p><p>提示 1：</p><p>输入：nums &#x3D; [1,1,0,1]<br>输出：3<br>解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。<br>示例 2：</p><p>输入：nums &#x3D; [0,1,1,1,0,1,1,0,1]<br>输出：5<br>解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。<br>示例 3：</p><p>输入：nums &#x3D; [1,1,1]<br>输出：2<br>解释：你必须要删除一个元素。<br>示例 4：</p><p>输入：nums &#x3D; [1,1,0,0,1,1,1,0,1]<br>输出：4<br>示例 5：</p><p>输入：nums &#x3D; [0,0,0]<br>输出：0</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5<br>nums[i] 要么是 0 要么是 1 。</p></blockquote><h1 id="方法-1-滑动窗口"><a href="#方法-1-滑动窗口" class="headerlink" title="方法 1 滑动窗口"></a>方法 1 滑动窗口</h1><p><img src="https://zengh1.github.io/post-images/1628786303953.png"></p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestSubarray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> (<br>        l, r          <span class="hljs-type">int</span><br>        windowHasZero <span class="hljs-type">bool</span>  <span class="hljs-comment">// 当前窗口内是否有 0</span><br>        zeroIndex     <span class="hljs-type">int</span><br>        res           <span class="hljs-type">int</span><br>    )<br><br>    <span class="hljs-keyword">for</span> r &lt; <span class="hljs-built_in">len</span>(nums) &#123;<br>        <span class="hljs-keyword">if</span> nums[r] == <span class="hljs-number">0</span> &amp;&amp; !windowHasZero &#123;<br>            windowHasZero = <span class="hljs-literal">true</span><br>            zeroIndex = r<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[r] == <span class="hljs-number">0</span> &amp;&amp; windowHasZero &#123;<br>            z := zeroIndex<br>            <span class="hljs-comment">// 更新当前位置为新的 zeroIndex</span><br>            zeroIndex = r<br>            res = max(res, r-l<span class="hljs-number">-1</span>)<br>            <span class="hljs-comment">// l 移动到之前 0 所在位置之后</span><br>            l = z + <span class="hljs-number">1</span>    <br>        &#125;<br>        r++<br>    &#125;<br>    res = max(res, r-l<span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; y &#123;<br>        <span class="hljs-keyword">return</span> x<br>    &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git clone 速度慢的解决方法</title>
    <link href="/2021/08/11/git-clone-su-du-man/"/>
    <url>/2021/08/11/git-clone-su-du-man/</url>
    
    <content type="html"><![CDATA[<p>使用国内镜像，目前已知Github国内镜像网站有 github.com.cnpmjs.org 和 git.sdut.me&#x2F; 。速度根据各地情况而定，在clone某个项目的时候将 github.com 替换为 github.com.cnpmjs.org 即可。</p><p>来源：<a href="https://blog.csdn.net/hzlarm/article/details/115415038">https://blog.csdn.net/hzlarm/article/details/115415038</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git push error: remote: fatal error in commit_refs</title>
    <link href="/2021/08/11/git-push-error-remote-fatal-error-in-commit_refs/"/>
    <url>/2021/08/11/git-push-error-remote-fatal-error-in-commit_refs/</url>
    
    <content type="html"><![CDATA[<p>在一如既往地执行 <code>git push</code> 到 Github 时，出现了一个从未遇到过的错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">remote: fatal error in commit_refs<br>To https://github.com/xxx<br> ! [remote rejected] master -&gt; master (failure)<br>error: failed to push some refs to &#x27;https://github.com/xxx&#x27;<br></code></pre></td></tr></table></figure><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git fsck<br>git gc<br></code></pre></td></tr></table></figure><p>参考： <a href="https://stackoverflow.com/questions/37341960/how-do-i-fix-remote-fatal-error-in-commit-refs-errors-trying-to-push-with-git#comment75666427_37342002">https://stackoverflow.com/questions/37341960/how-do-i-fix-remote-fatal-error-in-commit-refs-errors-trying-to-push-with-git#comment75666427_37342002</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 最左前缀原则失效</title>
    <link href="/2021/08/07/mysql-zui-zuo-qian-zhui-yuan-ze-shi-xiao/"/>
    <url>/2021/08/07/mysql-zui-zuo-qian-zhui-yuan-ze-shi-xiao/</url>
    
    <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>（<del>以后 mysql 的输出还是截图好一些，复制粘贴格式会很难看</del> 凑合看就完事了）</p><p>有如下表，结构如下，注意其还拥有一个名为 idx_name_age 的，内容为 (name, age) 的联合索引。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+-------+-------------+------+-----+---------+----------------+<br>|<span class="hljs-string"> Field </span>|<span class="hljs-string"> Type        </span>|<span class="hljs-string"> Null </span>|<span class="hljs-string"> Key </span>|<span class="hljs-string"> Default </span>|<span class="hljs-string"> Extra          </span>|<br>+-------+-------------+------+-----+---------+----------------+<br>|<span class="hljs-string"> id    </span>|<span class="hljs-string"> int         </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> PRI </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string"> auto_increment </span>|<br>|<span class="hljs-string"> name  </span>|<span class="hljs-string"> varchar(50) </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string"> MUL </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">                </span>|<br>|<span class="hljs-string"> age   </span>|<span class="hljs-string"> int         </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">                </span>|<br>+-------+-------------+------+-----+---------+----------------+<br></code></pre></td></tr></table></figure><blockquote><p>PS: 建表语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE stu_join_index (<br>  id INT NOT NULL AUTO_INCREMENT,<br>  name VARCHAR(50),<br>  age INT,<br>  PRIMARY KEY (id),<br>  INDEX idx_name_age (name, age)<br>);<br></code></pre></td></tr></table></figure><p>此外，我们还可以插入一些数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO stu_join_index (name, age)<br>VALUES<br>  (&#x27;John&#x27;, 20),<br>  (&#x27;Alice&#x27;, 25),<br>  (&#x27;Bob&#x27;, 22),<br>  (&#x27;Emily&#x27;, 21),<br>  (&#x27;David&#x27;, 23),<br>  (&#x27;Sophia&#x27;, 24),<br>  (&#x27;Michael&#x27;, 26),<br>  (&#x27;Olivia&#x27;, 19),<br>  (&#x27;Emma&#x27;, 27),<br>  (&#x27;Daniel&#x27;, 20);<br></code></pre></td></tr></table></figure></blockquote><p>执行下面的 SQL 语句，看看这次查询的索引使用信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;20&#x27;</span>;<br></code></pre></td></tr></table></figure><p>运行后发现 <code>type</code> 为 <code>index</code>，这代表这次查询走了索引。</p><p>（2022.3.20 更新：index 代表的是会对整个索引树进行扫描，仅比 all（全表扫描）要快一些 <del>其实也等同于全表查询，至于 index 相比 all 效率会不会更高，查阅了一些资料，都说 index 效率要更快一些</del>）</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">--------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">--------------------------</span>+<br>| id | select_type | table          | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                    |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">--------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">--------------------------</span>+<br>|  1 | SIMPLE      | stu_join_index | NULL       | index | idx_name_age  | idx_name_age | 208     | NULL |   10 |    10.00 | Using where; Using index |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">--------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">--------------------------</span>+<br></code></pre></td></tr></table></figure><p>这就奇怪了，按照 Mysql 最左前缀原则，建立的索引是 (name, age) ，应该只有 (name)，(name，age) 会走索引啊？再尝试查询一下（age, name），看会不会走索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;25&#x27;</span> <span class="hljs-keyword">and</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Alice&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">--------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br>| id | select_type | table          | partitions | type | possible_keys | key          | key_len | ref         | rows | filtered | Extra       |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">--------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br>|  1 | SIMPLE      | stu_join_index | NULL       | ref  | idx_name_age  | idx_name_age | 208     | const,const |    1 |   100.00 | Using index |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">--------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br></code></pre></td></tr></table></figure><p>可以看到这里也同样走了索引，这是为什么呢？</p><blockquote><p>补充：<code>Extra</code> 显示的是 <code>Using where; Using index</code>，其中的 <code>Using index</code> 代表：从表中仅使用索引树中的信息就能获取查询语句的列的信息, 而不必进行其他额外查找（seek）去读取实际的行记录。当查询的列是单个索引的部分的列时, 可以使用此策略。（简单的翻译就是：使用索引来直接获取列的数据，而不需回表，即覆盖索引）。</p></blockquote><p>后来在网上找到了一个同样问题的 <a href="https://segmentfault.com/a/1190000022690969">文章</a>，他的情况和我一样，创建了一张表，表中总共有四个字段。 id 为主键，还有一个由 name，age，address 组成的联合索引，当他执行下面的 SQL 时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> address<span class="hljs-operator">=</span><span class="hljs-string">&#x27;beijing&#x27;</span>;<br></code></pre></td></tr></table></figure><p>同样发现 <code>type</code> 字段为 <code>index</code>，即走了索引。</p><p>最终在评论区找到了答案：</p><blockquote><p>总结下，不是最左原则失效了。是因为一开始设计的字段只有四个：(id,name,age,address)，此时的联<br>合索引是（name, age, address），id 自带一个主键索引。相当于，四个字段都有索引。因为覆盖索引<br>的缘故，怎么查都会走索引。当增加一个字段（use）后，该字段没有索引，因此 select * 的时候不会<br>触发覆盖索引，因此不会走索引。但是如果只查询 select name,age,address,id 的话依然会走索引</p></blockquote><p>于是我进行了进一步测试，为表添加一个字段并插入一条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> stu_join_index <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> score <span class="hljs-type">int</span>;<br><span class="hljs-keyword">update</span> stu_join_index <span class="hljs-keyword">set</span> score <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Bob&#x27;</span>;<br></code></pre></td></tr></table></figure><p>此时的表信息如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index;<br><br><span class="hljs-operator">+</span><span class="hljs-comment">----+---------+------+-------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name    <span class="hljs-operator">|</span> age  <span class="hljs-operator">|</span> score <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+---------+------+-------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> John    <span class="hljs-operator">|</span>   <span class="hljs-number">20</span> <span class="hljs-operator">|</span>  <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> Alice   <span class="hljs-operator">|</span>   <span class="hljs-number">25</span> <span class="hljs-operator">|</span>  <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> Bob     <span class="hljs-operator">|</span>   <span class="hljs-number">22</span> <span class="hljs-operator">|</span>    <span class="hljs-number">90</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> Emily   <span class="hljs-operator">|</span>   <span class="hljs-number">21</span> <span class="hljs-operator">|</span>  <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> David   <span class="hljs-operator">|</span>   <span class="hljs-number">23</span> <span class="hljs-operator">|</span>  <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Sophia  <span class="hljs-operator">|</span>   <span class="hljs-number">24</span> <span class="hljs-operator">|</span>  <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7</span> <span class="hljs-operator">|</span> Michael <span class="hljs-operator">|</span>   <span class="hljs-number">26</span> <span class="hljs-operator">|</span>  <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">8</span> <span class="hljs-operator">|</span> Olivia  <span class="hljs-operator">|</span>   <span class="hljs-number">19</span> <span class="hljs-operator">|</span>  <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">9</span> <span class="hljs-operator">|</span> Emma    <span class="hljs-operator">|</span>   <span class="hljs-number">27</span> <span class="hljs-operator">|</span>  <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">10</span> <span class="hljs-operator">|</span> Daniel  <span class="hljs-operator">|</span>   <span class="hljs-number">20</span> <span class="hljs-operator">|</span>  <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+---------+------+-------+</span><br></code></pre></td></tr></table></figure><p>此时再使用 (score, age) 条件进行查询，看看结果如何：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> score <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span> <span class="hljs-number">22</span>;<br><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>          <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra       <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> stu_join_index <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>   <span class="hljs-number">10</span> <span class="hljs-operator">|</span>    <span class="hljs-number">10.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br></code></pre></td></tr></table></figure><p>可以看到此时 <code>type</code> 变为了 <code>ALL</code>，代表要扫描全表。</p><p>因为 (name, age) 相当于创建了 name 单列索引和 (name, age) 联合索引。对于多个字段的联合索引，也同理，比如 index(a, b, c) 这个联合索引，相当于创建了 a 单列索引，(a, b) 联合索引，和 (a, b, c )联合索引。上面的查询条件 (score, age) 既没有联合索引，各自也没有单列索引，所以自然要扫描全表。</p><p>测试：</p><p>思考一下，之前的查询语句 <code>explain select * from stu_join_index where age = 20;</code> 还会不会走索引？</p><p>结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>          <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra       <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> stu_join_index <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>   <span class="hljs-number">10</span> <span class="hljs-operator">|</span>    <span class="hljs-number">10.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br></code></pre></td></tr></table></figure><p>可以看到此时的 type 为 ALL，这是为什么呢？</p><p>我的猜测是，因为我们加了一个非索引字段 <code>score</code>，而我们的查询结果又是 *，而查询条件又是 age 这个无索引字段（我们创建的联合索引是 name, age），所以就会走全表扫描，但是 Extra 这里的 <code>Using where</code> 又是什么意思呢？</p><blockquote><p>来自 ChatGPT：</p><p>在 MySQL 的 <code>Extra</code> 列中，<code>Using where</code> 表示查询需要在存储引擎层面使用额外的条件过滤。具体含义如下：</p><ul><li><code>Using where</code> 表示在读取行数据后，MySQL 需要进一步应用 WHERE 条件进行过滤，以满足查询条件。这意味着查询结果中可能包含一些不符合 WHERE 条件的行，需要在 MySQL 层面进行进一步过滤。</li><li>当出现 <code>Using where</code> 时，MySQL 可能会使用索引或者全表扫描来获取满足 WHERE 条件的行数据。如果查询涉及到大量数据，或者没有适用的索引，可能会导致性能下降。</li><li>注意，<code>Using where</code> 并不表示一定会使用索引，它只表示需要在查询结果集上进行进一步的条件过滤。具体是否使用索引还需要考虑索引的定义、查询条件的复杂性以及数据分布等因素。</li></ul><p>总之，<code>Using where</code> 表示查询需要在 MySQL 层面进一步过滤数据以满足 WHERE 条件，但不表示一定会使用索引。需要综合考虑索引的设计和查询条件的优化，以提高查询性能。</p></blockquote><p>如果我们将查询条件修改为 name，或者查询结果由 * 改为 id,name,age，结果又会如何？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Bob&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>          <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key          <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>   <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> stu_join_index <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> idx_name_age  <span class="hljs-operator">|</span> idx_name_age <span class="hljs-operator">|</span> <span class="hljs-number">203</span>     <span class="hljs-operator">|</span> const <span class="hljs-operator">|</span>    <span class="hljs-number">1</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span><br><br>explain <span class="hljs-keyword">select</span> id,name,age <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>          <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type  <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key          <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra                    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> stu_join_index <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> index <span class="hljs-operator">|</span> idx_name_age  <span class="hljs-operator">|</span> idx_name_age <span class="hljs-operator">|</span> <span class="hljs-number">208</span>     <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>   <span class="hljs-number">10</span> <span class="hljs-operator">|</span>    <span class="hljs-number">10.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>; <span class="hljs-keyword">Using</span> index <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br></code></pre></td></tr></table></figure><p>可以看到，这两个查询都走了索引</p><h1 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h1><h2 id="1-where-条件只有-name"><a href="#1-where-条件只有-name" class="headerlink" title="1. where 条件只有 name"></a>1. where 条件只有 name</h2><p>如果 <code>where</code> 条件只有 <code>score</code> ，或者只有 <code>age</code> ，结果会怎样呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;12&#x27;</span>;<br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> score <span class="hljs-operator">=</span> <span class="hljs-number">90</span>;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br>| id | select_type | table          | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br>|  1 | SIMPLE      | stu_join_index | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |    20.00 | Using where |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br></code></pre></td></tr></table></figure><p>结果会扫描全表。这是因为 <code>socre</code> 和 <code>age</code> 都没有单列索引。</p><p>但是当 <code>where</code> 条件只有 <code>name</code> 时会怎样呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;aa&#x27;</span>;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------</span>+<br>| id | select_type | table          | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------</span>+<br>|  1 | SIMPLE      | stu_join_index | NULL       | ref  | name_age      | name_age | 203     | const |    1 |   100.00 | NULL  |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------</span>+<br></code></pre></td></tr></table></figure><p>此时 <code>type</code> 为 <code>ref</code>，在上面已经说过，(name, age) 联合索引会同时创建一个 <code>name</code> 单列索引。但是这里为什么是 <code>ref</code> 而不是 <code>index</code> 呢？</p><blockquote><p><code>ref</code> 使用非唯一索引扫描或唯一索引的前缀扫描，返回匹配某个单独值的记录行。</p><p>出现该连接类型的条件是： 查找条件列使用了索引而且不为主键和unique。其实，意思就是虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。</p></blockquote><p>我的猜测：</p><p><del>在没有添加 <code>score</code> 字段前，联合索引 (name, age) 是覆盖索引，但是添加了 <code>score</code> 后便不再是覆盖索引了</del></p><p>覆盖索引依然是 <code>ref</code></p><h2 id="2-为什么-name-为非字符串时不走索引"><a href="#2-为什么-name-为非字符串时不走索引" class="headerlink" title="2. 为什么 name 为非字符串时不走索引"></a>2. 为什么 name 为非字符串时不走索引</h2><p>在 1 中提到，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;aa&#x27;</span>;<br></code></pre></td></tr></table></figure><p>的 <code>type</code> 为 <code>ref</code>，那么如果把查询条件改为非字符串会怎样呢？（name 为 varchar 类型）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br>| id | select_type | table          | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br>|  1 | SIMPLE      | stu_join_index | NULL       | ALL  | name_age      | NULL | NULL    | NULL |    5 |    20.00 | Using where |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br></code></pre></td></tr></table></figure><p>结果变为了 <code>ALL</code>，为什么不是字符串就会索引失效呢？</p><p><strong>回答</strong></p><p>在博客 <a href="https://blog.csdn.net/qq_28194001/article/details/90488782">https://blog.csdn.net/qq_28194001/article/details/90488782</a> 中得出结论：</p><blockquote><ol><li>当我们使用的字段是数值类型时，加引号或者不加引号（sql中单引号和双引号实现相同效果）都不影响<br>索引的使用</li><li>当我们的字段是字符串类型时，不加引号的查询无法使用索引，加引号的查询才可正常使用索引</li></ol></blockquote><p>但是还是没给出原因，于是我又问了下 ChatGPT：</p><blockquote><p>Q：为什么 select * from stu_join_index where name &#x3D; ‘aa’; 会走索引，而 select * from stu_join_index where name &#x3D; 1 不会？</p><p>A：<code>select * from stu_join_index where name = 1;</code> 不会走索引：</p><p>这条查询语句中的条件 <code>name = 1</code> 的值类型为整数，而 <code>name</code> 字段的索引 <code>idx_name_age</code> 是建立在字符串类型上的。索引是按照索引列的数据类型进行排序和比较的，因此，整数值无法直接匹配到字符串类型的索引，所以无法使用该索引进行快速查找。在这种情况下，MySQL可能会选择全表扫描的方式来查找满足条件的行。</p></blockquote><blockquote><p>然后我又突发奇想，问了一下另外一种情况：</p><p>Q：那如果查询条件对应的列是 int 类型，但是我加了引号，比如 age &#x3D; ‘1’，这样会走索引吗</p><p>A：当查询条件对应的列是整数类型（如<code>int</code>），但是你将查询条件的值用引号括起来（如<code>age = &#39;1&#39;</code>），MySQL 会进行类型转换以匹配索引列的数据类型。在这种情况下，MySQL 通常会尝试将字符串类型的查询条件转换为整数类型，并尝试使用索引来进行匹配。</p><p>因此，在你提到的情况下，如果索引 <code>idx_name_age</code> 的列 <code>age</code> 是整数类型，MySQL 会尝试将查询条件中的字符串 <code>&#39;1&#39;</code> 转换为整数，并使用该索引进行匹配。如果转换成功，MySQL 将能够使用索引来加速查询。</p><p>需要注意的是，类型转换可能会带来一些性能开销，并且在某些情况下可能会导致索引失效。所以，最佳实践是确保查询条件的值与索引列的数据类型相匹配，这样可以更好地利用索引的优势。</p></blockquote><h2 id="3-不符合最左匹配原则但还是走了索引"><a href="#3-不符合最左匹配原则但还是走了索引" class="headerlink" title="3. 不符合最左匹配原则但还是走了索引"></a>3. 不符合最左匹配原则但还是走了索引</h2><p>再来看一种情况：<br>此时执行 (name, score, age)，看看结果如何：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;aa&#x27;</span> <span class="hljs-keyword">and</span> score <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+--------------+---------+-------------+------+----------+-------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>          <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key          <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>         <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra       <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+--------------+---------+-------------+------+----------+-------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> stu_join_index <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> idx_name_age  <span class="hljs-operator">|</span> idx_name_age <span class="hljs-operator">|</span> <span class="hljs-number">208</span>     <span class="hljs-operator">|</span> const,const <span class="hljs-operator">|</span>    <span class="hljs-number">1</span> <span class="hljs-operator">|</span>    <span class="hljs-number">10.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+--------------+---------+-------------+------+----------+-------------+</span><br></code></pre></td></tr></table></figure><p>这里明明不符合最左前缀原则，为什么 <code>type</code> 会是  <code>ref</code>？</p><blockquote><p>来自 ChatGPT：</p><p>在你提供的查询语句 <code>select * from stu_join_index where name = &#39;aa&#39; and score = 90 and age = 12;</code> 中，尽管不符合最左前缀原则，但是 MySQL 优化器可能会选择使用索引进行查询。</p><p>这是因为索引的选择并不仅仅依赖于最左前缀原则，MySQL 优化器会根据多个因素进行选择，包括索引的选择性、数据分布情况、查询的复杂度等。在某些情况下，MySQL 可能会选择使用较长的索引前缀或者联合索引的一部分来进行查询，而不仅仅局限于最左前缀。</p><p>在你的查询中，如果联合索引 <code>idx_name_age</code> 的前缀列 <code>name</code> 在数据分布上非常选择性高，且其他列的选择性也足够高，MySQL 可能会选择使用该索引进行查询，并且 <code>type</code> 字段显示为 <code>ref</code>。这表示使用了非唯一性索引，并且通过索引进行了范围查找。</p><p>需要注意的是，优化器的行为受多个因素影响，包括数据库的统计信息、查询的复杂度、索引的选择性等等。因此，虽然某些情况下 MySQL 可能会选择使用不符合最左前缀原则的索引，但并不是绝对的，具体的选择还是取决于优化器的判断和算法。</p></blockquote><h2 id="4-index-和-ref-的区别，以及二者各自触发的场景"><a href="#4-index-和-ref-的区别，以及二者各自触发的场景" class="headerlink" title="4. index 和 ref 的区别，以及二者各自触发的场景"></a>4. index 和 ref 的区别，以及二者各自触发的场景</h2><p>再次执行下面的语句（在文章一开始还没有添加 score 字段时，执行过该语句）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;12&#x27;</span> <span class="hljs-keyword">and</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;aa&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>          <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key          <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>         <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> stu_join_index <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> idx_name_age  <span class="hljs-operator">|</span> idx_name_age <span class="hljs-operator">|</span> <span class="hljs-number">208</span>     <span class="hljs-operator">|</span> const,const <span class="hljs-operator">|</span>    <span class="hljs-number">1</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+</span><br></code></pre></td></tr></table></figure><p>为什么加了 <code>score</code> 字段后， <code>type</code> 从 <code>index</code> 变为了 <code>ref</code>？</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程间通信的方式</title>
    <link href="/2021/08/06/jin-cheng-jian-tong-xin-de-fang-shi/"/>
    <url>/2021/08/06/jin-cheng-jian-tong-xin-de-fang-shi/</url>
    
    <content type="html"><![CDATA[<p>这是一道面试高频题</p><h1 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h1><p>无名管道只能用于父子进程之间的通信，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by zz on 2021/3/5.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../lib/apue.h&quot;</span></span><br><br><span class="hljs-comment">// 无名管道：只能在父子进程之间通信</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">pipe_t</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> fp[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">// pipe()：创建一个管道，经由参数 fd 返回两个文件描述符，fp[0] 为读打开，fp[1] 为写打开</span><br>    <span class="hljs-type">int</span> err = pipe(fp);<br>    <span class="hljs-comment">// 成功返回 0，失败返回 -1</span><br>    err == <span class="hljs-number">0</span> ? <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ok&quot;</span>) : <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;create pipe error&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 通过管道，从父进程传输数据到子进程</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">parent_to_child_pipe</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">char</span> line[MAXLINE];<br><br>    <span class="hljs-keyword">if</span> (pipe(fd) &lt; <span class="hljs-number">0</span>) &#123;     <span class="hljs-comment">// 由父进程创建一个管道，子进程会继承父进程所创建的管道</span><br>        err_sys(<span class="hljs-string">&quot;pipe error&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( (pid = fork()) &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// fork 创建一个子进程</span><br>        err_sys(<span class="hljs-string">&quot;fork error&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// 父进程</span><br>        close(fd[<span class="hljs-number">0</span>]);    <span class="hljs-comment">// 因为是 父 -&gt; 子，所以关闭父进程的读端 fd[0]</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;父进程发送数据...\n&quot;</span>);<br>        write(fd[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;hello world\n&quot;</span>, <span class="hljs-number">12</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-comment">// 该子进程会继承父进程所创建的管道</span><br>        close(fd[<span class="hljs-number">1</span>]);   <span class="hljs-comment">// 因为是 父 -&gt; 子，所以关闭子进程的写端 fd[1]</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子进程读取数据...\n&quot;</span>);<br>        n = read(fd[<span class="hljs-number">0</span>], line, <span class="hljs-keyword">sizeof</span>(line));<br>        write(STDOUT_FILENO, line, n);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    parent_to_child_pipe();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ./pipe<br>父进程发送数据...<br>子进程读取数据...<br>hello world<br></code></pre></td></tr></table></figure><h1 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h1><p>命名管道（FIFO）可以用于任意两个进程之间的通信。要想使用，首先需要创建一个 FIFO 文件，之后可以通过对其的读写来完成通信操作。</p><p>为了体现出 <strong>任意两个进程</strong> 这一特点，会创建两个 c 文件，一个是 <code>fifo_write.c</code>，它负责创建一个 FIFO 文件并向其中写入 “Hello, World!”，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../lib/apue.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIFO_NAME <span class="hljs-string">&quot;/tmp/my_fifo&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 如果文件不存在，则创建一个管道</span><br>    <span class="hljs-keyword">if</span> (access(FIFO_NAME, F_OK) == <span class="hljs-number">-1</span>) &#123;<br>        res = mkfifo(FIFO_NAME, <span class="hljs-number">0777</span>);<br>        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mkfifo error: %s \n&quot;</span>, strerror(errno));<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 以只写方式打开管道</span><br>    <span class="hljs-type">int</span> pipe_fd = open(FIFO_NAME, O_WRONLY);<br>    <span class="hljs-keyword">if</span> (pipe_fd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open fifo error: %s \n&quot;</span>, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-built_in">memset</span>(&amp;buf, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-number">1024</span>);<br><br>    <span class="hljs-built_in">strcpy</span>(buf, <span class="hljs-string">&quot;Hello, World!&quot;</span>);<br><br>    <span class="hljs-comment">// 向 fifo 中写入数据</span><br>    <span class="hljs-type">int</span> n = write(pipe_fd, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write data to fifo error: %s \n&quot;</span>, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;process %d write %d bytes to fifo \n&quot;</span>, getpid(), n);<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个文件时 <code>fifo_read.c</code>，它负责从 FIFO 管道中读取数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by zz on 2021/8/6.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../lib/apue.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIFO_NAME <span class="hljs-string">&quot;/tmp/my_fifo&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 只读方式打开管道</span><br>    <span class="hljs-type">int</span> pipe_fd = open(FIFO_NAME, O_RDONLY);<br>    <span class="hljs-keyword">if</span> (pipe_fd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open fifo error: %s \n&quot;</span>, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-built_in">memset</span>(&amp;buf, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-number">1024</span>);<br><br>    <span class="hljs-comment">// 从管道中读取数据</span><br>    <span class="hljs-type">int</span> n = read(pipe_fd, buf, <span class="hljs-number">1024</span>);<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read data from fifo error: %s \n&quot;</span>, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;process %d read from fifo: %s \n&quot;</span>, getpid(), buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意上面的代码创建的是 <strong>阻塞</strong> 命名管道，运行结果如下：</p><p>先运行 <code>fifo_write.c</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编译 fifo_write.c</span><br>➜  gcc -o fw fifo_write.c ../lib/apue.c<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行</span><br>./fw<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行后，发现整个程序阻塞了，没有任何反应</span><br></code></pre></td></tr></table></figure><p>再创建一个 terminal，运行 <code>fifo_read.c</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编译</span><br>➜  gcc -o fr fifo_read.c ../lib/apue.c<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行</span><br>./fr<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出结果</span><br>process 7601 read from fifo: Hello, World! <br></code></pre></td></tr></table></figure><p>此时再看 <code>fifo_write</code> 的 terminal，发现已经停止阻塞了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">process 7517 write 1024 bytes to fifo <br></code></pre></td></tr></table></figure><p>是不是发现实名管道和 Go 中的无缓冲 channel 非常相似呢？当向 channel 写入数据时，整个 goroutine 会进入阻塞状态，直到有另外一个 goroutine 从该 channel 中取出数据，才会停止阻塞。从 channel 中读取数据也是一样的，只有 channel 中存在数据才能读取，否则就会进入阻塞。</p><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>（内容来自 <a href="https://blog.csdn.net/ljianhui/article/details/10287879%EF%BC%89">https://blog.csdn.net/ljianhui/article/details/10287879）</a></p><p>消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。  每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。</p><p><code>Linux</code> 用宏 <code>MSGMAX</code> 和 <code>MSGMNB</code> 来限制一条消息的最大长度和一个队列的最大长度。</p><h2 id="消息队列的-API"><a href="#消息队列的-API" class="headerlink" title="消息队列的 API"></a>消息队列的 API</h2><h3 id="msgget-函数"><a href="#msgget-函数" class="headerlink" title="msgget 函数"></a>msgget 函数</h3><p>该函数用来创建和访问一个消息队列。它的原型为：<br><code>int msgget(key_t key, int msgflg);</code><br>与其他的 IPC 机制一样，程序必须提供一个键来命名某个特定的消息队列。<code>msgflg</code> 是一个权限标志，表示消息队列的访问权限，它与文件的访问权限一样。<code>msgflg</code> 可以与 <code>IPC_CREAT</code> 做或操作，表示当 <code>key</code> 所命名的消息队列不存在时创建一个消息队列，如果 <code>key</code> 所命名的消息队列存在时，<code>IPC_CREAT</code> 标志会被忽略，而只返回一个标识符。</p><p>它返回一个以 <code>key</code> 命名的消息队列的标识符（非零整数），失败时返回-1.</p><h3 id="msgsnd-函数"><a href="#msgsnd-函数" class="headerlink" title="msgsnd 函数"></a>msgsnd 函数</h3><p>该函数用来把消息添加到消息队列中。它的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">msgsend</span><span class="hljs-params">(<span class="hljs-type">int</span> msgid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *msg_ptr, <span class="hljs-type">size_t</span> msg_sz, <span class="hljs-type">int</span> msgflg)</span>;<br></code></pre></td></tr></table></figure><p><code>msgid</code> 是由 <code>msgget</code> 函数返回的消息队列标识符。</p><p><code>msg_ptr</code> 是一个指向准备发送消息的指针，但是消息的数据结构却有一定的要求，指针 <code>msg_ptr</code> 所指向的消息结构一定要是以一个长整型成员变量开始的结构体，接收函数将用这个成员来确定消息的类型。所以消息结构要定义成这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_message</span> &#123;</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> message_type;<br>    <span class="hljs-comment">/* The data you wish to transfer*/</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>msg_sz</code> 是 <code>msg_ptr</code> 指向的消息的长度，注意是消息的长度，而不是整个结构体的长度，也就是说<code>msg_sz</code> 是不包括长整型消息类型成员变量的长度。</p><p><code>msgflg</code> 用于控制当前消息队列满或队列消息到达系统范围的限制时将要发生的事情。</p><p>如果调用成功，消息数据的一分副本将被放到消息队列中，并返回 0，失败时返回 -1.</p><h3 id="msgrcv-函数"><a href="#msgrcv-函数" class="headerlink" title="msgrcv 函数"></a>msgrcv 函数</h3><p>该函数用来从一个消息队列获取消息，它的原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">msgrcv</span><span class="hljs-params">(<span class="hljs-type">int</span> msgid, <span class="hljs-type">void</span> *msg_ptr, <span class="hljs-type">size_t</span> msg_st, <span class="hljs-type">long</span> <span class="hljs-type">int</span> msgtype, <span class="hljs-type">int</span> msgflg)</span>;<br></code></pre></td></tr></table></figure><p><code>msgid, msg_ptr, msg_s</code>t 的作用也函数 <code>msgsnd</code> 函数的一样。</p><p><code>msgtype</code> 可以实现一种简单的接收优先级。如果 <code>msgtype</code> 为 0，就获取队列中的第一个消息。如果它的值大于零，将获取具有相同消息类型的第一个信息。如果它小于零，就获取类型等于或小于 <code>msgtype</code> 的绝对值的第一个消息。（ps: ？？？这里没太看懂）</p><p><code>msgflg</code> 用于控制当队列中没有相应类型的消息可以接收时将发生的事情。</p><p>调用成功时，该函数返回放到接收缓存区中的字节数，消息被复制到由 <code>msg_ptr</code> 指向的用户分配的缓存区中，然后删除消息队列中的对应消息。失败时返回 -1.</p><h3 id="msgctl函数"><a href="#msgctl函数" class="headerlink" title="msgctl函数"></a>msgctl函数</h3><p>该函数用来控制消息队列，它与共享内存的 <code>shmctl</code> 函数相似，它的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">msgctl</span><span class="hljs-params">(<span class="hljs-type">int</span> msgid, <span class="hljs-type">int</span> command, <span class="hljs-keyword">struct</span> msgid_ds *buf)</span>;<br></code></pre></td></tr></table></figure><p><code>command</code> 是将要采取的动作，它可以取3个值，<br>    <strong>IPC_STAT</strong>：把 <code>msgid_ds</code> 结构中的数据设置为消息队列的当前关联值，即用消息队列的当前关联值覆盖 <code>msgid_ds</code> 的值。<br>    <strong>IPC_SET</strong>：如果进程有足够的权限，就把消息列队的当前关联值设置为 <code>msgid_ds</code> 结构中给出的值<br>    <strong>IPC_RMID</strong>：删除消息队列</p><p><code>buf</code> 是指向 <code>msgid_ds</code> 结构的指针，它指向消息队列模式和访问权限的结构。<code>msgid_ds</code> 结构至少包括以下成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msgid_ds</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uid_t</span> shm_perm.uid;<br>    <span class="hljs-type">uid_t</span> shm_perm.gid;<br>    <span class="hljs-type">mode_t</span> shm_perm.mode;<br>&#125;;<br></code></pre></td></tr></table></figure><p>成功时返回 0，失败时返回 -1.</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面是 <code>mq_recv</code> 的代码，负责从消息队列中取出消息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by zz on 2021/8/6.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_st</span> &#123;</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> msg_type;<br>    <span class="hljs-type">char</span> text[BUFSIZ];<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> running = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> msgid = <span class="hljs-number">-1</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_st</span> <span class="hljs-title">data</span>;</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> msgtype = <span class="hljs-number">0</span>; <span class="hljs-comment">//注意1</span><br><br>    <span class="hljs-comment">// 建立消息队列</span><br>    msgid = msgget((<span class="hljs-type">key_t</span>) <span class="hljs-number">1234</span>, <span class="hljs-number">0666</span> | IPC_CREAT);<br>    <span class="hljs-keyword">if</span> (msgid == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;msgget failed with error: %d\n&quot;</span>, errno);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-comment">// 从队列中获取消息，直到遇到 end 消息为止</span><br>    <span class="hljs-keyword">while</span> (running) &#123;<br>        <span class="hljs-keyword">if</span> (msgrcv(msgid, (<span class="hljs-type">void</span> *) &amp;data, BUFSIZ, msgtype, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;msgrcv failed with errno: %d\n&quot;</span>, errno);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You wrote: %s\n&quot;</span>, data.text);<br>        <span class="hljs-comment">// 遇到end结束</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(data.text, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>)<br>            running = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 删除消息队列</span><br>    <span class="hljs-keyword">if</span> (msgctl(msgid, IPC_RMID, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;msgctl(IPC_RMID) failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是 <code>mq_send</code> 的代码，负责发送消息到消息队列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by zz on 2021/8/6.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TEXT 512</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_st</span> &#123;</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> msg_type;<br>    <span class="hljs-type">char</span> text[MAX_TEXT];<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> running = <span class="hljs-number">1</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_st</span> <span class="hljs-title">data</span>;</span><br>    <span class="hljs-type">char</span> buffer[BUFSIZ];<br>    <span class="hljs-type">int</span> msgid = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">// 建立消息队列</span><br>    msgid = msgget((<span class="hljs-type">key_t</span>) <span class="hljs-number">1234</span>, <span class="hljs-number">0666</span> | IPC_CREAT);<br>    <span class="hljs-keyword">if</span> (msgid == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;msgget failed with error: %d\n&quot;</span>, errno);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// 向消息队列中写消息，直到写入 end</span><br>    <span class="hljs-keyword">while</span> (running) &#123;<br>        <span class="hljs-comment">//输入数据</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter some text: &quot;</span>);<br>        fgets(buffer, BUFSIZ, <span class="hljs-built_in">stdin</span>);<br>        data.msg_type = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 注意2</span><br>        <span class="hljs-built_in">strcpy</span>(data.text, buffer);<br>        <span class="hljs-comment">// 向队列发送数据</span><br>        <span class="hljs-keyword">if</span> (msgsnd(msgid, (<span class="hljs-type">void</span> *) &amp;data, MAX_TEXT, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;msgsnd failed\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>        <span class="hljs-comment">// 输入 end 结束输入</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(buffer, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>)<br>            running = <span class="hljs-number">0</span>;<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p>为了验证消息队列可以避免命名管道的同步和阻塞问题，这里先运行 <code>mq_send</code>，向消息队列中发送 3 条消息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜   ./mq_send<br>Enter some text: 123<br>Enter some text: 456<br>Enter some text: 789<br><span class="hljs-meta prompt_"># </span><span class="language-bash">发送了 3 条消息</span><br></code></pre></td></tr></table></figure><p>再开启一个 terminal 运行 <code>mq_recv</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜   ./mq_recv<br>You wrote: 123<br><br>You wrote: 456<br><br>You wrote: 789<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从消息队列中取出了消息</span><br></code></pre></td></tr></table></figure><p>如果先运行 <code>mq_recv</code>，则程序会阻塞，直到消息队列中有数据。</p><h2 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h2><p>（ps: 这部分先不实践了）</p><p>这里主要说明一下消息类型是怎么一回事，注意 <code>msgreceive.</code>c 文件 <code>main</code> 函数中定义的变量 <code>msgtype</code>（注释为注意1），它作为 <code>msgrcv</code> 函数的接收信息类型参数的值，其值为 0，表示获取队列中第一个可用的消息。再来看看 <code>msgsend.c</code> 文件中 while 循环中的语句 <code>data.msg_type = 1</code>（注释为注意2），它用来设置发送的信息的信息类型，即其发送的信息的类型为 1 。所以程序 <code>msgreceive</code> 能够接收到程序 <code>msgsend</code> 发送的信息。</p><p>如果把注意1，即 <code>msgreceive.c</code> 文件 <code>main</code> 函数中的语句由 <code>long int msgtype = 0;</code> 改变为 <code>l ong int msgtype = 2;</code> 会发生什么情况，<code>msgreceive</code> 将不能接收到程序 <code>msgsend</code> 发送的信息。因为在调用 <code>msgrcv</code> 函数时，如果 <code>msgtype</code>（第四个参数）大于零，则将只获取具有相同消息类型的第一个消息，修改后获取的消息类型为2，而 <code>msgsend</code> 发送的消息类型为 1 ，所以不能被 <code>msgreceive</code> 程序接收。重新编译 <code>msgreceive.c</code> 文件并再次执行，其结果如下：</p><h2 id="消息队列与命名管道的比较"><a href="#消息队列与命名管道的比较" class="headerlink" title="消息队列与命名管道的比较"></a>消息队列与命名管道的比较</h2><p>消息队列跟命名管道有不少的相同之处，通过与命名管道一样，消息队列进行通信的进程可以是不相关的进程，同时它们都是通过发送和接收的方式来传递数据的。在命名管道中，发送数据用 <code>write</code> ，接收数据用<code>read</code>，则在消息队列中，发送数据用 <code>msgsnd</code>，接收数据用 <code>msgrcv</code>。而且它们对每个数据都有一个最大长度的限制。</p><p>与命名管道相比，消息队列的优势在于，1、消息队列也可以独立于发送和接收进程而存在，从而消除了在同步命名管道的打开和关闭时可能产生的困难。2、同时通过发送消息还可以避免命名管道的同步和阻塞问题，不需要由进程自己来提供同步方法。3、接收程序可以通过消息类型有选择地接收数据，而不是像命名管道中那样，只能默认地接收。</p><h2 id="消息队列的缺点"><a href="#消息队列的缺点" class="headerlink" title="消息队列的缺点"></a>消息队列的缺点</h2><p>一是通信不及时，二是附件也有大小限制，这同样也是消息队列通信不足的点。</p><p>消息队列不适合比较大数据的传输，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 MSGMAX 和 MSGMNB，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p><p>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p><h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><p>如果 <code>socket</code> 类型为 <code>TCP</code> 和 <code>UDP</code> ，那么可以在不同主机的进程间进行通信。<br>如果 <code>socket</code> 类型为 <code>UNIX</code>，可以在同一主机下的进程间通信。<br><code>TCP</code> 和 <code>UDP</code> 比较熟悉了，这里主要介绍一下 <code>UNIX</code>，代码示例采用 <code>Go</code>：</p><p><code>unxi_write</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>filename := <span class="hljs-string">&quot;/tmp/gounix.sock&quot;</span><br>l, err := net.Listen(<span class="hljs-string">&quot;unix&quot;</span>, filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;listen error: &quot;</span>, err)<br>os.Remove(filename)<span class="hljs-comment">// 出现错误一般是因为文件已存在，所以需要删除</span><br><span class="hljs-keyword">return</span><br>&#125;<br>log.Println(<span class="hljs-string">&quot;创建 UNIX Domain Socket 成功&quot;</span>)<br><span class="hljs-keyword">defer</span> l.Close()<br><br><span class="hljs-keyword">for</span> &#123;<br>conn, err := l.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;accept error: &quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// 向 unix 文件中写入数据</span><br>conn.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>))<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>unix_read</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>filename := <span class="hljs-string">&quot;/tmp/gounix.sock&quot;</span><br>conn, err := net.Dial(<span class="hljs-string">&quot;unix&quot;</span>, filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;dial error: &quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>_, err = conn.Read(b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;read error: &quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;b: %v\n&quot;</span>, <span class="hljs-type">string</span>(b))<br>&#125;<br></code></pre></td></tr></table></figure><p>怎么感觉 <code>unix socket</code> 和 命名管道是一样的。。。</p><h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>发送进程调用 <code>kill</code> 向接收进程发送一个信号，接收进程使用 <code>signal</code>  对该信号进行注册监听，当捕获到该信号时，可以进行相应的处理。<br>演示代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// handler 用来处理接收到的信号</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[parent] receive a SIGINT signal, finish the process!\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> pid;<br><br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork error!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// child</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[child] process id: %d, parent id: %d \n&quot;</span>, getpid(), getppid());<br>        sleep(<span class="hljs-number">5</span>);   <span class="hljs-comment">// 睡眠 5 秒</span><br>        <span class="hljs-comment">// 使用 kill 函数向指定的进程发送一个信号</span><br>        <span class="hljs-comment">// 这里向父进程发送一个 SIGINT 信号</span><br>        kill(getppid(), SIGINT);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[child] send a SIGINT signal\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// parent</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[parent] process id: %d \n&quot;</span>, getpid());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[parent] wait signal... \n&quot;</span>);<br>        <span class="hljs-comment">// 注册一个信号处理函数，当捕获到 SIGINT 时，调用 handler 函数进行处理</span><br>        (<span class="hljs-type">void</span>) signal(SIGINT, handler);<br>    &#125;<br>    sleep(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 等待父子进程执行完毕</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 153. 寻找旋转排序数组中的最小值</title>
    <link href="/2021/08/06/leetcode-153-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi/"/>
    <url>/2021/08/06/leetcode-153-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi/</url>
    
    <content type="html"><![CDATA[<blockquote><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums &#x3D; [0,1,2,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]<br>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p><p>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p><p>示例 1：</p><p>输入：nums &#x3D; [3,4,5,1,2]<br>输出：1<br>解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。<br>示例 2：</p><p>输入：nums &#x3D; [4,5,6,7,0,1,2]<br>输出：0<br>解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。<br>示例 3：</p><p>输入：nums &#x3D; [11,13,15,17]<br>输出：11<br>解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</p><p>提示：</p><p>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 5000<br>-5000 &lt;&#x3D; nums[i] &lt;&#x3D; 5000<br>nums 中的所有整数 互不相同<br>nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</p></blockquote><h1 id="方法-1-二分法"><a href="#方法-1-二分法" class="headerlink" title="方法 1 二分法"></a>方法 1 二分法</h1><p>和基本二分一样，初始变量 <code>l</code> 置于第一个元素，<code>r</code> 置于最后一个元素，<code>m</code> 取 (l + r) &gt;&gt; 1，通过判断 <code>nums[m]</code> 和 <code>nums[l]</code>、<code>nums[r]</code> 的大小关系，来判断哪部分是有序的。</p><p>比如 [3, 4, 5, 1, 2]，<code>m</code> &#x3D; 5，<code>l</code> &#x3D; 3，<code>r</code> &#x3D; 2，m &gt; l，所以 [l, m] 这部分有序。<br>又比如 [7, 0, 1, 2, 3, 4, 5]，<code>m</code> &#x3D; 2，<code>l</code> &#x3D; 7，<code>r</code> &#x3D; 5，m &lt; r，所以 [m, r] 这部分有序。<br>还有一种特殊情况：[0, 1, 2, 4, 5, 6, 7] 旋转 7 次后，依然是原数组 [0, 1, 2, 4, 5, 6, 7]，这种情况在后面会说。</p><p>首先我们假设当前数组是一个常规的旋转数组，比如 [3, 4, 5, 1, 2]，这种旋转数组有一个特点：整个数组被划分为两个有序子数组，大的子数组在前面，小的在后面。题目要找的是最小值，该值只可能是较小子数组的第一个，所以可以推断出以下策略：</p><ol><li><p>如果 <strong>nums[m] &lt; nums[r]<strong>，则代表 [m, r] 这部分有序，既然有序，那么这部分中最小的便是 m，举个例子：<br>[7, 0, 1, 2, 3, 4, 5, 6]，<code>l</code> &#x3D; 7，<code>m</code> &#x3D; 2，<code>r</code> &#x3D; 6，代表 [m, r] 这部分有序，即 [2, 3, 4, 5, 6] 这部分，其中最小的是 m &#x3D; 2。<br>但是 m 仅仅是这部分中的最小值，未必是整个数组中的最小值，它的前面仍然可能存在更小的值。比如上面的例子中，整个数组中最小的是 <code>0</code>。<br>所以此时的下一步做法是：</strong>将 r 移动到 m</strong>，这里为什么不能移动到 m - 1 呢？因为 m 也可能是最小的数，比如 [3, 4, 0, 1, 2] 这个例子，如果 r 移动到 m - 1，移动到了 4，这样就已经错过正确答案了。</p></li><li><p>如果 **nums[m] &gt; nums[l]**，则代表 [l, m] 这部分有序，它们在数组的左边（常规旋转数组），这意味着它们是数组中较大的那部分，比如：<br>[3, 4, 5, 1, 2]，<code>l</code> &#x3D; 3，<code>r</code> &#x3D; 2，<code>m</code> &#x3D; 5，[l, r] 这部分有序，即 [3, 4, 5] 这部分，它们在数组中是较大的部分，由于最小值只可能是较小子数组的第一个，所以这部分必然没有最小值，将 <strong><code>l</code> 移动到 m + 1 处</strong>（这里和 nums[m] &lt; nums[r] 的策略不同了）。</p></li><li><p>特殊情况：[0, 1, 2, 3, 4, 5, 6, 7]，此时处理也很简单，只要先判断 <strong>nums[m] &lt; nums[r]</strong> 关系即可，这样 <code>r</code> 就会从 7 移动到 3，忽略了右边那些较大元素。</p></li><li><p>解决了 <code>l</code> 和 <code>r</code> 移动的策略，剩下的就是问题就是何时返回何值，通过几个例子分析出结论：<br>[7, 0, 1, 2, 3, 4, 5]，在 n 次循环后，<code>l</code>，<code>r</code>，<code>m</code> 都处于元素 0 处。<br>[6, 7, 0, 1, 2, 3, 4, 5]，在 n 次循环后，<code>l</code>，<code>m</code> 处于元素 0 处，<code>r</code> 在元素 1 处。<br>[5, 6, 7, 0, 1, 2, 3, 4,]，在 n 次循环后，<code>l</code>，<code>r</code>，<code>m</code> 都处于元素 0 处。<br>[0, 1, 2, 3, 4, 5, 6, 7]，在 n 次循环后，<code>l</code>，<code>m</code> 处于元素 0 处，<code>r</code> 此时在下标 [-1]      处。</p><p>观察发现，最终都是 <code>l</code> 指向最小元素，且此时 <code>l</code> 和 <code>r</code> 的关系是 <strong>l &gt;&#x3D; r</strong> ，所以可以得出结论：循环推出条件为 <strong>l &gt;&#x3D; r</strong>，最终结果返回为 <code>nums[l]</code>。</p></li></ol><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMin</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    l, r := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> l &lt; r &#123;<br>        m := (l + r) &gt;&gt; <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> nums[m] &lt; nums[r] &#123;<br>            r = m<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[m] &gt;= nums[l] &#123;<br>            l = m + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums[l]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多级页表为什么节省内存</title>
    <link href="/2021/08/05/duo-ji-ye-biao/"/>
    <url>/2021/08/05/duo-ji-ye-biao/</url>
    
    <content type="html"><![CDATA[<h1 id="首先明确几个概念"><a href="#首先明确几个概念" class="headerlink" title="首先明确几个概念"></a>首先明确几个概念</h1><p><strong>逻辑地址</strong>：是程序编译后，生成的目标模块进行编址时都是从0号单元开始编址，称之为目标模块的相对地址，即为逻辑地址。</p><p><strong>页</strong>：将虚拟内存划分的块，对应的大小就叫页面大小。</p><p><strong>页框</strong>：将物理内存划分的块。</p><p>页和页框二者一一对应，一个页放入一个页框，（理论上）页的大小和页框的大小相等。</p><p><strong>页表</strong>：就是一个页和页框一一对应的关系表。【存放在内存中】 关系表只是起到一个索引的作用，说白了就是能根据关系表能查到某一个页面和哪一个页框所对应。</p><h1 id="一级页表"><a href="#一级页表" class="headerlink" title="一级页表"></a>一级页表</h1><p><img src="https://youseebiggirl.github.io/post-images/1628171493242.png"></p><p>操作系统中，一页一般为 <code>4 KB</code>，所以在 4 GB （32 位系统）下一共有 4 GB &#x2F; 4 KB &#x3D; 4 GB * 1024 (4096 MB)  * 1024(4194304KB) &#x2F; 4KB &#x3D; <code>1048576</code> 个页，每个页需要一个 PTE 来保存映射信息，所以需要和页同等数量的 1048576 个 PTE，每个 PTE 占 4 byte，一共需要 <code>4 MB</code> 的内存。</p><p>每个进程都有自己的虚拟地址空间，也就是说每个进程都有自己的页表，如果当前有 100 个进程，那么仅仅是页表就占用了 <code>400 MB</code> 的内存，这还是在 32 位下的情况，在 64 位系统中会占用更多。</p><p>此外，一个进程一般而言不会占用这么多的内存（4 GB，整整占满），所以其页表中会有一些页表项并未映射物理内存，但是却依然占用了内存，这显然也是一种浪费。</p><h1 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h1><p><img src="https://youseebiggirl.github.io/post-images/1628172136856.png"><br>图片来源：<a href="https://www.cnblogs.com/xiaolincoding/p/13213699.html">https://www.cnblogs.com/xiaolincoding/p/13213699.html</a></p><p>在一级页表中我们知道，在 <code>32 位</code>和页大小 <code>4KB </code>的环境下，一个进程的页表需要装下 1048576 （1024 * 1024）个页表项，我们可以把这单个页表项拆分为二级页表，第一级页表有 1024 个页表项，每个页表项指向一个二级页表，每个二级页表项包含了 1024 个页表项，算下来也是 1024 * 1024 个页表项。</p><p>那么二级页表是如何解决一级页表存在的内存占用问题的呢？在二级页表中，第一级页表有 <code>1024</code> 个页表项，共占用 <code>4 KB</code> 内存，如果当前页表项有被映射，那么就继续创建其对应的二级页表，同样的，如果当前页表项没有被映射，就不创建二级页表，相应的内存就省下了。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）&#x3D; 0.804MB，这对比单级页表的 <code>4MB</code> 是不是一个巨大的节约？</p><p>再来看看 <strong>深入理解计算机系统</strong> 中的 第 9.6.3 节 <strong>多级页表</strong> 中是如何描述的：<br><img src="https://youseebiggirl.github.io/post-images/1657525690938.png"></p><p>在上图中，片 2 到 7 是未被分配的。然而，如果在片 i 中至少有一个页是分配了的，那么一级 PTE i 就指向 一个二级页表的基址。例如，在上图中，片<code>0、 1 和 8</code>的 所有或者部分已被分配，所以它们的一级 PTE 就指向二级页表。</p><p>这种方法从两个方面减少了内存要求。第一 ，<strong>如果一级页表中的一个 PTE 是空的，那么相应的二级页表就根本不会存在</strong>。这代表着一种巨大的潜在节约，因为对于一个典型的程序，4GB 的虚拟地址空间的大部分都会是未分配的。第二，<strong>只有一级页表才需要总是在主存中</strong>；<strong>虚拟内存系统可以在需要时创建、页面调入或调出二级页表</strong>，这就减少了主存的压力；<strong>只有最经常使用的二级页表才需要缓存在主存中</strong> 。</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 225. 用队列实现栈</title>
    <link href="/2021/08/04/leetcode-225-yong-dui-lie-shi-xian-zhan/"/>
    <url>/2021/08/04/leetcode-225-yong-dui-lie-shi-xian-zhan/</url>
    
    <content type="html"><![CDATA[<blockquote><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><p>实现 MyStack 类：</p><p>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p><p>注意：</p><p>你只能使用队列的基本操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p><p>示例：</p><p>输入：<br>[“MyStack”, “push”, “push”, “top”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 2, 2, false]</p><p>解释：<br>MyStack myStack &#x3D; new MyStack();<br>myStack.push(1);<br>myStack.push(2);<br>myStack.top(); &#x2F;&#x2F; 返回 2<br>myStack.pop(); &#x2F;&#x2F; 返回 2<br>myStack.empty(); &#x2F;&#x2F; 返回 False</p><p>提示：</p><p>1 &lt;&#x3D; x &lt;&#x3D; 9<br>最多调用100 次 push、pop、top 和 empty<br>每次调用 pop 和 top 都保证栈不为空</p><p>进阶：你能否实现每种操作的均摊时间复杂度为 O(1) 的栈？换句话说，执行 n 个操作的总时间复杂度 O(n) ，尽管其中某个操作可能需要比其他操作更长的时间。你可以使用两个以上的队列。</p></blockquote><h1 id="方法-1-两个队列"><a href="#方法-1-两个队列" class="headerlink" title="方法 1 两个队列"></a>方法 1 两个队列</h1><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1628083312198.png"></p><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStack <span class="hljs-keyword">struct</span> &#123;<br>    q1 *list.List<br>    q2 *list.List<br>&#125;<br><br><br><span class="hljs-comment">/** Initialize your data structure here. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyStack &#123;<br>    <span class="hljs-keyword">return</span> MyStack&#123;<br>        q1: list.New(),<br>        q2: list.New(),<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/** Push element x onto stack. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyStack)</span></span> Push(x <span class="hljs-type">int</span>)  &#123;<br>    m.q2.PushBack(x)<br>    <span class="hljs-keyword">for</span> m.q1.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        pop := m.q1.Remove(m.q1.Front()).(<span class="hljs-type">int</span>)<br>        m.q2.PushBack(pop)<br>    &#125;<br><br>    m.q1, m.q2 = m.q2, m.q1<br>&#125;<br><br><br><span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyStack)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> m.q1.Remove(m.q1.Front()).(<span class="hljs-type">int</span>)<br>&#125;<br><br><br><span class="hljs-comment">/** Get the top element. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> m.q1.Front().Value.(<span class="hljs-type">int</span>)<br>&#125;  <br><br><br><span class="hljs-comment">/** Returns whether the stack is empty. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyStack)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> m.q1.Len() == <span class="hljs-number">0</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(x);</span><br><span class="hljs-comment"> * param_2 := obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Top();</span><br><span class="hljs-comment"> * param_4 := obj.Empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h1 id="方法-2-一个队列"><a href="#方法-2-一个队列" class="headerlink" title="方法 2  一个队列"></a>方法 2  一个队列</h1><p>其实用两个队列有些多余，反而使程序逻辑变复杂了，只要一个队列即可。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1628084445226.png"></p><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStack <span class="hljs-keyword">struct</span> &#123;<br>    queue *list.List<br>&#125;<br><br><br><span class="hljs-comment">/** Initialize your data structure here. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyStack &#123;<br>    <span class="hljs-keyword">return</span> MyStack&#123;<br>        queue: list.New(),<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/** Push element x onto stack. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyStack)</span></span> Push(x <span class="hljs-type">int</span>)  &#123;<br>    queueLen := m.queue.Len()<br>    m.queue.PushBack(x)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; queueLen; i++ &#123;<br>        pop := m.queue.Remove(m.queue.Front()).(<span class="hljs-type">int</span>)<br>        m.queue.PushBack(pop)<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyStack)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br>    pop := m.queue.Remove(m.queue.Front()).(<span class="hljs-type">int</span>) <br>    <span class="hljs-keyword">return</span> pop<br>&#125;<br><br><br><span class="hljs-comment">/** Get the top element. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> m.queue.Front().Value.(<span class="hljs-type">int</span>)<br>&#125;<br><br><br><span class="hljs-comment">/** Returns whether the stack is empty. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyStack)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> m.queue.Len() == <span class="hljs-number">0</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(x);</span><br><span class="hljs-comment"> * param_2 := obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Top();</span><br><span class="hljs-comment"> * param_4 := obj.Empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 155. 最小栈</title>
    <link href="/2021/08/04/leetcode-155-zui-xiao-zhan/"/>
    <url>/2021/08/04/leetcode-155-zui-xiao-zhan/</url>
    
    <content type="html"><![CDATA[<blockquote><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li>push(x) —— 将元素 x 推入栈中。</li><li>pop() —— 删除栈顶的元素。</li><li>top() —— 获取栈顶元素。</li><li>getMin() —— 检索栈中的最小元素。</li></ul><p>示例:</p><p>输入：<br>[“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]</p><p>输出：<br>[null,null,null,null,-3,null,0,-2]</p><p>解释：<br>MinStack minStack &#x3D; new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p><p>提示：</p><p>pop、top 和 getMin 操作总是在 非空栈 上调用。</p></blockquote><h1 id="方法-两个栈"><a href="#方法-两个栈" class="headerlink" title="方法 两个栈"></a>方法 两个栈</h1><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1628052697775.png"></p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MinStack <span class="hljs-keyword">struct</span> &#123;<br>    s1, s2 *list.List<br>&#125;<br><br><br><span class="hljs-comment">/** initialize your data structure here. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MinStack &#123;<br>    <span class="hljs-keyword">return</span> MinStack&#123;<br>        s1: list.New(),<br>        s2: list.New(),<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MinStack)</span></span> Push(val <span class="hljs-type">int</span>)  &#123;<br>    m.s1.PushBack(val)<br>    <span class="hljs-keyword">if</span> m.s2.Len() == <span class="hljs-number">0</span> &#123;<br>        m.s2.PushBack(val)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> m.s2.Len() &gt; <span class="hljs-number">0</span> &amp;&amp; val &lt;= m.s2.Back().Value.(<span class="hljs-type">int</span>) &#123;<br>        m.s2.PushBack(val)<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MinStack)</span></span> Pop()  &#123;<br>    <span class="hljs-keyword">if</span> m.s1.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">if</span> m.s1.Back().Value.(<span class="hljs-type">int</span>) == m.s2.Back().Value.(<span class="hljs-type">int</span>) &#123;<br>            m.s2.Remove(m.s2.Back())<br>        &#125;<br>        m.s1.Remove(m.s1.Back())<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MinStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> m.s1.Back().Value.(<span class="hljs-type">int</span>)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MinStack)</span></span> GetMin() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> m.s2.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> m.s2.Back().Value.(<span class="hljs-type">int</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(val);</span><br><span class="hljs-comment"> * obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Top();</span><br><span class="hljs-comment"> * param_4 := obj.GetMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[牛客][腾讯2020笔试题] 第二题. 逛街</title>
    <link href="/2021/08/03/niu-ke-teng-xun-2020-bi-shi-ti-di-er-ti-guang-jie/"/>
    <url>/2021/08/03/niu-ke-teng-xun-2020-bi-shi-ti-di-er-ti-guang-jie/</url>
    
    <content type="html"><![CDATA[<blockquote><p>小Q在周末的时候和他的小伙伴来到大城市逛街，一条步行街上有很多高楼，共有n座高楼排成一行。<br>小Q从第一栋一直走到了最后一栋，小Q从来都没有见到这么多的楼，所以他想知道他在每栋楼的位置处能看到多少栋楼呢？（当前面的楼的高度大于等于后面的楼时，后面的楼将被挡住） </p><p>输入例子1:<br>[5,3,8,3,2,5]</p><p>输出例子1:<br>[3,3,5,4,4,4]</p><p>例子说明1:<br>当小Q处于位置3时，他可以向前看到位置2,1处的楼，向后看到位置4,6处的楼，加上第3栋楼，共可看到5栋楼。当小Q处于位置4时，他可以向前看到位置3处的楼，向后看到位置5,6处的楼，加上第4栋楼，共可看到4栋楼。</p></blockquote><p>对例子的进一步说明：上面所说的位置序号是从 1 开始的，所以位置 3 的楼高为 8。</p><p>从 8 的左边看，可以看到高度为 5，3 的这两栋楼（5 在左边，3 在右边，所以先看到 3 再看到 5，如果是 [3, 5, 8]，那么就只能看到 5 而看不到 3 了，因为被挡住了）。</p><p>从 8 的右边看，可以看到高度为 3，5 的这两栋楼，注意，在 3，5 之间的 2 是看不到的，因为被 3 挡住了。</p><h1 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h1><p>看评论里的，一开始没想到最小栈的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;container/list&quot;</span><br>)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param heights int整型一维数组 </span><br><span class="hljs-comment"> * @return int整型一维数组</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findBuilding</span><span class="hljs-params">( heights []<span class="hljs-type">int</span> )</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-keyword">var</span> (<br>        res = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights))<br>        stack = list.New()    <span class="hljs-comment">// min stack</span><br>        <span class="hljs-comment">//rs := list.New()    // stack</span><br>        l = <span class="hljs-built_in">len</span>(heights)<br>    )<br>    <br>    <span class="hljs-comment">// 每个位置都能看见自己，所以初值都为 1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(res); i++ &#123;<br>        res[i] = <span class="hljs-number">1</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 每栋楼左边能看到的数量</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; l<span class="hljs-number">-1</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> stack.Len() &gt; <span class="hljs-number">0</span> &amp;&amp; stack.Back().Value.(<span class="hljs-type">int</span>) &lt;= heights[i] &#123;<br>            stack.Remove(stack.Back())<br>        &#125;<br>        stack.PushBack(heights[i])<br>        res[i+<span class="hljs-number">1</span>] += stack.Len()<br>    &#125;<br>    <br>    stack.Init()    <span class="hljs-comment">// clear stack</span><br>    <br>    <span class="hljs-comment">// 每栋楼右边能看到的数量</span><br>    <span class="hljs-keyword">for</span> i := l<span class="hljs-number">-1</span>; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> stack.Len() &gt; <span class="hljs-number">0</span> &amp;&amp; stack.Back().Value.(<span class="hljs-type">int</span>) &lt;= heights[i] &#123;<br>            stack.Remove(stack.Back())<br>        &#125;<br>        stack.PushBack(heights[i])<br>        res[i<span class="hljs-number">-1</span>] += stack.Len()<br>    &#125; <br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h1><p>自己写的，运行超时，5&#x2F;10 组用例通过，仅做保留记录，无参考价值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param heights int整型一维数组 </span><br><span class="hljs-comment"> * @return int整型一维数组</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findBuilding</span><span class="hljs-params">( heights []<span class="hljs-type">int</span> )</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-keyword">var</span> (<br>        <span class="hljs-comment">//isSelf bool</span><br>        res = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights))<br>    )<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(heights); i++ &#123;<br>        <span class="hljs-keyword">var</span> curMaxHeight = <span class="hljs-number">-1</span>    <span class="hljs-comment">// </span><br>        <span class="hljs-comment">// 当前位置一共可以看见几栋楼，因为可以看见自己所在的楼，所以初值为 1</span><br>        <span class="hljs-keyword">var</span> total = <span class="hljs-number">1</span> <br>        <br>        <span class="hljs-comment">// 当前位置的左边可以看见几栋楼</span><br>        <span class="hljs-keyword">for</span> j := i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br>            <span class="hljs-keyword">if</span> heights[j] &lt; curMaxHeight &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            curMaxHeight = max(heights[j], curMaxHeight)<br>            total++<br>        &#125;<br>        <br>        curMaxHeight = <span class="hljs-number">-1</span>    <span class="hljs-comment">// 重置</span><br>        <br>        <span class="hljs-comment">// 当前位置的右边一共可以看见几栋楼</span><br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(heights); j++ &#123;<br>            <span class="hljs-keyword">if</span> heights[j] &lt; curMaxHeight &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            curMaxHeight = max(heights[j], curMaxHeight)<br>            total++<br>        &#125;<br>        <br>        res[i] = total<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; y &#123;<br>        <span class="hljs-keyword">return</span> x<br>    &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>笔试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[牛客][腾讯2020笔试题] 第一题. 压缩算法</title>
    <link href="/2021/08/03/teng-xun-2020-bi-shi-ti-ya-suo-suan-fa/"/>
    <url>/2021/08/03/teng-xun-2020-bi-shi-ti-ya-suo-suan-fa/</url>
    
    <content type="html"><![CDATA[<blockquote><p>说明：该题出自牛客 —— 腾讯2020校园招聘-后台</p></blockquote><blockquote><p>时间限制：C&#x2F;C++ 1秒，其他语言2秒</p><p>空间限制：C&#x2F;C++ 256M，其他语言512M</p><p>小Q想要给他的朋友发送一个神秘字符串，但是他发现字符串的过于长了，于是小Q发明了一种压缩算法对字<br>符串中重复的部分进行了压缩，对于字符串中连续的m个相同字符串S将会压缩为[m|S](m为一个整数且<br>1&lt;&#x3D;m&lt;&#x3D;100)，例如字符串ABCABCABC将会被压缩为[3|ABC]，现在小Q的同学收到了小Q发送过来的字符<br>串，你能帮助他进行解压缩么？ </p><p>输入例子1:<br>“HG[3|B[2|CA]]F”</p><p>输出例子1:<br>“HGBCACABCACABCACAF”</p><p>例子说明1:<br>HG[3|B[2|CA]]F −&gt; HG[3|BCACA]F −&gt; HGBCACABCACABCACAF</p></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>这道题和 <code>leetcode 394. 字符串解码</code> 基本相似，只是多了一个 “|” 符号，只要添加 “|” 对应的逻辑即可，观察发现 “|” 是在数字之后出现的，所以遍历到 “|” 时需要将当前数字变量添加到数字栈，同时将当前数字变量置 0。<br>同时也需要更改遇到 “[” 时的逻辑，此时只需要添加当前字符串变量到字符串栈，并清空当前字符串变量。可以参考 lc394 的思路： <code>https://zengh1.github.io/post/leetcode-394-zi-fu-chuan-jie-ma/</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;container/list&quot;</span><br>    <span class="hljs-string">&quot;unicode&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param str string字符串 </span><br><span class="hljs-comment"> * @return string字符串</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compress</span><span class="hljs-params">( str <span class="hljs-type">string</span> )</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-comment">// write code here</span><br>    mulstack := list.New()    <span class="hljs-comment">// 保存数字的栈</span><br>    letstack := list.New()    <span class="hljs-comment">// 保存字母的栈</span><br>    <br>    <span class="hljs-keyword">var</span> (<br>        mul <span class="hljs-type">int</span><br>        res strings.Builder<br>    )<br>    <br>    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> str &#123;<br>        <span class="hljs-keyword">if</span> unicode.IsLetter(c) &#123;<br>            res.WriteRune(c)<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> unicode.IsNumber(c) &#123;<br>            mul = mul*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(c-<span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;[&#x27;</span> &#123;<br>            letstack.PushBack(res.String())<br>            res.Reset()<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;|&#x27;</span> &#123;<br>            mulstack.PushBack(mul)<br>            mul = <span class="hljs-number">0</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;]&#x27;</span> &#123;<br>            popmul := mulstack.Remove(mulstack.Back()).(<span class="hljs-type">int</span>)<br>            <span class="hljs-keyword">var</span> temp <span class="hljs-type">string</span><br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; popmul; i++ &#123;<br>                temp += res.String()<br>            &#125;<br>            <br>            popchar := letstack.Remove(letstack.Back()).(<span class="hljs-type">string</span>)<br>            <br>            res.Reset()<br>            res.WriteString(popchar + temp)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res.String()<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>笔试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 持久化之 AOF 与 RDB</title>
    <link href="/2021/08/02/redis-chi-jiu-hua-zhi-aof-yu-rdb/"/>
    <url>/2021/08/02/redis-chi-jiu-hua-zhi-aof-yu-rdb/</url>
    
    <content type="html"><![CDATA[<h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><p><code>RDB</code> 可以将某个时间点上的数据库状态保存到一个 <code>RDB</code> 文件中（该文件的文件名可以在 redis.conf 中的 <code>dbfilename</code> 进行配置，默认为 <code>dump.rdb</code>），该文件是一个经过压缩的二进制文件，里面保存了数据库中的键值对，通过该文件可以还原生成 <code>RDB</code> 文件的数据库状态。 </p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>使用 <code>SAVE</code> 或者 <code>BGSAVE</code> 来生成 RDB 文件，二者的区别是 <code>SAVE</code> 会阻塞进程直到 <code>RDB</code> 文件创建完毕为止，阻塞期间不能处理任何请求，而 <code>BGSAVE</code> 会 <code>fork</code> 一个子进程取创建 <code>RDB</code>，不会阻塞主进程。</p><h2 id="RDB-的坑"><a href="#RDB-的坑" class="headerlink" title="RDB 的坑"></a>RDB 的坑</h2><h3 id="1-生成的-dump-rdb-所在位置"><a href="#1-生成的-dump-rdb-所在位置" class="headerlink" title="1. 生成的 dump.rdb 所在位置"></a>1. 生成的 dump.rdb 所在位置</h3><blockquote><p>在 <code>redis.conf</code> 中指明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">The working directory.</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># The DB will be written inside this directory, with the filename specified</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># above using the &#x27;dbfilename&#x27; configuration directive.</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># The Append Only File will also be created inside this directory.</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># Note that you must specify a directory here, not a file name.</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-built_in">dir</span> /usr/local/var/db/redis/</span><br></code></pre></td></tr></table></figure><p>一些博客中说的是在 <code>redis-cli</code> 中使用 <code>config get dir</code> 查看，但是</p></blockquote><h3 id="2-客户端执行-shutdown-或者-直接-ctrl-c-退出服务端，会自动-save"><a href="#2-客户端执行-shutdown-或者-直接-ctrl-c-退出服务端，会自动-save" class="headerlink" title="2. 客户端执行 shutdown 或者 直接 ctrl+c 退出服务端，会自动 save"></a>2. 客户端执行 shutdown 或者 直接 ctrl+c 退出服务端，会自动 save</h3><p>当时我想做一个测试：先 <code>set</code> 几条数据，然后执行 <code>save</code> 对这几条将数据持久化，再执行 <code>flushdb</code> 清空数据库，当再次启动 <code>redis-server</code> 时，会读取 <code>dump.rdb</code> ，将 <code>set</code> 的那几条数据恢复过来。</p><blockquote><p>tips: <code>flushdb</code> 清空数据库后不会执行 save，而 <code>flushall</code> 清空后会执行 save </p></blockquote><p>然而当我实践时却事与愿违，<code>redis-server</code> 的启动日志上显示了读取 <code>rdb</code>，但使用 <code>keys *</code> 却显示 empty，起初以为是自己对 <code>rdb</code> 工作机制不够了解，找了半天资料，最后才发现是因为退出会自动执行 <code>save</code>，当退出时，<code>redis-server</code> 输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">56163:M 02 Aug 2021 16:20:34.361 # User requested shutdown...<br>56163:M 02 Aug 2021 16:20:34.361 * Saving the final RDB snapshot before exiting.<br>56163:M 02 Aug 2021 16:20:34.362 * DB saved on disk<br>56163:M 02 Aug 2021 16:20:34.362 # Redis is now ready to exit, bye bye...<br></code></pre></td></tr></table></figure><p>所以出现上面情况的原因在于，<code>redis-server</code> 退出时自动执行 save，将当前执行过 <code>flushdb</code> 命令的数据库又持久化了一份，并覆盖掉了之前的 RDB 文件。</p><p>解决方法：让 <code>redis-server</code> 非正常退出即可，比如使用 <code>kill -9</code> （ <code>kill</code> 是无效的）。</p><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>与 <code>RDB</code> 持久化通过保存数据库中的键值对来记录数据库状态不同，<code>AOF</code> 持久化是通过保存 <code>Redis</code> 服务器所执行的<strong>写命令</strong>来记录数据库状态的。</p><p><code>AOF</code> 默认关闭，要想开启需要修改 <code>redis.conf</code> 中的 <code>appendonly</code> 为 <code>yes</code>。和 <code>RDB</code> 一样，当 Redis 退出时，会自动进行持久化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">56925:M 02 Aug 2021 17:21:03.892 # User requested shutdown...<br>56925:M 02 Aug 2021 17:21:03.892 * Calling fsync() on the AOF file.<br>56925:M 02 Aug 2021 17:21:03.892 * Saving the final RDB snapshot before exiting.<br>56925:M 02 Aug 2021 17:21:03.892 * DB saved on disk<br>56925:M 02 Aug 2021 17:21:03.892 * Removing the pid file.<br>56925:M 02 Aug 2021 17:21:03.893 # Redis is now ready to exit, bye bye...<br></code></pre></td></tr></table></figure><p><code>AOF</code> 生成的默认文件名为 <code>appendonly.aof</code>，其中保存的是协议化后的写命令，是文本文件，所以可以使用 <code>cat</code> 打印查看，该 <code>db</code> 存储了两个<code>key</code>：a:b 和 b:b，其对应的 AOF 文件如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">*2<br><span class="hljs-meta prompt_">$</span><span class="language-bash">6</span><br>SELECT<br><span class="hljs-meta prompt_">$</span><span class="language-bash">1</span><br>0<br>*3<br><span class="hljs-meta prompt_">$</span><span class="language-bash">3</span><br>set<br><span class="hljs-meta prompt_">$</span><span class="language-bash">1</span><br>a<br><span class="hljs-meta prompt_">$</span><span class="language-bash">1</span><br>a<br>*3<br><span class="hljs-meta prompt_">$</span><span class="language-bash">3</span><br>set<br><span class="hljs-meta prompt_">$</span><span class="language-bash">1</span><br>b<br><span class="hljs-meta prompt_">$</span><span class="language-bash">1</span><br>b<br></code></pre></td></tr></table></figure><h2 id="如何使用-1"><a href="#如何使用-1" class="headerlink" title="如何使用"></a>如何使用</h2><p>通过 <code>BGREWRITEAOF </code> 命令进行持久化。</p><h2 id="AOF-持久化的实现"><a href="#AOF-持久化的实现" class="headerlink" title="AOF 持久化的实现"></a>AOF 持久化的实现</h2><p><code>AOF</code> 持久化功能的实现可以分为 <strong>命令追加（append）</strong>、<strong>文件写入</strong>，<strong>文件同步（sync）</strong> 三个步骤。</p><ol><li>命令追加：服务器在执行完一个写命令后，会以协议格式追加到 <code>aof_buf</code> 缓冲区的末尾。</li><li>文件写入：此时不会把数据直接写入到 <code>AOF</code> 文件，而是先将 <code>aof_buf</code> 中的数据保存到一个内存缓冲区。</li><li>文件同步：将内存缓冲区的数据写入到 <code>AOF</code> 文件中。</li></ol><p>这里要注意写入和同步的区别</p><h3 id="写入和同步的区别"><a href="#写入和同步的区别" class="headerlink" title="写入和同步的区别"></a>写入和同步的区别</h3><p>在现代 OS 中，为了提高文件的写入操作，当用户调用到 <code>write</code> 函数将数据写入文件时，<code>os</code> 先将数据写入到一个内存缓冲区里，正常是等到缓冲区满了或是规定时间到了，才真正地将缓冲区里的数据写入磁盘，这时才是持久化完成。</p><p>类似你用记事本写东西一样，写完之后你会 Ctrl+v（保存），但是在没执行 Ctrl+v 的时候你也能看到自己写的，这时因为保存在内存缓冲区里了，然后你保存了，这才保存到磁盘了，所以我们可以把你写东西当做是对 <code>aof</code> 文件的写入，你执行 Ctrl+v 才是同步到磁盘操作。</p><p>这样虽然大大提高了效率，但是很不安全，在你写了好多字时，卡，忽然电脑停机了，写的东西全没了，就问你气不气？</p><p>所以 <code>appendfsync</code> 的选项值中的 <code>always</code>、<code>everysec</code> 都可以强制让 OS 立即将缓冲区里的数据写入硬盘。<code>always</code> 是写到缓冲区了立马就同步到磁盘，<code>everysec</code> 是写到缓冲区的数据每秒就同步一次，丢失了也就丢失了上一秒内的数据，也不是很气。</p><p>写入同步的策略取决于配置文件中的 <code>appendfsync</code> 选项，在 <strong>Redis 设计与实现</strong> 中有详细说明，这里就不介绍了。</p><h2 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h2><p>TODO</p><h3 id="一个问题：子进程在重写过程中，父进程依然可以写入新的-kv，此时会怎么处理？"><a href="#一个问题：子进程在重写过程中，父进程依然可以写入新的-kv，此时会怎么处理？" class="headerlink" title="一个问题：子进程在重写过程中，父进程依然可以写入新的 kv，此时会怎么处理？"></a>一个问题：子进程在重写过程中，父进程依然可以写入新的 kv，此时会怎么处理？</h3><p><strong>重写过程中，主进程依然可以正常处理命令</strong>，那问题来了，重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，那么会发生写时复制，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？</p><p>为了解决这种数据不一致问题，Redis 设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。</p><p>在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong>。</p><p>当子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p><p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p><ul><li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li><li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li></ul><p>信号函数执行完后，主进程就可以继续像往常一样处理命令了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可靠传输的实现机制 —— 停止-等待协议SW（Stop-and-Wait）</title>
    <link href="/2021/07/30/ke-kao-chuan-shu-de-shi-xian-ji-zhi-ting-zhi-deng-dai-xie-yi-swstop-and-wait/"/>
    <url>/2021/07/30/ke-kao-chuan-shu-de-shi-xian-ji-zhi-ting-zhi-deng-dai-xie-yi-swstop-and-wait/</url>
    
    <content type="html"><![CDATA[<h1 id="何为停等协议"><a href="#何为停等协议" class="headerlink" title="何为停等协议"></a>何为停等协议</h1><p>首先假设有这样一个简单的可靠传输协议，<code>主机 A</code> 发送数据分组给 <code>主机 B</code>，由于网络传输过程中可能会出现数据损坏，所以<code>主机 B</code>会进行校验和检测，如果数据完整则发送 <code>ACK</code>，否则发送 <code>NAK</code>，如果收到 <code>ACK</code>，则可以继续发送下一个数据分组（如果有），收到 <code>NAK</code> 则重新发送当前数据分组。</p><p>在收到 <code>主机 B</code> 的回复之前，<code>主机 A</code> 不会进行任何操作，这便是停等协议，类似于串行操作。</p><p><img src="https://zengh1.github.io/post-images/1627643333323.jpg"></p><h1 id="存在的问题及解决方法"><a href="#存在的问题及解决方法" class="headerlink" title="存在的问题及解决方法"></a>存在的问题及解决方法</h1><h2 id="1-长时间得不到回应"><a href="#1-长时间得不到回应" class="headerlink" title="1. 长时间得不到回应"></a>1. 长时间得不到回应</h2><p><img src="https://zengh1.github.io/post-images/1627643411856.jpg"></p><p>解决方法：<br><img src="https://zengh1.github.io/post-images/1627643674456.jpg"></p><h2 id="2-ACK、NAK-丢失"><a href="#2-ACK、NAK-丢失" class="headerlink" title="2. ACK、NAK 丢失"></a>2. ACK、NAK 丢失</h2><p>既然是网络传输，那么不仅报文会丢失，ACK、NAK 同样也有丢失的可能，如果丢失会产生什么问题呢？看如下场景：<br><img src="https://zengh1.github.io/post-images/1627643890538.jpg"></p><p>在上图中，因为 ACK 的丢失，触发超时重传，又发送了一次数据给对端，但是对端已经接收到了这个数据，属于冗余数据，无需再次接收。那么可以丢弃吗？答案是不可以，因为对端并不知道它的 ACK 是否丢失，所以也无法分辨这次接收到的是冗余重传还是新的报文，冗余重传可以丢弃，但是新报文不能。</p><p>解决方法：给每个分组带上序号，由于停等协议每发送一个数据分组就停止等待，只要保证每发送一个新的数据分组，其发送序号与上次发送的数据分组的序号不同就可以了，所以一次用一个<code>比特</code>（0 或 1）来编号就够了，01不断循环，这次发送编号为 0，下次发送则编号为 1，再下次为 0，如此往复。</p><p><img src="https://zengh1.github.io/post-images/1627645085797.jpg"></p><p>如上图所示，当接收到重传分组 data0 时，便可根据编号判断出这是一个冗余数据，便可以丢弃了。这里注意数据可以丢弃，但是依然要回复一个 ACK，告诉对方我已经收到了你的数据，下次不用再发了。</p><h2 id="3-另一种情况"><a href="#3-另一种情况" class="headerlink" title="3. 另一种情况"></a>3. 另一种情况</h2><p>仅仅给分组带上序号就可以了吗？看如下情况：<br><img src="https://zengh1.github.io/post-images/1627645491169.jpg"></p><p>DATA0 的 ACK 延迟了，这导致 DATA0 重传，再发起重传后不久，延迟的 ACK 到达了，于是继续发送下一个数据 DATA1，之后又收到了重传 DATA0 返回的 ACK，那么问题来了：接收端如何辨别这次的 ACK 是 DATA0 返回的还是 DATA1 返回的？</p><p>解决方法：给 ACK 也加上序号<br><img src="https://zengh1.github.io/post-images/1627646445947.jpg"></p><h1 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h1><p>计算机网络微课堂——湖科大教书匠，<a href="https://www.bilibili.com/video/BV1c4411d7jb?p=25%EF%BC%8C%E5%9B%BE%E7%89%87%E5%8F%8A%E5%86%85%E5%AE%B9%E7%9A%86%E6%9D%A5%E8%87%AA%E4%BA%8E%E6%AD%A4">https://www.bilibili.com/video/BV1c4411d7jb?p=25，图片及内容皆来自于此</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go map 源码阅读</title>
    <link href="/2021/07/29/go-map-yuan-ma-yue-du/"/>
    <url>/2021/07/29/go-map-yuan-ma-yue-du/</url>
    
    <content type="html"><![CDATA[<p>看看 map 这个重要数据结构在 go 中是如何实现的</p><span id="more"></span><h1 id="hmap"><a href="#hmap" class="headerlink" title="hmap"></a>hmap</h1><p>map 的结构体 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A header for a Go map.</span><br><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// count 代表哈希表中的元素个数，调用len(map)时，返回的就是该字段值。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.</span><br><span class="hljs-comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span><br>count <span class="hljs-type">int</span> <span class="hljs-comment">// # live cells == size of map.  Must be first (used by len() builtin)</span><br>flags <span class="hljs-type">uint8</span><br><br><span class="hljs-comment">// B 桶的数目是 2 的 B 次幂，因为选择桶使用的是与运算的方法</span><br>B <span class="hljs-type">uint8</span> <span class="hljs-comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span><br><br><span class="hljs-comment">// 使用的溢出桶的数量</span><br>noverflow <span class="hljs-type">uint16</span> <span class="hljs-comment">// approximate number of overflow buckets; see incrnoverflow for details</span><br><br><span class="hljs-comment">// hash0 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，</span><br><span class="hljs-comment">// 并在调用哈希函数时作为参数传入</span><br>hash0 <span class="hljs-type">uint32</span> <span class="hljs-comment">// hash seed</span><br><br><span class="hljs-comment">// buckets 桶的位置，实际类型为 []bmap</span><br>buckets unsafe.Pointer <span class="hljs-comment">// array of 2^B Buckets. may be nil if count==0.</span><br><br><span class="hljs-comment">// oldbuckets 用于在扩容阶段保存旧桶的位置</span><br><span class="hljs-comment">// 如果 oldbuckets == nil，则代表以及迁移完成</span><br><span class="hljs-comment">// 判断函数为 growing()</span><br>oldbuckets unsafe.Pointer <span class="hljs-comment">// previous bucket array of half the size, non-nil only when growing</span><br><br><span class="hljs-comment">// 记录渐进式扩容阶段下一个要迁移的旧桶编号</span><br><span class="hljs-comment">// 何为渐进式？</span><br><span class="hljs-comment">// 如果触发扩容，此时不会一次性把 kv 全部从旧桶迁移到新桶，而是当执行插入（包括修改）、删除操作时，</span><br><span class="hljs-comment">// 对一部分 kv 进行迁移，这样就可以把迁移的时间分摊到多次 map 操作中，防止瞬间性能抖动</span><br><span class="hljs-comment">// ps: 每次最多只会搬迁 2 个 bucket，迁移是否完成的判断依据是 oldbuckets 字段是否为空</span><br>nevacuate <span class="hljs-type">uintptr</span> <span class="hljs-comment">// progress counter for evacuation (buckets less than this have been evacuated)</span><br><br><span class="hljs-comment">// 指向一个 mapextra，mapextra 里面记录的是溢出桶的相关信息</span><br>extra *mapextra <span class="hljs-comment">// optional fields</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="bmap"><a href="#bmap" class="headerlink" title="bmap"></a>bmap</h1><p><code>bmap</code> 是一个桶，编译期间会动态地创建一个新的结构：</p><blockquote><p> 来自 Go 语言设计与实现：<br> runtime.bmap 中的其他字段在运行时也都是通过计算内存地址的方式访问的，<br> 所以它的定义中就不包含这些字段，不过我们能根据编译期间的 cmd&#x2F;compile&#x2F;internal&#x2F;gc.bmap<br> 函数重建它的结构 </p></blockquote><p> 但是在 go 1.16 中没有找到这个函数，所以在其他博客找了这个结构体，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    topbits  [<span class="hljs-number">8</span>]<span class="hljs-type">uint8</span><br>    keys     [<span class="hljs-number">8</span>]keytype<br>    values   [<span class="hljs-number">8</span>]valuetype<br>    pad      <span class="hljs-type">uintptr</span><br>    overflow <span class="hljs-type">uintptr</span><br>&#125;<br></code></pre></td></tr></table></figure><p>桶中存放 kv 的方式如下：</p><p>计算出的<code>hash 值</code>的高八位为 <code>tophash</code>，用于在一个独立的桶中区别出键，低位用于选择桶，<br>例如下面是一个计算出来的 <code> hash</code>：</p><blockquote><p>高 8 位 <strong>66883387</strong>    391851     <strong>01010</strong>  低 5 位                   </p></blockquote><p>当 <code>B</code> 等于 5 时，那么我们选择的哈希值低位也是 5 位，即 01010，它的十进制值为 10，代表 10 号桶。<br>再用哈希值的高 8 位，找到此 <code>key</code> 在桶中的位置。</p><p>桶里面会最多装 8 个 <code>key/value</code>，这些 <code> key</code> 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果的 低B位是相同的，而多个 key 装入一个桶就是 go 用来处理  <strong>hash 冲突</strong> 的方式。在桶内，会根据 <code>key</code> 的 <code>hash</code> 值的高 8 位作为 <code>tophash</code>，<code>tophash</code> 的作用是在一个独立的桶中区别出键，可以在查找 <code>key</code> 时进行快速判断，快速的原因在于：</p><blockquote><p>在某个 <code>bmap</code> 里快速判等<code> key</code> 时使用，若 hash 高八位不相等就不用进一步比较 <code>key</code> 是否相等了，判断<code> key</code> 是否相等会根据 <code>key</code> 的类型找到对应的<code>equal</code> 函数，然后调用函数拿到判等结果；而判断 <code>tophash</code> 就没那么复杂了。来源：<a href="https://www.bilibili.com/video/BV1Sp4y1U7dJ%EF%BC%8C%E3%80%90Golang%E3%80%91Map%E9%95%BF%E5%95%A5%E6%A0%B7%E5%84%BF%EF%BC%9F%E9%87%8C%E7%9A%84%E8%AF%84%E8%AE%BA">https://www.bilibili.com/video/BV1Sp4y1U7dJ，【Golang】Map长啥样儿？里的评论</a></p></blockquote><p> 计算 tophash 的函数是：func tophash(hash uintptr) uint8</p><p>  bmap 的结构图示：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1627563904668.webp"></p><p>在8个键值对数据后面有一个overflow指针，因为桶中最多只能装 8 个键值对，如果有多余的键值对落到了当前桶，那么就需要再构建一个桶（称为溢出桶），通过 overflow 指针链接起来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A bucket for a Go map.</span><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// tophash generally contains the top byte of the hash value</span><br><span class="hljs-comment">// for each key in this bucket. If tophash[0] &lt; minTopHash,</span><br><span class="hljs-comment">// tophash[0] is a bucket evacuation state instead.</span><br>tophash [bucketCnt]<span class="hljs-type">uint8</span><br><span class="hljs-comment">// Followed by bucketCnt keys and then bucketCnt elems.</span><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> packing all the keys together and then all the elems together makes the</span><br><span class="hljs-comment">// code a bit more complicated than alternating key/elem/key/elem/... but it allows</span><br><span class="hljs-comment">// us to eliminate padding which would be needed for, e.g., map[int64]int8.</span><br><span class="hljs-comment">// Followed by an overflow pointer.</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="创建-map"><a href="#创建-map" class="headerlink" title="创建 map"></a>创建 map</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// map 初始化的流程：</span><br><span class="hljs-comment">// 1. 入参校验，判断 key 的类型是否合法，必须为可比较类型</span><br><span class="hljs-comment">// 2. 底层调用 makemap 函数，计算得到合适的 B，map 容量最多可容纳 6.5 * 2^B 个元素，</span><br><span class="hljs-comment">//   6.5 为装载因子阈值常量。</span><br><span class="hljs-comment">// 装载因子的计算公式是：装载因子 = 填入表中的元素个数/散列表的长度，装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降</span><br><br><span class="hljs-comment">// makemap implements Go map creation for make(map[k]v, hint).</span><br><span class="hljs-comment">// If the compiler has determined that the map or the first bucket</span><br><span class="hljs-comment">// can be created on the stack, h and/or bucket may be non-nil.</span><br><span class="hljs-comment">// If h != nil, the map can be created directly in h.</span><br><span class="hljs-comment">// If h.buckets != nil, bucket pointed to can be used as the first bucket.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makemap</span><span class="hljs-params">(t *maptype, hint <span class="hljs-type">int</span>, h *hmap)</span></span> *hmap &#123;<br><span class="hljs-comment">//println(&quot;[make map] start...&quot;)</span><br><span class="hljs-comment">// 1. 计算哈希占用的内存是否溢出或者超出能分配的最大值</span><br>mem, overflow := math.MulUintptr(<span class="hljs-type">uintptr</span>(hint), t.bucket.size)<br><span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc &#123;<br>hint = <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-comment">//println(&quot;[make map] cap: &quot;, hint, &quot;, use mem: &quot;, mem)</span><br><span class="hljs-comment">//log.Printf(&quot;[make map] cap: %d, use mem: %d \n&quot;, hint, mem)</span><br><br><span class="hljs-comment">// initialize Hmap</span><br><span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;<br>h = <span class="hljs-built_in">new</span>(hmap)<br>&#125;<br><span class="hljs-comment">// 2. 调用 runtime.fastrand 获取一个随机的哈希种子</span><br>h.hash0 = fastrand()<br><br><span class="hljs-comment">// Find the size parameter B which will hold the requested # of elements.</span><br><span class="hljs-comment">// For hint &lt; 0 overLoadFactor returns false since hint &lt; bucketCnt.</span><br>B := <span class="hljs-type">uint8</span>(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment">// 3. 根据传入的 hint 计算出需要的最小需要的桶的数量</span><br><span class="hljs-keyword">for</span> overLoadFactor(hint, B) &#123;<br>B++<br>&#125;<br><span class="hljs-comment">//println(&quot;B is &quot;, B)</span><br><span class="hljs-comment">//log.Printf(&quot;B is %d, that mean the total bocket number is 2^B = %v \n&quot;, B, math2.Pow(2, float64(B)))</span><br>h.B = B<br><br><span class="hljs-comment">// 分配初始哈希表</span><br><span class="hljs-comment">// 如果 B 为 0，那么 buckets 字段后续会在 mapassign（map 的添加函数） 方法中 lazily 分配</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// allocate initial hash table</span><br><span class="hljs-comment">// if B == 0, the buckets field is allocated lazily later (in mapassign)</span><br><span class="hljs-comment">// If hint is large zeroing this memory could take a while.</span><br><span class="hljs-keyword">if</span> h.B != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> nextOverflow *bmap<br><span class="hljs-comment">// 4. 使用 runtime.makeBucketArray 创建用于保存桶的数组</span><br><span class="hljs-comment">// runtime.makeBucketArray 会根据传入的 B 计算出的需要创建的桶数量</span><br><span class="hljs-comment">// 并在内存中分配一片连续的空间用于存储数据</span><br>h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> nextOverflow != <span class="hljs-literal">nil</span> &#123;<br>h.extra = <span class="hljs-built_in">new</span>(mapextra)<br>h.extra.nextOverflow = nextOverflow<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> h<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="创建保存桶的数组"><a href="#创建保存桶的数组" class="headerlink" title="创建保存桶的数组"></a>创建保存桶的数组</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// makeBucket 为 map 创建用于保存 buckets 的数组。</span><br><span class="hljs-comment">// 当桶的数量小于 24 时，由于数据较少、使用溢出桶的可能性较低，会省略创建的过程以减少额外开销；</span><br><span class="hljs-comment">// 当桶的数量多于 24 时，会额外创建 2^B − 4 个溢出桶；</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// makeBucketArray initializes a backing array for map buckets.</span><br><span class="hljs-comment">// 1&lt;&lt;b is the minimum number of buckets to allocate.</span><br><span class="hljs-comment">// dirtyalloc should either be nil or a bucket array previously</span><br><span class="hljs-comment">// allocated by makeBucketArray with the same t and b parameters.</span><br><span class="hljs-comment">// If dirtyalloc is nil a new backing array will be alloced and</span><br><span class="hljs-comment">// otherwise dirtyalloc will be cleared and reused as backing array.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeBucketArray</span><span class="hljs-params">(t *maptype, b <span class="hljs-type">uint8</span>, dirtyalloc unsafe.Pointer)</span></span> (buckets unsafe.Pointer, nextOverflow *bmap) &#123;<br>base := bucketShift(b)<br>nbuckets := base<br><span class="hljs-comment">// 对于小的 b 值（小于4），即桶的数量小于 16 时，使用溢出桶的可能性很小。</span><br><span class="hljs-comment">// 对于此情况，就避免计算开销。</span><br><span class="hljs-comment">// For small b, overflow buckets are unlikely.</span><br><span class="hljs-comment">// Avoid the overhead of the calculation.</span><br><span class="hljs-keyword">if</span> b &gt;= <span class="hljs-number">4</span> &#123;<br><span class="hljs-comment">// 当桶的数量大于等于 16 个时，正常情况下就会额外创建 2^(b-4) 个溢出桶</span><br><span class="hljs-comment">// Add on the estimated number of overflow buckets</span><br><span class="hljs-comment">// required to insert the median number of elements</span><br><span class="hljs-comment">// used with this value of b.</span><br>nbuckets += bucketShift(b - <span class="hljs-number">4</span>)<br>sz := t.bucket.size * nbuckets<br>up := roundupsize(sz)<br><span class="hljs-keyword">if</span> up != sz &#123;<br>nbuckets = up / t.bucket.size<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 这里，dirtyalloc 分两种情况。如果它为 nil，则会分配一个新的底层数组。</span><br><span class="hljs-comment">// 如果它不为 nil，则它指向的是曾经分配过的底层数组，该底层数组是由之前同</span><br><span class="hljs-comment">// 样的 t 和 b 参数通过 makeBucketArray 分配的，如果数组不为空，需要把</span><br><span class="hljs-comment">// 该数组之前的数据清空并复用。</span><br><span class="hljs-keyword">if</span> dirtyalloc == <span class="hljs-literal">nil</span> &#123;<br>buckets = newarray(t.bucket, <span class="hljs-type">int</span>(nbuckets))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// dirtyalloc was previously generated by</span><br><span class="hljs-comment">// the above newarray(t.bucket, int(nbuckets))</span><br><span class="hljs-comment">// but may not be empty.</span><br>buckets = dirtyalloc<br>size := t.bucket.size * nbuckets<br><span class="hljs-keyword">if</span> t.bucket.ptrdata != <span class="hljs-number">0</span> &#123;<br>memclrHasPointers(buckets, size)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>memclrNoHeapPointers(buckets, size)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 即 b 大于等于 4 的情况下，会预分配一些溢出桶。</span><br><span class="hljs-comment">// 为了把跟踪这些溢出桶的开销降至最低，使用了以下约定：</span><br><span class="hljs-comment">// 如果预分配的溢出桶的 overflow 指针为 nil，那么可以通过指针碰撞（bumping the pointer）获得更多可用桶。</span><br><span class="hljs-comment">//（关于指针碰撞：假设内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为</span><br><span class="hljs-comment">// 分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”）</span><br><span class="hljs-comment">// 对于最后一个溢出桶，需要一个安全的非 nil 指针指向它。</span><br><span class="hljs-keyword">if</span> base != nbuckets &#123;<br><span class="hljs-comment">// We preallocated some overflow buckets.</span><br><span class="hljs-comment">// To keep the overhead of tracking these overflow buckets to a minimum,</span><br><span class="hljs-comment">// we use the convention that if a preallocated overflow bucket&#x27;s overflow</span><br><span class="hljs-comment">// pointer is nil, then there are more available by bumping the pointer.</span><br><span class="hljs-comment">// We need a safe non-nil pointer for the last overflow bucket; just use buckets.</span><br>nextOverflow = (*bmap)(add(buckets, base*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br>last := (*bmap)(add(buckets, (nbuckets<span class="hljs-number">-1</span>)*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br>last.setoverflow(t, (*bmap)(buckets))<br>&#125;<br><span class="hljs-keyword">return</span> buckets, nextOverflow<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>查找有两个函数，<code>mapaccess1</code> 对应 <code>h[key]</code> 这种形式，<code>mapaccess2</code> 对应 <code>v, ok := h[key]</code> ，ok 表示该 key 是否存在。</p><h2 id="mapaccess1"><a href="#mapaccess1" class="headerlink" title="mapaccess1"></a>mapaccess1</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// map 查找 key</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// mapaccess1 returns a pointer to h[key].  Never returns nil, instead</span><br><span class="hljs-comment">// it will return a reference to the zero object for the elem type if</span><br><span class="hljs-comment">// the key is not in the map.</span><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> The returned pointer may keep the whole map live, so don&#x27;t</span><br><span class="hljs-comment">// hold onto it for very long.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapaccess1</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;<br><span class="hljs-keyword">if</span> raceenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;<br>callerpc := getcallerpc()<br>pc := funcPC(mapaccess1)<br>racereadpc(unsafe.Pointer(h), callerpc, pc)<br>raceReadObjectPC(t.key, key, callerpc, pc)<br>&#125;<br><span class="hljs-keyword">if</span> msanenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;<br>msanread(key, t.key.size)<br>&#125;<br><br><span class="hljs-comment">// 如果 map 为空或者元素个数为 0，返回零值</span><br><span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> || h.count == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> t.hashMightPanic() &#123;<br>t.hasher(key, <span class="hljs-number">0</span>) <span class="hljs-comment">// see issue 23734</span><br>&#125;<br><span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="hljs-number">0</span>])<br>&#125;<br><br><span class="hljs-comment">// 写和读冲突，即并发操作</span><br><span class="hljs-keyword">if</span> h.flags&amp;hashWriting != <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;concurrent map read and map write&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 计算哈希值，并且加入 hash0 引入随机性</span><br><span class="hljs-comment">// 不同类型的 key，会使用不同的 hash 算法</span><br>hash := t.hasher(key, <span class="hljs-type">uintptr</span>(h.hash0))<br>m := bucketMask(h.B)<br><br><span class="hljs-comment">// b 就是 bucket 的地址</span><br>b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br><span class="hljs-comment">// 如果 oldbuckets 不为空，那么证明 map 发生了扩容</span><br><span class="hljs-comment">// 如果有扩容发生，老的 buckets 中的数据可能还未搬迁至新的 buckets 里</span><br><span class="hljs-comment">// 所以需要先在老的 buckets 中找</span><br><span class="hljs-keyword">if</span> c := h.oldbuckets; c != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !h.sameSizeGrow() &#123;<br><span class="hljs-comment">// There used to be half as many buckets; mask down one more power of two.</span><br>m &gt;&gt;= <span class="hljs-number">1</span><br>&#125;<br>oldb := (*bmap)(add(c, (hash&amp;m)*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br><span class="hljs-keyword">if</span> !evacuated(oldb) &#123;<br>b = oldb<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 计算出当前 key 的高 8 位的 hash，也就是 tophash</span><br>top := tophash(hash)<br>bucketloop:<br><span class="hljs-comment">// 双重循环遍历：外层循环是从桶到溢出桶遍历；内层是桶中的 cell 遍历</span><br><span class="hljs-comment">// 跳出循环的条件有三种：</span><br><span class="hljs-comment">// 第一种是已经找到 key 值；</span><br><span class="hljs-comment">// 第二种是当前桶再无溢出桶；</span><br><span class="hljs-comment">// 第三种是当前桶中有 cell 位的 tophash 值是 emptyRest</span><br><span class="hljs-comment">// 它代表此时的桶后面的 cell 还未利用，所以无需再继续遍历。</span><br><br><span class="hljs-comment">// 前面已经通过 hash 值的低位确定是几号桶了，但是桶可能还连接着溢出桶，所以使用 for 循序</span><br><span class="hljs-comment">// 来遍历该桶以及其连接的溢出桶</span><br><span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;<br><span class="hljs-comment">// 每个桶内最多存放 8 个 key/value，每个 kv 对应一个 tophash，所以</span><br><span class="hljs-comment">// 遍历这 8 个 tophash 来查找 key</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;<br><span class="hljs-comment">// tophash 不匹配</span><br><span class="hljs-keyword">if</span> b.tophash[i] != top &#123;<br><span class="hljs-comment">// 如果是 emptyRest，代表此时的桶后面的 cell 还未利用，所以无需再继续遍历</span><br><span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;<br><span class="hljs-keyword">break</span> bucketloop<br>&#125;<br><span class="hljs-comment">// 继续查找</span><br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// 到这里说明找到了 key，得到 key 的地址</span><br>k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-type">uintptr</span>(t.keysize))<br><span class="hljs-keyword">if</span> t.indirectkey() &#123;<br>k = *((*unsafe.Pointer)(k))<br>&#125;<br><span class="hljs-comment">// tophash 相同还需要判断 key 是否相等</span><br><span class="hljs-comment">// 如果 key 也相同则代表找到了，返回</span><br><span class="hljs-comment">// 如果 key 不相同，则进入下轮循环</span><br><span class="hljs-keyword">if</span> t.key.equal(key, k) &#123;<br>e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize)+i*<span class="hljs-type">uintptr</span>(t.elemsize))<br><span class="hljs-keyword">if</span> t.indirectelem() &#123;<br>e = *((*unsafe.Pointer)(e))<br>&#125;<br><span class="hljs-keyword">return</span> e<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 所有的 bucket 都未找到，则返回零值</span><br><span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mapaccess2"><a href="#mapaccess2" class="headerlink" title="mapaccess2"></a>mapaccess2</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapaccess2</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> (unsafe.Pointer, <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">if</span> raceenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;<br>callerpc := getcallerpc()<br>pc := funcPC(mapaccess2)<br>racereadpc(unsafe.Pointer(h), callerpc, pc)<br>raceReadObjectPC(t.key, key, callerpc, pc)<br>&#125;<br><span class="hljs-keyword">if</span> msanenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;<br>msanread(key, t.key.size)<br>&#125;<br><span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> || h.count == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> t.hashMightPanic() &#123;<br>t.hasher(key, <span class="hljs-number">0</span>) <span class="hljs-comment">// see issue 23734</span><br>&#125;<br><span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="hljs-number">0</span>]), <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> h.flags&amp;hashWriting != <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;concurrent map read and map write&quot;</span>)<br>&#125;<br>hash := t.hasher(key, <span class="hljs-type">uintptr</span>(h.hash0))<br>m := bucketMask(h.B)<br>b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br><span class="hljs-keyword">if</span> c := h.oldbuckets; c != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !h.sameSizeGrow() &#123;<br><span class="hljs-comment">// There used to be half as many buckets; mask down one more power of two.</span><br>m &gt;&gt;= <span class="hljs-number">1</span><br>&#125;<br>oldb := (*bmap)(add(c, (hash&amp;m)*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br><span class="hljs-keyword">if</span> !evacuated(oldb) &#123;<br>b = oldb<br>&#125;<br>&#125;<br>top := tophash(hash)<br>bucketloop:<br><span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;<br><span class="hljs-keyword">if</span> b.tophash[i] != top &#123;<br><span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;<br><span class="hljs-keyword">break</span> bucketloop<br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br>k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-type">uintptr</span>(t.keysize))<br><span class="hljs-keyword">if</span> t.indirectkey() &#123;<br>k = *((*unsafe.Pointer)(k))<br>&#125;<br><span class="hljs-keyword">if</span> t.key.equal(key, k) &#123;<br>e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize)+i*<span class="hljs-type">uintptr</span>(t.elemsize))<br><span class="hljs-keyword">if</span> t.indirectelem() &#123;<br>e = *((*unsafe.Pointer)(e))<br>&#125;<br><span class="hljs-keyword">return</span> e, <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="hljs-number">0</span>]), <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// map 的添加函数</span><br><span class="hljs-comment">// Like mapaccess, but allocates a slot for the key if it is not present in the map.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapassign</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;<br><span class="hljs-comment">//println(&quot;insert key into map...&quot;)</span><br><span class="hljs-comment">// 如果 h 是空指针，赋值会引起 panic</span><br><span class="hljs-comment">// 例如以下语句</span><br><span class="hljs-comment">// var m map[string]int</span><br><span class="hljs-comment">// m[&quot;k&quot;] = 1</span><br><span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;assignment to entry in nil map&quot;</span>))<br>&#125;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>callerpc := getcallerpc()<br>pc := funcPC(mapassign)<br>racewritepc(unsafe.Pointer(h), callerpc, pc)<br>raceReadObjectPC(t.key, key, callerpc, pc)<br>&#125;<br><span class="hljs-keyword">if</span> msanenabled &#123;<br>msanread(key, t.key.size)<br>&#125;<br><br><span class="hljs-comment">// 有其他 goroutine 正在往 map 中写 key，会抛出以下错误</span><br><span class="hljs-keyword">if</span> h.flags&amp;hashWriting != <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;concurrent map writes&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 通过 key 和哈希种子，算出对应哈希值</span><br>hash := t.hasher(key, <span class="hljs-type">uintptr</span>(h.hash0))<br><span class="hljs-comment">//println(&quot;this key hash is &quot;, hash)</span><br><br><span class="hljs-comment">// 将 flags 的值与 hashWriting 做按位或运算</span><br><span class="hljs-comment">// 因为在当前 goroutine 可能还未完成 key 的写入，再次调用 t.hasher 会发生 panic。</span><br><span class="hljs-comment">// Set hashWriting after calling t.hasher, since t.hasher may panic,</span><br><span class="hljs-comment">// in which case we have not actually done a write.</span><br>h.flags ^= hashWriting<br><br><span class="hljs-keyword">if</span> h.buckets == <span class="hljs-literal">nil</span> &#123;<br>h.buckets = newobject(t.bucket) <span class="hljs-comment">// newarray(t.bucket, 1)</span><br>&#125;<br><br>again:<br><span class="hljs-comment">// bucketMask 返回值是 2 的 B 次方减 1</span><br><span class="hljs-comment">// 因此，通过 hash 值与 bucketMask 返回值做按位与操作，</span><br><span class="hljs-comment">// 返回的在 buckets 数组中的第几号桶</span><br>bucket := hash &amp; bucketMask(h.B)<br><span class="hljs-comment">//println(&quot;this key will store in bucket &quot;, bucket)</span><br><span class="hljs-comment">// 如果 map 正在搬迁（即 h.oldbuckets != nil）中,则同时进行搬迁工作</span><br><span class="hljs-comment">// 这里涉及到了渐进式扩容这一概念，即扩容不是一次性迁移所有键，而是在其他</span><br><span class="hljs-comment">// 操作中进行小部分迁移</span><br><span class="hljs-keyword">if</span> h.growing() &#123;<br><span class="hljs-comment">//println(&quot;the map is growing!&quot;)</span><br>growWork(t, h, bucket)<br>&#125;<br><span class="hljs-comment">// 计算出上面求出的第几号 bucket 的内存位置</span><br>b := (*bmap)(add(h.buckets, bucket*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br><span class="hljs-comment">// 计算出 tophash</span><br>top := tophash(hash)<br><span class="hljs-comment">//println(&quot;this key&#x27;s tophash is: &quot;, top)</span><br><br><span class="hljs-comment">// 是否当前 key 是否已经添加成功了，如果为 nil 则表示未成功</span><br><span class="hljs-keyword">var</span> inserti *<span class="hljs-type">uint8</span><br><span class="hljs-keyword">var</span> insertk unsafe.Pointer <span class="hljs-comment">// key 的地址</span><br><span class="hljs-keyword">var</span> elem unsafe.Pointer    <span class="hljs-comment">// value 的地址</span><br>bucketloop:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 遍历桶中的 8 个 cell，找到一个空位插入</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;<br><span class="hljs-comment">//println(&quot;cur bucket tophash is &quot;, b.tophash[i])</span><br><span class="hljs-comment">// 如果当前 cell 的 tophash 不等于当前 key 的 tophash</span><br><span class="hljs-keyword">if</span> b.tophash[i] != top &#123;<br><span class="hljs-comment">//println(&quot;b.tophash[i] != top&quot;)</span><br><span class="hljs-comment">// 如果 cell 位为空，那么就可以在对应位置进行插入</span><br><span class="hljs-keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="hljs-literal">nil</span> &#123;<br>inserti = &amp;b.tophash[i] <span class="hljs-comment">// 更新 inserti，表示已经添加成功</span><br>insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-type">uintptr</span>(t.keysize))<br>elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize)+i*<span class="hljs-type">uintptr</span>(t.elemsize))<br>&#125;<br><span class="hljs-comment">// emptyRest 表示当前 cell 及之后都为空，此时已经找到空位了，</span><br><span class="hljs-comment">// 所以没必要再遍历了</span><br><span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;<br><span class="hljs-keyword">break</span> bucketloop<br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// 第二种情况是 cell 位的 tophash 值和当前的 tophash 值相等</span><br>k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-type">uintptr</span>(t.keysize))<br><span class="hljs-keyword">if</span> t.indirectkey() &#123;<br>k = *((*unsafe.Pointer)(k))<br>&#125;<br><span class="hljs-comment">// 即使当前 cell 位的 tophash 值相等，不一定它对应的 key 也是相等的，</span><br><span class="hljs-comment">// 所以还要做一个 key 值判断，key 值不同则 continue 继续寻找空位</span><br><span class="hljs-keyword">if</span> !t.key.equal(key, k) &#123;<br><span class="hljs-comment">//println(&quot;tophash equal but key not equal&quot;)</span><br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// 如果已经有该 key 了，就更新它</span><br><span class="hljs-comment">// already have a mapping for key. Update it.</span><br><span class="hljs-keyword">if</span> t.needkeyupdate() &#123;<br><span class="hljs-comment">//println(&quot;tophash equal and key equal, update the value&quot;)</span><br>typedmemmove(t.key, k, key)<br>&#125;<br><span class="hljs-comment">// 这里获取到了要插入 key 对应的 value 的内存地址</span><br>elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize)+i*<span class="hljs-type">uintptr</span>(t.elemsize))<br><span class="hljs-comment">// 如果顺利到这，就直接跳到 done 的结束逻辑中去</span><br><span class="hljs-keyword">goto</span> done<br>&#125;<br><span class="hljs-comment">//println(&quot;range this bucket over, not find empty cell to insert key, continue range overflow buckets&quot;)</span><br><span class="hljs-comment">// 如果桶中的 8 个 cell 遍历完，还未找到对应的空 cell 或覆盖 cell，</span><br><span class="hljs-comment">// 那么就进入它的溢出桶中去遍历</span><br>ovf := b.overflow(t)<br><span class="hljs-comment">// 如果连溢出桶中都没有找到合适的 cell，跳出循环</span><br><span class="hljs-keyword">if</span> ovf == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">//println(&quot;overflow buckets not find empty cell, need grow&quot;)</span><br><span class="hljs-keyword">break</span><br>&#125;<br>b = ovf<br>&#125;<br><br><span class="hljs-comment">// 在已有的桶和溢出桶中都未找到合适的 cell 供 key 写入，那么有可能会触发以下两种情况</span><br><span class="hljs-comment">// 情况一：</span><br><span class="hljs-comment">// 判断当前 map 的装载因子是否达到设定的 6.5 阈值，或者当前 map 的溢出桶数量是否过多。</span><br><span class="hljs-comment">// 如果存在这两种情况之一，则进行扩容操作。</span><br><span class="hljs-comment">// hashGrow() 实际并未完成扩容，对哈希表数据的搬迁（复制）操作是通过 growWork() 来完成的。</span><br><span class="hljs-comment">// 重新跳入 again 逻辑，在进行完 growWork() 操作后，再次遍历新的桶。</span><br><br><span class="hljs-comment">// Did not find mapping for key. Allocate new cell &amp; add entry.</span><br><br><span class="hljs-comment">// If we hit the max load factor or we have too many overflow buckets,</span><br><span class="hljs-comment">// and we&#x27;re not already in the middle of growing, start growing.</span><br><span class="hljs-keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="hljs-number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;<br>hashGrow(t, h)<br><span class="hljs-keyword">goto</span> again <span class="hljs-comment">// Growing the table invalidates everything, so try again</span><br>&#125;<br><br><span class="hljs-comment">// 情况二：</span><br><span class="hljs-comment">// 在不满足情况一的条件下，会为当前桶再新建溢出桶，并将 tophash，</span><br><span class="hljs-comment">// key 插入到新建溢出桶的对应内存的 0 号位置</span><br><span class="hljs-keyword">if</span> inserti == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// The current bucket and all the overflow buckets connected to it are full, allocate a new one.</span><br>newb := h.newoverflow(t, b)<br>inserti = &amp;newb.tophash[<span class="hljs-number">0</span>]<br>insertk = add(unsafe.Pointer(newb), dataOffset)<br>elem = add(insertk, bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize))<br>&#125;<br><br><span class="hljs-comment">// 在插入位置存入新的 key 和 value</span><br><span class="hljs-comment">// store new key/elem at insert position</span><br><span class="hljs-keyword">if</span> t.indirectkey() &#123;<br>kmem := newobject(t.key)<br>*(*unsafe.Pointer)(insertk) = kmem<br>insertk = kmem<br>&#125;<br><span class="hljs-keyword">if</span> t.indirectelem() &#123;<br>vmem := newobject(t.elem)<br>*(*unsafe.Pointer)(elem) = vmem<br>&#125;<br>typedmemmove(t.key, insertk, key)<br>*inserti = top<br><span class="hljs-comment">// map 中的 key 数量 + 1</span><br>h.count++<br><br>done:<br><span class="hljs-keyword">if</span> h.flags&amp;hashWriting == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;concurrent map writes&quot;</span>)<br>&#125;<br>h.flags &amp;^= hashWriting<br><span class="hljs-keyword">if</span> t.indirectelem() &#123;<br>elem = *((*unsafe.Pointer)(elem))<br>&#125;<br><span class="hljs-keyword">return</span> elem<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapdelete</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;<br><span class="hljs-keyword">if</span> raceenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;<br>callerpc := getcallerpc()<br>pc := funcPC(mapdelete)<br>racewritepc(unsafe.Pointer(h), callerpc, pc)<br>raceReadObjectPC(t.key, key, callerpc, pc)<br>&#125;<br><span class="hljs-keyword">if</span> msanenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;<br>msanread(key, t.key.size)<br>&#125;<br><span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> || h.count == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> t.hashMightPanic() &#123;<br>t.hasher(key, <span class="hljs-number">0</span>) <span class="hljs-comment">// see issue 23734</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> h.flags&amp;hashWriting != <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;concurrent map writes&quot;</span>)<br>&#125;<br><br>hash := t.hasher(key, <span class="hljs-type">uintptr</span>(h.hash0))<br><br><span class="hljs-comment">// Set hashWriting after calling t.hasher, since t.hasher may panic,</span><br><span class="hljs-comment">// in which case we have not actually done a write (delete).</span><br>h.flags ^= hashWriting<br><br>bucket := hash &amp; bucketMask(h.B)<br><span class="hljs-keyword">if</span> h.growing() &#123;<br>growWork(t, h, bucket)<br>&#125;<br>b := (*bmap)(add(h.buckets, bucket*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br>bOrig := b<br>top := tophash(hash)<br>search:<br><span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;<br><span class="hljs-keyword">if</span> b.tophash[i] != top &#123;<br><span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;<br><span class="hljs-keyword">break</span> search<br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br>k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-type">uintptr</span>(t.keysize))<br>k2 := k<br><span class="hljs-keyword">if</span> t.indirectkey() &#123;<br>k2 = *((*unsafe.Pointer)(k2))<br>&#125;<br><span class="hljs-keyword">if</span> !t.key.equal(key, k2) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// Only clear key if there are pointers in it.</span><br><span class="hljs-keyword">if</span> t.indirectkey() &#123;<br>*(*unsafe.Pointer)(k) = <span class="hljs-literal">nil</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> t.key.ptrdata != <span class="hljs-number">0</span> &#123;<br>memclrHasPointers(k, t.key.size)<br>&#125;<br>e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize)+i*<span class="hljs-type">uintptr</span>(t.elemsize))<br><span class="hljs-keyword">if</span> t.indirectelem() &#123;<br>*(*unsafe.Pointer)(e) = <span class="hljs-literal">nil</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> t.elem.ptrdata != <span class="hljs-number">0</span> &#123;<br>memclrHasPointers(e, t.elem.size)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>memclrNoHeapPointers(e, t.elem.size)<br>&#125;<br>b.tophash[i] = emptyOne<br><span class="hljs-comment">// If the bucket now ends in a bunch of emptyOne states,</span><br><span class="hljs-comment">// change those to emptyRest states.</span><br><span class="hljs-comment">// It would be nice to make this a separate function, but</span><br><span class="hljs-comment">// for loops are not currently inlineable.</span><br><span class="hljs-keyword">if</span> i == bucketCnt<span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">if</span> b.overflow(t) != <span class="hljs-literal">nil</span> &amp;&amp; b.overflow(t).tophash[<span class="hljs-number">0</span>] != emptyRest &#123;<br><span class="hljs-keyword">goto</span> notLast<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> b.tophash[i+<span class="hljs-number">1</span>] != emptyRest &#123;<br><span class="hljs-keyword">goto</span> notLast<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>b.tophash[i] = emptyRest<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> b == bOrig &#123;<br><span class="hljs-keyword">break</span> <span class="hljs-comment">// beginning of initial bucket, we&#x27;re done.</span><br>&#125;<br><span class="hljs-comment">// Find previous bucket, continue at its last entry.</span><br>c := b<br><span class="hljs-keyword">for</span> b = bOrig; b.overflow(t) != c; b = b.overflow(t) &#123;<br>&#125;<br>i = bucketCnt - <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>i--<br>&#125;<br><span class="hljs-keyword">if</span> b.tophash[i] != emptyOne &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>notLast:<br>h.count--<br><span class="hljs-comment">// Reset the hash seed to make it more difficult for attackers to</span><br><span class="hljs-comment">// repeatedly trigger hash collisions. See issue 25237.</span><br><span class="hljs-keyword">if</span> h.count == <span class="hljs-number">0</span> &#123;<br>h.hash0 = fastrand()<br>&#125;<br><span class="hljs-keyword">break</span> search<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> h.flags&amp;hashWriting == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;concurrent map writes&quot;</span>)<br>&#125;<br>h.flags &amp;^= hashWriting<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p> 扩容策略分以下两种情况：</p><ol><li><p>判断已经达到装载因子的临界点，即元素个数 &gt;&#x3D; 桶（bucket）总数 * 6.5，这时候说明大部分的桶可能都快满了（即平均每个桶存储的键值对达到6.5个），如果插入新元素，有大概率需要挂在溢出桶（overflow bucket）上，判断<br>函数为 <code>overLoadFactor</code></p></li><li><p>判断溢出桶是否太多，当桶总数 &lt; 2 ^ 15 时，如果溢出桶总数 &gt;&#x3D; 桶总数，<br>则认为溢出桶过多。当桶总数 &gt;&#x3D; 2 ^ 15 时，直接与 2 ^ 15 比较，当溢出<br>桶总数 &gt;&#x3D; 2 ^ 15 时，即认为溢出桶太多了，判断函数：<code>tooManyOverflowBuckets</code></p><p>在某些场景下，比如不断的增删，这样会造成 overflow 的 bucket 数量增多，但负载因子<br>又不高，未达不到第 1 点的临界值，就不能触发扩容来缓解这种情况。这样会造成桶的使用率不高，<br>值存储得比较稀疏，查找插入效率会变得非常低，因此有了第 2 点判断指标。这就像是一座空城，房<br>子很多，但是住户很少，都分散了，找起人来很困难</p><p>两种情况官方采用了不同的解决方案</p><p> 针对 1，将 B + 1（桶数量为 2 ^ B，B+1 则代表翻倍），新建一个 buckets 数组，<br> 新的 buckets 大小是原来的 2 倍，然后旧 buckets 数据搬迁到新的 buckets。该方法我们称之为增量扩容。</p><p>针对 2，并不扩大容量，buckets 数量维持不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对<br>重新排列一次，把在 overflow bucket 中的 key 移动到 bucket 中来以使 bucket 的使用率<br> 更高，进而保证更快的存取。该方法我们称之为等量扩容。</p></li></ol><h2 id="判断扩容条件函数"><a href="#判断扩容条件函数" class="headerlink" title="判断扩容条件函数"></a>判断扩容条件函数</h2><h3 id="tooManyOverflowBuckets"><a href="#tooManyOverflowBuckets" class="headerlink" title="tooManyOverflowBuckets"></a>tooManyOverflowBuckets</h3><p>判断溢出桶是否太多，当桶总数 &lt; 2 ^ 15 时，如果溢出桶总数 &gt;&#x3D; 桶总数，则认为溢出桶过多。当桶总数 &gt;&#x3D; 2 ^ 15 时，直接与 2 ^ 15 比较，当溢出桶总数 &gt;&#x3D; 2 ^ 15 时，即认为溢出桶太多了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1&lt;&lt;B buckets.</span><br><span class="hljs-comment">// Note that most of these overflow buckets must be in sparse use;</span><br><span class="hljs-comment">// if use was dense, then we&#x27;d have already triggered regular map growth.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tooManyOverflowBuckets</span><span class="hljs-params">(noverflow <span class="hljs-type">uint16</span>, B <span class="hljs-type">uint8</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// If the threshold is too low, we do extraneous work.</span><br><span class="hljs-comment">// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.</span><br><span class="hljs-comment">// &quot;too many&quot; means (approximately) as many overflow buckets as regular buckets.</span><br><span class="hljs-comment">// See incrnoverflow for more details.</span><br><span class="hljs-keyword">if</span> B &gt; <span class="hljs-number">15</span> &#123;<br>B = <span class="hljs-number">15</span><br>&#125;<br><span class="hljs-comment">// The compiler doesn&#x27;t see here that B &lt; 16; mask B to generate shorter shift code.</span><br><span class="hljs-keyword">return</span> noverflow &gt;= <span class="hljs-type">uint16</span>(<span class="hljs-number">1</span>)&lt;&lt;(B&amp;<span class="hljs-number">15</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="overLoadFactor"><a href="#overLoadFactor" class="headerlink" title="overLoadFactor"></a>overLoadFactor</h3><p>判断已经达到装载因子的临界点，即元素个数 &gt;&#x3D; 桶（bucket）总数 * 6.5，这时候说明大部分的桶可能都快满了<br>（即平均每个桶存储的键值对达到 6.5 个），如果插入新元素，有大概率需要挂在溢出桶（overflow bucket）上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">overLoadFactor</span><span class="hljs-params">(count <span class="hljs-type">int</span>, B <span class="hljs-type">uint8</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="hljs-type">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="扩容函数"><a href="#扩容函数" class="headerlink" title="扩容函数"></a>扩容函数</h2><h3 id="hashGrow"><a href="#hashGrow" class="headerlink" title="hashGrow"></a>hashGrow</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// hashGrow() 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets</span><br><span class="hljs-comment">// 挂到了 hmap.oldbuckets 字段上。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hashGrow</span><span class="hljs-params">(t *maptype, h *hmap)</span></span> &#123;<br><span class="hljs-comment">// If we&#x27;ve hit the load factor, get bigger.</span><br><span class="hljs-comment">// Otherwise, there are too many overflow buckets,</span><br><span class="hljs-comment">// so keep the same number of buckets and &quot;grow&quot; laterally.</span><br>bigger := <span class="hljs-type">uint8</span>(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 如果没有达到负载因子临界点，则设置为等量扩容</span><br><span class="hljs-keyword">if</span> !overLoadFactor(h.count+<span class="hljs-number">1</span>, h.B) &#123;<br>bigger = <span class="hljs-number">0</span> <span class="hljs-comment">// bigger 设置为 0</span><br>h.flags |= sameSizeGrow<br>&#125;<br><span class="hljs-comment">// 记录老 buckets 的位置</span><br>oldbuckets := h.buckets<br><span class="hljs-comment">// 分配一个新的数组用来存放新桶</span><br>newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="hljs-literal">nil</span>)<br><br>flags := h.flags &amp;^ (iterator | oldIterator)<br><span class="hljs-keyword">if</span> h.flags&amp;iterator != <span class="hljs-number">0</span> &#123;<br>flags |= oldIterator<br>&#125;<br><span class="hljs-comment">// commit the grow (atomic wrt gc)</span><br>h.B += bigger<br>h.flags = flags<br>h.oldbuckets = oldbuckets<br>h.buckets = newbuckets<br>h.nevacuate = <span class="hljs-number">0</span><br>h.noverflow = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">if</span> h.extra != <span class="hljs-literal">nil</span> &amp;&amp; h.extra.overflow != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// Promote current overflow buckets to the old generation.</span><br><span class="hljs-keyword">if</span> h.extra.oldoverflow != <span class="hljs-literal">nil</span> &#123;<br>throw(<span class="hljs-string">&quot;oldoverflow is not nil&quot;</span>)<br>&#125;<br>h.extra.oldoverflow = h.extra.overflow<br>h.extra.overflow = <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> nextOverflow != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> h.extra == <span class="hljs-literal">nil</span> &#123;<br>h.extra = <span class="hljs-built_in">new</span>(mapextra)<br>&#125;<br>h.extra.nextOverflow = nextOverflow<br>&#125;<br><br><span class="hljs-comment">// the actual copying of the hash table data is done incrementally</span><br><span class="hljs-comment">// by growWork() and evacuate().</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="growWork"><a href="#growWork" class="headerlink" title="growWork"></a>growWork</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 真正搬迁 buckets 的动作在 growWork() 函数中，而调用 growWork() 函数的动作是在</span><br><span class="hljs-comment">// mapassign() 和 mapdelete() 函数中。也就是插入（包括修改）、删除 key 的时候，都</span><br><span class="hljs-comment">// 会尝试进行搬迁 buckets 的工作。它们会先检查 oldbuckets 是否搬迁完毕（检查 oldbuckets</span><br><span class="hljs-comment">// 是否为 nil），再决定是否进行搬迁工作。</span><br><span class="hljs-comment">// growWork 会搬迁 0~2 个桶</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">growWork</span><span class="hljs-params">(t *maptype, h *hmap, bucket <span class="hljs-type">uintptr</span>)</span></span> &#123;<br><span class="hljs-comment">// make sure we evacuate the oldbucket corresponding</span><br><span class="hljs-comment">// to the bucket we&#x27;re about to use</span><br>evacuate(t, h, bucket&amp;h.oldbucketmask())<br><br><span class="hljs-comment">// evacuate one more oldbucket to make progress on growing</span><br><span class="hljs-keyword">if</span> h.growing() &#123; <span class="hljs-comment">// 再多搬迁一个桶</span><br>evacuate(t, h, h.nevacuate)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><ol><li>如果两个 key 落入同一个桶，且恰巧它们的 <code>tophash</code> 也相同，此时的<code>添加</code>和<code>查找</code>流程会怎样？</li></ol><blockquote><p>对于 <code>查找</code> 而言，如果 <code>tophash</code> 相同还会进一步判断 <code>key</code> 是否相同，如果 <code>key</code> 相同则返回，不同则继续查找。</p><p><code>添加</code> 也是类似的，如果 <code>tophash</code> 和 <code>key</code> 都相同，说明该 <code>key</code> 已经存在，会执行更新操作，否则继续寻找空位，也就是说，在一个桶中可能出现相同相同的 <code>tophash</code>。</p></blockquote><ol start="2"><li>go map 的负载因子是多少？</li></ol><blockquote><p>负载因子是 <code>6.5</code>，在源码中表现为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Maximum average load of a bucket that triggers growth is 6.5.</span><br><span class="hljs-comment">// Represent as loadFactorNum/loadFactorDen, to allow integer math.</span><br>loadFactorNum = <span class="hljs-number">13</span><br>loadFactorDen = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>Go是如何设计Map的 — 机器铃砍菜刀，<a href="https://mp.weixin.qq.com/s/q3qyc5uf3IMVt4KQD12IKQ">https://mp.weixin.qq.com/s/q3qyc5uf3IMVt4KQD12IKQ</a></p><p>【Golang】Map长啥样儿？— 幼麟实验室，<a href="https://www.bilibili.com/video/BV1Sp4y1U7dJ">https://www.bilibili.com/video/BV1Sp4y1U7dJ</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>源码</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 25. K 个一组翻转链表</title>
    <link href="/2021/07/29/leetcode-25-k-ge-yi-zu-fan-zhuan-lian-biao/"/>
    <url>/2021/07/29/leetcode-25-k-ge-yi-zu-fan-zhuan-lian-biao/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>进阶：</p><p>你可以设计一个只使用常数额外空间的算法来解决此问题吗？<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>输出：[2,1,4,3,5]</p><p>示例 2：</p><p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3<br>输出：[3,2,1,4,5]</p><p>示例 3：</p><p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 1<br>输出：[1,2,3,4,5]</p><p>示例 4：</p><p>输入：head &#x3D; [1], k &#x3D; 1<br>输出：[1]</p><p>提示：</p><p>列表中节点的数量在范围 sz 内<br>1 &lt;&#x3D; sz &lt;&#x3D; 5000<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>1 &lt;&#x3D; k &lt;&#x3D; sz</p></blockquote><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>这里借用 leetcode 题解的 <a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/">流程图</a>，比较直观，只要照着图上的流程，基本就可以编写出代码了。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1627527292593.png"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    s := &amp;ListNode&#123;Next: head&#125;<br><br>    <span class="hljs-keyword">var</span> (<br>        pre   = s           <span class="hljs-comment">// start 的前继节点</span><br>        next  = pre       <span class="hljs-comment">// end 的后继节点</span><br>        start *ListNode <span class="hljs-comment">// 要翻转的第一个节点</span><br>        end   = pre       <span class="hljs-comment">// 要翻转的最后一个节点</span><br>    )<br><br>    <span class="hljs-keyword">for</span> pre != <span class="hljs-literal">nil</span> &#123;<br>        start = pre.Next<br>        <span class="hljs-comment">// end 移动到要翻转的最后一个节点</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>            end = end.Next<br>            <span class="hljs-keyword">if</span> end == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> s.Next<br>&#125;<br>        &#125;<br>        next = end.Next<br>        end.Next = <span class="hljs-literal">nil</span> <span class="hljs-comment">// 断链</span><br><br>        rh, rt := reverse(start) <span class="hljs-comment">// 反转 start - end</span><br>         <br>        <span class="hljs-comment">// 重新连接链表</span><br>        pre.Next = rh<br>        rt.Next = next<br><br>        pre = rt<br>        end = rt<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> s.Next<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(head *ListNode)</span></span> (rhead, rtail *ListNode) &#123;<br>    <span class="hljs-keyword">var</span> (<br>        cur = head<br>        prev, next *ListNode<br>    )<br><br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        next = cur.Next<br>        cur.Next = prev<br>        prev = cur<br>        cur = next<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> prev, head<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程题]二叉树的下一个结点</title>
    <link href="/2021/07/28/bian-cheng-ti-er-cha-shu-de-xia-yi-ge-jie-dian/"/>
    <url>/2021/07/28/bian-cheng-ti-er-cha-shu-de-xia-yi-ge-jie-dian/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给定二叉树其中的一个结点，请找出其中序遍历顺序的下一个结点并且返回。</p><p>注意，树中的结点不仅包含左右子结点，而且包含指向父结点的指针。</p><p>示例:<br>输入:{8,6,10,5,7,9,11},8<br>返回:9<br>解析:这个组装传入的子树根节点，其实就是整颗树，中序遍历{5,6,7,8,9,10,11}，根节点8的下一个节点就是9，应该返回{9,10,11}，后台只打印子树的下一个节点，所以只会打印9，如下图，其实都有指向左右孩子的指针，还有指向父节点的指针，下图没有画出来<br><img src="https://zengh1.github.io/post-images/1627470369081.png"></p><p>特别说明：leetcode 上没有这道题，测评请前往牛客，评测地址：<a href="https://www.nowcoder.com/questionTerminal/9023a0c988684a53960365b889ceaf5e">https://www.nowcoder.com/questionTerminal/9023a0c988684a53960365b889ceaf5e</a></p></blockquote><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>有如下情况：</p><ol><li><p>该节点有右子树，那么下一个节点是右子树的最左节点，比如上图中的 <code>8</code>，其右子树为 <code>10</code>，<code>10</code> 的最左节点为 <code>9</code>，所以 <code>8</code> 的下一个节点是 <code>9</code>。</p></li><li><p>该节点无右子树，那么又有以下两种情况：</p><ol><li><p>该节点为其父节点的左子节点，比如 <code>9</code> 就是其父节点 <code>10</code> 的左子节点，此时下一个节点就是父节点。</p></li><li><p>该节点为其父节点的右子节点，比如 <code>7</code> 就是其父节点 <code>6</code> 的右子节点，此时下一个节点是：左子节点是其父节点<br>的节点，说起来比较绕，就是左子节点为 <code>6</code>  的节点，在图中是 <code>8</code>。</p><p>再举一个例子：如果给定的节点为 <code>11</code> ，其父节点为 <code>10</code>，但是没有任何一个节点的左子节点为 <code>10</code>，此时只能继续向上找，看 <code>10</code> 的父节点 <code>8</code> 的情况，同样的，没有任何一个节点的左子节点为 <code>8</code>，继续向上，但此时 <code>8</code> 已经没有父节点了，所以返回 nil</p></li></ol></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">type TreeLinkNode struct &#123;</span><br><span class="hljs-comment">    Val int</span><br><span class="hljs-comment">    Left *TreeLinkNode</span><br><span class="hljs-comment">    Right *TreeLinkNode</span><br><span class="hljs-comment">    Next *TreeLinkNode</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetNext</span><span class="hljs-params">(pNode *TreeLinkNode)</span></span> *TreeLinkNode &#123;<br>    <span class="hljs-comment">// 右子树不为空</span><br>    <span class="hljs-keyword">if</span> pNode.Right != <span class="hljs-literal">nil</span> &#123;<br>        p := pNode.Right<br>      <span class="hljs-comment">// 右子树中最左边的节点</span><br>        <span class="hljs-keyword">for</span> p.Left != <span class="hljs-literal">nil</span> &#123;<br>            p = p.Left<br>        &#125;<br>        <span class="hljs-keyword">return</span> p<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 右子树为空</span><br>      <span class="hljs-comment">// 如果 pNode 是其父节点的左子节点（注意父节点的非空判断）</span><br>        <span class="hljs-keyword">if</span> pNode.Next != <span class="hljs-literal">nil</span> &amp;&amp; pNode.Next.Left == pNode &#123;<br>            <span class="hljs-comment">// 则下一个节点是父节点</span><br>            <span class="hljs-keyword">return</span> pNode.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// pNode 是父节点的右子节点</span><br>            p := pNode.Next<span class="hljs-comment">// pNode 的父节点</span><br>     <br>            <span class="hljs-comment">// 不断向上查找，直到找到一个节点的左子节点为 p 或者 p == nil</span><br>            <span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &amp;&amp; p.Next != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-comment">// 如果 p（父节点）的父节点的左子节点不是 p</span><br>                <span class="hljs-comment">// 则继续向上查找</span><br>                <span class="hljs-keyword">if</span> p.Next.Left != p &#123;<br>                    p = p.Next<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> p.Next<br>                &#125;   <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 面试题</title>
    <link href="/2021/07/25/mysql-mian-jing/"/>
    <url>/2021/07/25/mysql-mian-jing/</url>
    
    <content type="html"><![CDATA[<h1 id="1-char-和-varchar-的区别"><a href="#1-char-和-varchar-的区别" class="headerlink" title="1. char 和 varchar 的区别"></a>1. char 和 varchar 的区别</h1><p>char 是固定长度，varchar 长度可变，存储时，前者不管实际存储数据的长度，直接规定 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的存储空间。</p><p>以char(32)和varchar(32)举例：（这里的 32 表示字符数）</p><table><thead><tr><th align="left"></th><th>char(32)</th><th>varchar(32)</th></tr></thead><tbody><tr><td align="left">占用空间</td><td>固定32字符（如果数据长度不够32将用空格补齐）</td><td>跟随实际存储内容长度，但不超过32</td></tr><tr><td align="left">空格处理</td><td>检索时会去掉尾部空格（数据本身有空白符也会被去掉）</td><td>不会对空格处理</td></tr><tr><td align="left">是否记录字段长度</td><td>否</td><td>是。额外拿出空间记录字段数据长度（字符数）</td></tr><tr><td align="left">适用场景</td><td>存储的数据长度基本一致，不需要空格，eg 手机号、UUID、密码加密后的密文</td><td>数据长度不一定，长度范围变化较大的场景</td></tr></tbody></table><p><em>小问题：char(1) 和 varchar(1) 的区别？两个都只能保存单个字符，但是 varchar 要多占一个或两个存储位置用来记录存储长度信息</em></p><h1 id="2-建立一个联合索引，问-select-a，b，c-和-select-a，c，b-有什么区别"><a href="#2-建立一个联合索引，问-select-a，b，c-和-select-a，c，b-有什么区别" class="headerlink" title="2. 建立一个联合索引，问 select a，b，c 和 select a，c，b 有什么区别"></a>2. 建立一个联合索引，问 select a，b，c 和 select a，c，b 有什么区别</h1><p>MySQL 的 最左前缀匹配原则</p><h1 id="3-varchar-类型，插入的数据超过设置的长度会怎样"><a href="#3-varchar-类型，插入的数据超过设置的长度会怎样" class="headerlink" title="3. varchar 类型，插入的数据超过设置的长度会怎样"></a>3. varchar 类型，插入的数据超过设置的长度会怎样</h1><p>来源： <a href="https://www.hegongshan.com/2020/04/22/mysql-varchar/">https://www.hegongshan.com/2020/04/22/mysql-varchar/</a></p><p>网上基本都说字符串会被自动截断，并报出一个 warning，但是，我在本机上测试时（MySQL 8.0.16），却报了如下错误：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">ERROR </span>1406 (22001): Data too long for column &#x27;name&#x27; at row 1<br></code></pre></td></tr></table></figure><p>这是怎么回事呢？后来，我发现，这两种情况是由于SQL模式不同造成的。</p><p>在MySQL中，有如下三种最重要的SQL模式（官网称之为<code>The Most Important SQL Modes</code>）</p><ol><li><p>ANSI </p><blockquote><p>宽松模式</p><p>此模式更改语法和行为，使其更接近标准SQL</p></blockquote></li><li><p>STRICT_TRANS_TABLES</p><blockquote><p>严格模式</p><p>在该模式下,如果一个值不能插入到一个事务表中,则中断当前的操作,对非事务表不做限制</p></blockquote></li><li><p>TRADITIONAL</p><blockquote><p>在向列中插入错误值时，此模式“给出错误而不是警告”。</p><p>TRADITIONAL 是一个组合模式，它包含了 STRICT_TRANS_TABLES</p></blockquote></li></ol><p>使用 <code>select @@sql_mode</code> 查看当前的 sql_mode。</p><p><code>set @@sql_mode = &#39;traditional&#39;</code> 更改当前 sql_mode。</p><p><strong>总结</strong></p><p>当 varchar 超过限制长度时，</p><p>1.如果当前的 SQL 模式为宽松模式，那么将会按照从前往后的顺序，对字符串进行截断，并提示一个警告；</p><p>2.如果当前的 SQL 模式为严格模式，那么将会报出一个错误。</p><h1 id="MYSQL-事务的-ACID"><a href="#MYSQL-事务的-ACID" class="headerlink" title="MYSQL 事务的 ACID"></a>MYSQL 事务的 ACID</h1><ul><li><p><strong>1. 原子性 (Atomicity)</strong></p></li><li><p><strong>含义：</strong> 一个事务被视为一个不可分割的、最小的工作单元。事务中的所有操作<strong>要么全部成功执行，要么全部不执行（回滚）</strong>。绝对不会出现事务只执行了一部分的情况。</p></li><li><p><strong>类比：</strong> 就像原子是物质的最小不可分割单位一样，事务是数据库操作的最小逻辑单元。</p></li><li><p><strong>目的：</strong> 保证数据的完整性。例如，在一个银行转账事务中，包含两个操作：从账户 A 扣款，给账户 B 存款。原子性确保这两个操作要么都完成，要么如果中间任何一步失败（比如 B 账户不存在或系统崩溃），已经执行的扣款操作也会被撤销（回滚），数据库状态将恢复到事务开始之前的样子，避免了钱凭空消失或产生的情况。</p></li><li><p><strong>实现机制：</strong> MySQL 主要通过 <strong>Undo Log（回滚日志）</strong> 来实现原子性。在执行数据修改操作之前，会先将原始数据记录到 Undo Log 中。如果事务需要回滚，数据库可以利用 Undo Log 中的信息将数据恢复到事务开始时的状态。</p></li></ul><p><strong>2. 一致性 (Consistency)</strong></p><ul><li><p><strong>含义：</strong> 事务的执行必须使数据库从一个<strong>一致性状态</strong>转变到另一个<strong>一致性状态</strong>。一致性状态意味着数据库中的数据满足所有的预定约束（如主键约束、外键约束、唯一性约束、数据类型约束以及业务规则定义的约束）。</p></li><li><p><strong>关键点：</strong></p><ul><li><p><strong>事务开始前</strong>，数据库处于一致状态。</p></li><li><p><strong>事务结束后</strong>，无论事务是成功提交还是失败回滚，数据库<strong>也必须</strong>处于一致状态。</p></li><li><p><strong>事务执行过程中</strong>，数据可能暂时处于不一致状态（例如转账过程中，一个账户已扣款但另一个账户还未收款），但这是中间状态，最终结果必须是一致的。</p></li></ul></li><li><p><strong>目的：</strong> 维护数据的正确性和业务规则的有效性。确保不会因为事务的执行而产生无效或矛盾的数据。</p></li><li><p><strong>实现机制：</strong> 一致性是 ACID 的最终目标，它依赖于其他三个属性（原子性、隔离性、持久性）以及数据库自身的约束机制（如约束检查、触发器等）共同保证。原子性保证了操作的完整性，隔离性防止了并发事务间的干扰，持久性确保了结果的永久性，这些都是实现一致性的基础。数据库还会执行约束检查，确保插入或更新的数据符合规则。</p></li></ul><blockquote><p>PS: 一致性不太好理解，简单的说，就是其他三个特性确保了一致性。</p></blockquote><p><strong>3. 隔离性 (Isolation)</strong></p><ul><li><p><strong>含义：</strong> 数据库允许多个事务<strong>并发</strong>执行，但一个事务的执行<strong>不应被其他并发执行的事务所干扰</strong>。即，并发执行的事务之间应该相互隔离，使得每个事务都感觉像是在独立地操作数据库。</p></li><li><p><strong>目的：</strong> 防止并发环境下可能出现的数据问题，如：</p><ul><li><p><strong>脏读 (Dirty Read):</strong> 一个事务读取了另一个事务尚未提交的修改数据。如果那个事务最终回滚，那么读取到的就是无效的“脏”数据。</p></li><li><p><strong>不可重复读 (Non-repeatable Read):</strong> 一个事务在同一次执行中，对同一数据进行多次读取，但由于其他事务在此期间修改了该数据并提交，导致两次读取的结果不一致。</p></li><li><p><strong>幻读 (Phantom Read):</strong> 一个事务在同一次执行中，按相同条件多次查询，但由于其他事务在此期间插入或删除了符合条件的数据并提交，导致两次查询返回的记录<strong>行数</strong>不一致，好像出现了“幻影”行。</p></li></ul></li><li><p><strong>实现机制：</strong> MySQL 通过<strong>锁机制 (Locking)</strong> 和 <strong>多版本并发控制 (MVCC - Multi-Version Concurrency Control)</strong> 来实现隔离性。</p><ul><li><p><strong>锁机制：</strong> 通过对数据行、表等加锁，阻止其他事务进行冲突的操作。</p></li><li><p><strong>MVCC:</strong> 在 InnoDB 存储引擎中广泛使用。为每一行数据维护多个版本（通过隐藏的版本号和 Undo Log 实现），使得读操作（通常）不需要加锁，可以读取到事务开始时的一个一致性快照，从而避免了读写冲突，提高了并发性能。</p></li><li><p><strong>隔离级别 (Isolation Levels):</strong> MySQL 提供了四种隔离级别（读未提交 Read Uncommitted, 读已提交 Read Committed, 可重复读 Repeatable Read (默认), 串行化 Serializable），允许用户根据应用需求在并发性能和数据一致性之间进行权衡。不同的隔离级别能解决不同程度的并发问题。</p></li></ul></li></ul><p><strong>4. 持久性 (Durability)</strong></p><ul><li><p><strong>含义：</strong> 一旦事务成功<strong>提交 (Commit)<strong>，它对数据库所做的更改就应该是</strong>永久性</strong>的。即使后续发生系统崩溃、断电等故障，这些已提交的更改也<strong>不能丢失</strong>。</p></li><li><p><strong>目的：</strong> 保证数据的可靠性。用户的操作结果（只要事务成功提交）是值得信赖的，不会因为意外情况而消失。</p></li><li><p><strong>实现机制：</strong> MySQL 主要通过 <strong>Redo Log（重做日志）</strong> 来实现持久性。</p><ul><li><p>当事务提交时，其所做的修改会先被写入到 Redo Log 文件中（通常是顺序写入，速度很快）。</p></li><li><p>只有当 Redo Log 写入成功后，事务才算真正提交。</p></li><li><p>数据页（Data Page）的修改可能会稍后才被刷新（Flush）到磁盘上的数据文件中（为了性能）。</p></li><li><p>如果在数据页刷新到磁盘前系统崩溃，数据库在重启后可以通过 Redo Log 中的记录，重新执行那些已提交但未完全落盘的事务操作，将数据库恢复到崩溃前的最后一个一致状态，从而保证了已提交事务的持久性。</p></li></ul></li></ul><h1 id="MySQL-原子性怎么保证"><a href="#MySQL-原子性怎么保证" class="headerlink" title="MySQL 原子性怎么保证"></a>MySQL 原子性怎么保证</h1><p>MySQL (特别是使用 <strong>InnoDB</strong> 存储引擎时，因为像 MyISAM 这样的引擎不支持事务) 主要通过 <strong>Undo Log (回滚日志)</strong> 来保证事务的原子性（Atomicity）。</p><p>以下是详细的保证机制：</p><ol><li><p><strong>记录反向操作信息 (Undo Log):</strong></p><ul><li><p>当一个事务开始对数据进行修改（如 INSERT, UPDATE, DELETE）时，在<strong>实际修改数据页 (Data Page) 之前</strong>，InnoDB 会先将用于<strong>撤销</strong>这些操作所需的信息记录到 Undo Log 中。</p></li><li><p><strong>对于 INSERT 操作：</strong> Undo Log 会记录下新插入数据的主键或其他唯一标识，以便在回滚时可以根据这个标识删除这条记录。</p></li><li><p><strong>对于 UPDATE 操作：</strong> Undo Log 会记录下被修改行修改<strong>之前</strong>的旧值。如果事务回滚，InnoDB 可以根据 Undo Log 中的旧值将数据恢复原状。</p></li><li><p><strong>对于 DELETE 操作：</strong> Undo Log 会记录下被删除行的内容。如果事务回滚，InnoDB 可以根据 Undo Log 中的记录将这行数据重新插入回去。</p></li><li><p>这些 Undo Log 记录会与事务 ID 关联起来，形成一个操作链。</p></li></ul></li><li><p><strong>事务提交 (Commit):</strong></p><ul><li><p>如果事务中的所有操作都成功执行，并且用户发出了 COMMIT 指令。</p></li><li><p>此时，事务被认为是成功的。虽然数据的最终落盘可能稍后由 Redo Log 保证（为了持久性），但从原子性的角度看，这个事务逻辑上已经完成了“全部执行”的部分。与该事务相关的 Undo Log 在不再被其他事务所需要（例如用于 MVCC 一致性读）之后，可以被清理。</p></li></ul></li><li><p><strong>事务回滚 (Rollback):</strong></p><ul><li><p>如果在事务执行过程中发生任何错误（如违反约束、SQL 错误、死锁牺牲品等），或者用户显式执行了 ROLLBACK 命令。</p></li><li><p>数据库系统会利用该事务对应的 <strong>Undo Log</strong>。</p></li><li><p>它会<strong>按照与执行操作相反的顺序</strong>，读取 Undo Log 中的记录，并执行相应的“反向”操作：</p><ul><li><p>对于之前的 INSERT，执行 DELETE。</p></li><li><p>对于之前的 UPDATE，使用旧值恢复数据。</p></li><li><p>对于之前的 DELETE，重新 INSERT 数据。</p></li></ul></li><li><p>通过执行这些反向操作，数据库的状态被<strong>精确地恢复到该事务开始执行之前</strong>的样子。</p></li><li><p>这就实现了原子性的“全部不执行”部分。</p></li></ul></li><li><p><strong>系统崩溃恢复:</strong></p><ul><li><p>如果数据库在事务执行过程中（尚未提交）发生崩溃。</p></li><li><p>当数据库重启时，它会检查事务日志（特别是 Redo Log 和 Undo Log）。</p></li><li><p>对于那些已经写入 Redo Log 但尚未标记为 Commit 的<strong>未完成事务</strong>，数据库会利用 Undo Log 将这些事务进行<strong>回滚</strong>，以确保它们没有部分更改留在数据库中，保证了原子性。</p></li><li><p>（对于已 Commit 但可能未完全刷盘的事务，则会用 Redo Log 来前滚，保证持久性）。</p></li></ul></li></ol><h2 id="撤销日志（Undo-Log）"><a href="#撤销日志（Undo-Log）" class="headerlink" title="撤销日志（Undo Log）"></a><del>撤销日志（Undo Log）</del></h2><ul><li><p><del>作用：记录事务执行前的数据状态</del></p></li><li><p><del>工作原理：</del></p></li><li><p><del>事务开始前，将修改的数据原始状态保存在撤销日志中</del></p></li><li><p><del>若事务需要回滚，系统使用撤销日志将数据恢复到事务前状态</del></p></li><li><p><del>对每个操作记录反向操作（如INSERT的反向是DELETE）</del></p></li><li><p><del>实现：InnoDB在回滚段（Rollback Segment）中维护撤销日志</del></p></li></ul><h1 id="redolog-工作原理"><a href="#redolog-工作原理" class="headerlink" title="redolog 工作原理"></a>redolog 工作原理</h1><p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，</p><p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下图所示。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/redolog.webp"></p><p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录（也就是写入到硬盘），把 checkpoint 推进一下（写入成功后只移动 checkpoint，而不会清空数据，后续直接覆盖写即可）。</p><h1 id="redolog-中会存在未提交事务产生的内容吗"><a href="#redolog-中会存在未提交事务产生的内容吗" class="headerlink" title="redolog 中会存在未提交事务产生的内容吗"></a>redolog 中会存在未提交事务产生的内容吗</h1><p>是的，<strong>MySQL 的 redo log（重做日志）中</strong>是会存在<strong>未提交事务产生的内容</strong>的。</p><hr><h3 id="一、为什么-redo-log-中会有未提交事务的内容？"><a href="#一、为什么-redo-log-中会有未提交事务的内容？" class="headerlink" title="一、为什么 redo log 中会有未提交事务的内容？"></a>一、为什么 redo log 中会有未提交事务的内容？</h3><p>MySQL 的 InnoDB 存储引擎使用 <strong>WAL（Write-Ahead Logging）机制</strong>，即：</p><ul><li><p>修改数据时，<strong>先写 redo log</strong>，再更新内存中的数据（Buffer Pool），</p></li><li><p>之后再将数据异步刷新到磁盘的 <code>.ibd</code> 文件中（即真正的数据页）。</p></li></ul><blockquote><p><strong>redo log 记录的是对数据页的物理更改，用于崩溃恢复（Crash Recovery）</strong></p></blockquote><p>关键点在于：</p><ul><li><p><strong>事务在执行过程中就会不断写入 redo log</strong>，但这些日志的 <code>trx id</code>（事务 id）对应的事务可能还没有提交。</p></li><li><p>所以 redo log 中<strong>包含了尚未提交的事务产生的变更信息</strong>。</p></li></ul><hr><h3 id="二、这些未提交的-redo-log-有什么用？"><a href="#二、这些未提交的-redo-log-有什么用？" class="headerlink" title="二、这些未提交的 redo log 有什么用？"></a>二、这些未提交的 redo log 有什么用？</h3><ol><li><p><strong>崩溃恢复时会用到</strong></p><ul><li><p>如果发生宕机，MySQL 会在重启时根据 redo log 执行恢复操作。</p></li><li><p>InnoDB 会扫描 redo log，根据事务的提交状态：</p><ul><li><p><strong>已提交的事务</strong> → 做 <strong>重做（redo）</strong></p></li><li><p><strong>未提交的事务</strong> → 忽略（或做 undo）</p></li></ul></li></ul></li><li><p><strong>性能优化（提前写入日志）</strong></p><ul><li><p>事务执行过程中先写日志，不等事务提交，有助于提高写入性能。</p></li><li><p>不必等所有修改完成、事务提交时才写日志。</p></li></ul></li></ol><hr><h3 id="三、redo-log-和事务提交的关系"><a href="#三、redo-log-和事务提交的关系" class="headerlink" title="三、redo log 和事务提交的关系"></a>三、redo log 和事务提交的关系</h3><ul><li><p>redo log 分为两部分：</p><ul><li><p><strong>prepare 阶段</strong>：事务执行时写入 redo log，但未提交。</p></li><li><p><strong>commit 阶段</strong>：事务提交时写入 commit 标记（特殊日志）。</p></li></ul></li></ul><p>只有在 redo log 中发现有 <strong>prepare + commit 标志</strong> 的事务，MySQL 才会在恢复时进行重做。</p><hr><h3 id="四、举个例子"><a href="#四、举个例子" class="headerlink" title="四、举个例子"></a>四、举个例子</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-comment">-- 此时已经写入 redo log（prepare 阶段），但未 commit</span><br><span class="hljs-comment">-- 如果宕机，InnoDB 会发现这两个操作产生的 redo log 是未提交的</span><br><span class="hljs-comment">-- 所以不会做 redo</span><br><span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-comment">-- 写入 redo log 的 commit 标记，此时事务才真正生效</span><br></code></pre></td></tr></table></figure><hr><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><table><thead><tr><th>阶段</th><th>redo log 中是否存在</th><th>redo log 是否生效</th></tr></thead><tbody><tr><td>未提交</td><td>✅ 有</td><td>❌ 不生效</td></tr><tr><td>已提交</td><td>✅ 有</td><td>✅ 恢复时生效</td></tr></tbody></table><hr><p>如你后续还有关于 undo log、binlog 的配合或 crash recovery 流程感兴趣，也可以展开聊聊 👍</p><h1 id="宕机后如何保证数据不丢失？"><a href="#宕机后如何保证数据不丢失？" class="headerlink" title="宕机后如何保证数据不丢失？"></a>宕机后如何保证数据不丢失？</h1><p>保证 MySQL (特别是 InnoDB 存储引擎) 在宕机后数据不丢失，主要依赖于<strong>持久性 (Durability)</strong> 的实现，其核心机制是 **Write-Ahead Logging (WAL)**，具体体现在 <strong>Redo Log (重做日志)</strong> 的使用上。</p><p>以下是保证数据不丢失的关键步骤和原理：</p><ol><li><p><strong>Redo Log (重做日志) - 先写日志，再写数据:</strong></p><ul><li><p><strong>什么是 Redo Log:</strong> 它是一个物理日志，记录的是对数据页（Data Page）所做的<strong>物理修改</strong>，而不是逻辑操作（比如不是记录 UPDATE SET col&#x3D;val WHERE id&#x3D;1，而是记录类似“在表空间 X 的 Y 页的偏移量 Z 处写入字节 W”这样的底层修改）。</p></li><li><p><strong>写在前面 (Write-Ahead):</strong> 当一个事务修改数据时，InnoDB <strong>首先</strong>会将这些修改操作对应的 Redo Log 记录写入到<strong>内存中的 Redo Log Buffer</strong>。然后，在事务<strong>提交 (Commit)</strong> 时（或根据配置策略），这些 Redo Log 记录<strong>必须先被刷新 (Flush) 到磁盘上的 Redo Log 文件中</strong>，然后事务才算真正成功提交。这个“先写日志”的操作是持久性的关键。</p></li><li><p><strong>顺序写入:</strong> Redo Log 文件通常是<strong>顺序写入</strong>的，这比向数据文件进行随机写入要快得多。</p></li></ul></li><li><p><strong>Buffer Pool (缓冲池) - 内存加速:</strong></p><ul><li><p>InnoDB 在内存中维护一个 Buffer Pool，用于缓存磁盘上的数据页。</p></li><li><p>当事务修改数据时，它实际上是先修改<strong>内存中 Buffer Pool 里的数据页</strong>。这些被修改过的页被称为“脏页 (Dirty Pages)”。</p></li></ul></li><li><p><strong>数据页延迟写入 (Delayed Write):</strong></p><ul><li><p>修改后的“脏页”<strong>不一定</strong>会在事务提交时立即被写回到磁盘上的数据文件 (.ibd 文件) 中。</p></li><li><p>InnoDB 会在后台根据一定的策略（如 Checkpoint 机制、Buffer Pool 空间不足时等）将这些脏页<strong>异步地、批量地</strong>刷新回磁盘。这样做可以合并写入操作，减少随机 I&#x2F;O，提高性能。</p></li></ul></li><li><p><strong>事务提交的关键点:</strong></p><ul><li><p>一个事务被认为成功提交并具有持久性的<strong>充要条件</strong>是：与该事务相关的所有 Redo Log 记录<strong>已经成功写入到磁盘上的 Redo Log 文件中</strong>。</p></li><li><p>即使此时对应的“脏页”还没有刷新到磁盘数据文件中，数据也是安全的。</p></li></ul></li><li><p><strong>宕机后的恢复过程 (Crash Recovery):</strong></p><ul><li><p>当 MySQL 因宕机（如断电、操作系统崩溃）重启时，InnoDB 会执行恢复流程：</p><ul><li><p><strong>检查 Redo Log:</strong> InnoDB 会读取磁盘上的 Redo Log 文件。</p></li><li><p><strong>找到最后检查点 (Checkpoint):</strong> 它会找到最后一个成功的检查点（Checkpoint LSN - Log Sequence Number），这个点表示在此之前的 Redo Log 对应的所有数据页修改都<strong>保证</strong>已经刷新到磁盘数据文件了。</p></li><li><p><strong>重放 Redo Log (Roll Forward):</strong> 对于检查点<strong>之后</strong>的 Redo Log 记录，InnoDB 会将这些记录代表的物理修改<strong>重新应用</strong>到内存的 Buffer Pool 中（如果需要，会先从磁盘加载对应的数据页）。这会把那些在宕机前已提交但其数据页修改尚未落盘的操作重新做一遍。</p></li><li><p><strong>(回滚未提交事务):</strong> 同时，InnoDB 也会利用 Undo Log 回滚那些在宕机时还未提交的事务（保证原子性）。</p></li></ul></li><li><p><strong>结果:</strong> 通过重放 Redo Log，所有<strong>已成功提交</strong>的事务（即其 Redo Log 已落盘）的效果都被恢复到了数据库中，即使它们的数据页在宕机前没有写入磁盘，也保证了数据的持久性，不会丢失。</p></li></ul></li></ol><p><strong>配置参数的影响 (innodb_flush_log_at_trx_commit)</strong></p><p>这个参数直接影响 Redo Log 的刷盘时机，从而影响持久性的强度和性能：</p><ul><li><p><strong>1 (默认值):</strong> 最高安全性。每次事务提交时，都会将 Redo Log Buffer 的内容<strong>同步</strong>写入到磁盘上的 Redo Log 文件并完成 fsync 操作。即使操作系统或数据库主机宕机，也最多丢失未提交的事务。这是完全符合 ACID 持久性的设置。</p></li><li><p><strong>2:</strong> 性能较好。每次事务提交时，仅将 Redo Log Buffer 写入操作系统的文件缓存 (Page Cache)，大约每秒由操作系统将缓存刷新到磁盘。如果仅仅是 MySQL 进程崩溃，数据不会丢失；但如果操作系统也同时崩溃或服务器断电，可能会丢失最后一秒内提交的事务。</p></li><li><p><strong>0:</strong> 性能最好。大约每秒才将 Redo Log Buffer 写入操作系统的文件缓存，并由操作系统刷新到磁盘。MySQL 进程崩溃或操作系统崩溃&#x2F;断电都可能导致丢失最后一秒的事务。</p></li></ul><p><strong>总结:</strong></p><p>MySQL InnoDB 通过 <strong>Write-Ahead Logging (WAL)</strong> 策略，利用 <strong>Redo Log</strong> 实现了持久性。核心在于<strong>强制要求事务提交前必须先将对应的 Redo Log 记录写入磁盘</strong>。这样即使数据页的写入是延迟和异步的，在系统宕机后，也能通过重放 Redo Log 来恢复所有已提交事务的修改，从而保证数据不丢失。配置参数 innodb_flush_log_at_trx_commit 允许在持久性强度和性能之间进行权衡。</p><p><del>通过 redolog，MySQL 使用了 WAL，在更新记录时会先将操作写到 redo log（redo log 也是一个文件，保存在磁盘上），然后 MySQL 启动时会先检查一下 redo log，看里面有没有内容，有的话说明就说明存在未落盘的数据，此时就可以通过 redo log 将这些数据重新写入到磁盘，从而保证数据不丢失。</del></p><p><del>redo log 的工作原理参见上面</del></p><h1 id="如果-rollback-了，之前已经写入到-redolog-的数据会一起删除吗？此外，redolog-的刷盘时机是什么？它不会把未提交事务的数据刷盘吗？"><a href="#如果-rollback-了，之前已经写入到-redolog-的数据会一起删除吗？此外，redolog-的刷盘时机是什么？它不会把未提交事务的数据刷盘吗？" class="headerlink" title="如果 rollback 了，之前已经写入到 redolog 的数据会一起删除吗？此外，redolog 的刷盘时机是什么？它不会把未提交事务的数据刷盘吗？"></a>如果 rollback 了，之前已经写入到 redolog 的数据会一起删除吗？此外，redolog 的刷盘时机是什么？它不会把未提交事务的数据刷盘吗？</h1><p> ✅ 问题一：如果 rollback 了，之前已经写入到 redo log 的内容会一起删除吗？</p><p><strong>不会删除！但会被标记为无效。</strong></p><p>原因：</p><ol><li><p><strong>redo log 是顺序写入的日志文件，不支持“回滚删除”</strong></p><ul><li><p>redo log 是一种物理日志，只记录数据页的修改操作，底层是顺序写入、环形结构。</p></li><li><p>不会因为事务回滚而“物理删除”之前写入的日志。</p></li></ul></li><li><p><strong>rollback 时会写 undo log 来“逻辑回滚”</strong></p><ul><li><p>当你 <code>ROLLBACK</code> 一个事务时，InnoDB 会根据 <strong>undo log</strong> 来将数据恢复到原始状态。</p></li><li><p>redo log 里虽然还存在那些未提交时的修改记录，但这些事务是未提交的，因此恢复时会 <strong>忽略</strong>。</p></li></ul></li><li><p><strong>crash recovery 时：</strong></p><ul><li><p>InnoDB 会遍历 redo log 日志：</p><ul><li><p>找到 <strong>已提交事务的日志</strong> → redo 恢复（应用日志）</p></li><li><p>找到 <strong>未提交事务的日志</strong> → <strong>不执行</strong>，等事务恢复机制清理它。</p></li></ul></li></ul></li></ol><p>🔁 所以你可以理解为：<strong>rollback 不会删除 redo log 中的数据，而是通过 undo log 做逻辑回退，redo log 留着作为 crash recovery 的一部分，但不会真正重放。</strong></p><p><strong>redo log 的刷盘时机</strong></p><p>InnoDB 会根据两种时机刷盘 redo log：</p><table><thead><tr><th>场景</th><th>行为</th></tr></thead><tbody><tr><td>1. 写入 redo log buffer（内存）时</td><td>不立即刷盘（写入内存）</td></tr><tr><td>2. 满足以下任何一种情况时才会刷盘（fsync 到磁盘）</td><td></td></tr><tr><td>- <code>COMMIT</code> 提交事务</td><td>✅ 刷盘（取决于 <code>innodb_flush_log_at_trx_commit</code> 参数）</td></tr><tr><td>- redo log buffer 空间不足</td><td>✅ 刷盘</td></tr><tr><td>- 后台定时刷新（如每秒）</td><td>✅ 刷盘</td></tr><tr><td>- crash recover</td><td>✅ 读取 redo log 日志恢复</td></tr></tbody></table><hr><p><strong>关键参数：<code>innodb_flush_log_at_trx_commit</code></strong></p><p>这个参数控制 <strong>事务提交时是否强制将 redo log 刷到磁盘</strong>：</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td><code>0</code></td><td>不在事务提交时刷盘，只由后台线程周期性刷盘（如每秒）</td></tr><tr><td><code>1</code></td><td>每次事务提交时都立刻 fsync（最安全）✅ 推荐</td></tr><tr><td><code>2</code></td><td>提交时写 redo buffer，不 fsync，fsync 交给后台</td></tr></tbody></table><p>💡 <strong>说明：</strong></p><ul><li><p>即使你没有 commit，InnoDB 也可能把 redo log <strong>提前刷到磁盘</strong>（比如 buffer 快满了）。</p></li><li><p>所以磁盘上可能存在很多 <strong>未提交事务的 redo log 数据</strong>。</p></li></ul><hr><p><strong>这安全吗？为啥不怕刷了未提交事务？</strong></p><p>这正是 <strong>InnoDB crash recovery 机制</strong> 的关键设计点：</p><ul><li><p><strong>刷盘 ≠ 提交成功</strong></p></li><li><p>redo log 中必须有 <code>COMMIT</code> 标志，才表示这个事务成功提交，才会在恢复时执行。</p></li><li><p>所以即使 redo log 中刷了很多还没提交的数据也没关系，<strong>崩溃恢复时不会重放这些“半成品”</strong>。</p></li></ul><p><strong>✅ 总结</strong></p><table><thead><tr><th>问题</th><th>答案</th></tr></thead><tbody><tr><td>rollback 时 redo log 数据会删除吗？</td><td>❌ 不会删除，但会被标记为“未提交”，恢复时不会执行</td></tr><tr><td>redo log 会不会写未提交事务的数据？</td><td>✅ 会，为了性能提前写入</td></tr><tr><td>redo log 会不会把未提交事务的数据刷盘？</td><td>✅ 会，但恢复时会根据是否有 COMMIT 标记判断是否应用</td></tr><tr><td>为啥这样设计是安全的？</td><td>因为 InnoDB crash recovery 会忽略没有 commit 的日志</td></tr></tbody></table><h2 id="✅-redo-log-并不会“主动”将数据写入-ibd-文件"><a href="#✅-redo-log-并不会“主动”将数据写入-ibd-文件" class="headerlink" title="✅ redo log 并不会“主动”将数据写入 .ibd 文件"></a>✅ redo log 并不会“主动”将数据写入 <code>.ibd</code> 文件</h2><ul><li><p><strong>redo log 是物理日志</strong>，它的主要作用是：<strong>在数据库崩溃后用于恢复未刷盘的脏页</strong>。</p></li><li><p>它<strong>不直接负责</strong>将内存中修改后的数据写入 <code>.ibd</code> 表空间文件。</p></li></ul><h2 id="✅-ibd-文件的写入由-脏页刷盘机制-来完成："><a href="#✅-ibd-文件的写入由-脏页刷盘机制-来完成：" class="headerlink" title="✅ .ibd 文件的写入由 脏页刷盘机制 来完成："></a>✅ <code>.ibd</code> 文件的写入由 <strong>脏页刷盘机制</strong> 来完成：</h2><ul><li><p>当 InnoDB 在 Buffer Pool 中修改了某个数据页后，该页变成了 <strong>dirty page（脏页）</strong>。</p></li><li><p>InnoDB 的后台线程（如 Page Cleaner）会根据策略（时间、水位、压力）<strong>异步将这些脏页 flush 到磁盘 <code>.ibd</code> 文件中</strong>。</p></li><li><p>这个过程 <strong>与 redo log 是否写入或刷盘没有直接关系</strong>，它们是<strong>并行的两个机制</strong>。</p></li></ul><h1 id="undolog-在宕机时怎么保证原子性"><a href="#undolog-在宕机时怎么保证原子性" class="headerlink" title="undolog 在宕机时怎么保证原子性"></a>undolog 在宕机时怎么保证原子性</h1><p><strong>🔧 假设的未提交事务：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>);<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Alice&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">-- 还没 commit，MySQL 崩溃了 💥</span><br></code></pre></td></tr></table></figure><p>这个事务还没提交，MySQL 崩溃了。现在我们来看看：</p><p>每条操作的流程：</p><table><thead><tr><th>操作</th><th>redo log 中记录了什么</th></tr></thead><tbody><tr><td><code>INSERT INTO user VALUES (2, &#39;Jerry&#39;)</code></td><td>哪个页插入了什么值的位置，插入前页的状态，插入的值</td></tr><tr><td><code>INSERT INTO user VALUES (3, &#39;Bob&#39;)</code></td><td>同上</td></tr><tr><td><code>UPDATE user SET name = &#39;Alice&#39; WHERE id = 1</code></td><td>该页中某个记录字段从 “Tom” 改为 “Alice”</td></tr><tr><td><code>DELETE FROM user WHERE id = 10</code></td><td>哪个页删除了哪一行、位置在哪里等信息</td></tr><tr><td>这些信息都写入 redo log 中，<strong>redo log 会打一个 “prepare” 标记</strong>，但<strong>还没有写 commit 标记</strong>。</td><td></td></tr></tbody></table><p>此外，每条操作也会生成一份 undo log，供 rollback 使用。</p><p>此时，我们再来模拟崩溃恢复。</p><p><strong>🧠 恢复过程如下：</strong></p><ol><li><p><strong>MySQL 重启</strong>，Buffer Pool 是空的</p></li><li><p>InnoDB 读取 redo log，发现该事务有 <strong>prepare</strong>，但没有 <strong>commit</strong></p></li><li><p>确认这是个 <strong>未提交事务</strong></p></li><li><p><strong>不执行 redo log 的重做</strong></p></li><li><p>找到该事务的 undo log，执行回滚操作（相当于手动执行 rollback）</p></li><li><p>Buffer Pool 重新加载时，所有对页的恢复都是基于已提交事务</p></li></ol><h1 id="为什么重启要做-undo？如果这个提交还没有-commit，那我直接把它扔掉不就好了吗？buffer-pool-直接加载当前数据？"><a href="#为什么重启要做-undo？如果这个提交还没有-commit，那我直接把它扔掉不就好了吗？buffer-pool-直接加载当前数据？" class="headerlink" title="为什么重启要做 undo？如果这个提交还没有 commit，那我直接把它扔掉不就好了吗？buffer pool 直接加载当前数据？"></a>为什么重启要做 undo？如果这个提交还没有 commit，那我直接把它扔掉不就好了吗？buffer pool 直接加载当前数据？</h1><p>这个问题问得非常精准！很多人第一次学 InnoDB crash recovery 时也会有这个疑惑：</p><blockquote><p>❓“未提交的事务不是没 commit 吗？为啥还要 rollback？直接别恢复它不就好了？”</p></blockquote><p>咱们今天就把这件事彻底讲清楚👇</p><hr><p> ✅ 先给出简洁回答：</p><blockquote><p><strong>InnoDB 不是真正把“未提交事务”数据忽略掉，而是需要主动用 undo log 回滚它</strong>，<br>因为：<strong>这些未提交的修改，已经写入到了数据页（甚至写入磁盘）中了！不能不管！</strong></p></blockquote><hr><p>📌 为什么不能“直接不恢复”？</p><p>我们得从 <strong>redo log 与数据页的时序关系</strong> 来看：</p><ol><li><p>redo log 是“先写日志，再修改内存页（Buffer Pool）”，对吧？</p></li><li><p>如果内存页（Buffer Pool）被刷到磁盘（.ibd 文件），但事务还没 commit，就成了“脏数据”</p></li></ol><hr><p> ⛔ 场景还原：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Alice&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>执行完：</p><ul><li><p>🔸 生成 redo log（写到 redo buffer，可能已刷盘）</p></li><li><p>🔸 Buffer Pool 中修改页内容</p></li><li><p>🔸 Buffer Pool 脏页可能已经异步刷到磁盘（.ibd）</p></li></ul><p>这时突然宕机！</p><hr><p>🔥 如果你“啥也不做”，直接加载当前数据页？</p><ul><li><p>数据页上已经是 “name &#x3D; ‘Alice’”</p></li><li><p>但这个事务没 commit！</p></li><li><p>你就相当于把一个“<strong>未提交事务的修改</strong>”当成“<strong>正常数据</strong>”用了！</p></li></ul><p>这就破坏了 MySQL 的 <strong>事务原子性 &amp; 一致性</strong>（ACID）：</p><blockquote><p>❌ 未提交的内容绝不能被恢复成正式数据！</p></blockquote><hr><p> ✅ 所以必须干嘛？</p><blockquote><p>🔁 在恢复阶段：</p><ul><li><p>识别 redo log 中哪些事务没 commit</p></li><li><p>用它们的 <strong>undo log 回滚</strong>这部分数据页的修改</p></li><li><p>让数据页回到事务开始之前的样子</p></li></ul></blockquote><p>这样才能做到 <strong>事务一致性</strong>：崩溃恢复后只留下那些“已经提交”的结果。</p><hr><p>🧠 简单总结一句话：</p><blockquote><p><strong>InnoDB 不是简单地“忽略”未提交事务，而是必须“显式地撤销”它做过的事。</strong></p></blockquote><p>因为它的修改很可能已经影响了磁盘数据，必须还原！</p><hr><p>如果你想更深入，我可以模拟一次“未提交事务刷脏页”+“undo 回滚”的具体过程（页号 + offset + undo slot），你要不要看看硬核版本的？😎</p><h1 id="什么是-buffer-pool"><a href="#什么是-buffer-pool" class="headerlink" title="什么是 buffer pool"></a>什么是 buffer pool</h1><p><strong>Buffer Pool 是什么？</strong></p><p>简单来说，<strong>Buffer Pool 是 InnoDB 存储引擎在内存中开辟的一块区域，用于缓存磁盘上数据文件（.ibd 文件）中的数据页 (Data Page) 和索引页 (Index Page)。</strong></p><p>你可以把它想象成是数据库为了<strong>减少磁盘 I&#x2F;O</strong> 而在内存里建立的一个高速缓存区。</p><p><strong>为什么需要 Buffer Pool？</strong></p><ul><li><p><strong>磁盘 I&#x2F;O 很慢:</strong> 相比于内存访问，磁盘的随机读写速度要慢好几个数量级。如果每次读写数据都要直接操作磁盘，数据库性能会非常低下。</p></li><li><p><strong>数据访问局部性原理:</strong> 应用程序访问数据通常具有局部性，即最近访问过的数据或其附近的数据很可能在不久的将来再次被访问。将这些热点数据缓存到内存中，可以极大地提高访问速度。</p></li></ul><p><strong>Buffer Pool 如何工作？</strong></p><ol><li><p><strong>缓存数据页和索引页:</strong> 当 InnoDB 需要读取某个数据页或索引页时，它会首先检查这个页是否已经在 Buffer Pool 中：</p><ul><li><p><strong>缓存命中 (Cache Hit):</strong> 如果页在 Buffer Pool 中，InnoDB 直接从内存读取，速度非常快。</p></li><li><p><strong>缓存未命中 (Cache Miss):</strong> 如果页不在 Buffer Pool 中，InnoDB 需要从磁盘上的数据文件将其读取到 Buffer Pool 中一个空闲的缓存页位置，然后再从 Buffer Pool 读取。这个过程相对较慢，因为涉及磁盘 I&#x2F;O。</p></li></ul></li><li><p><strong>缓存修改后的数据 (脏页 Dirty Pages):</strong> 当 InnoDB 需要修改某个数据页时（例如执行 UPDATE 或 INSERT）：</p><ul><li><p>它会先将该页读入 Buffer Pool（如果不在的话）。</p></li><li><p>然后，<strong>直接修改内存中 Buffer Pool 里的这个页</strong>。这个被修改过但尚未写回磁盘的页被称为“脏页 (Dirty Page)”。</p></li><li><p><strong>重要：</strong> 修改<strong>不会</strong>立即写回磁盘的数据文件。这是为了性能。内存修改非常快。</p></li><li><p>为了保证持久性（ACID 中的 D），对数据页的修改操作会先被记录到 <strong>Redo Log</strong> 中，并且 Redo Log 会在事务提交时（或根据策略）被刷到磁盘。</p></li></ul></li><li><p><strong>脏页的刷盘 (Flush):</strong> Buffer Pool 中的脏页最终需要被写回到磁盘上的数据文件中。这个过程通常由后台线程异步、批量地完成，主要触发时机包括：</p><ul><li><p><strong>Checkpoint 机制:</strong> InnoDB 会定期执行 Checkpoint，将某个时间点之前的脏页刷新到磁盘，以推进 Redo Log 的可重用空间。</p></li><li><p><strong>Buffer Pool 空间不足:</strong> 当需要加载新页到 Buffer Pool 但没有足够空闲页时，需要将一些“最久未使用”的脏页刷盘腾出空间。</p></li><li><p><strong>Redo Log 写满:</strong> 为了推进 Redo Log，需要确保对应的脏页已落盘。</p></li><li><p><strong>数据库正常关闭时:</strong> 所有脏页会被刷盘。</p></li></ul></li><li><p><strong>缓存页的淘汰 (Eviction):</strong> Buffer Pool 的大小是有限的。当需要加载新页但没有空闲缓存页时，InnoDB 需要选择一个现有的缓存页进行淘汰。它使用一种改进的 <strong>LRU (Least Recently Used - 最近最少使用)</strong> 算法来决定淘汰哪个页：</p><ul><li><p><strong>基本 LRU:</strong> 维护一个列表，最近访问的页放在列表头部，最久未访问的在尾部。淘汰时从尾部移除。</p></li><li><p><strong>InnoDB 的改进 (Midpoint Insertion Strategy):</strong> 为了防止全表扫描等操作污染缓存（将大量只访问一次的页放入热区），InnoDB 将 LRU 列表分为 “Young” (热数据) 和 “Old” (冷数据) 两个子列表。新读入的页通常先放入 Old 区的头部。只有当 Old 区的页再次被访问时，才会被移动到 Young 区的头部。淘汰优先从 Old 区的尾部进行。</p></li></ul></li></ol><p><strong>Buffer Pool 的重要性:</strong></p><ul><li><p><strong>性能核心:</strong> Buffer Pool 是 InnoDB 性能的关键。一个配置合理、足够大的 Buffer Pool 可以显著减少磁盘 I&#x2F;O，大幅提升数据库的读写性能。</p></li><li><p><strong>配置关键参数:</strong> innodb_buffer_pool_size 是最重要的配置参数之一，它直接决定了 Buffer Pool 的大小。在专用的数据库服务器上，通常建议将其设置为物理内存的 50% 到 80%（需要给操作系统和其他进程留出内存）。</p></li><li><p><strong>监控:</strong> 通过 SHOW ENGINE INNODB STATUS 或相关的 Performance Schema&#x2F;Information Schema 表，可以监控 Buffer Pool 的命中率、脏页数量、I&#x2F;O 活动等关键指标，用于性能分析和调优。</p></li></ul><p><strong>总结:</strong></p><p>MySQL 的 Buffer Pool (主要指 InnoDB 的) 是一个<strong>内存缓存区</strong>，用于存放从磁盘读取的数据页和索引页。它通过将热点数据保留在内存中来<strong>加速读操作</strong>，并通过在内存中修改数据（产生脏页）再异步刷盘来<strong>优化写操作</strong>。其大小和管理效率直接影响数据库性能，是性能调优时必须关注的核心组件。</p><h1 id="buffer-pool-可能会把未提交事务产生的数据刷到-ibd-里面吗？"><a href="#buffer-pool-可能会把未提交事务产生的数据刷到-ibd-里面吗？" class="headerlink" title="buffer pool 可能会把未提交事务产生的数据刷到 ibd 里面吗？"></a>buffer pool 可能会把未提交事务产生的数据刷到 ibd 里面吗？</h1><p>是的，<strong>Buffer Pool 完全有可能将包含未提交事务所做修改的数据页（即“脏页”）刷入到磁盘上的 .ibd 数据文件中</strong>。</p><p>这听起来可能有点反直觉，但这是 InnoDB 设计中正常且必要的行为，并且 <strong>不会破坏事务的原子性或隔离性</strong>，原因如下：</p><ol><li><p><strong>刷盘是基于页 (Page)，而非基于事务 (Transaction):</strong></p><ul><li><p>Buffer Pool 管理和刷盘的基本单位是<strong>数据页</strong>。一个数据页上可能同时包含来自<strong>多个不同事务</strong>（包括已提交、未提交、活跃的）所做的修改记录。</p></li><li><p>InnoDB 的后台刷盘线程（如 Page Cleaner Thread）选择哪些脏页进行刷盘，主要是基于 LRU 算法（淘汰最近最少使用的页）、Checkpoint 进度、脏页比例等因素，而<strong>不是</strong>基于这些页上的修改是否都来自已提交的事务。</p></li><li><p>因此，一个包含未提交事务修改的脏页，完全可能因为上述原因被选中并刷回到 .ibd 文件。</p></li></ul></li><li><p><strong>为什么允许这样做？性能！</strong></p><ul><li><p>如果要求必须等到页上所有的修改都来自已提交的事务才允许刷盘，那么刷盘效率会大大降低。一个包含活跃事务修改的“热点页”可能长时间无法刷盘，导致 Buffer Pool 中脏页堆积，增加恢复时间，并可能阻塞其他需要缓存空间的操作。</p></li><li><p>允许混合刷盘使得刷盘过程更加平滑和高效。</p></li></ul></li><li><p><strong>如何保证原子性和一致性？靠 Undo Log！</strong></p><ul><li><p>即使包含了未提交事务修改的数据页被写入了磁盘，这并不会导致数据不一致或破坏原子性。</p></li><li><p><strong>如果事务最终提交：</strong> 那么这些修改就是有效的，写入磁盘是应该的（虽然 Redo Log 已经保证了持久性）。</p></li><li><p><strong>如果事务最终回滚 (Rollback)：</strong></p><ul><li><p>InnoDB 会使用该事务对应的 <strong>Undo Log</strong> 来撤销这些修改。这个撤销操作<strong>同样会修改 Buffer Pool 中的数据页</strong>（应用反向操作），将这些页再次标记为“脏页”，最终这些“撤销”后的状态也会被刷回磁盘。</p></li><li><p>如果是在<strong>宕机恢复</strong>时需要回滚未提交事务：InnoDB 会先通过 Redo Log 将数据库恢复到崩溃前的状态（这可能包含未提交的修改），然后利用 Undo Log 对所有未提交事务进行回滚操作，将数据页恢复到事务开始前的状态。最终写回磁盘的也是这个回滚后的状态。</p></li></ul></li><li><p><strong>MVCC (多版本并发控制) 的作用：</strong> 对于其他正在运行的事务，它们通过 MVCC 机制读取数据。它们会根据事务的隔离级别和事务 ID，利用 Undo Log 来看到它们应该看到的、一致性的数据版本（通常是事务开始时的快照，或者已提交的数据），而<strong>不会读到</strong>其他未提交事务所做的、即使已经刷盘的修改。</p></li></ul></li></ol><p><strong>总结:</strong></p><ul><li><p><strong>是的，包含未提交事务修改的脏页可能会被刷入 .ibd 文件。</strong></p></li><li><p>这是 InnoDB 出于<strong>性能考虑</strong>的正常设计。</p></li><li><p>数据库的<strong>原子性</strong>（未提交事务最终无效）和<strong>隔离性</strong>（并发事务不看到未提交的修改）是通过 <strong>Undo Log 和 MVCC</strong> 机制来保证的，<strong>而不是</strong>通过阻止未提交修改的数据页刷盘来实现的。</p></li><li><p>宕机恢复时，Redo Log 先恢复所有（包括未提交的）修改，然后 Undo Log 负责回滚未提交的事务，最终确保数据文件只反映已提交事务的状态。</p></li></ul><h1 id="什么是-binlog"><a href="#什么是-binlog" class="headerlink" title="什么是 binlog"></a>什么是 binlog</h1><p>binlog 用于记录数据库执行的写入性操作（不包括查询）信息，以二进制的形式保存在磁盘中。binlog 是 MySQL 的逻辑日志，并且由 Server 层进行记录，使用任何存储引擎的 <a href="https://cloud.tencent.com/product/cdb?from_column=20065&from=20065">MySQL数据库</a> 都会记录 binlog 日志。</p><ul><li>逻辑日志：可以简单理解为记录的就是 SQL 语句。</li><li>物理日志：因为 MySQL 数据最终是保存在数据页中的，物理日志记录的就是数据页变更。</li></ul><p>binlog 是通过追加的方式进行写入的，可以通过 max_binlog_size 参数设置每个 binlog 文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。</p><p>在实际应用中，binlog 的主要使用场景有两个，分别是主从复制和数据恢复。</p><ul><li>主从复制：在 Master 端开启 binlog，然后将 binlog 发送到各个 Slave 端，Slave 端重放 binlog 从而达到主从数据一致。</li><li>数据恢复：通过使用 mysqlbinlog 工具来恢复数据。</li></ul><h1 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h1><ul><li>主库的更新 SQL (update、insert、delete) 被写到 binlog。</li><li>从库发起连接，连接到主库。</li><li>此时主库创建一个 binlog dump thread，把 bin log 的内容发送到从库。</li><li>从库启动之后，创建一个 I&#x2F;O 线程，读取主库传过来的 bin log 内容并写入到 relay log（中继日志）。</li><li>从库还会创建一个 SQL 线程，从 relay log 里面读取内容，从 ExecMasterLog_Pos 位置开始执行读取到的更新事件，将更新内容写入到 slave 的 db。</li></ul><h1 id="为什么有了-redolog-还需要-binlog？二者的区别和使用场景？"><a href="#为什么有了-redolog-还需要-binlog？二者的区别和使用场景？" class="headerlink" title="为什么有了 redolog 还需要 binlog？二者的区别和使用场景？"></a>为什么有了 redolog 还需要 binlog？二者的区别和使用场景？</h1><p><strong>为什么需要两者？&#x2F; 二者的关键区别与互补性</strong></p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>特性</td><td>Redo Log (InnoDB)</td><td>Binlog (MySQL Server)</td></tr><tr><td><strong>层面</strong></td><td>存储引擎层 (InnoDB 特有)</td><td>Server 层 (所有引擎共享)</td></tr><tr><td><strong>目的</strong></td><td><strong>崩溃恢复</strong>, <strong>保证持久性 (Durability)</strong></td><td><strong>复制</strong>, <strong>数据恢复 (PITR)</strong>, <strong>审计</strong></td></tr><tr><td><strong>内容</strong></td><td><strong>物理</strong>操作 (数据页修改)</td><td><strong>逻辑</strong>操作 (SQL 语句或行变更)</td></tr><tr><td><strong>格式</strong></td><td>二进制物理格式</td><td>逻辑格式 (Statement&#x2F;Row&#x2F;Mixed), 可解析</td></tr><tr><td><strong>文件结构</strong></td><td>固定大小, <strong>循环写入</strong></td><td>追加写入, 文件序列, <strong>不循环</strong></td></tr><tr><td><strong>写入时机</strong></td><td>事务执行中产生, 提交时<strong>强制或按策略</strong>刷盘 (WAL)</td><td>事务提交过程中写入 (通常在 Redo Log Prepare 后)</td></tr><tr><td><strong>崩溃安全</strong></td><td><strong>保证</strong> InnoDB 自身崩溃安全</td><td><strong>不直接保证</strong> 引擎层崩溃安全 (依赖引擎的 Redo Log)</td></tr></tbody></table><p><strong>核心原因：职责不同</strong></p><ul><li><p><strong>Redo Log 负责让 InnoDB 自己“不出错”:</strong> 它保证了 InnoDB 存储引擎自身在面对崩溃时的恢复能力，使得 InnoDB 符合 ACID 中的 D（持久性）。它只关心物理数据页如何恢复，不关心逻辑操作是什么。</p></li><li><p><strong>Binlog 负责让 MySQL Server“能被复制”和“能回溯”:</strong> 它记录了数据库发生的逻辑变更，使得其他 MySQL 服务器（从库）可以重放这些变更，或者 DBA 可以利用它进行精确到时间点的数据恢复。它不负责保证单个事务在引擎崩溃时的持久性。</p></li></ul><h1 id="幻读和不可重复读的区别"><a href="#幻读和不可重复读的区别" class="headerlink" title="幻读和不可重复读的区别"></a>幻读和不可重复读的区别</h1><p>不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了</p><p>幻读（Phantom Read）和不可重复读（Non-repeatable Read）都是并发环境下可能出现的数据读取问题，但它们的原因和表现方式有所不同。</p><ol><li>幻读（Phantom Read）： 幻读指的是在事务中多次执行相同的查询，但在两次查询之间有其他事务插入了新的数据，导致第二次查询返回的结果集中出现了新插入的数据，就好像产生了”幻影”一样。幻读通常与范围查询（Range Query）有关，例如使用了 WHERE 子句的查询。</li></ol><p>幻读的产生原因是由于并发事务之间的插入操作，可能导致事务在同样的查询条件下获取的结果集不一致，从而出现了额外的行数据。</p><ol><li>不可重复读（Non-repeatable Read）： 不可重复读指的是在事务中多次执行相同的查询，但在两次查询之间有其他事务对同一行数据进行了修改或删除，导致第二次查询返回的结果与第一次查询不一致。</li></ol><p>不可重复读的产生原因是由于并发事务之间的更新或删除操作，导致事务在多次读取同一行数据时，数据内容发生了变化，从而出现了不一致的情况。</p><p>区别：</p><ul><li>幻读与范围查询有关，主要涉及到新增数据，而不可重复读主要涉及到已有数据的更新或删除。</li><li>幻读是指查询同样的条件下结果集的行数发生了变化，而不可重复读是指查询同样的条件下结果集的行数据内容发生了变化。</li></ul><p>解决方法：</p><ul><li>幻读通常通过使用锁或多版本并发控制（MVCC）来解决。</li><li>不可重复读通常通过使用锁或使用行级别的读取锁（Read Lock）来解决。</li></ul><p>需要注意的是，幻读和不可重复读是数据库事务隔离级别中的现象。在不同的事务隔离级别下，这些问题的出现与解决方式也可能有所不同。</p><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>四种事务隔离级别</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>说明</th></tr></thead><tbody><tr><td><strong>READ UNCOMMITTED</strong></td><td>✅</td><td>✅</td><td>✅</td><td>最低级别，可能读到未提交的数据（脏读）</td></tr><tr><td><strong>READ COMMITTED</strong></td><td>❌</td><td>✅</td><td>✅</td><td>Oracle 默认，解决脏读，但可能看到别的事务提交的新数据（不可重复读）</td></tr><tr><td><strong>REPEATABLE READ</strong></td><td>❌</td><td>❌</td><td>✅</td><td>MySQL InnoDB 默认，保证同一事务内多次读数据一致，但可能遇到幻读</td></tr><tr><td><strong>SERIALIZABLE</strong></td><td>❌</td><td>❌</td><td>❌</td><td>最严格，串行执行（对每行加锁），最慢最安全</td></tr></tbody></table><p><strong>1. 读未提交 (Read Uncommitted)</strong></p><ul><li><p><strong>级别最低：</strong> 一个事务可以读取到其他事务<strong>尚未提交</strong>的修改。</p></li><li><p><strong>存在问题：</strong></p><ul><li><p><strong>脏读 (Dirty Read):</strong> 读取到了其他事务未提交的数据，如果那个事务最终回滚，读取到的就是无效的脏数据。</p></li><li><p><strong>不可重复读 (Non-repeatable Read):</strong> 在同一事务内，两次读取同一行数据，结果可能不同，因为其他事务在此期间修改并提交了该行。</p></li><li><p><strong>幻读 (Phantom Read):</strong> 在同一事务内，两次执行相同的范围查询，结果集中的行数可能不同，因为其他事务在此期间插入或删除了符合条件的行。</p></li></ul></li><li><p><strong>并发性能：</strong> 最高，因为读操作几乎不加锁（或加锁时间极短）。</p></li><li><p><strong>使用场景：</strong> 很少使用，除非对数据一致性要求极低，能容忍脏读。</p></li></ul><p><strong>2. 读已提交 (Read Committed)</strong></p><ul><li><p><strong>解决了脏读：</strong> 一个事务只能读取到其他事务<strong>已经提交</strong>的修改。</p></li><li><p><strong>实现方式 (InnoDB):</strong> 通常通过 MVCC (多版本并发控制) 实现。每次 SELECT 语句执行时，都会创建一个新的读视图 (Read View)，只能看到在该视图创建之前已经提交的事务的修改。</p></li><li><p><strong>存在问题：</strong></p><ul><li><p><strong>不可重复读 (Non-repeatable Read):</strong> 因为事务内每次 SELECT 都会创建新的读视图，如果在两次 SELECT 之间，有其他事务修改了数据并提交，那么第二次 SELECT 就能看到这个提交后的新值，导致两次读取结果不一致。</p></li><li><p><strong>幻读 (Phantom Read):</strong> 同样因为每次 SELECT 创建新视图，可能看到其他事务新插入并提交的行。</p></li></ul></li><li><p><strong>并发性能：</strong> 较好，读操作不阻塞写操作，写操作也不阻塞读操作（基于 MVCC）。</p></li><li><p><strong>使用场景：</strong> 很多数据库的默认级别（如 Oracle, PostgreSQL, SQL Server 的默认 RCSI）。适用于大多数要求避免脏读，但可以容忍不可重复读和幻读的应用。</p></li></ul><p><strong>3. 可重复读 (Repeatable Read) - MySQL InnoDB 默认级别</strong></p><ul><li><p><strong>解决了脏读和不可重复读：</strong> 在同一个事务内，多次读取同一行数据，结果保证是一致的。</p></li><li><p><strong>实现方式 (InnoDB):</strong> 同样基于 MVCC。关键区别在于，<strong>读视图 (Read View) 是在事务第一次执行 SELECT 语句时创建的，并且在整个事务期间保持不变</strong>。后续的所有 SELECT 都使用这个<strong>初始的读视图</strong>，因此它们只能看到在事务开始时就已经提交的数据，或者本事务自己所做的修改，看不到其他并发事务在此期间提交的修改。</p></li><li><p><strong>存在问题：</strong></p><ul><li><p><strong>幻读 (Phantom Read):</strong> 理论上，标准的 RR 级别仍然允许幻读。但在 <strong>MySQL 的 InnoDB</strong> 中，通过结合 <strong>MVCC 和 Next-Key Locking (间隙锁 + 记录锁)<strong>，它在很大程度上</strong>解决了幻读问题</strong>。</p><ul><li><p>对于快照读 (SELECT)，MVCC 保证看不到新插入的行。</p></li><li><p>对于当前读 (SELECT … FOR UPDATE, SELECT … LOCK IN SHARE MODE, INSERT, UPDATE, DELETE)，Next-Key Lock 会锁定扫描到的索引记录及其间的间隙，阻止其他事务在这些间隙中插入新的、可能导致幻读的行。</p></li></ul></li></ul></li><li><p><strong>并发性能：</strong> 良好。快照读性能高。但由于 Next-Key Lock 的存在，在某些并发写入场景下可能会锁定更大范围，降低并发度，并增加死锁的风险。</p></li><li><p><strong>使用场景：</strong> MySQL InnoDB 的默认设置，提供了较高的数据一致性保证（基本避免幻读），适用于大多数需要事务内数据一致性的应用。</p></li></ul><p><strong>4. 串行化 (Serializable)</strong></p><ul><li><p><strong>级别最高：</strong> 解决了脏读、不可重复读和幻读。强制事务串行执行，即一个接一个地执行，完全避免了并发问题。</p></li><li><p><strong>实现方式 (InnoDB):</strong> 通常会对所有读取的行都加上**共享锁 (S Lock)<strong>，对写入的行加上</strong>排他锁 (X Lock)**。如果遇到锁冲突，事务必须等待。相当于所有读操作都隐式地变成了 SELECT … LOCK IN SHARE MODE。</p></li><li><p><strong>存在问题：</strong></p><ul><li><strong>并发性能极差：</strong> 大量的锁竞争导致事务需要排队等待，系统吞吐量会急剧下降。</li></ul></li><li><p><strong>并发性能：</strong> 最低。</p></li><li><p><strong>使用场景：</strong> 对数据一致性要求极其严格，且可以接受极低并发性能的场景。非常少用，通常只有在特定业务逻辑需要绝对串行保证时才会考虑。</p></li></ul><h1 id="间隙锁是怎么解决幻读问题的？"><a href="#间隙锁是怎么解决幻读问题的？" class="headerlink" title="间隙锁是怎么解决幻读问题的？"></a>间隙锁是怎么解决幻读问题的？</h1><p>首先说明，RR 可重复度级别，如果是 SELECT 是不会有幻读问题的，因为使用的是快照读，且 RR 级别整个事务只会使用一个快照。只有使用类似 SELECT FOR UPDATE 这种当前读（读取最新的数据）时才会出现。</p><p>解决的方法是间隙锁+Next-Key Lock，它的锁定范围会比行锁大一些，且这个锁会持续锁定，直到事务结束。Next-Key Lock 是间隙锁 + 行锁的结合，间隙锁锁定的是<strong>索引记录之间的间隙 (Gap)<strong>，</strong>不包括</strong>记录本身。</p><p><strong>示例：</strong></p><p>假设有一个 products 表，id 是主键，当前有数据 id &#x3D; 10 和 id &#x3D; 20。</p><ul><li><p><strong>事务 A</strong> 执行： SELECT * FROM products WHERE id &gt; 9 AND id &lt; 25 FOR UPDATE;</p></li><li><p><strong>InnoDB (RR 级别) 的锁定行为：</strong></p><ul><li><p>扫描索引，找到 id &#x3D; 10。对 id &#x3D; 10 加 Next-Key Lock（锁住记录 10 和间隙 (…, 10]）。</p></li><li><p>扫描索引，找到 id &#x3D; 20。对 id &#x3D; 20 加 Next-Key Lock（锁住记录 20 和间隙 (10, 20]）。</p></li><li><p>继续扫描，没有找到 id &#x3D; 25，但扫描会越过 id &#x3D; 20。它需要锁定 id &#x3D; 20 之后的间隙，直到下一个存在的键（或者无穷大）。所以，它会在 id &#x3D; 20 之后加上一个间隙锁，覆盖 (20, +∞) 的范围（具体范围取决于索引结构和查询）。</p></li><li><p><strong>关键效果：</strong> 现在，间隙 (10, 20] 和 (20, …) 都被事务 A 锁定了。</p></li></ul></li><li><p><strong>事务 B</strong> 尝试执行： INSERT INTO products (id) VALUES (15);</p></li><li><p><strong>InnoDB 的反应：</strong></p><ul><li><p>事务 B 想要在 id &#x3D; 15 的位置插入数据。这个位置位于间隙 (10, 20] 中。</p></li><li><p>事务 A 持有覆盖该间隙的 Gap Lock（作为 id &#x3D; 20 的 Next-Key Lock 的一部分）。</p></li><li><p>事务 B 需要获取一个<strong>插入意向锁 (Insert Intention Lock)</strong> 才能在这个间隙插入。</p></li><li><p>插入意向锁与间隙锁是<strong>不兼容</strong>的。</p></li><li><p>因此，<strong>事务 B 的 INSERT 操作会被阻塞</strong>，直到事务 A 提交或回滚，释放了那个间隙锁。</p></li></ul></li><li><p><strong>结果：</strong> 由于事务 B 被阻塞，无法插入 id &#x3D; 15 的新行，因此事务 A 在其后续的任何（当前读或快照读）查询中，都不会看到 id &#x3D; 15 这个“幻影”行。幻读被阻止了。</p></li></ul><h1 id="介绍下乐观锁悲观锁，以及各自的使用场景"><a href="#介绍下乐观锁悲观锁，以及各自的使用场景" class="headerlink" title="介绍下乐观锁悲观锁，以及各自的使用场景"></a>介绍下乐观锁悲观锁，以及各自的使用场景</h1><p>乐观锁和悲观锁是并发控制中常见的两种策略，用于解决多个线程或进程并发访问共享资源时可能发生的数据一致性问题。</p><ol><li>悲观锁（Pessimistic Locking）： 悲观锁是一种保守的并发控制策略，它假设并发访问的操作会发生冲突，因此在访问共享资源之前，会先对资源进行加锁，确保其他线程无法同时修改该资源。悲观锁的典型应用是使用数据库的行级锁（如行锁、表锁）来保证数据的一致性。悲观锁的特点是阻塞其他线程的访问，可能导致线程等待和性能下降。</li></ol><p>适用场景：</p><ul><li>需要修改共享资源的概率较高。</li><li>并发访问频率较高。</li><li>并发冲突的概率较大。</li><li>数据库事务隔离级别为串行化（Serializable）。</li></ul><ol><li>乐观锁（Optimistic Locking）： 乐观锁是一种乐观的并发控制策略，它假设并发访问的操作不会发生冲突，因此在访问共享资源时，不会立即对资源加锁，而是在更新操作时检查资源是否被其他线程修改过。乐观锁通过使用版本号、时间戳等机制来判断资源是否被修改。如果检测到冲突，则需要进行回滚或重试操作。乐观锁的特点是不阻塞其他线程的访问，但可能存在冲突处理的开销。</li></ol><p>适用场景：</p><ul><li>读取操作远远大于写入操作。</li><li>并发访问冲突较少。</li><li>数据库事务隔离级别为读已提交（Read Committed）或更低。</li></ul><p>选择乐观锁还是悲观锁取决于具体的应用场景和需求。在高并发环境下，悲观锁可能导致性能下降和线程阻塞，而乐观锁可以提供更好的并发性能。但是，乐观锁需要额外的冲突检测和处理机制，适用于冲突较少的场景。在实际应用中，可以根据具体情况选择合适的并发控制策略。</p><h1 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h1><p><a href="https://juejin.cn/post/6844904009329803277">https://juejin.cn/post/6844904009329803277</a></p><ol><li><p><strong>为常作为查询条件的字段建立索引</strong></p><p>如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。</p></li><li><p><strong>避免索引失效（参考索引失效场景）</strong></p></li><li><p><strong>为经常需要排序、分组操作的字段建立索引</strong></p><p>经常需要 ORDER BY、GROUP BY、DISTINCT 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。</p></li><li><p><strong>限制索引的数目</strong></p><p>索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦。越多的索引，会使更新表变得很浪费时间。</p></li><li><p><strong>扩展索引</strong></p><p>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加 (a,b) 的索引，那么只需要修改原来的索引即可</p></li><li><p><strong>尽量使用数据量少的索引</strong></p><p>如果索引的值很长，那么查询的速度会受到影响。例如，对一个 CHAR(100 )类型的字段进行全文检索需要的时间要比对CHAR(10)类型的字段需要的时间要多。</p></li><li><p><strong>尽量使用前缀来索引</strong></p><p>如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。</p></li><li><p>删除不再使用或者很少使用的索引</p><p>表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</p></li></ol><h1 id="说一下-Mysql-二阶段提交"><a href="#说一下-Mysql-二阶段提交" class="headerlink" title="说一下 Mysql 二阶段提交"></a>说一下 Mysql 二阶段提交</h1><h1 id="索引失效场景"><a href="#索引失效场景" class="headerlink" title="索引失效场景"></a>索引失效场景</h1><p>在 MySQL 中，索引可能会失效的几种常见情况包括：</p><ol><li>不使用索引列或对索引列进行函数操作：当查询条件中对索引列进行函数操作、类型转换或计算时，索引可能无法被利用，导致失效。例如：<code>WHERE UPPER(name) = &#39;JOHN&#39;</code>。</li><li>使用 <code>OR</code> 进行条件判断：当查询条件 WHERE 中包含 <code>OR</code> 运算符时，如果其中一个条件无法使用索引，整个查询可能无法使用索引优化。例如：<code>WHERE name = &#39;John&#39; OR age = 25</code>。</li><li>使用 <code>NOT</code> 进行条件判断：<code>NOT</code> 运算符通常会导致索引失效，因为它会使索引无法直接匹配，需要全表扫描。例如：<code>WHERE NOT name = &#39;John&#39;</code>。</li><li>对索引使用左或者左右模糊匹配：当查询条件使用通配符在索引列开头，或者在开头和结尾，此时进行模糊匹配，索引可能无法被利用。例如：<code>WHERE name LIKE &#39;%John%&#39;, WHERE name LIKE &#39;%John&#39;</code>。</li><li>索引列参与运算：当查询条件中的索引列参与运算（如加减乘除）时，索引可能会失效。例如：<code>WHERE age + 5 = 30</code>。</li><li>隐式类型转换：当查询条件中使用的数据类型与索引列的数据类型不匹配时，MySQL 可能会进行隐式类型转换，导致索引失效。例如：索引列为整数类型，但查询条件中使用字符串进行比较。</li><li>联合索引不满足最左匹配原则</li><li>数据量过小的情况：如果表中的数据量非常小，MySQL 可能认为全表扫描比使用索引更高效，因此选择不使用索引。</li><li>索引列的选择性不高：如果索引列的选择性非常低，即索引列的值重复率很高，MySQL 可能不会选择使用索引进行查询，而是进行全表扫描。</li></ol><p>需要注意的是，以上情况并不是绝对的，MySQL 的查询优化器会根据具体的情况和统计信息来选择合适的执行计划，有时即使符合上述情况，MySQL 仍然可能使用索引。因此，在实际使用中，需要结合具体情况进行分析和测试，确保索引的正确使用和性能优化。</p><h1 id="B-树和-B-树的区别？为什么-MySQL-用-B-树实现索引？3-层-B-树有多少个节点？"><a href="#B-树和-B-树的区别？为什么-MySQL-用-B-树实现索引？3-层-B-树有多少个节点？" class="headerlink" title="B 树和 B+ 树的区别？为什么 MySQL 用 B+ 树实现索引？3 层 B+ 树有多少个节点？"></a>B 树和 B+ 树的区别？为什么 MySQL 用 B+ 树实现索引？3 层 B+ 树有多少个节点？</h1><h1 id="执行一条-SQL-的流程"><a href="#执行一条-SQL-的流程" class="headerlink" title="执行一条 SQL 的流程"></a>执行一条 SQL 的流程</h1><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250417150253.png" alt="image.png"></p><ol><li><strong>连接器</strong></li></ol><ul><li>与客户端进行 TCP 三次握手建立连接；</li><li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li><li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li></ul><ol start="2"><li><strong>查询缓存</strong></li></ol><p>​mysql 收到 sql 后，解析第一个字段，获取语句类型，如果是 <strong>查询语句</strong>，那么就会去缓存中查找，缓存以键值对形式保存，其中键是 sql 语句，值是对应的查询结果，如果查询的语句没有命中缓存，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。</p><p>​ps：这个功能因为作用不大，在 8.0 版本被删除，因为如果表里的数据经常发生变动，缓存的命中率就会变得很低，只要一个表有更新操作，那么这个表的查询缓存就会被清空。</p><ol start="3"><li><strong>分析器</strong></li></ol><p>负责 <strong>词法分析</strong> 和 <strong>语法分析</strong></p><ul><li>词法分析</li></ul><p>​MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方面后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</p><ul><li>语法分析</li></ul><p>​根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><ol start="4"><li><strong>预处理器</strong></li></ol><ul><li>检查 SQL 查询语句中的表或者字段是否存在；</li><li>将 select * 中的 * 符号，扩展为表上的所有列；</li></ul><ol start="5"><li><strong>优化器</strong></li></ol><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p><ol start="6"><li><strong>执行器</strong></li></ol><p>根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端</p><h1 id="MySQL-死锁，什么情况下会触发死锁"><a href="#MySQL-死锁，什么情况下会触发死锁" class="headerlink" title="MySQL 死锁，什么情况下会触发死锁"></a>MySQL 死锁，什么情况下会触发死锁</h1><p> ✅ 1. <strong>两个事务操作同一资源，但顺序不同</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务 A</span><br><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Alice&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">-- 等待事务 B</span><br><br><span class="hljs-comment">-- 事务 B</span><br><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Bob&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-comment">-- 等待事务 A</span><br></code></pre></td></tr></table></figure><p>然后：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务 A</span><br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;X&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">-- 🚫 被事务 B 锁住</span><br><br><span class="hljs-comment">-- 事务 B</span><br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Y&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">-- 🚫 被事务 A 锁住</span><br></code></pre></td></tr></table></figure><p>→ A 等 B，B 等 A，死锁！</p><p>原因是：两个事务更新同一行，<strong>会加锁</strong>，而且是 <strong>排他锁（X 锁）</strong>！多个事务同时更新同一行，会发生锁竞争，后来的事务必须等待前一个释放锁或被回滚。</p><h1 id="慢查询分析"><a href="#慢查询分析" class="headerlink" title="慢查询分析"></a>慢查询分析</h1><h2 id="慢查询相关系统参数"><a href="#慢查询相关系统参数" class="headerlink" title="慢查询相关系统参数"></a>慢查询相关系统参数</h2><h3 id="slow-query-log：开启慢查询日志"><a href="#slow-query-log：开启慢查询日志" class="headerlink" title="slow_query_log：开启慢查询日志"></a>slow_query_log：开启慢查询日志</h3><p>在 MySQL 中，慢查询日志默认为 OFF 状态，通过如下命令进行查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">show variables like <span class="hljs-string">&quot;slow_query_log&quot;</span>;</span><br>+----------------+-------+<br>| Variable_name  | Value |<br>+----------------+-------+<br>| slow_query_log | OFF   |<br>+----------------+-------+<br></code></pre></td></tr></table></figure><p>通过如下命令进行设置为 ON 状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set global slow_query_log = &quot;ON&quot;;<br></code></pre></td></tr></table></figure><h3 id="slow-query-log-file：慢查询日志存储位置"><a href="#slow-query-log-file：慢查询日志存储位置" class="headerlink" title="slow_query_log_file：慢查询日志存储位置"></a>slow_query_log_file：慢查询日志存储位置</h3><p><code>slow_query_log_file</code> 属性表示慢查询日志存储位置，其日志默认名称为 host 名称，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">show variables like <span class="hljs-string">&quot;slow_query_log_file&quot;</span>;</span><br>+---------------------+----------------------------------------------+<br>| Variable_name       | Value                                        |<br>+---------------------+----------------------------------------------+<br>| slow_query_log_file | /bitnami/mysql/data/mysql-primary-0-slow.log |<br>+---------------------+----------------------------------------------+<br></code></pre></td></tr></table></figure><p>也可使用 以下命令进行修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set global slow_query_log_file = $&#123;path&#125;/$&#123;filename&#125;.log;<br></code></pre></td></tr></table></figure><h3 id="long-query-time：慢查询超时时间"><a href="#long-query-time：慢查询超时时间" class="headerlink" title="long_query_time：慢查询超时时间"></a>long_query_time：慢查询超时时间</h3><p>慢查询查询时间，当 SQL 执行时间超过该值时，则会记录在 slow_query_log_file 文件中，其默认为 10 ，最小值为 0，(单位：秒)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">show variables like <span class="hljs-string">&quot;long_query_time&quot;</span>;</span><br>+-----------------+-----------+<br>| Variable_name   | Value     |<br>+-----------------+-----------+<br>| long_query_time | 10.000000 |<br>+-----------------+-----------+<br></code></pre></td></tr></table></figure><p>可通过以下命令进行修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash"><span class="hljs-built_in">set</span> global long_query_time = 5;</span><br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>调用 sleep 函数，让这条 sql 的执行时间超过慢查询的超时时间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash"><span class="hljs-keyword">select</span> <span class="hljs-built_in">sleep</span>(11);</span><br></code></pre></td></tr></table></figure><p>查看慢查询日志内容（记得执行 quit 退出 mysql）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /bitnami/mysql/data/mysql-primary-0-slow.log</span><br>/opt/bitnami/mysql/bin/mysqld, Version: 8.0.34 (Source distribution). started with:<br>Tcp port: 3306  Unix socket: /opt/bitnami/mysql/tmp/mysql.sock<br>Time                 Id Command    Argument<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Time: 2023-08-17T16:45:52.534231Z</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">User@Host: root[root] @ localhost []  Id: 52593</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Query_time: 11.000171  Lock_time: 0.000000 Rows_sent: 1  Rows_examined: 1</span><br>SET timestamp=1692290741;<br>select sleep(11);<br></code></pre></td></tr></table></figure><p>慢查询日志内容含义如下：</p><ol><li>慢查询日志以 # 作为起始符。</li><li>User@Host：表示用户和慢查询查询的 ip 地址。</li><li>如上所述，表示 root 用户 localhost 地址。</li><li>Query_time: 表示 SQL 查询持续时间，单位 (秒)。</li><li>Lock_time: 表示获取锁的时间， 单位(秒)。</li><li>Rows_sent: 表示发送给客户端的行数。</li><li>Rows_examined: 表示服务器层检查的行数。</li><li>set timestamp：表示慢 SQL 记录时的时间戳。</li><li>最后一行的 select sleep(11) 则表示慢 SQL 语句。</li></ol><h1 id="Innodb-页合并和页分裂"><a href="#Innodb-页合并和页分裂" class="headerlink" title="Innodb 页合并和页分裂"></a>Innodb 页合并和页分裂</h1>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 面试题</title>
    <link href="/2021/07/25/redis-mian-jing/"/>
    <url>/2021/07/25/redis-mian-jing/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis-的数据类型以及日常的应用"><a href="#Redis-的数据类型以及日常的应用" class="headerlink" title="Redis 的数据类型以及日常的应用"></a>Redis 的数据类型以及日常的应用</h1><p>PS：这里说的数据类型指的是 value 的类型，Redis 是一个 kv 数据库，它的 key 都是 string 类型的，但是 value 可以是多种类型。</p><h2 id="string-字符串类型"><a href="#string-字符串类型" class="headerlink" title="string 字符串类型"></a>string 字符串类型</h2><h3 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a><strong>缓存对象</strong></h3><p>这个没啥好说的，就是存一些字符串，这些字符串可以是各种各样的值，比如可以是常规的 “name”: “zhang3”，也可以是一个序列化为 JSON 的对象 {“XXX”: “YYY”}。</p><h3 id="常规计数"><a href="#常规计数" class="headerlink" title="常规计数"></a>常规计数</h3><p>因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。</p><p>虽然存储的是字符串类型，但是可以用 <code>INCR</code>（自增 1），<code>INCRBY</code>（自增指定数值），<code>decr</code>（自减 1），<code>decyby</code>（自减指定数值）对这个数值进行操作，貌似 Redis 会将其转换为 int 进行处理。</p><h2 id="hashmap-哈希表"><a href="#hashmap-哈希表" class="headerlink" title="hashmap 哈希表"></a>hashmap 哈希表</h2><p>哈希表本身就没啥好说的了，敲过代码的都知道是干嘛的</p><p><code>HSET key field value [field value ...]</code></p><p>key 可以看成是哈希表的名字，后面跟着的是 key&#x2F;value。</p><h3 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h3><ul><li>添加商品：<code>HSET cart:&#123;用户id&#125; &#123;商品id&#125; 1 &#123;商品id2&#125; 2</code> </li><li>添加数量：<code>HINCRBY cart:&#123;用户id&#125; &#123;商品id&#125; 1</code></li><li>商品总数：<code>HLEN cart:&#123;用户id&#125;</code></li><li>删除商品：<code>HDEL cart:&#123;用户id&#125; &#123;商品id&#125;</code></li><li>获取购物车所有商品：<code>HGETALL cart:&#123;用户id&#125;</code></li></ul><h2 id="list-双向链表"><a href="#list-双向链表" class="headerlink" title="list 双向链表"></a>list 双向链表</h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>list 支持 <code>LPUSH</code>（push 到最左端），<code>LPOP</code>（将最左端 pop） 以及同理的 <code>RPUSH</code> 和 <code>RPOP</code> 操作，所以我们可以很容易的实现一个先进先出的队列（LPUSH + RPOP，或者 RPUSH + LPOP），来作为消息队列使用。</p><blockquote><p>不过感觉用 Redis 做 mq 还是有点太”抽象“了，毕竟这也不是 Redis 的本职工作，而且 Redis 后面提供了一个 stream 类型这个更专业的消息队列。</p></blockquote><p>不过作为消息队列还需要考虑以下几点：</p><ol><li>消费者不知道队列里面有没有数据，所以需要通过轮询的方式去不断 Pop ，但如果队列里面长时间没数据，可能会导致 CPU 空转浪费性能，为了解决这个问题，Redis 提供了 BRPOP 命令。<strong>BRPOP 命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据</strong>。和消费者程序自己不停地调用 RPOP 命令相比，这种方式能节省 CPU 开销。</li><li>重复消费的问题，这个在 Redis 层面是没有提供相关功能的，只能我们在应用层自行实现。可以让生产者生产的消息携带一个全局 ID，然后消费者那边通过这个全局 ID 来判断是否已经消费过。</li><li>如何保证消息可靠性，消费者消费一条消息，意味着这条消息会从 list 中 pop 出去，那如果消费者这边消费失败了，就没有机会去再次消费了，为了留存消息，List 类型提供了 <code>BRPOPLPUSH</code> 命令，这个命令的 <strong>作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存</strong>。</li></ol><p>此外 <strong>List 不支持多个消费者消费同一条消息</strong>，因为一旦消费者拉取一条消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费。这个问题无解。</p><h2 id="set-去重集合"><a href="#set-去重集合" class="headerlink" title="set 去重集合"></a>set 去重集合</h2><h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p>Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章 id，value 是用户 id。</p><p><code>uid:1</code> 、<code>uid:2</code>、<code>uid:3</code> 三个用户分别对 article:1 文章点赞了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">uid:1 用户对文章 article:1 点赞</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SADD article:1 uid:1</span><br>(integer) 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">uid:2 用户对文章 article:1 点赞</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SADD article:1 uid:2</span><br>(integer) 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">uid:3 用户对文章 article:1 点赞</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SADD article:1 uid:3</span><br>(integer) 1<br></code></pre></td></tr></table></figure><p><code>uid:1</code> 取消了对 article:1 文章点赞。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">&gt; SREM article:1 uid:1<br>(integer) 1<br></code></pre></td></tr></table></figure><p>获取 article:1 文章所有点赞用户 :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SMEMBERS article:1</span><br>1) &quot;uid:3&quot;<br>2) &quot;uid:2&quot;<br></code></pre></td></tr></table></figure><p>获取 article:1 文章的点赞用户数量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SCARD article:1</span><br>(integer) 2<br></code></pre></td></tr></table></figure><p>判断用户 <code>uid:1</code> 是否对文章 article:1 点赞了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SISMEMBER article:1 uid:1</span><br>(integer) 0  # 返回0说明没点赞，返回1则说明点赞了<br></code></pre></td></tr></table></figure><h3 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h3><p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p><p>key 可以是用户 id，value 则是已关注的公众号的 id。</p><p><code>uid:1</code> 用户关注公众号 id 为 5、6、7、8、9，<code>uid:2</code> 用户关注公众号 id 为 7、8、9、10、11。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">uid:1 用户关注公众号 <span class="hljs-built_in">id</span> 为 5、6、7、8、9</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SADD uid:1 5 6 7 8 9</span><br>(integer) 5<br><span class="hljs-meta prompt_"># </span><span class="language-bash">uid:2  用户关注公众号 <span class="hljs-built_in">id</span> 为 7、8、9、10、11</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SADD uid:2 7 8 9 10 11</span><br>(integer) 5<br></code></pre></td></tr></table></figure><p><code>uid:1</code> 和 <code>uid:2</code> 共同关注的公众号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">获取共同关注</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SINTER uid:1 uid:2</span><br>1) &quot;7&quot;<br>2) &quot;8&quot;<br>3) &quot;9&quot;<br></code></pre></td></tr></table></figure><p>给 <code>uid:2</code> 推荐 <code>uid:1</code> 关注的公众号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SDIFF uid:1 uid:2</span><br>1) &quot;5&quot;<br>2) &quot;6&quot;<br></code></pre></td></tr></table></figure><p>验证某个公众号是否同时被 <code>uid:1</code> 或 <code>uid:2</code> 关注:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SISMEMBER uid:1 5</span><br>(integer) 1 # 返回0，说明关注了<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SISMEMBER uid:2 5</span><br>(integer) 0 # 返回0，说明没关注<br></code></pre></td></tr></table></figure><h3 id="抽奖活动"><a href="#抽奖活动" class="headerlink" title="抽奖活动"></a>抽奖活动</h3><p>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</p><p>key 为抽奖活动名，value 为员工名称，把所有员工名称放入抽奖箱 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">SADD lucky Tom Jerry John Sean Marry Lindy Sary Mark</span><br>(integer) 5<br></code></pre></td></tr></table></figure><p>如果允许重复中奖，可以使用 SRANDMEMBER 命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">抽取 1 个一等奖：</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SRANDMEMBER lucky 1</span><br>1) &quot;Tom&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">抽取 2 个二等奖：</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SRANDMEMBER lucky 2</span><br>1) &quot;Mark&quot;<br>2) &quot;Jerry&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">抽取 3 个三等奖：</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SRANDMEMBER lucky 3</span><br>1) &quot;Sary&quot;<br>2) &quot;Tom&quot;<br>3) &quot;Jerry&quot;<br></code></pre></td></tr></table></figure><p>如果不允许重复中奖，可以使用 SPOP 命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">抽取一等奖1个</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SPOP lucky 1</span><br>1) &quot;Sary&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">抽取二等奖2个</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SPOP lucky 2</span><br>1) &quot;Jerry&quot;<br>2) &quot;Mark&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">抽取三等奖3个</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SPOP lucky 3</span><br>1) &quot;John&quot;<br>2) &quot;Sean&quot;<br>3) &quot;Lindy&quot;<br></code></pre></td></tr></table></figure><h2 id="zset-排序-set"><a href="#zset-排序-set" class="headerlink" title="zset 排序 set"></a>zset 排序 set</h2><h4 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h4><p>有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。</p><p>我们以博文点赞排名为例，小林发表了五篇博文，分别获得赞为 200、40、100、50、150。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">arcticle:1 文章获得了200个赞</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 200 arcticle:1</span><br>(integer) 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">arcticle:2 文章获得了40个赞</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 40 arcticle:2</span><br>(integer) 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">arcticle:3 文章获得了100个赞</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 100 arcticle:3</span><br>(integer) 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">arcticle:4 文章获得了50个赞</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 50 arcticle:4</span><br>(integer) 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">arcticle:5 文章获得了150个赞</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 150 arcticle:5</span><br>(integer) 1<br></code></pre></td></tr></table></figure><p>文章 arcticle:4 新增一个赞，可以使用 ZINCRBY 命令（为有序集合key中元素member的分值加上increment）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ZINCRBY user:xiaolin:ranking 1 arcticle:4</span><br>&quot;51&quot;<br></code></pre></td></tr></table></figure><p>查看某篇文章的赞数，可以使用 ZSCORE 命令（返回有序集合key中元素个数）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ZSCORE user:xiaolin:ranking arcticle:4</span><br>&quot;50&quot;<br></code></pre></td></tr></table></figure><p>获取小林文章赞数最多的 3 篇文章，可以使用 ZREVRANGE 命令（倒序获取有序集合 key 从start下标到stop下标的元素）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">WITHSCORES 表示把 score 也显示出来</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ZREVRANGE user:xiaolin:ranking 0 2 WITHSCORES</span><br>1) &quot;arcticle:1&quot;<br>2) &quot;200&quot;<br>3) &quot;arcticle:5&quot;<br>4) &quot;150&quot;<br>5) &quot;arcticle:3&quot;<br>6) &quot;100&quot;<br></code></pre></td></tr></table></figure><p>获取小林 100 赞到 200 赞的文章，可以使用 ZRANGEBYSCORE 命令（返回有序集合中指定分数区间内的成员，分数由低到高排序）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYSCORE user:xiaolin:ranking 100 200 WITHSCORES</span><br>1) &quot;arcticle:3&quot;<br>2) &quot;100&quot;<br>3) &quot;arcticle:5&quot;<br>4) &quot;150&quot;<br>5) &quot;arcticle:1&quot;<br>6) &quot;200&quot;<br></code></pre></td></tr></table></figure><h1 id="Redis-的发布-x2F-订阅的原理"><a href="#Redis-的发布-x2F-订阅的原理" class="headerlink" title="Redis 的发布&#x2F;订阅的原理"></a>Redis 的发布&#x2F;订阅的原理</h1><h1 id="zset-的底层实现"><a href="#zset-的底层实现" class="headerlink" title="zset 的底层实现"></a>zset 的底层实现</h1><p>zset 底层使用跳表 + 哈希表实现。</p><p>哈希表存储的是 member 到 score 的映射，这样可以让 ZSCORE 这种根据 member 查询 score 的操作的时间复杂度为 O(1)</p><h1 id="数据缓存过期策略"><a href="#数据缓存过期策略" class="headerlink" title="数据缓存过期策略"></a>数据缓存过期策略</h1><h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><p>通常来说，过期缓存有以下几种策略：</p><ol><li>定时删除：设置带过期时间的 key 的同时创建一个定时事件，然后到期后由这个定时事件进行删除，这样可以保证 key 过期后被尽快删除，对内存友好，但是缺点也很明显，开销太大了，如果 key 很多将会创建大量定时器，对 CPU 不友好。</li><li>惰性删除：操作一个 key 时，先检查一下该 key 是否过期，过期则删掉，这样对 CPU 友好，但是一些冷门 key 因为很少被访问到，所以即便过期也会占据内存，造成内存泄露，对内存不友好。</li><li>定期删除：每隔一段时间从过期字典（redis 将所有带有过期时间的 key 存在一个 map 中）中抽出来一定数量的 key，然后删掉其中过期的，这种方法相当于是上面两种的中和（内存友好不如定时删除，但优于惰性删除；CPU 友好不如惰性删除，但优于定期删除。），难点是合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）。</li></ol><p>Redis 采用的是惰性删除 + 定期删除策略，这样可以一定程度平衡使用 CPU 时间和避免内存浪费。</p><p>其中，定期删除的流程是：</p><ol><li>从过期字典中随机取出 20 个键</li><li>删除这 20 个键中过期的键</li><li>如果过期键的比例超过 25% ，重复步骤 1 和 2</li></ol><p>为了保证扫描不会出现循环过度，导致线程卡死现象，还增加了扫描时间的上限，默认是 25 毫秒（即默认在慢模式下，如果是快模式，扫描上限是 1 毫秒）</p><blockquote><p>🤔 疑问：</p><p>Redis 定期删除也是跑在单线程的事件循环中的吗？</p></blockquote><h2 id="AOF、RDB-和复制功能对过期键的处理"><a href="#AOF、RDB-和复制功能对过期键的处理" class="headerlink" title="AOF、RDB 和复制功能对过期键的处理"></a>AOF、RDB 和复制功能对过期键的处理</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p><strong>生成 RDB 文件</strong></p><p>在执行 save 命令或 bgsave 命令创建一个新的 RDB文件时，程序会对数据库中的键进行检查，已过期的键就不会被保存到新创建的 RDB文件中</p><p><strong>载入 RDB 文件</strong></p><p><strong>主服务器</strong>：载入 RDB 文件时，会对键进行检查，过期的键会被忽略</p><p><strong>从服务器</strong>：载入 RDB文件时，所有键都会载入。但是会在主从同步的时候，清空从服务器的数据库，所以过期的键载入也不会造成啥影响</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p><strong>AOF 文件写入</strong></p><p>当过期键被惰性删除或定期删除后，程序会向 AOF 文件追加一条 del 命令，来显示的记录该键已经被删除</p><p><strong>AOF 重写</strong></p><p>重启过程会对键进行检查，如果过期就不会被保存到重写后的 AOF 文件中</p><h1 id="Redis-的部署模式"><a href="#Redis-的部署模式" class="headerlink" title="Redis 的部署模式"></a>Redis 的部署模式</h1><p><a href="https://blog.csdn.net/qq_26012495/article/details/120299332">https://blog.csdn.net/qq_26012495/article/details/120299332</a></p><h2 id="单节点模式"><a href="#单节点模式" class="headerlink" title="单节点模式"></a>单节点模式</h2><p>最简单粗暴的方式，只跑一个 Redis 节点，所有的操作也只需要使用这一个节点即可，问题也很明显，如果这一个节点挂了服务直接就不可用了，如果是生产环境这种必须高可用的场景，这种部署模式肯定就不行了。</p><h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><p>这种部署模式将会部署多个 Redis 节点，并且还将节点分为了主节点和从节点两种类型，其中主节点可以读写，而从节点只能读，然后主节点会复制数据给从节点，这种数据单向复制（只能主同步给从）可以简化主从节点之间数据一致性的实现。</p><p>部署多个节点可以提高系统的可用性，如果主节点挂了，可以手动把某个从节点提升为主节点，但因为是手动，所以对运维人员不友好（万一主节点半夜挂了），而且如果主节点全挂了那么整个系统将丧失写能力。</p><h3 id="主从复制流程"><a href="#主从复制流程" class="headerlink" title="主从复制流程"></a>主从复制流程</h3><h4 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h4><p>主从节点之间的第一次数据同步使用的是 <strong>全量同步</strong>，全量同步的流程大致如图</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/redis_master_slave_sync.webp"></p><p>主从库间建立连接、协商同步： 从库向主库发起同步请求，从库执行 <code>replicaof</code> 并发送 <code>psync</code> 命令，表示要执行数据同步，主库收到命令后根据参数启动复制。命令包含了<strong>主库的 runID</strong> 和 <strong>复制进度 offset</strong> 两个参数。</p><ul><li><strong>runID</strong>：每个 Redis 实例启动都会自动生成一个 唯一标识 ID，第一次主从复制，还不知道主库 runID，参数设置为 「?」。</li><li><strong>offset</strong>：第一次复制设置为 -1，<strong>表示第一次复制</strong>，记录复制进度偏移量。</li></ul><p>主库响应请求，返回 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset（每个 redis 启动时）。从库收到响应后，会记录下这两个参数。</p><p>主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。</p><p><strong>在主库将数据同步给从库的过程中，主库不会被阻塞</strong>，仍然可以正常接收请求。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，<strong>主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作</strong>。当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</p><p>准确的说，<strong>主服务器在下面这三个时间间隙中将收到的写操作命令，写入到 replication buffer 缓冲区里</strong>：</p><ul><li>主服务器生成 RDB 文件期间；</li><li>主服务器发送 RDB 文件给从服务器期间；</li><li>「从服务器」加载 RDB 文件期间；</li></ul><p>也就是说，从主服务器开始生成 RDB 文件，到成功发送给从服务器，且从服务加载 RDB 完成后的这段时间呢，新写入到主服务器的命令都会写入到缓冲区。</p><blockquote><p>疑问：</p><p>主库如何知道 RDB 已经发送完成，并且对方已全部接收成功？</p><p>下面就会回答这个问题</p></blockquote><p>在主服务器生成的 RDB 文件发送完，从服务器收到 RDB 文件后，丢弃所有旧数据，将 RDB 数据载入到内存。<strong>完成 RDB 的载入后，会回复一个确认消息给主服务器。</strong></p><p>接着，主服务器将 replication buffer 缓冲区里所记录的写操作命令发送给从服务器，从服务器执行来自主服务器 replication buffer 缓冲区里发来的命令，这时主从服务器的数据就一致了。</p><p>至此，主从服务器的第一次同步的工作就完成了。</p><blockquote><p>又有一个疑问：如果主服务器迟迟收不到从服务器发来的确认信息呢？</p></blockquote><h4 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h4><p>主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 长连接。</p><p>后续主服务器可以通过这个连接继续 <strong>将写操作命令传播给从服务器</strong>，然后从服务器执行该命令，使得与主服务器的数据库状态相同。</p><h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><p>主从服务器在完成第一次同步后，就会基于长连接进行命令传播，但是如果出现网络问题，就会导致命令无法传播，进而导致主从间数据不一致。为了解决这个问题，Redis 提供了增量复制功能，这样相比全量复制性能更高。</p><p>主要有三个步骤：</p><ul><li>从服务器在恢复网络后，会发送 psync 命令给主服务器，此时的 psync 命令里的 offset 参数不是 -1（不是 -1 表示不是第一次复制，即不是全量复制）；</li><li>主服务器收到该命令后，然后用 CONTINUE 响应命令告诉从服务器接下来采用增量复制的方式同步数据；</li><li>然后主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。</li></ul><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>哨兵模式的出现用于解决主从模式中无法自动升级主节点的问题，一个哨兵是一个节点，用于监控主从节点的健康，当主节点挂掉的时候，自动选择一个最优从节点升级为主节点。</p><p>但哨兵如果挂了怎么办？于是哨兵一般都会是一个集群，是集群高可用的心脏，一般由 3-5 个节点组成，即使个别节点挂了，集群还可以正常运行。</p><p>客户端连接 Redis，会首先连接 Sentinel，通过 Sentinel 查询 master 地址，然后再连接 master 进行数据交互。当 master 挂了，客户端重新跟 Sentinel 要 master 地址，连接新的 master。</p><p>上图中可看，master 挂了，原先的主从复制断开，客户端和 master 也断开。然后一个 slave 变成新的 master，和其余的 slave 进行新的主从复制，客户端通过新的 master 继续交互，Sentinel 持续监控已经挂掉的旧的 master，一旦旧的 master 恢复，集群会变为下图，旧的 master 成为新的 slave，从新的 master 建立主从复制关系。</p><h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><p>集群方案真正实现了 Redis 高可用，有很多种实现方式，目前最常用的 Redis Cluster 是 Redis 的亲儿子，是 Redis 作者自己提供的 Redis 集群化方案，从Redis 3.0 版本开始正式提供。</p><p>集群由多个 Redis 主从组成，每一个主从代表一个节点，每个节点负责一部分数据，他们之间通过一种特殊的二进制协议交互集群信息。</p><p>Redis Cluster 将所有数据分片，分成 16384 个槽位，Redis Cluster 对 key 值使用 crc16 算法进行 hash，然后用除留余数发模除 16384 得到具体的槽位，每个节点负责其中一部分槽位。</p><p>当客户端连接集群，会得到一份集群的槽位匹配信息，当客户端要查找 key，可以直接定位到目标节点。</p><p>Cluster 去中心化，由多个节点组成，客户端连接时可以只用一个节点的地址，其余节点可通过该节点自动发现，但如果该节点挂了，就必须手动更换地址，因此连接多个地址安全性更高。</p><p><strong>容错</strong></p><p>Redis Cluster 拥有类似哨兵的功能，每个节点仍需设置若干从节点，主节点发生故障，集群可将 slave 升级为 master；否则如果 master 挂了，集群完全不可用；</p><p>且 Redis Cluster 是去中心化，集群内某个节点不可用时，一个节点认为他失联并不代表所以节点都认为他失联，集群要进行一次商议，只有大多数节点认为他失联，才会认为其需要主从切换来容错。</p><p><strong>动态扩容</strong></p><p>假如原先集群中有 3 个节点，一共 3000 个数据，可能 1-1000 在第一个节点，1001-2000 在第二个节点，2001-3000 在第三个节点。</p><p>当新节点加入集群，需要手动将槽和数据迁移到新节点，可以使用 redis-trib 工具或手动命令迁移（略）。</p><h1 id="Redis-为什么速度比较快"><a href="#Redis-为什么速度比较快" class="headerlink" title="Redis 为什么速度比较快"></a>Redis 为什么速度比较快</h1><ol><li><p>纯内存操作，因为内存的速度远高于磁盘，所以 Redis 的速度也会远快于 Mysql 。</p><blockquote><p>抬杠式提问</p><p>为啥内存速度比硬盘快？</p><p>（不知道，基础稀烂）</p><p>因为内存直接由 CPU 控制，也就是 CPU 内部集成的内存控制器，所以说内存是直接与 CPU 对接，享受与 CPU 通信的最优带宽。</p></blockquote></li><li><p>单线程 + IO 多路复用</p><p>Redis 处理命令的模型使用的是 IO 多路复用，这样就可以一条线程同时监听很多个 socket，当有 socket 发生事件时会唤醒线程进行处理，相当于多个命令其实是在排队同步执行的，因为 Redis 的命令处理操作通常都是一些数据结构相关的 crud 操作，而且都是在内存里面操作，又不涉及网络调用等时间开销大的操作，所以每个命令的执行时间都很短，所以即使排队执行也不会有特别大的延迟问题（一些比较耗时的操作，比如持久化，Redis 是会开一条进程后台处理的），而且因为是单线程，所以避免了并发同步相关的锁开销，实现起来也会简单很多。</p></li></ol><h1 id="Reids-的大-key-相关"><a href="#Reids-的大-key-相关" class="headerlink" title="Reids 的大 key 相关"></a>Reids 的大 key 相关</h1><h2 id="什么是大-key？"><a href="#什么是大-key？" class="headerlink" title="什么是大 key？"></a><strong>什么是大 key？</strong></h2><p>Redis 大 key 问题指的是某个 key 对应的 value 值所占的内存空间比较大，导致 Redis 的性能下降、内存不足、数据不均衡以及主从同步延迟等问题。</p><h2 id="多大算大？"><a href="#多大算大？" class="headerlink" title="多大算大？"></a><strong>多大算大？</strong></h2><p>没有固定的判别标准，通常认为字符串类型的 key 对应的 value 值占用空间大于 1M，或者集合类型的 k 元素数量超过 1 万个，就算是大 key，但是具体还要看业务场景、并发量等因素。</p><h2 id="大-key-带来的影响"><a href="#大-key-带来的影响" class="headerlink" title="大 key 带来的影响"></a><strong>大 key 带来的影响</strong></h2><ol><li>内存占用过高。大 Key 占用过多的内存空间，可能导致可用内存不足，从而触发内存淘汰策略。在极端情况下，可能导致内存耗尽，Redis 实例崩溃，影响系统的稳定性。</li><li>性能下降。大 Key 会占用大量内存空间，导致内存碎片增加，进而影响 Redis 的性能。对于大 Key 的操作，如读取、写入、删除等，都会消耗更多的 CPU 时间和内存资源，进一步降低系统性能。</li><li>阻塞其他操作。某些对大 Key 的操作可能会导致 Redis 实例阻塞。例如，使用 DEL 命令删除一个大 Key 时，可能会导致 Redis 实例在一段时间内无法响应其他客户端请求，从而影响系统的响应时间和吞吐量。</li><li>网络拥塞。每次获取大 key 产生的网络流量较大，可能造成机器或局域网的带宽被打满，同时波及其他服务。例如：一个大 key 占用空间是 1 MB，每秒访问1000次，就有 1000 MB的流量。</li><li>主从同步延迟。当 Redis 实例配置了主从同步时，大 Key 可能导致主从同步延迟。由于大 Key 占用较多内存，同步过程中需要传输大量数据，这会导致主从之间的网络传输延迟增加，进而影响数据一致性。</li><li>数据倾斜。在 Redis 集群模式中，某个数据分片的内存使用率远超其他数据分片，无法使数据分片的内存资源达到均衡。另外也可能造成 Redis 内存达到maxmemory 参数定义的上限导致重要的 key 被逐出，甚至引发内存溢出。</li></ol><h2 id="大-key-产生的原因"><a href="#大-key-产生的原因" class="headerlink" title="大 key 产生的原因"></a><strong>大 key 产生的原因</strong></h2><ol><li>业务设计不合理。这是最常见的原因，不应该把大量数据存储在一个 key 中，而应该分散到多个 key。例如：把全国数据按照省行政区拆分成 34 个key，或者按照城市拆分成 300 个key，可以进一步降低产生大 key 的概率。</li><li>没有预见 value 的动态增长问题。如果一直添加 value 数据，没有删除机制、过期机制或者限制数量，迟早出现大 key。例如：微博明星的粉丝列表、热门评论等。</li><li>过期时间设置不当。如果没有给某个 key 设置过期时间，或者过期时间设置较长。随着时间推移，value 数量快速累积，最终形成大 key。</li><li>程序 bug。某些异常情况导致某些 key 的生命周期超出预期，或者 value 数量异常增长 ，也会产生大 key。</li></ol><h2 id="如何排查大-key"><a href="#如何排查大-key" class="headerlink" title="如何排查大 key"></a>如何排查大 key</h2><p>使用 –bigkeys 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">redis-cli --bigkeys -a rootroot</span><br><br>[00.00%] Biggest hash   found so far &#x27;&quot;very_big_key&quot;&#x27; with 2050 fields<br><br>-------- summary -------<br><br>Sampled 1 keys in the keyspace!<br>Total key length in bytes is 12 (avg len 12.00)<br><br>Biggest   hash found &#x27;&quot;very_big_key&quot;&#x27; has 2050 fields<br><br>0 strings with 0 bytes (00.00% of keys, avg size 0.00)<br>0 lists with 0 items (00.00% of keys, avg size 0.00)<br>1 hashs with 2050 fields (100.00% of keys, avg size 2050.00)<br>0 streams with 0 entries (00.00% of keys, avg size 0.00)<br>0 sets with 0 members (00.00% of keys, avg size 0.00)<br>0 zsets with 0 members (00.00% of keys, avg size 0.00)<br></code></pre></td></tr></table></figure><p>可以看到找到了一个拥有 2050 个字段的大 key ：very_big_key</p><h2 id="怎样解决大-key"><a href="#怎样解决大-key" class="headerlink" title="怎样解决大 key"></a>怎样解决大 key</h2><ol><li>拆分成多个小 key。这是最容易想到的办法，降低单 key 的大小，读取可以用 mget 批量读取。</li><li>数据压缩。使用 String 类型的时候，使用压缩算法减少 value 大小。或者是使用 Hash 类型存储，因为 Hash 类型底层使用了压缩列表数据结构。</li><li>设置合理的过期时间。为每个 key 设置过期时间，并设置合理的过期时间，以便在数据失效后自动清理，避免长时间累积的大 Key 问题。</li><li>启用内存淘汰策略。启用 Redis 的内存淘汰策略，例如 LRU（Least Recently Used，最近最少使用），以便在内存不足时自动淘汰最近最少使用的数据，防止大 Key 长时间占用内存。</li><li>数据分片。例如使用 Redis Cluster 将数据分散到多个 Redis 实例，以减轻单个实例的负担，降低大 Key 问题的风险。</li><li>删除大 key。<strong>使用 UNLINK 命令删除大 key</strong>，UNLINK 命令是 DEL 命令的异步版本，它可以在后台删除 Key，避免阻塞 Redis 实例。</li></ol><h1 id="Redis-热-key-处理"><a href="#Redis-热-key-处理" class="headerlink" title="Redis 热 key 处理"></a>Redis 热 key 处理</h1><h1 id="如何实现分布式锁的"><a href="#如何实现分布式锁的" class="headerlink" title="如何实现分布式锁的"></a>如何实现分布式锁的</h1><h1 id="持久化策略及其对比"><a href="#持久化策略及其对比" class="headerlink" title="持久化策略及其对比"></a>持久化策略及其对比</h1><h2 id="AOF-1"><a href="#AOF-1" class="headerlink" title="AOF"></a>AOF</h2><p>AOF 会将 Redis 所有的 <strong>写命令</strong> 记录到一个文件内，当要恢复数据时，只要读取这个文件，将里面所有的命令执行一遍即可，原理非常简单。</p><p>AOF 记录写命令不是直接以文本的格式，而是以一种特殊的协议，比如如果要保存 <code>set name xiaolin</code> 这个命令，格式将会是下面这样：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-number">*3</span><br><span class="hljs-variable">$3</span><br><span class="hljs-built_in">set</span><br><span class="hljs-variable">$4</span><br>name<br><span class="hljs-variable">$7</span><br>xiaolin<br></code></pre></td></tr></table></figure><p>「<code>*3</code>」表示当前命令有三个部分，每部分都是以「<code>$+数字</code>」开头，后面紧跟着具体的命令、键或值。然后，这里的「<code>数字</code>」表示这部分中的命令、键或值一共有多少字节。例如，「<code>$3 set</code>」表示这部分有 3 个字节，也就是「<code>set</code>」命令这个字符串的长度。</p><p>Redis 会先执行写命令，然后再写 AOF 文件，这样有以下几点好处：</p><ol><li>避免额外的检查开销，如果执行的命令有误，那么将会执行失败，从而避免写入到 AOF，这样可以保证 AOF 中保存的都是正确的命令。</li><li>不会阻塞当前的命令，因为写命令完成后才会写 AOF，但这样也意味着可能会阻塞下一个写命令。</li></ol><p>但这种方式也有缺点：</p><ol><li>如果写 AOF 执行时间过长，那么将会阻塞下一个命令，因为 AOF 操作也是在主循环里面执行的</li><li>如果写命令执行完成了，但是 Redis 宕机了，将会导致没有将命令写入到 AOF 文件，从而丢失记录</li></ol><h3 id="AOF-写入流程"><a href="#AOF-写入流程" class="headerlink" title="AOF  写入流程"></a>AOF  写入流程</h3><p>AOF 的写入流程如下：</p><ol><li>执行写操作命令</li><li>命令追加到 server.aof_buf 缓冲区</li><li>执行系统调用 write 函数，将缓存区的内容拷贝到内核缓冲区 page cache，等待内核将数据写入硬盘</li><li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定，可能是缓冲区满了再刷到硬盘，也有可能是一定时间后写入</li></ol><p>为什么要搞一个内核缓冲区？</p><p>因为磁盘的 IO 操作是很慢的，如果每次操作都直接写入硬盘，那么会影响性能，所以准备了一个缓冲区，先把数据扔到缓冲区里面，等满了（或者别的情况）再一次性将缓冲区内的内容全部刷到硬盘，这样可以保证一次磁盘 IO 干更多的活，从而提高性能。</p><p>但是这样又引出了一个问题，如果系统宕机了，而缓冲区中还存在未刷盘的数据，这样不就导致数据丢失了吗？</p><p>为了解决这个问题，系统提供了 <code>fsync</code> 和 <code>fdatasync</code> 两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据刷到硬盘，从而保证数据的安全性。</p><h3 id="AOF-刷盘策略"><a href="#AOF-刷盘策略" class="headerlink" title="AOF 刷盘策略"></a>AOF 刷盘策略</h3><p>Redis AOF 提供了以下几种刷盘策略：</p><ul><li><p><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘（也就是调用 fsync 函数吗？）；</p><p>因为 Always 策略每执行一条写操作命令就同步将 AOF 内容写回硬盘，所以它是最安全的一种策略，即使出现故障停机，也只会丢失一个事件循环中所产生的命令数据；但同时它也是最慢的，因为它会产生大量磁盘 IO。</p></li><li><p><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</p><p>从效率上来讲，everysec 模式足够快，并且就算出现故障停机，数据库也只丢失一秒钟的命令数据。所以说这是一种折中的方案，可以保证数据丢失量小于 No 策略，同时保证写入性能高于 Always 策略。</p></li><li><p><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</p><p>这种策略相比于 Always 策略性能较好，但是操作系统写回硬盘的时机是不可预知的，如果 AOF 日志内容没有写回硬盘，一旦服务器宕机，就会丢失不定数量的数据。</p></li></ul><p>大家根据自己的业务场景进行选择：</p><ul><li>如果要高性能，就选择 No 策略；</li><li>如果要高可靠，就选择 Always 策略；</li><li>如果允许数据丢失一点，但又想性能高，就选择 Everysec 策略。</li></ul><h3 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h3><blockquote><p> PS：执行 <code>BGREWEITEAOF</code> 命令进行 AOF 重写。</p></blockquote><p>随着 Redis 运行时间越来越长，AOF 文件记录的写命令也会越来越多，这将会导致文件越来越大，使用 AOF 恢复数据的时间也会越来越长，为了解决这个问题，Redis 提供了 AOF 重写的功能。</p><p>什么情况下可以进行重写？</p><p>比如如果用户执行了下面的命令：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">set</span> <span class="hljs-keyword">name</span> a<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">name</span> b<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">name</span> c<br></code></pre></td></tr></table></figure><p>此时 AOF 文件中将会保存 3 条命令，但是实际上我们可以只保存 <code>set name c</code> 这一条命令，因为前面两条命令都已经被覆盖掉了，所以保存它们并没有什么意义。</p><h4 id="AOF-重写如何实现"><a href="#AOF-重写如何实现" class="headerlink" title="AOF 重写如何实现"></a>AOF 重写如何实现</h4><p>实际上和名字不同，Redis 并不会对现有的 AOF 做任何读取、分析、写入等操作，所以也不存在 “重写” 这一说，它会新创建一个文件，然后读取当前 Redis 中 所有 key 的值（忽略过期 key），然后用一条写命令写入到 AOF 文件即可，实现的原理非常简单。</p><h4 id="AOF-后台重写"><a href="#AOF-后台重写" class="headerlink" title="AOF 后台重写"></a>AOF 后台重写</h4><p>从上面的 AOF 重写原理我们就可以感觉出，这可能是一个非常耗时的操作，如果 key 很多的话它将触发大量 IO 操作，如果让它在事件循环里执行将会阻塞后续的命令，为了解决这个问题，Redis 将会新开一个子进程来干这件事。使用进程而不是线程，是为了可以在避免使用锁的情况下保证数据的安全性。</p><p>不过，使用子进程也有一个问题需要解决，因为子进程在进行 AOF 重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的 AOF 文件所保存的数据库状态不一致。（和主从同步一样的问题）</p><p>为了解决这种数据不一致问题，<strong>Redis 服务器设置了一个 AOF 重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用</strong>，当 Redis 服务器执行完一个写命令之后，它会同时将这个写命令发送给 AOF 缓冲区 和 AOF 重写缓冲区（AOF 缓冲区就是我们前面提到的 server.aof_buf，用来拷贝给内核缓冲区进行刷盘的）。</p><p><strong>当子进程完成 AOF 重写工作之后，它会向父进程发送一个信号</strong>，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作:</p><ol><li><p>将 AOF 重写缓冲区中的所有内容写人到新 AOF 文件中，这时新 AOF 文件所保存的数据库状态将和服务器当前的数据库状态一致。</p></li><li><p>对新的 AOF 文件进行改名 ， 原子地 (atomic) 覆盖现有的 AOF 文件，完成新旧两个 AOF 文件的替换。</p><p>这个信号处理函数执行完毕之后，父进程就可以继续像往常一样接受命令请求了。 <strong>在整个 AOF 后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞</strong>，在其他时候，AOF 后台重写都不会阻塞父进程，这将 AOF 重写对服务器性能造成的影响降到了最低。</p></li></ol><h2 id="RDB-1"><a href="#RDB-1" class="headerlink" title="RDB"></a>RDB</h2><p>RDB 是快照，其保存的是 Redis 某一时刻的数据，文件内容为二进制数据，所以相比保存写命令的 AOF 而言，RDB 恢复起来会更快，只需要将 RDB 读取到内存即可，而不需要像 AOF 那样一条条执行命令。</p><p>生成 RDB 快照有两种命令：</p><ul><li>save：在主线程进行快照生成操作，会影响其他命令的执行。</li><li>bgsave：新开一条子进程执行快照生成操作，从而避免对其他命令的阻塞。</li></ul><p>RDB 文件的加载工作是在服务器启动时自动执行的，Redis 并没有提供专门用于加载 RDB 文件的命令。</p><p>可以通过配置来指定 Redis 进行定期 RDB 快照备份，比如像下面这样：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span># <span class="hljs-number">900</span> 秒之内，对数据库进行了至少 <span class="hljs-number">1</span> 次修改；<br><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span> # <span class="hljs-number">300</span> 秒之内，对数据库进行了至少 <span class="hljs-number">10</span> 次修改；<br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span> # <span class="hljs-number">60</span> 秒之内，对数据库进行了至少 <span class="hljs-number">10000</span> 次修改。<br></code></pre></td></tr></table></figure><p>只要满足上面条件的任意一个，就会执行 bgsave 进行 RDB 持久化。</p><p>Redis 的快照是 <strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。</p><p>这也意味着 RDB 是一个耗时的操作，所以不能频繁执行。</p><p>但是如果执行频率太低，会导致丢失数据更多，比如如果设置至少 5 分钟才保存一次快照，这时如果 Redis 出现宕机等情况，则意味着最多可能丢失 5 分钟数据。比如 Redis 已经在 10:00 的时候执行过一次 RDB，那么其下次执行 RDB 的时间将会是 10:05，如果在 10:04 的时候 Redis 挂掉了，那么就意味着 10:00 - 10:04 这段时间的数据丢失了。</p><p>所以这也是 RDB 相较于 AOF 的一个缺点，它丢失的数据会更多。</p><h3 id="执行快照时，数据能被修改吗？"><a href="#执行快照时，数据能被修改吗？" class="headerlink" title="执行快照时，数据能被修改吗？"></a>执行快照时，数据能被修改吗？</h3><p>在 bgsave 的过程中，Redis 会使用写时复制，也就是子进程先会避免复制内存，而是和父进程共用同一片内存，只有当父进程对自己的内存执行修改操作时，子进程才会开始复制内存，这样的目的是为了减少创建子进程时的性能损耗，从而加快创建子进程的速度，毕竟创建子进程的过程中，是会阻塞主线程的。</p><p>比如当前正在执行 bgsave，子进程此时正与父进程共用同一片内存，然后 Redis 这边执行了 set a b 命令，将原先的 a &#x3D; c 改为了 a &#x3D; b，也就是对父进程的内存进行了修改，这个时候就会触发写时复制，执行 bgsave 的子进程会拷贝一份父进程的内存（拷贝的是修改之前的，也就是 a &#x3D; b 那份），然后用这份拷贝的内存执行后续的操作。</p><p>这也意味着 RDB 保存的数据是 bgsave 开始时 Redis 的数据，如果 bgsave 期间对 Redis 进行了修改是无法记录到 RDB 中的，只能由下一次 bgsave 来完成。</p><p>此外这还意味着，如果系统恰好在 RDB 快照文件创建完毕后崩溃了，那么 Redis 将会丢失主线程在快照期间修改的数据。</p><p>比如我在 10:00 执行了 bgsave，然后 10:01 执行了 set k v，10:02 bgsave 执行完毕，然后 Redis 就挂掉了，此时 set k v 这个数据就丢失了。</p><h1 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h1><h1 id="缓存雪崩、缓存击穿、缓存穿透"><a href="#缓存雪崩、缓存击穿、缓存穿透" class="headerlink" title="缓存雪崩、缓存击穿、缓存穿透"></a>缓存雪崩、缓存击穿、缓存穿透</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>什么是</strong></p><p>大量的 key 在同一时间过期或者 Redis 宕机，将会导致请求无法命中缓存，如果是高并发系统，将会导致大量的请求打到数据库，导致数据库压力巨大，威胁业务稳定性。</p><p><strong>如何解决</strong></p><p><strong>针对 同一时间过期 问题</strong></p><ol><li><p>均匀设置过期时间，可以在设置过期时间时加一个随机数，保证 key 的过期时间相对分散。</p></li><li><p>互斥锁，类似 go groupcache 里面的 singeflight 机制，如果多个请求请求的是同一个 key，而且这个 key 还过期被删掉了，那么就搞一个互斥锁，让这些请求去抢锁，第一个拿到锁的去构建缓存（查询数据库填充缓存），其他请求阻塞等待，等拿到锁的那个构建完成了再返回，这样就可以避免多个请求全都打到数据库。至于这个锁，应该是需要用分布式锁（关于分布式锁这里不展开）。</p></li><li><p>业务线程不再负责更新缓存，缓存也不设置有效期，而是 <strong>让缓存“永久有效”，并将更新缓存过期时间的工作交由后台线程定时更新</strong>。</p><blockquote><p> 后台更新这里暂时还没太搞明白，是开一条线程做 db 和 redis 的数据同步吗？这个策略应该只适用于热 key 吧？</p></blockquote><p>而且 Redis 还存在内存淘汰策略，那这个 key 虽然不过期了，但依然可能会被干掉</p><blockquote><p>这个策略没太搞明白，先记录一下 <a href="https://xiaolincoding.com/redis/cluster/cache_problem.html#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">原文出处</a></p></blockquote></li></ol><p><strong>针对 Redis 宕机</strong></p><ol><li>构建 Redis 缓存高可靠集群：使用主从或者集群等部署模型来保证 Redis 的高可用</li><li>增加限流&#x2F;熔断的中间件，当 Redis 宕机时开启熔断&#x2F;限流，来防止大量请求打到数据库。</li></ol><p>此外还可以曲线救国，既然你数据库这么容易挂，那我就在数据库层面做一些策略，让它变得坚强一点，比如分库分表、读写分离啥的</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>（老是和缓存穿透搞混）</p><p>和缓存雪崩类似，也是缓存过期导致请求打到数据库，只不过缓存击穿更侧重描述单个 key 失效，而雪崩则侧重描述大部分 key 失效？</p><p>解决方法也和雪崩类似，搞互斥锁或者设置永不过期（热 key 的话）</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>请求一个数据库中不存在的 key，那正常来说这个 key 在缓存中也不存在，然后更严重的问题是缓存还无法构建（数据库中没有，缓存又是基于数据库构建），相当于缓存永久失效了。简单地说，就是请求的 key 既不存在于数据库，又不存在于缓存。</p><p>应对缓存穿透的方案，常见的方案有三种。</p><ul><li><p>第一种方案，非法请求的限制；比如请求的 key 是数据库 ID，然后请求的值是 -1，这显然是非法的。</p></li><li><p>第二种方案，缓存空值或者默认值；给这些导致穿透的 key 设置一个空值。</p></li><li><p>第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在；</p><p>通过布隆过滤器将用户请求的 key 标记起来，可以在后续快速判断请求的 key 是否存在于数据库，从而避免请求直接打到数据库。</p><p>方案大致流程（随便想的，可能存在 bug 且非最优）：</p><ol><li>准备一个 map，用来记录 key 是否已经被布隆过滤器记录过。</li><li>拿到 key 以后，用上面的 map 判断，看是否记录过<ol><li>如果没记录过，去查数据库，查到的话就记录到布隆过滤器，然后在 map 中标记该 key ，说明已被记录过，不管数据库中有没有查到，都要执行这一步</li><li>如果记录过，直接去查布隆过滤器，看有没有，如果没有，那么代表这个值一定在数据库中也不存在，直接返回。</li></ol></li></ol><p>这种方法需要一个额外的 map，如果 key 很多可能会导致内存浪费，看了一下其他的解决方法，还有其他几种方案：</p><p><strong>方案 2：</strong></p><p>应用启动时，从数据库构建布隆过滤器，然后请求先走布隆过滤器，有的话再走 Redis，然后 Redis 缓存未命中，查数据库同时构建缓存，布隆过滤器没有的话直接返回。感觉这种方法比较简单，不过构建布隆过滤器这里</p><p><strong>方案 3：</strong></p><p>来源：<a href="https://github.com/daydreamdev/MeetingFilm/blob/master/note/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.md">https://github.com/daydreamdev/MeetingFilm/blob/master/note/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.md</a></p><p>反着来，布隆过滤器记录的是数据库中不存在的 key，比如用 abc 这个 key 去查布隆过滤器，返回结果为 true，则代表这个 key 不存在。</p><p>但是感觉有问题？因为布隆过滤器的特性是：它记录存在的数据，实际并不一定存在，因为存在哈希碰撞问题；但是它没记录的则一定不存在。如果布隆过滤器记录的是不存在的 key，那可能存在一种情况，就是用户请求的 key 可能实际存在于数据库，但是因为哈希碰撞导致布隆过滤器这里也有记录（意味着这个 key 将被判断为不存在），然后用户请求被直接打回，导致缓存也无法构建。</p><p>而且还有个问题，就是我可以搞一堆非法请求，比如用户 ID 我请求 -1 到 -9999999999，这些 key 数据库里面肯定是没有的，然后就全写到布隆过滤器里面了，内存里装了一大堆无用的垃圾数据。</p><p><strong>感觉这个方案不可用</strong></p><p>此外还有一个共同的问题：布隆过滤器是否需要定期更新？比如数据库中存在 abc 这个 key，布隆过滤器也记录了，但是后面这个 key 从数据库中删掉了，此时二者数据不一致了，而且布隆过滤器无法删除，这也是一个问题。</p><p>可以在操作数据库的同时更新布隆过滤器，使得二者数据一致，但是删除操作暂时无解。</p><p>删除操作想到了一种策略：</p><p>可以在我方案 1 的基础上，给 map 的 value 再加一种状态：”已删除”，所以一共有这几种状态：”已标记”，”未标记“，”已删除”，当数据库执行删除操作时，查一下这个 map，如果这个 key 存在且状态为 “已标记”，则将其更新为 “已删除”。</p><p>然后，key 进来时先用 map 检查一下，如果是 “已删除” 则直接 return。数据库执行插入、更新操作时也要查一下 map，看这个 key 的状态是不是 “已删除”，是的话将其改为 “已标记”，因为 “已删除” 只能由 “已标记” 流转过来，说明其已经存在于布隆过滤器中。</p><p>或者用布谷鸟过滤器？听说是支持删除操作，这个数据结构还没了解。</p></li></ul><h1 id="假如我有一个-Redis-集群，该怎么保证缓存的一致性？"><a href="#假如我有一个-Redis-集群，该怎么保证缓存的一致性？" class="headerlink" title="假如我有一个 Redis 集群，该怎么保证缓存的一致性？"></a>假如我有一个 Redis 集群，该怎么保证缓存的一致性？</h1><h1 id="Redis-Cluster-为什么选哈希槽不选一致性哈希？"><a href="#Redis-Cluster-为什么选哈希槽不选一致性哈希？" class="headerlink" title="Redis Cluster 为什么选哈希槽不选一致性哈希？"></a>Redis Cluster 为什么选哈希槽不选一致性哈希？</h1><h1 id="Redis-底层的统一结构体是什么样？让你设计你会怎么做？"><a href="#Redis-底层的统一结构体是什么样？让你设计你会怎么做？" class="headerlink" title="Redis 底层的统一结构体是什么样？让你设计你会怎么做？"></a>Redis 底层的统一结构体是什么样？让你设计你会怎么做？</h1><p>Redis 的底层数据结构是一个统一的结构体 <code>robj</code>，用于表示各种不同类型的数据（字符串、列表、哈希、集合等）。这个结构体定义在 <code>src/object.h</code> 文件中，如下所示：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog">cCopy code<br><span class="hljs-keyword">struct</span> redisObject &#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">type</span>:<span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">unsigned</span> lru:LRU_BITS; <span class="hljs-comment">/* LRU time (relative to server.lruclock) */</span><br>    <span class="hljs-keyword">int</span> refcount;<br>    <span class="hljs-keyword">void</span> *ptr;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中，<code>type</code> 表示对象类型，<code>encoding</code> 表示数据编码方式，<code>lru</code> 表示 LRU 时间戳，<code>refcount</code> 表示引用计数，<code>ptr</code> 是指向实际数据的指针。</p><p>如果我需要重新设计 Redis 的底层数据结构，我可能会考虑以下几点：</p><ol><li><strong>灵活性和扩展性</strong>：确保数据结构的设计足够灵活，能够支持不同类型的数据，以及未来的扩展和新增数据类型。</li><li><strong>高效存储</strong>：选择适当的数据编码方式，以便在内存中紧凑存储数据，减少空间浪费。</li><li><strong>引用计数和内存管理</strong>：引入引用计数机制，确保在多个引用指向同一个数据时能够正确管理内存释放。</li><li><strong>LRU 时间戳</strong>：为了支持 LRU 缓存淘汰策略，可以在数据结构中添加时间戳字段，用于记录数据最近的访问时间。</li><li><strong>线程安全性</strong>：考虑多线程环境下的数据访问和修改，需要设计合适的并发控制机制。</li><li><strong>快速访问</strong>：在结构体中添加必要的元数据，以支持快速访问数据类型和相关信息。</li><li><strong>对齐和内存布局</strong>：考虑数据结构的对齐方式和内存布局，以减少内存碎片和提高访问效率。</li><li><strong>扩展性和兼容性</strong>：确保设计允许后续新增数据类型和功能，同时保持与现有 Redis 版本的兼容性。</li></ol><p>需要注意的是，设计 Redis 的底层数据结构是一个复杂的任务，需要考虑很多因素，包括性能、内存管理、并发性等。同时，Redis 的现有设计已经在实践中得到了验证，所以重新设计需要充分考虑到这些因素。</p><h1 id="如果-Redis-同时开启-AOF-和-RDB，那恢复时会使用哪个？"><a href="#如果-Redis-同时开启-AOF-和-RDB，那恢复时会使用哪个？" class="headerlink" title="如果 Redis 同时开启 AOF 和 RDB，那恢复时会使用哪个？"></a>如果 Redis 同时开启 AOF 和 RDB，那恢复时会使用哪个？</h1><p>AOF 是基于命令追加，而 RDB 是基于快照，根据策略每隔一段时间保存一份数据快照，相比较之下，AOF 更新频率更高，数据更加完整，所以如果 AOF 和 RDB 同时存在的时候，Redis 会优先使用 AOF 文件来还原数据库状态，如果 AOF 处于关闭状态时，则从 RDB 中恢复。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>epoll 的 LT 和 ET</title>
    <link href="/2021/07/23/epoll-de-lt-he-et/"/>
    <url>/2021/07/23/epoll-de-lt-he-et/</url>
    
    <content type="html"><![CDATA[<p>Linux epoll 的 <strong>条件触发</strong>( Level Trigger )和 <strong>边缘触发</strong> ( Edge Trigger ) 实践</p><h1 id="LT-效果演示"><a href="#LT-效果演示" class="headerlink" title="LT 效果演示"></a>LT 效果演示</h1><p>一个简单的小 demo，从标准输入 stdin 读入数据，并输出到标准输出 stdout，这里设置了每次读取的 BUF_SIZE 为 2。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 2</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> epfd, nfds;<br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event</span>, <span class="hljs-title">events</span>[5];</span><br>    epfd = epoll_create(<span class="hljs-number">1</span>);<br>    event.data.fd = STDIN_FILENO;<br>    event.events = EPOLLIN <span class="hljs-comment">/*| EPOLLET*/</span>;<br>    epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &amp;event);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        nfds = epoll_wait(epfd, events, <span class="hljs-number">5</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">//printf(&quot;%d events already\n&quot;, nfds);</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nfds; i++) &#123;<br>            <span class="hljs-keyword">if</span> (events[i].data.fd == STDIN_FILENO) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;trigger once!\n&quot;</span>);<br>                <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE);<br>                read(events[i].data.fd, buf, BUF_SIZE);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read content: %s\n&quot;</span>, buf);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行程序，输入一个长度为 6 的字符串，因为设置了每次读 2 字节，所以一次并不能读完：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1627049775702.jpg"></p><p>运行结果如下：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1627049789070.jpg"></p><p>可以看到，在 LT 模式下，只要缓冲区中还有数据，该事件就依然会触发（这里最后一次触发不是很明白，输出的内容也是空，可能读取的是换行符？）</p><h1 id="ET-效果演示"><a href="#ET-效果演示" class="headerlink" title="ET 效果演示"></a>ET 效果演示</h1><p>ET 的代码和 LT 基本一样，只需要在 events 处小小改动，加一个 EPOLLET 条件： <code>event.events = EPOLLIN | EPOLLET</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 2</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> epfd, nfds;<br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event</span>, <span class="hljs-title">events</span>[5];</span><br>    epfd = epoll_create(<span class="hljs-number">1</span>);<br>    event.data.fd = STDIN_FILENO;<br>    event.events = EPOLLIN | EPOLLET;   <span class="hljs-comment">// set et</span><br>    epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &amp;event);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        nfds = epoll_wait(epfd, events, <span class="hljs-number">5</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">//printf(&quot;%d events already\n&quot;, nfds);</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nfds; i++) &#123;<br>            <span class="hljs-keyword">if</span> (events[i].data.fd == STDIN_FILENO) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;trigger once!\n&quot;</span>);<br>                <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE);<br>                read(events[i].data.fd, buf, BUF_SIZE);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read content: %s\n&quot;</span>, buf);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的输入，运行结果如下：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1627049988168.jpg"></p><p>在 ET 模式下，整个事件只会触发一次，即便缓冲区中还有残余数据未被处理，要想再次触发，只有在终端中再次输入：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1627050340406.jpg"></p><p>这里输入了 adaasdad ，使得事件得以再次触发。</p><p>这个 demo 说明了，如果使用 ET 模式，就一定要在一次事件中，一次性把 socket 上的数据收取干净才行，否则可能造成数据的遗漏。</p><h1 id="ET-的问题"><a href="#ET-的问题" class="headerlink" title="ET 的问题"></a>ET 的问题</h1><p>为了解决上面的问题，需要在一个死循环中不断调用 read，直到读完为止。修改后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 2</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> epfd, nfds;<br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event</span>, <span class="hljs-title">events</span>[5];</span><br>    epfd = epoll_create(<span class="hljs-number">1</span>);<br>    event.data.fd = STDIN_FILENO;<br>    event.events = EPOLLIN | EPOLLET;   <span class="hljs-comment">// set et</span><br>    epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &amp;event);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        nfds = epoll_wait(epfd, events, <span class="hljs-number">5</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">//printf(&quot;%d events already\n&quot;, nfds);</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nfds; i++) &#123;<br>            <span class="hljs-keyword">if</span> (events[i].data.fd == STDIN_FILENO) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;trigger once!\n&quot;</span>);<br>                <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE);<br>                <span class="hljs-comment">// 不断读取直到全部读完</span><br>                <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-type">int</span> n = read(events[i].data.fd, buf, BUF_SIZE);<br>                    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read EOF\n&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read content: %s\n&quot;</span>, buf);<br>                &#125;<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ET-需要和-NONBLOCK-搭配使用"><a href="#ET-需要和-NONBLOCK-搭配使用" class="headerlink" title="ET 需要和 NONBLOCK 搭配使用"></a>ET 需要和 NONBLOCK 搭配使用</h1><p>上面的 demo 只是一个简单的演示，实际中 epoll 更多的应用在网络编程中，这将涉及到多个连接的并发问题，比如有如下一个使用 epoll ET 实现的 echo server：</p><blockquote><p>PS: 这段代码使用了我自己随便瞎写的一个库，也就是引用的  pkg&#x2F;net&#x2F;net.h，将 socket 的一些操作简单封装了下</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../pkg/net/net.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 4  <span class="hljs-comment">// 将调用 read 函数时使用的缓冲大小缩减为 4 个字节</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLL_SIZE 50</span><br><br><span class="hljs-comment">// g++ -o echo_et echo_et.cc ../pkg/net/net.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Server <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>)</span></span>;<br>    s.<span class="hljs-built_in">Listen</span>(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br><br>    <span class="hljs-type">int</span> epfd = <span class="hljs-built_in">epoll_create</span>(EPOLL_SIZE);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> *events;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> event;<br><br>    events = (epoll_event*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> epoll_event) * EPOLL_SIZE);<br>    event.data.fd = s.<span class="hljs-built_in">Sockfd</span>();<br>    event.events = EPOLLIN | EPOLLET;   <span class="hljs-comment">// ET</span><br>    <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, s.<span class="hljs-built_in">Sockfd</span>(), &amp;event);<br><br>    <span class="hljs-keyword">for</span> (; ;) &#123;<br>        <span class="hljs-type">int</span> okcnt = <span class="hljs-built_in">epoll_wait</span>(epfd, events, EPOLL_SIZE, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span> (okcnt == <span class="hljs-number">-1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;epoll wait error&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 插入验证 epoll_wait 函数调用次数的语句</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;trigger once!&quot;</span> &lt;&lt; endl;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; okcnt; i++) &#123;<br>            <span class="hljs-keyword">if</span> (events[i].data.fd == s.<span class="hljs-built_in">Sockfd</span>()) &#123;<br>                <span class="hljs-keyword">auto</span> conn = s.<span class="hljs-built_in">Accept</span>();<br>                event.events = EPOLLIN | EPOLLET;<br>                event.data.fd = conn-&gt;<span class="hljs-built_in">Connfd</span>();<br>                <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, conn-&gt;<span class="hljs-built_in">Connfd</span>(), &amp;event);<br>                cout &lt;&lt; <span class="hljs-string">&quot;connected client: &quot;</span> &lt;&lt; conn-&gt;<span class="hljs-built_in">Connfd</span>() &lt;&lt; endl;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-type">int</span> n = <span class="hljs-built_in">read</span>(events[i].data.fd, buf, BUF_SIZE);<br>                    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, events[i].data.fd, <span class="hljs-literal">nullptr</span>);<br>                        <span class="hljs-built_in">close</span>(events[i].data.fd);<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;closed client: %d\n&quot;</span>, events[i].data.fd);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;  <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-built_in">write</span>(events[i].data.fd, buf, n);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的程序是不具备并发能力的，原因在于这段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">read</span>(events[i].data.fd, buf, BUF_SIZE);<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, events[i].data.fd, <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-built_in">close</span>(events[i].data.fd);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;closed client: %d\n&quot;</span>, events[i].data.fd);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;  <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">write</span>(events[i].data.fd, buf, n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为 ET 的特性，需要一次性将数据全部读完，所以需要在一个死循环中不断调用 read 来读取数据。</p><p>但是 socket 建立的连接默认是阻塞模式的，这将导致 read 函数在最后一次被阻塞，比如要读取数据 1234，每次读 2 个，第一次循环读取 12，第二次循环读取 34，读取完后进入第三次循环，但是因为此时已经无数据可读了，所以会阻塞在 read 处，除非对端主动关闭返回 0，否则将永远阻塞。而整个程序又是单线程的，这将导致其他连接无法被处理。</p><p>解决方法是将 socket 设置为非阻塞（NONBLOCK），当无数据可读时，会立马返回 EAGAIN 错误（ps：EAGAIN 和 EWOULDBLOCK 是一样的）而不是阻塞。只需要将 accpet 返回的 conn 设置为非阻塞即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (events[i].data.fd == s.<span class="hljs-built_in">Sockfd</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> conn = s.<span class="hljs-built_in">Accept</span>();<br>        <span class="hljs-comment">// set conn nonblock</span><br>        util::<span class="hljs-built_in">SetNonBlock</span>(conn-&gt;<span class="hljs-built_in">Connfd</span>());<br>        event.events = EPOLLIN | EPOLLET;<br>        event.data.fd = conn-&gt;<span class="hljs-built_in">Connfd</span>();<br>        <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, conn-&gt;<span class="hljs-built_in">Connfd</span>(), &amp;event);<br>        cout &lt;&lt; <span class="hljs-string">&quot;connected client: &quot;</span> &lt;&lt; conn-&gt;<span class="hljs-built_in">Connfd</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">util::SetNonBlock</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span> </span>&#123;<br>    <span class="hljs-type">int</span> old_opt = <span class="hljs-built_in">fcntl</span>(fd, F_GETFL);<br>    <span class="hljs-type">int</span> new_opt = old_opt | O_NONBLOCK;<br>    <span class="hljs-built_in">fcntl</span>(fd, F_SETFL, new_opt);<br>    <span class="hljs-keyword">return</span> old_opt;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="为什么-LT-不需要设置非阻塞"><a href="#为什么-LT-不需要设置非阻塞" class="headerlink" title="为什么 LT 不需要设置非阻塞"></a>为什么 LT 不需要设置非阻塞</h1><p>LT 下的 echo 服务：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by root on 7/18/21.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../pkg/net/net.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 4  <span class="hljs-comment">// 将调用 read 函数时使用的缓冲大小缩减为 4 个字节</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLL_SIZE 50</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Server <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>)</span></span>;<br>    s.<span class="hljs-built_in">Listen</span>(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br><br>    <span class="hljs-type">int</span> epfd = <span class="hljs-built_in">epoll_create</span>(EPOLL_SIZE);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> *events;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> event;<br><br>    events = (epoll_event*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> epoll_event) * EPOLL_SIZE);<br>    event.data.fd = s.<span class="hljs-built_in">Sockfd</span>();<br>    event.events = EPOLLIN;<br>    <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, s.<span class="hljs-built_in">Sockfd</span>(), &amp;event);<br><br>    <span class="hljs-keyword">for</span> (; ;) &#123;<br>        <span class="hljs-type">int</span> okcnt = <span class="hljs-built_in">epoll_wait</span>(epfd, events, EPOLL_SIZE, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span> (okcnt == <span class="hljs-number">-1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;epoll wait error&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 插入验证 epoll_wait 函数调用次数的语句</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;trigger once!&quot;</span> &lt;&lt; endl;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; okcnt; i++) &#123;<br>            <span class="hljs-keyword">if</span> (events[i].data.fd == s.<span class="hljs-built_in">Sockfd</span>()) &#123;<br>                <span class="hljs-keyword">auto</span> conn = s.<span class="hljs-built_in">Accept</span>();<br>                event.events = EPOLLIN;<br>                event.data.fd = conn-&gt;<span class="hljs-built_in">Connfd</span>();<br>                <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, conn-&gt;<span class="hljs-built_in">Connfd</span>(), &amp;event);<br>                cout &lt;&lt; <span class="hljs-string">&quot;connected client: &quot;</span> &lt;&lt; conn-&gt;<span class="hljs-built_in">Connfd</span>() &lt;&lt; endl;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> n = <span class="hljs-built_in">read</span>(events[i].data.fd, buf, BUF_SIZE);<br>                <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, events[i].data.fd, <span class="hljs-literal">nullptr</span>);<br>                    <span class="hljs-built_in">close</span>(events[i].data.fd);<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;closed client: %d\n&quot;</span>, events[i].data.fd);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">write</span>(events[i].data.fd, buf, n);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>LT 模式下，只要缓冲区还有数据就会触发事件，所以不需要一次全部读取，每次触发事件只会 read 一次（触发事件即表示 read 可读），而不是像 ET 一样在死循环里一直 read，自然也就不会发生阻塞问题了。比如读取 1234，第一次读取 12 退出循环，因为还有数据，继续触发事件，读取剩余的 34。</p>]]></content>
    
    
    
    <tags>
      
      <tag>epoll</tag>
      
      <tag>多路复用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go container/heap 源码阅读</title>
    <link href="/2021/07/22/go-containerheap-yuan-ma-yue-du/"/>
    <url>/2021/07/22/go-containerheap-yuan-ma-yue-du/</url>
    
    <content type="html"><![CDATA[<p>heap（堆），是一个用数组表示的完全二叉树，常用于构建优先队列，排序和快速找出一个集合中的最小值（或者最大值）。在 go 标准库下的 container 包中提供了这种数据结构。</p><span id="more"></span><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p>要想使用堆，需要实现 <code>Interface</code> 接口，这个接口中内嵌了一个 <code>sort.Interface</code> 接口，所以一共需要包含 5 个方法：Len() 用于返回长度，Swap() 用于交换两个值，Less() 用于定义比较两个值的规则，Push() 和 Pop() 分别代表添加到末尾和弹出末尾元素。通过 Less() 可以自定义堆为最大堆还是最小堆。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br>sort.Interface<br>Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-comment">// 添加 x 到末尾</span><br>Pop() <span class="hljs-keyword">interface</span>&#123;&#125;   <span class="hljs-comment">// 弹出末尾元素并返回</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一开始我不是很明白为什么要实现 Push 和 Pop 两个方法，因为这两个方法的定义已经很明确了，后来看了 heap 包下的 example_pq_test.go 才明白了原因，主要在于一些操作还需要做一些额外的工作，比如优先级队列的实现，其实现的 Pop() 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq *PriorityQueue)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>old := *pq<br>n := <span class="hljs-built_in">len</span>(old)<br>item := old[n<span class="hljs-number">-1</span>]<br>old[n<span class="hljs-number">-1</span>] = <span class="hljs-literal">nil</span>  <span class="hljs-comment">// avoid memory leak</span><br>    <span class="hljs-comment">// 将 index 置为 -1 是为了标识该数据已经出了优先级队列了</span><br>item.index = <span class="hljs-number">-1</span> <br>*pq = old[<span class="hljs-number">0</span> : n<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> item<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Push</span><span class="hljs-params">(h Interface, x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>h.Push(x)<br><span class="hljs-comment">// 从下到上堆化</span><br>up(h, h.Len()<span class="hljs-number">-1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>Push 会先执行自己实现的 h.Push 方法，将 x 添加到末尾，之后再执行 up 进行堆化。</p><h2 id="up"><a href="#up" class="headerlink" title="up"></a>up</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// up 代表上浮，从下到上堆化</span><br><span class="hljs-comment">// j 代表需要堆化的元素 index，up 会从该元素开始，不断向上调整堆</span><br><span class="hljs-comment">// 在 Push 中会调用 up</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">up</span><span class="hljs-params">(h Interface, j <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// j 的父节点</span><br>i := (j - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> <span class="hljs-comment">// parent</span><br><br><span class="hljs-comment">// i == j ：此时 i 是最后一个元素</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 在解释 !h.Less(j, i) 之前，先来看看 Less(i, j int) 接口的定义：</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// func (m myheap) Less(i, j int) bool &#123;</span><br><span class="hljs-comment">//return m[i] &lt; m[j]// 这代表实现的堆为最小堆</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// func (m myheap) Less(i, j int) bool &#123;</span><br><span class="hljs-comment">//return m[i] &gt; m[j]// 这代表实现的堆为最大堆</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 1. 最小堆，如果 j（子节点）大于 i（父节点），情况如下图：</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//3i</span><br><span class="hljs-comment">//  \</span><br><span class="hljs-comment">//   5  j</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 此时便不需要交换 i 和 j，!h.Less(j, i) 对应 !m[j] &lt; m[i]，即 m[j] &gt; m[i]</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 最大堆同理</span><br><span class="hljs-keyword">if</span> i == j || !h.Less(j, i) &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-comment">// 否则需要进行交换，还是以最小堆为例：</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//5i</span><br><span class="hljs-comment">//  \</span><br><span class="hljs-comment">//   3  j</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 此时不满足 !h.Less(j, i)，此时 i（父节点）大于 j（子节点），</span><br><span class="hljs-comment">// 不满足最小堆的定义，所以需要进行交换</span><br>h.Swap(i, j)<br><br><span class="hljs-comment">// up 代表上浮，所以更新 j 为其父节点 i</span><br>j = i<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Push-的流程图示"><a href="#Push-的流程图示" class="headerlink" title="Push 的流程图示"></a>Push 的流程图示</h2><p>执行以下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myheap []<span class="hljs-type">int</span>   <span class="hljs-comment">// myheap 是一个最小堆</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestHeapPushPop</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>h := <span class="hljs-built_in">new</span>(myheap)<br>heap.Push(h, <span class="hljs-number">5</span>)<br>heap.Push(h, <span class="hljs-number">10</span>)<br>heap.Push(h, <span class="hljs-number">2</span>)<br>heap.Push(h, <span class="hljs-number">99</span>)<br>heap.Push(h, <span class="hljs-number">3</span>)<br>heap.Push(h, <span class="hljs-number">233</span>)<br>heap.Push(h, <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1626964254407.png"></p><h2 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pop</span><span class="hljs-params">(h Interface)</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>n := h.Len() - <span class="hljs-number">1</span><br><span class="hljs-comment">// 堆顶是最小（或最大）元素，将其交换到末尾，pop 会移除该元素</span><br>h.Swap(<span class="hljs-number">0</span>, n)<br><span class="hljs-comment">// FIXME down 的作用不确定，以下为猜测</span><br><span class="hljs-comment">// down 会将第二小（或大）的元素移动到堆顶，便于下次操作</span><br>down(h, <span class="hljs-number">0</span>, n)<br><span class="hljs-keyword">return</span> h.Pop()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="down"><a href="#down" class="headerlink" title="down"></a>down</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">down</span><span class="hljs-params">(h Interface, i0, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>i := i0<br><span class="hljs-keyword">for</span> &#123;<br>j1 := <span class="hljs-number">2</span>*i + <span class="hljs-number">1</span>          <span class="hljs-comment">// j1 是 i 的左子节点</span><br><span class="hljs-comment">// j1 &gt; n 代表子节点不存在</span><br><span class="hljs-comment">// j1 == n 代表子节点是堆中最后一个节点，down 操作会忽略最后一个元素</span><br><span class="hljs-keyword">if</span> j1 &gt;= n || j1 &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// j1 &lt; 0 after int overflow</span><br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-comment">// j 用来保存子节点中较小（大）的那个，默认为左子节点</span><br>j := j1 <span class="hljs-comment">// left child</span><br><br><span class="hljs-comment">// j2 := j1 + 1，这表示 j2 是 i 的右子节点</span><br><span class="hljs-comment">// 这里是 j2 &lt; n 而不是 j2 &lt;= n，因为 down 操作会忽略最后一个元素</span><br><span class="hljs-comment">// 如果是最小堆，则选出 j1（左子节点）和 j2（右子节点）中较小的那个</span><br><span class="hljs-comment">// 如果是最大堆，则选出 j1（左子节点）和 j2（右子节点）中较大的那个</span><br><span class="hljs-keyword">if</span> j2 := j1 + <span class="hljs-number">1</span>; j2 &lt; n &amp;&amp; h.Less(j2, j1) &#123;<br><span class="hljs-comment">// 满足条件，则更新 j 为右子节点</span><br>j = j2 <span class="hljs-comment">// = 2*i + 2  // right child</span><br>&#125;<br><br><span class="hljs-comment">// 判断 j（子节点） 和 i（父节点）的关系</span><br><span class="hljs-comment">// 如果是最小堆，!h.Less(j, i) 代表 j &gt; i，即父节点小于较小的子节点，</span><br><span class="hljs-comment">// 此时已经满足最小堆的特性了，直接 break</span><br><span class="hljs-comment">// 如果是最大堆，!h.Less(j, i) 代表 j &lt; i，与上面同理</span><br><span class="hljs-keyword">if</span> !h.Less(j, i) &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><br><span class="hljs-comment">// 到这里说明 j（子节点） 和 i（父节点）不满足堆的特性，</span><br><span class="hljs-comment">// 如果是最小堆，说明此时 i &gt; j，需要交换</span><br><span class="hljs-comment">// 如果是最大堆，说明此时 i &lt; j，需要交换</span><br>h.Swap(i, j)<br><br><span class="hljs-comment">// down 代表下沉，更新 i 为其子节点 j，进行下一轮循环</span><br>i = j<br>&#125;<br><br><span class="hljs-comment">// 如果没有执行过 i = j，则不满足 i &gt; i0 条件，</span><br><span class="hljs-comment">// 这代表没有进行 down 操作</span><br><span class="hljs-keyword">return</span> i &gt; i0<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Pop-的流程如下图："><a href="#Pop-的流程如下图：" class="headerlink" title="Pop 的流程如下图："></a>Pop 的流程如下图：</h2><p><img src="https://github.com/autsu/diagrams/blob/master/img/%E5%A0%86%E7%9A%84pop%E6%93%8D%E4%BD%9C.png?raw=true"> </p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>上面只对 <code>heap</code> 包中的核心函数进行了分析，剩余还有 <code>Init</code>，<code>Remove</code>，<code>Fix()</code> 函数，但是其内部也是调用了 <code>up</code> 和 <code>down</code> 这两个函数，所以就不一一分析了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>源码</tag>
      
      <tag>数据结构</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 40. 最小的 k 个数</title>
    <link href="/2021/07/21/jian-zhi-offer-40-zui-xiao-de-k-ge-shu/"/>
    <url>/2021/07/21/jian-zhi-offer-40-zui-xiao-de-k-ge-shu/</url>
    
    <content type="html"><![CDATA[<p>输入整数数组 arr ，找出其中最小的 k 个数</p><span id="more"></span><blockquote><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8 这 8 个数字，则最小的 4 个数字是 1、2、3、4。</p><p>示例 1：</p><p>输入：arr &#x3D; [3,2,1], k &#x3D; 2<br>输出：[1,2] 或者 [2,1]</p><p>示例 2：</p><p>输入：arr &#x3D; [0,1,2,1], k &#x3D; 1<br>输出：[0]</p></blockquote><h1 id="方法1-排序"><a href="#方法1-排序" class="headerlink" title="方法1 排序"></a>方法1 排序</h1><p>使用任意一种排序算法进行排序，排序后取前 k 个即可，这里使用快排：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    quickSort(arr)<br>    <span class="hljs-keyword">return</span> arr[:k]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>q := arr[<span class="hljs-number">0</span>]<br>l, r := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span><br><br><span class="hljs-keyword">for</span> l &lt; r &#123;<br><span class="hljs-keyword">for</span> r &gt; l &amp;&amp; arr[r] &gt; q &#123;<br>r--<br>&#125;<br>arr[l] = arr[r]<br><br><span class="hljs-keyword">for</span> r &gt; l &amp;&amp; arr[l] &lt;= q &#123;<br>l++<br>&#125;<br>arr[r] = arr[l]<br>&#125;<br><br>arr[l] = q<br><br>quickSort(arr[:r])<br>quickSort(arr[r+<span class="hljs-number">1</span>:])<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="方法2-优化快排"><a href="#方法2-优化快排" class="headerlink" title="方法2 优化快排"></a>方法2 优化快排</h1><p>题目只是要求找出 top k，但是方法 1 却对整个数组进行了排序，显然是不必要的。这里可以利用快排的性质做一些优化，快排的核心是，每轮都会选出一个基准点，以该点为分隔线，将比它小的都放在左边，比它大的放在右边，可以利用这个特性对 topk 进行优化。</p><p>当挑选出基准点 p 时，将其与 k 进行比对，有以下几种情况：</p><ol><li><p>p &lt; k</p><p>比如：-1, 1, <strong>2</strong>, 5, 3, 5, 9，k &#x3D; 5，第一轮求得 p &#x3D; [2] &#x3D; 2</p><p>此时 2 作为基准点，其左边元素都比它小，右边元素都比它大，题目要求的是求前 5 个最小元素，现在已经确定了 -1，1，2 三个元素，还差 5 - 3 &#x3D; 2 个，且这两个元素一定在 2 的右边，所以可以再对右边部分 [5, 3, 5, 9] 进行快排，同时 k 需要更改为 k - p - 1 &#x3D; 5 - 2 - 1 &#x3D; 2。</p><p>上面的结果：5, 3, 5, 9，k &#x3D; 2，p &#x3D; [2] &#x3D; 5，此时 k &#x3D; p，结束（k &#x3D; p 的情况在后面会说明）。至此，数组排序为 -1, 1, 2, 5, 3, 5, 9，可以看到并没有对整个数组进行排序。最后只需要返回排序后数组的前 k 个元素即可，即 -1, 1, 2, 5, 3（前 k 个元素不需要有序）</p></li><li><p>p &gt; k</p><p>比如：-1, 2, 3, 4, 1, <strong>5</strong>, 8, 9,  k &#x3D; 3，第一轮求得 p &#x3D; [5] &#x3D; 5</p><p>p 的左边都是小于 p 的，而此时 p &gt; k，代表我们只需要 3 个元素，但是 p 之前却包含了 5 个元素，这超过了我们的所需数量，所以需要再从这 5 个元素找出最小的 3 个，即再对 p 的左边部分进行快排。</p></li><li><p>p &#x3D; k</p><p>比如：-1, 1, <strong>2</strong>, 5, 3, 5, 9，k &#x3D; 2，第一轮求得 p &#x3D; [2] &#x3D; 2</p><p>此时 p &#x3D; k，这代表着：p 左边的元素数量刚好等于所需的数量 k，此时数组的 [0:k-1] 部分已经是所需了，无需任何操作，直接返回即可，</p></li></ol><p>通过上诉操作可以避免对整个数组进行排序，提示了效率。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    quickSort(arr, k)<br>    <span class="hljs-keyword">return</span> arr[:k]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>q := arr[<span class="hljs-number">0</span>]<br>l, r := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span><br><br><span class="hljs-keyword">for</span> l &lt; r &#123;<br><span class="hljs-keyword">for</span> r &gt; l &amp;&amp; arr[r] &gt; q &#123;<br>r--<br>&#125;<br>arr[l] = arr[r]<br><br><span class="hljs-keyword">for</span> r &gt; l &amp;&amp; arr[l] &lt;= q &#123;<br>l++<br>&#125;<br>arr[r] = arr[l]<br>&#125;<br><br>arr[l] = q<br>    <br>    <span class="hljs-keyword">if</span> l &gt; k &#123;<br>        quickSort(arr[:l], k)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l &lt; k &#123;<br>        quickSort(arr[l+<span class="hljs-number">1</span>:], k-l<span class="hljs-number">-1</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="方法-3-堆"><a href="#方法-3-堆" class="headerlink" title="方法 3 堆"></a>方法 3 堆</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myHeap []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h myHeap)</span></span> Len() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h myHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>h[i], h[j] = h[j], h[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h myHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> h[i] &gt; h[j]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *myHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>*h = <span class="hljs-built_in">append</span>(*h, x.(<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *myHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>p := (*h)[<span class="hljs-built_in">len</span>(*h)<span class="hljs-number">-1</span>]<br>*h = (*h)[:<span class="hljs-built_in">len</span>(*h)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> p<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h myHeap)</span></span> Top() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> h[<span class="hljs-number">0</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) == <span class="hljs-number">0</span> || k == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    h := <span class="hljs-built_in">new</span>(myHeap)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br><span class="hljs-keyword">if</span> h.Len() &lt; k &#123;<br>            heap.Push(h, arr[i])<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> h.Top() &gt; arr[i] &#123;<br>heap.Pop(h)<br>heap.Push(h, arr[i])<br>&#125;<br>&#125;<br>        <br>&#125;<br><br><span class="hljs-keyword">return</span> *h<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>堆</tag>
      
      <tag>topK</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 92. 反转链表 II</title>
    <link href="/2021/07/20/leetcode-92-fan-zhuan-lian-biao-ii/"/>
    <url>/2021/07/20/leetcode-92-fan-zhuan-lian-biao-ii/</url>
    
    <content type="html"><![CDATA[<p>反转链表的指定部分</p><span id="more"></span><blockquote><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回反转后的链表 。</p><p>示例1：</p><p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5反转前</p><p>1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5反转后</p><p>输入：head &#x3D; [1,2,3,4,5], left &#x3D; 2, right &#x3D; 4<br>输出：[1,4,3,2,5]</p><p>说明：反转第二个元素到第四个元素这部分（从 1 开始）</p><p><strong>进阶：</strong> 你可以使用一趟扫描完成反转吗？</p></blockquote><h1 id="方法1-断链，反转，再拼接"><a href="#方法1-断链，反转，再拼接" class="headerlink" title="方法1 断链，反转，再拼接"></a>方法1 断链，反转，再拼接</h1><p>这是一个比较直观，容易想到的方法，首先找到 left 和 right 对应的节点，在上面的例子中，left 对应节点为 2，right 对应节点为 4，然后将 right 断链，即 right.Next &#x3D; nil，此时链表变为：1 -&gt; 2 -&gt; 3 -&gt; 4。同时还要记录 left 的前一个节点和 right 的后一个节点，用于之后恢复链表。</p><p>再定义一个反转链表函数，和 <code>lc206 反转链表</code> 一样，传入参数为 left 节点，函数会把 left 到 right 这部分反转（right 已经断链了，所以不会影响 right 后面的部分），反转过后 2 -&gt; 3 -&gt; 4 变为  4 -&gt; 3 -&gt; 2，但是这时 1 依然还指向 2，所以这里需要更新 1 的指向，将 1 指向反转后的链表头，此时链表为 1 -&gt; 4 -&gt; 3 -&gt; 2，然后再将链表尾指向先前保存的 right 的后一个节点，1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5，大功告成。</p><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> (<br>        leftPrev, leftNode *ListNode<br>        rightNext, rightNode *ListNode<br>        count = <span class="hljs-number">1</span><br>    ) <br><br>    h := head<br>    <span class="hljs-keyword">for</span> h != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 找到 left 对应的节点及该节点的 prev 节点</span><br>        <span class="hljs-keyword">if</span> count != left &amp;&amp; leftNode == <span class="hljs-literal">nil</span> &#123;<br>            leftPrev = h<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> count == left &#123;<br>            leftNode = h<br>        &#125;<br>        <br>        <span class="hljs-comment">// 找到 right 对应的节点及该节点的 next 节点</span><br>        <span class="hljs-keyword">if</span> count == right &amp;&amp; rightNode == <span class="hljs-literal">nil</span> &#123;<br>            rightNode = h<br>            rightNext = h.Next<br>        &#125;<br><br>        h = h.Next<br>        count++<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> rightNode != <span class="hljs-literal">nil</span> &#123;<br>        rightNode.Next = <span class="hljs-literal">nil</span>    <span class="hljs-comment">// 断链</span><br>    &#125;<br>    <br><br>    <span class="hljs-comment">// 把 leftNode 到 rightNode 这部分反转</span><br>    reverse(leftNode)<br>    <span class="hljs-comment">//fmt.Println(leftPrev, leftNode, rightNode, rightNext)</span><br>    <span class="hljs-comment">//printList(rightNode)</span><br>    <br>    <span class="hljs-comment">// 反转之后，rightNode 成了头节点，leftNode 成了最后一个节点</span><br>    <span class="hljs-comment">// 此时再将 leftPrev 接上 rightNode，leftNode 接上 rightNext</span><br>    <span class="hljs-keyword">if</span> leftPrev != <span class="hljs-literal">nil</span> &#123;<br>        leftPrev.Next = rightNode<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果 leftPrev 为 nil</span><br>        leftNode.Next = rightNext<br>        <span class="hljs-keyword">return</span> rightNode<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> leftNode != <span class="hljs-literal">nil</span> &#123;<br>        leftNode.Next = rightNext<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> head<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(head *ListNode)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> (<br>        cur = head<br>        next *ListNode<br>        prev *ListNode    <br>    )<br><br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        next = cur.Next<br>        cur.Next = prev<br>        prev = cur<br>        cur = next<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 调试函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printList</span><span class="hljs-params">(head *ListNode)</span></span> &#123;<br>    h := head<br>    <span class="hljs-keyword">for</span> h != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Print(h.Val, <span class="hljs-string">&quot; -&gt; &quot;</span>)<br>        h = h.Next<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码有不少的边界判断，导致略显冗余杂乱，可能更好的解决方法是设置一个<strong>哨兵节点</strong>，这样就可以应对 一些边界情况了，比如 left 是第一个元素，这时 prev 将是 nil，当 leftPrev.Next 时就会报错，但设置了哨兵节点后，prev 是哨兵节点，这样 leftPrev.Next 就不会产生错误了，但是这里我还没有实践，因为还有一种更好的方法。</p><h1 id="方法2-一次遍历"><a href="#方法2-一次遍历" class="headerlink" title="方法2 一次遍历"></a>方法2 一次遍历</h1><p>方法 1 虽然可以 ac，但是不满足题目的进阶要求：只遍历链表一次。在参考了题解后，了解了另一种方法，但是该方法略微有些繁琐，文字难以描述，直接上图更好理解：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1626763188487.png"></p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> (<br>        s = &amp;ListNode&#123;Next: head&#125;<br>        prev = s<br>        cur, next *ListNode<br>    )<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; left<span class="hljs-number">-1</span>; i++ &#123;<br>        prev = prev.Next<br>    &#125;<br>    cur = prev.Next<br>    next = cur.Next<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; right-left; i++ &#123;<br>        cur.Next = next.Next<br>        next.Next = prev.Next<br>        prev.Next = next<br>        next = cur.Next<br>    &#125; <br><br>    <span class="hljs-keyword">return</span> s.Next<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux select 的错误使用案例</title>
    <link href="/2021/07/18/linux-select-de-cuo-wu-shi-yong-an-li/"/>
    <url>/2021/07/18/linux-select-de-cuo-wu-shi-yong-an-li/</url>
    
    <content type="html"><![CDATA[<p>select 错误使用记录，加深对 select 的理解</p><span id="more"></span><h1 id="错误的代码"><a href="#错误的代码" class="headerlink" title="错误的代码"></a>错误的代码</h1><p>有如下一个使用多路复用 select 实现的 echo（回响）服务器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br>  <span class="hljs-comment">// 简单封装了一下 socket 的创建流程</span><br>    Server <span class="hljs-title function_">s</span><span class="hljs-params">(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>)</span>;<br>    s.Listen(<span class="hljs-number">1024</span>);<br><br>    fd_set readfds;<br>    <span class="hljs-comment">// 监听服务端socket，当有客户连接时会触发事件</span><br>    FD_ZERO(&amp;readfds);<br>    FD_SET(s.Sockfd(), &amp;readfds);<br><br>    <span class="hljs-type">int</span> maxfd = s.Sockfd();<br><br>    <span class="hljs-keyword">for</span> (; ;) &#123;<br>        <span class="hljs-type">int</span> okcnt = select(maxfd+<span class="hljs-number">1</span>, &amp;readfds, nullptr, nullptr, nullptr);<br>        <span class="hljs-keyword">if</span> (okcnt == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;select error\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (okcnt == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历 select 数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; maxfd+<span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-comment">// 找到所有值为 1 的 fd，这表示该 fd 已经准备就绪了</span><br>            <span class="hljs-keyword">if</span> (FD_ISSET(i, &amp;readfds)) &#123;<br>                <span class="hljs-comment">// 如果就绪的 fd 为 server,说明有新的连接请求</span><br>                <span class="hljs-keyword">if</span> (i == s.Sockfd()) &#123;<br>                    <span class="hljs-comment">// 调用 accept 接收客户端的连接请求</span><br>                    <span class="hljs-keyword">auto</span> conn = s.Accept();<br>                    <span class="hljs-type">int</span> connfd = conn-&gt;Connfd();<br>                    <span class="hljs-comment">// 更新 maxfd</span><br>                    <span class="hljs-keyword">if</span> (connfd &gt; maxfd) &#123;<br>                        maxfd = connfd;<br>                    &#125;<br>                    <span class="hljs-comment">// 将 conn 的 fd 添加到 select 监听集合中</span><br>                    FD_SET(connfd, &amp;readfds);<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connected client: %d\n&quot;</span>, conn-&gt;Connfd());<br>                    <span class="hljs-comment">// 如果就绪的 fd 不是 server fd，则是 conn fd</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;conn %d is already\n&quot;</span>, i);<br>                    <span class="hljs-comment">// 可以对这些准备就绪的 conn 进行 echo 处理了</span><br>                    <span class="hljs-type">int</span> n = read(i, buf, BUF_SIZE);<br>                    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// EOF</span><br>                        <span class="hljs-comment">//</span><br>                        FD_CLR(i, &amp;readfds);<br>                        close(i);<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;close conn: %d\n&quot;</span>, i);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        write(i, buf, n);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    s.Close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>编译并运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ -o echo_server_wrong_example echo_server_wrong_example.cc<br>./echo_server_wrong_example<br></code></pre></td></tr></table></figure><p>新建一个终端并开启第一个客户端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc localhost 8080<br></code></pre></td></tr></table></figure><p>此时只连接到服务端，不发送任何数据，服务端的日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">connected client: 4<br>conn 4 is already<br></code></pre></td></tr></table></figure><p>随后再新建一个终端并开启第二个客户端，并尝试发送数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc localhost 8080<br><br>1<br></code></pre></td></tr></table></figure><p>但是没有任何回应，查看服务端日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">connected client: 4<br>conn 4 is already<br></code></pre></td></tr></table></figure><p>根本没有接收第二个服务端的连接！说明编写的这个程序是没有并发能力的，一定是某个地方写错了</p><p>再返回去看第一个客户端是否能正常收到响应：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc localhost 8080<br><br>1 // 发送的<br>1// 响应的<br></code></pre></td></tr></table></figure><p>第一个客户端是可以正常工作的</p><p>再将第一个服务端结束，服务端日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">close conn: 4<br></code></pre></td></tr></table></figure><p>此时切换到第二个客户端，发现原来阻塞的请求得到了响应：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc localhost 8080<br><br>1<br>l<br></code></pre></td></tr></table></figure><p>服务端日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 之前的<br>connected client: 4<br>conn 4 is already<br>close conn: 4<br><br>// 新的 <br>connected client: 4<br>conn 4 is already<br></code></pre></td></tr></table></figure><p>并且之后的所有请求都能够得到响应</p><p>此时再启动第一个客户端：</p><p>服务端日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">connected client: 5<br>conn 5 is already<br></code></pre></td></tr></table></figure><p>尝试发送数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">kk<br>kk<br>adasd<br>adasd<br></code></pre></td></tr></table></figure><p>全部能够得到响应</p><p>再切到第二个客户端，并发送数据，结果发现阻塞了，服务端日志没有任何变化</p><h1 id="正确的代码"><a href="#正确的代码" class="headerlink" title="正确的代码"></a>正确的代码</h1><p>修改为正确的程序：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by root on 7/17/21.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../pkg/net/net.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 100</span><br><br><span class="hljs-comment">// g++ -o echo_server echo_server.cc ../pkg/net/net.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br>    <span class="hljs-function">Server <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>)</span></span>;<br>    s.<span class="hljs-built_in">Listen</span>(<span class="hljs-number">1024</span>);<br><br>    fd_set readfds;<br>    <span class="hljs-built_in">FD_ZERO</span>(&amp;readfds);<br>    <span class="hljs-comment">// 监听服务端socket，当有客户连接时会触发事件</span><br>    <span class="hljs-built_in">FD_SET</span>(s.<span class="hljs-built_in">Sockfd</span>(), &amp;readfds);<br><br>    <span class="hljs-type">int</span> maxfd = s.<span class="hljs-built_in">Sockfd</span>();<br><br>    <span class="hljs-keyword">for</span> (; ;) &#123;<br>        <span class="hljs-comment">// 这句话非常重要，否则会出现多条连接只有一条能正常工作，其他全部阻塞的 bug</span><br>        <span class="hljs-comment">// readfds 保存的是要监听的 fd 集合，但是每次调用 select 后，会将这些监</span><br>        <span class="hljs-comment">// 听 fd 中已经准备好的置 1，未准备好的置 0，如果使用这个已被更改的 fdset，</span><br>        <span class="hljs-comment">// 可能会导致一些异常情况发生，所以这里将 fdset 拷贝一份，调用 select 时传</span><br>        <span class="hljs-comment">// 入拷贝值，这样 select 的更改就不会影响到原 fdset</span><br>        fd_set cpyset = readfds;<br><br>        <span class="hljs-comment">// okcnt：准备就绪的 fd 数量</span><br>        <span class="hljs-type">int</span> okcnt = <span class="hljs-built_in">select</span>(maxfd+<span class="hljs-number">1</span>, &amp;cpyset, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">if</span> (okcnt == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;select error\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (okcnt == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历 select 数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; maxfd+<span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-comment">// 找到所有值为 1 的 fd，这表示该 fd 已经准备就绪了</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FD_ISSET</span>(i, &amp;cpyset)) &#123;<br>                <span class="hljs-comment">// 如果就绪的 fd 为 server,说明有新的连接请求</span><br>                <span class="hljs-keyword">if</span> (i == s.<span class="hljs-built_in">Sockfd</span>()) &#123;<br>                    <span class="hljs-comment">// 调用 accept 接收客户端的连接请求</span><br>                    <span class="hljs-keyword">auto</span> conn = s.<span class="hljs-built_in">Accept</span>();<br>                    <span class="hljs-type">int</span> connfd = conn-&gt;<span class="hljs-built_in">Connfd</span>();<br>                    <span class="hljs-comment">// 更新 maxfd</span><br>                    <span class="hljs-keyword">if</span> (connfd &gt; maxfd) &#123;<br>                        maxfd = connfd;<br>                    &#125;<br>                    <span class="hljs-comment">// 将 conn 的 fd 添加到 select 监听集合中</span><br>                    <span class="hljs-built_in">FD_SET</span>(connfd, &amp;readfds);<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connected client: %d\n&quot;</span>, conn-&gt;<span class="hljs-built_in">Connfd</span>());<br>                <span class="hljs-comment">// 如果就绪的 fd 不是 server fd，则是 conn fd</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;conn %d is already\n&quot;</span>, i);<br>                    <span class="hljs-comment">// 可以对这些准备就绪的 conn 进行 echo 处理了</span><br>                    <span class="hljs-type">int</span> n = <span class="hljs-built_in">read</span>(i, buf, BUF_SIZE);<br>                    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// EOF</span><br>                        <span class="hljs-comment">//</span><br>                        <span class="hljs-built_in">FD_CLR</span>(i, &amp;readfds);<br>                        <span class="hljs-built_in">close</span>(i);<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;close conn: %d\n&quot;</span>, i);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-built_in">write</span>(i, buf, n);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    s.<span class="hljs-built_in">Close</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>这段代码只更改了几个地方：</p><p>29 行的 <code>fd_set cpyset = readfds</code></p><p>32 行的 <code>select(maxfd+1, &amp;cpyset, nullptr, nullptr, nullptr)</code>，将第二个参数由 <code>readfds</code> 更改为 <code>cpyset</code></p><p>44 行的 <code>if (FD_ISSET(i, &amp;cpyset))</code>，之前为 <code>if (FD_ISSET(i, &amp;readfds))</code></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>简单说明下程序的流程：</p><p>先将服务端 socket 加入到 select 的监听集合，之后调用 select <code>int okcnt = select(maxfd+1, &amp;readfds, nullptr, nullptr, nullptr);</code> 这里会阻塞，直到有 fd 准备好。</p><p>当服务端 socket 准备好了以后，select 返回 1（因为只监听了一个 fd），继续向下执行 <code>for (int i = 0; i &lt; maxfd+1; ++i)</code>，继续执行 <code>if (FD_ISSET(i, &amp;readfds))</code>，这样会遍历 fdset 并找到准备就绪的 fd，此时只有服务端的 fd 准备好了，所以必然进入下面的语句<code>if (i == s.Sockfd())</code>，之后 <code>FD_SET(connfd, &amp;readfds)</code>并且更新 maxfd。</p><p><strong>问题来了</strong>，<code>FD_SET(connfd, &amp;readfds)</code>是希望将 connfd 添加到监听集合中，但是程序会错误的继续执行 <code>for (int i = 0; i &lt; maxfd+1; ++i)</code>，并找到 connfd，因为刚刚的 FD_SET 操作把其置于 1，导致程序错误的认为该 fd 已经准备就绪，又因为不满足 <code>if (i == s.Sockfd())</code>，所以进入 else 分支，进入 <code>read(i, buf, BUF_SIZE)</code> 操作，但是因为该 fd 根本没有准备好，所以整个程序会进入阻塞。</p><p>造成该问题的根本原因是 select 的机制问题：传入要监听的 fd 到 fdset 中，当其返回时，会将监听中已就绪的置1，未就绪的置 0，fdset 即充当了记录被监听 fd 的角色，又充当了记录已就绪 fd 的角色，这样会导致混乱的结果，在错误的程序中就是这样，<code>readfds</code> 充当了两个角色，导致了程序的不正确。</p><p>解决方法就是额外创建一个 fdset，一个用来记录要监听的 fd，一个记录已就绪 fd，在正确的代码中， <code>readfds</code>就是用来<strong>记录要监听的 fd</strong>，<code>cpyset</code> 是用来记录<strong>已就绪 fd</strong>。</p><p>每次 for 循环，<code>cpyset</code> 都会拷贝 <code>readfds</code>获得要监听的所有 fd，并传入 select，得到已就绪的 fd，之后的 FD_ISSET 也是基于cpyset，当要新记录 fd 时，执行语句<code>FD_SET(connfd, &amp;readfds)</code>，将 fd 添加到 readfds 中，删除 fd 时也是 <code>FD_CLR(i, &amp;readfds)</code>，这样二者各司其职，就可以保证程序的正常工作了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>多路复用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 516. 最长回文子序列</title>
    <link href="/2021/07/01/leetcode-516-zui-chang-hui-wen-zi-xu-lie/"/>
    <url>/2021/07/01/leetcode-516-zui-chang-hui-wen-zi-xu-lie/</url>
    
    <content type="html"><![CDATA[<p>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度</p><span id="more"></span><blockquote><p>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为<br>1000 。</p><p>示例 1:<br>输入:<br>“bbbab”</p><p>输出:<br>4</p><p>一个可能的最长回文子序列为 “bbbb”。</p><p>示例 2:<br>输入:<br>“cbbd”</p><p>输出:<br>2<br>一个可能的最长回文子序列为 “bb”。</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 只包含小写英文字母</p></blockquote><h1 id="方法1-动态规划"><a href="#方法1-动态规划" class="headerlink" title="方法1 动态规划"></a>方法1 动态规划</h1><p>这道题和 <code>LeetCode 5 最长回文子串</code> 类似，（<a href="https://zengh1.github.io/post/leetcode-5-zui-chang-hui-wen-zi-chuan/">https://zengh1.github.io/post/leetcode-5-zui-chang-hui-wen-zi-chuan/</a> ）</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1625109230825.png"></p><p>代码如下：<br><code>cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len, <span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> maxlen = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; len; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i == j) &#123;<br>                    dp[i][j] = <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                    dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>                <br>                maxlen = <span class="hljs-built_in">max</span>(maxlen, dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxlen;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 5. 最长回文子串</title>
    <link href="/2021/06/29/leetcode-5-zui-chang-hui-wen-zi-chuan/"/>
    <url>/2021/06/29/leetcode-5-zui-chang-hui-wen-zi-chuan/</url>
    
    <content type="html"><![CDATA[<p>给你一个字符串 s，找到 s 中最长的回文子串。</p><span id="more"></span><blockquote><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>示例 1：</p><p>输入：s &#x3D; “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p><p>示例 2：</p><p>输入：s &#x3D; “cbbd”<br>输出：”bb”</p><p>示例 3：</p><p>输入：s &#x3D; “a”<br>输出：”a”</p><p>示例 4：</p><p>输入：s &#x3D; “ac”<br>输出：”a”</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 仅由数字和英文字母（大写和&#x2F;或小写）组成</p></blockquote><h1 id="方法1-动态规划"><a href="#方法1-动态规划" class="headerlink" title="方法1  动态规划"></a>方法1  动态规划</h1><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1624979080690.png"></p><p>代码如下：</p><p><code>cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(s.<span class="hljs-built_in">size</span>()));<br>        string res;<br>        <span class="hljs-type">int</span> maxlen = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>(); i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (i == j) &#123;   <br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] != s[j]) &#123;<br>                    dp[i][j] = <span class="hljs-literal">false</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == j<span class="hljs-number">-1</span>) &#123;<br>                    dp[i][j] = s[i] == s[j];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                    dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>];<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span> (dp[i][j]) &#123;<br>                    <span class="hljs-keyword">if</span> (j-i &gt;= maxlen) &#123;<br>                        maxlen = j - i;<br>                        res = s.<span class="hljs-built_in">substr</span>(i, j-i+<span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 43. 字符串相乘</title>
    <link href="/2021/06/23/leetcode-43-zi-fu-chuan-xiang-cheng/"/>
    <url>/2021/06/23/leetcode-43-zi-fu-chuan-xiang-cheng/</url>
    
    <content type="html"><![CDATA[<p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><span id="more"></span><blockquote><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p>示例 1:</p><p>输入: num1 &#x3D; “2”, num2 &#x3D; “3”<br>输出: “6”</p><p>示例 2:</p><p>输入: num1 &#x3D; “123”, num2 &#x3D; “456”<br>输出: “56088”</p><p>说明：</p><p>num1 和 num2 的长度小于110。<br>num1 和 num2 只包含数字 0-9。<br>num1 和 num2 均不以零开头，除非是数字 0 本身。<br>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</p></blockquote><h1 id="方法1-模拟数学"><a href="#方法1-模拟数学" class="headerlink" title="方法1 模拟数学"></a>方法1 模拟数学</h1><p>在草稿纸上写一下乘法的运算步骤，并将其改写为代码形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//  45</span><br><span class="hljs-comment">//*  123</span><br><span class="hljs-comment">// --------------</span><br><span class="hljs-comment">//     135</span><br><span class="hljs-comment">//  +  90        </span><br><span class="hljs-comment">//    45</span><br><span class="hljs-comment">// ---------------</span><br><span class="hljs-comment">//    5535</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiply</span><span class="hljs-params">(num1 <span class="hljs-type">string</span>, num2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">var</span> (<br>flag <span class="hljs-type">int</span>             <span class="hljs-comment">// 保存进位</span><br>res  <span class="hljs-type">string</span> <br>pown <span class="hljs-type">int</span>             <span class="hljs-comment">// 确定要补几个 0</span><br>)<br>    <br>    <span class="hljs-keyword">if</span> num1 == <span class="hljs-string">&quot;0&quot;</span> || num2 == <span class="hljs-string">&quot;0&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span><br>    &#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(num1) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br><span class="hljs-keyword">var</span> r strings.Builder<br>        <br><span class="hljs-keyword">for</span> j := <span class="hljs-built_in">len</span>(num2) - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br>v1 := <span class="hljs-type">int</span>(num1[i] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>v2 := <span class="hljs-type">int</span>(num2[j] - <span class="hljs-string">&#x27;0&#x27;</span>)<br><br>tmp := v1*v2 + flag<br>flag = tmp / <span class="hljs-number">10</span><br>tmp %= <span class="hljs-number">10</span><br><br>r.WriteByte(<span class="hljs-type">byte</span>(tmp + <span class="hljs-string">&#x27;0&#x27;</span>))<br>&#125;<br><br><span class="hljs-keyword">if</span> flag != <span class="hljs-number">0</span> &#123;<br>r.WriteByte(<span class="hljs-type">byte</span>(flag) + <span class="hljs-string">&#x27;0&#x27;</span>)<br>flag = <span class="hljs-number">0</span><br>&#125;<br><br>rstr := reverseStr(r.String())<br><br><span class="hljs-comment">//  45</span><br><span class="hljs-comment">//*  123</span><br><span class="hljs-comment">// --------------每步后面补 n-1 个 0，n 为 位数</span><br><span class="hljs-comment">//     135135 补 0 个</span><br><span class="hljs-comment">//     90         =&gt;  900 补 1 个</span><br><span class="hljs-comment">//    45    4500  补 2 个</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; pown; i++ &#123;<br>rstr += <span class="hljs-string">&quot;0&quot;</span><br>&#125;<br>pown++<br><br>    <span class="hljs-comment">// 字符串相加</span><br>res = strAdd(res, rstr)<br>&#125;<br>    <br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseStr</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>b := []<span class="hljs-type">byte</span>(s)<br><span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>; i &lt; j; i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> &#123;<br>b[i], b[j] = b[j], b[i]<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(b)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strAdd</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> (<br>flag <span class="hljs-type">int</span><br>res strings.Builder<br>)<br><span class="hljs-keyword">for</span> i, j := <span class="hljs-built_in">len</span>(s1)<span class="hljs-number">-1</span>, <span class="hljs-built_in">len</span>(s2)<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>; i, j = i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">var</span> v1, v2 <span class="hljs-type">int</span><br><span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> &#123;<br>v1 = <span class="hljs-type">int</span>(s1[i] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>v1 = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-keyword">if</span> j &gt;= <span class="hljs-number">0</span> &#123;<br>v2 = <span class="hljs-type">int</span>(s2[j] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>v2 = <span class="hljs-number">0</span><br>&#125;<br><br>sum := v1 + v2 + flag<br>flag = sum / <span class="hljs-number">10</span><br>sum %= <span class="hljs-number">10</span><br><br>res.WriteByte(<span class="hljs-type">byte</span>(sum) + <span class="hljs-string">&#x27;0&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> flag != <span class="hljs-number">0</span> &#123;<br>res.WriteByte(<span class="hljs-type">byte</span>(flag) + <span class="hljs-string">&#x27;0&#x27;</span>)<br>&#125;<br><br>str := reverseStr(res.String())<br><span class="hljs-keyword">return</span> str<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="方法2-优化"><a href="#方法2-优化" class="headerlink" title="方法2 优化"></a>方法2 优化</h1><p>方法一的做法是从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加，整个过程中涉及到较多字符串相加的操作。如果使用数组代替字符串存储结果，则可以减少对字符串的操作。具体的方法如下：</p><p><img src="https://zengh1.github.io/post-images/1624428548462.png"></p><p>代码如下：</p><p><code>go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiply</span><span class="hljs-params">(num1 <span class="hljs-type">string</span>, num2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> num1 == <span class="hljs-string">&quot;0&quot;</span> || num2 == <span class="hljs-string">&quot;0&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span><br>    &#125;<br>    <br>    n1l := <span class="hljs-built_in">len</span>(num1)<br>    n2l := <span class="hljs-built_in">len</span>(num2)<br>    <br>    n := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n1l+n2l, n1l+n2l)<br>    <br>    <span class="hljs-keyword">for</span> i := n1l - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        v1 := num1[i] - <span class="hljs-string">&#x27;0&#x27;</span><br>        <span class="hljs-keyword">for</span> j := n2l - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br>            v2 := num2[j] - <span class="hljs-string">&#x27;0&#x27;</span><br>            n[i+j+<span class="hljs-number">1</span>] += <span class="hljs-type">int</span>(v1) * <span class="hljs-type">int</span>(v2)<br>            <br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">var</span> (<br>        flag  <span class="hljs-type">int</span><br>        res   strings.Builder<br>        start <span class="hljs-type">int</span><br>    )    <br>        <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(n) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        n[i] += flag<br>        flag = n[i] / <span class="hljs-number">10</span><br>        n[i] %= <span class="hljs-number">10</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//fmt.Println(n)</span><br>    <br>    <span class="hljs-keyword">if</span> n[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &#123;<br>        start = <span class="hljs-number">1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> ; start &lt; <span class="hljs-built_in">len</span>(n); start++ &#123;<br>        s := strconv.Itoa(n[start])<br>        res.WriteString(s)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res.String()<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><code>cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">multiply</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (num1 == <span class="hljs-string">&quot;0&quot;</span> || num2 == <span class="hljs-string">&quot;0&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> n1l = num1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n2l = num2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n1l + n2l)</span></span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n1l - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n2l - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                v[i+j+<span class="hljs-number">1</span>] += (num1[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * (num2[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>        string res;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = v.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            v[i] += flag;<br>            flag = v[i] / <span class="hljs-number">10</span>;<br>            v[i] %= <span class="hljs-number">10</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// for (auto vv : v) &#123;</span><br>        <span class="hljs-comment">//     cout &lt;&lt; vv &lt;&lt; endl;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-keyword">if</span> (v[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>            start = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <br>        <span class="hljs-keyword">for</span> (; start &lt; v.<span class="hljs-built_in">size</span>(); start++) &#123;<br>            res += <span class="hljs-built_in">char</span>(v[start]+<span class="hljs-string">&#x27;0&#x27;</span>);    <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 460. LFU 缓存</title>
    <link href="/2021/06/16/leetcode-460-lfu-huan-cun/"/>
    <url>/2021/06/16/leetcode-460-lfu-huan-cun/</url>
    
    <content type="html"><![CDATA[<p>最不经常使用（LFU）缓存算法</p><span id="more"></span><blockquote><p>请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。</p><p>实现 LFUCache 类：</p><p>LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象<br>int get(int key) - 如果键存在于缓存中，则获取键的值，否则返回 -1。<br>void put(int key, int value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。<br>注意「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。</p><p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。</p><p>当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。</p><p> </p><p>示例：</p><p>输入：<br>[“LFUCache”, “put”, “put”, “get”, “put”, “get”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]<br>输出：<br>[null, null, null, 1, null, -1, 3, null, -1, 3, 4]</p><p>解释：<br>&#x2F;&#x2F; cnt(x) &#x3D; 键 x 的使用计数<br>&#x2F;&#x2F; cache&#x3D;[] 将显示最后一次使用的顺序（最左边的元素是最近的）<br>LFUCache lFUCache &#x3D; new LFUCache(2);<br>lFUCache.put(1, 1);   &#x2F;&#x2F; cache&#x3D;[1,_], cnt(1)&#x3D;1<br>lFUCache.put(2, 2);   &#x2F;&#x2F; cache&#x3D;[2,1], cnt(2)&#x3D;1, cnt(1)&#x3D;1<br>lFUCache.get(1);       &#x2F;&#x2F; 返回 1<br>                                  &#x2F;&#x2F; cache&#x3D;[1,2], cnt(2)&#x3D;1, cnt(1)&#x3D;2<br>lFUCache.put(3, 3);   &#x2F;&#x2F; 去除键 2 ，因为 cnt(2)&#x3D;1 ，使用计数最小<br>                                  &#x2F;&#x2F; cache&#x3D;[3,1], cnt(3)&#x3D;1, cnt(1)&#x3D;2<br>lFUCache.get(2);       &#x2F;&#x2F; 返回 -1（未找到）<br>lFUCache.get(3);       &#x2F;&#x2F; 返回 3<br>                                  &#x2F;&#x2F; cache&#x3D;[3,1], cnt(3)&#x3D;2, cnt(1)&#x3D;2<br>lFUCache.put(4, 4);   &#x2F;&#x2F; 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用<br>                                  &#x2F;&#x2F; cache&#x3D;[4,3], cnt(4)&#x3D;1, cnt(3)&#x3D;2<br>lFUCache.get(1);      &#x2F;&#x2F; 返回 -1（未找到）<br>lFUCache.get(3);      &#x2F;&#x2F; 返回 3<br>                                 &#x2F;&#x2F; cache&#x3D;[3,4], cnt(4)&#x3D;1, cnt(3)&#x3D;3<br>lFUCache.get(4);      &#x2F;&#x2F; 返回 4<br>                                &#x2F;&#x2F; cache&#x3D;[3,4], cnt(4)&#x3D;2, cnt(3)&#x3D;3</p><p>提示：</p><p>0 &lt;&#x3D; capacity, key, value &lt;&#x3D; 104<br>最多调用 105 次 get 和 put 方法</p><p>进阶：你可以为这两种操作设计时间复杂度为 O(1) 的实现吗？</p></blockquote><h2 id="方法1双哈希表-链表"><a href="#方法1双哈希表-链表" class="headerlink" title="方法1双哈希表+链表"></a>方法1双哈希表+链表</h2><p>哈希表1：</p><p>key 记录使用次数</p><p>value 为一条链表</p><p>因为可能有多个键使用次数相同，所以用链表将这些相同频次的键连接起来，此外，该链表也可以记录这些键的使用时间，链表头为最近使用过的，链表尾为<strong>最近最久未使用</strong>的。当需要淘汰键时，移除链表尾即可，当需要插入时，添加到链表头。</p><p>哈希表2：</p><p>key 与键相同，做快速映射</p><p>value  为链表中的一个节点</p><p>此外，还需要一个 min 值来保存全局最少使用次数，当需要淘汰时便。</p><h3 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h3><p>由题可知，当执行 get 和 put 操作时，都会使得键的使用次数增加，而使用次数增加后，就需要从当前链表移动到其他链表中，操作思路为：先获取到当前键的使用次数，通过 <strong>哈希表1</strong> 定位到所在链表，并从中移除，再通过<strong>哈希表1</strong> 获取 使用次数+1 处的链表，并将键添加到链表头，（这两步都需要注意映射的链表是否为 null，否则会导致空指针错误），此外还需要更新该 key 的使用次数。</p><p>get 首先从 <strong>哈希表2</strong> 中查找，如果找到了，则执行上面的移动操作，并返回值，未找到则返回 -1。</p><p>put 首先需要查找是否存在，如果存在则只更新 value，同时执行移动操作，返回。如果不存在，则需要先判断是否需要淘汰，淘汰可以通过全局最少使用次数 min 从 <strong>哈希表1</strong> 中定位到链表，并移除该链表的尾元素，同时也要从 <strong>哈希表2</strong> 中移除。如果不需要淘汰，则直接添加到两个哈希表即可，因为是新值，所以使用次数为 1，要将 min 置为 1。</p><p>这里还有一个问题，如何更新 min 的值呢？当需要移动时，检查一下移动后，该链表长度是否为 0，如果为空则更新 min。例如：</p><p>哈希表1 情况如下：</p><p>1 -&gt; [3, 3]<br>2 -&gt; [1, 1]<br>此时 min &#x3D; 1</p><p>当执行 get 3 操作时：<br>2 -&gt; [3, 3] -&gt; [1, 1]<br>此时应该更新 min &#x3D; 2</p><p>当 [3, 3] 从 1 移动到 2 后，1 对应的链表长度为 0，且 [3, 3] 的使用次数 &#x3D; min &#x3D; 1，所以需要将 min 更新为 2。</p><p><img src="https://zengh1.github.io/post-images/1623900640431.png"></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> lfu<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/list&quot;</span><br><br><span class="hljs-keyword">type</span> LFUCache <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 记录出现次数，key 为次数，value 为链表，</span><br><span class="hljs-comment">// 因为同一个次数可能有多个值，按照规定，次数相同时按使用时间来比较，</span><br><span class="hljs-comment">// 所以用链表来记录顺序，新节点插入到链表头，当需要淘汰时，淘汰链表尾</span><br>cm <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*list.List<br><br><span class="hljs-comment">// 以键值 key 为索引，每个索引存放对应缓存在 cm 中链表里的内存地址</span><br>m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*list.Element<br><br><span class="hljs-comment">// 最大容量</span><br><span class="hljs-built_in">cap</span> <span class="hljs-type">int</span><br><br><span class="hljs-comment">// 全局最少使用次数，当需要执行淘汰操作时，通过该变量可以在 O(1) 内定位到 cm 的对应链表</span><br>min <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// node 链表中存储的值</span><br><span class="hljs-keyword">type</span> node <span class="hljs-keyword">struct</span> &#123;<br>key <span class="hljs-type">int</span><br>val <span class="hljs-type">int</span><br>cnt <span class="hljs-type">int</span> <span class="hljs-comment">// 使用次数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> LFUCache &#123;<br><span class="hljs-keyword">return</span> LFUCache&#123;<br>cm:  <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*list.List),<br>m:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*list.Element),<br><span class="hljs-built_in">cap</span>: capacity,<br>min: <span class="hljs-number">0</span>,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *LFUCache)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> c.<span class="hljs-built_in">cap</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-keyword">if</span> e, ok := c.m[key]; ok &#123;<br>n := e.Value.(*node)<br><br><span class="hljs-comment">// 将 n 从旧的链表中移除，因为 get() 后其使用次数增加了</span><br><span class="hljs-keyword">if</span> c.cm[n.cnt] != <span class="hljs-literal">nil</span> &#123;<br>c.cm[n.cnt].Remove(e)<br>&#125;<br><br><span class="hljs-comment">// 如果移除后旧链表为空，则更新全局最小使用次数 min</span><br><span class="hljs-keyword">if</span> c.cm[n.cnt] == <span class="hljs-literal">nil</span> || c.cm[n.cnt].Len() == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// 链表为空了，cm 保存也就没意义了，可以从 cm 中删除</span><br><span class="hljs-built_in">delete</span>(c.cm, n.cnt)<br><span class="hljs-keyword">if</span> c.min == n.cnt &#123;<br>c.min++<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 更新 n 的使用次数</span><br>n.cnt++<br><br><span class="hljs-comment">// 获取新的链表，并将 n 添加到头部</span><br><span class="hljs-keyword">if</span> c.cm[n.cnt] == <span class="hljs-literal">nil</span> &#123;<br>c.cm[n.cnt] = list.New()<br>&#125;<br>ele := c.cm[n.cnt].PushFront(n)<br><span class="hljs-comment">// 更新 m 中的信息</span><br>c.m[key] = ele<br><br><span class="hljs-keyword">return</span> e.Value.(*node).val<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *LFUCache)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">// 需要先判断是否存在，再判断容量是否溢出，例如</span><br><span class="hljs-comment">// LFU 容量为 2，现有如下数据：</span><br><span class="hljs-comment">// 1 -&gt; [1,5] -&gt; [2,6]     // 使用 1 次对应的链表</span><br><span class="hljs-comment">// 此时 push [1,2]，如果先判断容量溢出，则会触发移除操作，</span><br><span class="hljs-comment">// 将 [2,6] 移除，导致结果为 1 -&gt; [1,2] -&gt; [1,5]，</span><br><span class="hljs-comment">// 正确结果应该为：</span><br><span class="hljs-comment">// 1 -&gt; [2,6]</span><br><span class="hljs-comment">// 2 -&gt; [1,2]</span><br><br><span class="hljs-comment">// 如果该 key 已经存在</span><br><span class="hljs-keyword">if</span> no, ok := c.m[key]; ok &#123;<br>n := no.Value.(*node)<br><br><span class="hljs-keyword">if</span> c.cm[n.cnt] != <span class="hljs-literal">nil</span> &#123;<br>c.cm[n.cnt].Remove(no)<br>&#125;<br><br><span class="hljs-keyword">if</span> c.cm[n.cnt] == <span class="hljs-literal">nil</span> || c.cm[n.cnt].Len() == <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">delete</span>(c.cm, n.cnt)<br><span class="hljs-keyword">if</span> c.min == n.cnt &#123;<br>c.min++<br>&#125;<br>&#125;<br><br>n.cnt++       <span class="hljs-comment">// 使用次数 +1</span><br>n.val = value <span class="hljs-comment">// 更新 val</span><br><br><span class="hljs-keyword">if</span> c.cm[n.cnt] == <span class="hljs-literal">nil</span> &#123;<br>c.cm[n.cnt] = list.New()<br>&#125;<br>ele := c.cm[n.cnt].PushFront(n)<br>c.m[key] = ele<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 如果添加该节点后容量溢出，则需要淘汰使用次数最少的节点</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c.m) == c.<span class="hljs-built_in">cap</span> &#123;<br><span class="hljs-comment">// 根据 min 字段，取出最小使用次数对应的链表</span><br>l := c.cm[c.min]<br><span class="hljs-keyword">if</span> l != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">//fmt.Println(l.Back())</span><br><span class="hljs-comment">// 该链表的最后一个即为最长时间未使用的节点，将其移除</span><br>rm := l.Remove(l.Back())<br><span class="hljs-comment">// 同时也从 m 中移除</span><br><span class="hljs-built_in">delete</span>(c.m, rm.(*node).key)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// key 不存在</span><br>n := &amp;node&#123;<br>key: key,<br>val: value,<br>cnt: <span class="hljs-number">1</span>,<br>&#125;<br><br><span class="hljs-keyword">if</span> _, ok := c.cm[<span class="hljs-number">1</span>]; !ok &#123;<br>c.cm[<span class="hljs-number">1</span>] = list.New()<br>&#125;<br><br>l := c.cm[<span class="hljs-number">1</span>]<br><span class="hljs-comment">// 添加到计数链表中</span><br>node := l.PushFront(n)<br><span class="hljs-comment">// 添加到 m 中</span><br>c.m[key] = node<br><span class="hljs-comment">// 更新全局最小使用次数 min 为 1</span><br>c.min = <span class="hljs-number">1</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LFU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>25匹马的角逐</title>
    <link href="/2021/06/15/25-pi-ma-de-jiao-zhu/"/>
    <url>/2021/06/15/25-pi-ma-de-jiao-zhu/</url>
    
    <content type="html"><![CDATA[<blockquote><p>25 匹马，5条跑道，每个跑道最多能有 1 匹马进行比赛，（就是说最多同时可以有 5 匹马一起比赛），<br>不能使用计时器，且每匹马的速度都很稳定（意思是在上一场比赛中 A 马比 B 马快，则下一场比赛中A马<br>依然比 B 马快），问最少比多少次能比出前3名和前5名？</p></blockquote><h1 id="前-3-名"><a href="#前-3-名" class="headerlink" title="前 3 名"></a>前 3 名</h1><p>首先将 25 匹马分成 5 组，每组 5 匹马。</p><p><strong>1 - 5 次</strong><br>每组分别进行比赛，选出每组的第一名，假设总体比赛情况为：</p><pre><code class="hljs">    A组：  [A1  A2  A3   A4  A5]    B组：  [B1  B2  B3   B4  B5]    C组：  [C1  C2  C3  C4  C5]    D组：  [D1  D2  D3  D4  D5]    E组：  [E1  E2  E3   E4  E5]</code></pre><p>每组第一名为 [A1, B1, C1, D1, E1]</p><p><strong>第 6 次</strong><br>再对这 5 个第一名进行比赛，这里面的第一名便是所有马中最快的，这里假设结果为 [A1, B1, C1, D1, E1]，第一名为 A1。</p><p>此时第一名已经确定了，还剩下二三名需要确定。</p><p><strong>第 7 次</strong><br>第二名可能是紧随 A1 其后的 A2，同时也可能是 B 组的第一名 B1，因为不能使用计时器，所以无法确定到底是哪个，解决办法就是让 A2 和 B1 进行一次比赛，决出第二名，但是跑道一共有 5 条，现在却只有两匹马参赛，空出来的 3 条跑道岂不是白白浪费了，这里可以利用起来，决出第三名。</p><p>可能出现的情况：</p><ol><li>第二名为 A2<br>那么第三名将从 A2 之后的 A3，以及 B 组的第一 B1 二者中确定。</li><li>第二名为 B1<br>第三名将从 A2，B2，以及 C 组的头榜 C1 中确定。</li></ol><p>第二三名的全部情况：<br>[A2, A3]<br>[A2, B1]<br>[B1, B2]<br>[B1, A2]<br>[B1, C1]</p><p>所以用上面的 5 匹马 [A2, A3, B1, B2, C1] 进行一次比赛即可确定第2，3名，其中的第1，2名则为全部马匹中的第2，3名。</p><p>综上，最少需要 7 次即可确定马匹中的前 3 名。</p><h1 id="前-5-名"><a href="#前-5-名" class="headerlink" title="前 5 名"></a>前 5 名</h1><p><strong>1-7 次</strong><br>和 <strong>前 3 名</strong> 一样，通过这 7 次可以确定出所有马匹中的 1，2，3名。全部情况为：<br>[A1, A2, A3]<br>[A1, A2, B1]<br>[A1, B1, B2]<br>[A1, B1, A2]<br>[A1, B1, C1]</p><p><strong>第 8 次</strong><br>第 8 次需要根据第7场的所有可能的比赛情况进行分析。</p><ol><li><p>第二名 &#x3D; A2，第三名 &#x3D; A3，那么第四名为 A4 或者 B1。</p><ol><li>如果第四名为 A4，那么第五名为 A5 或者 B1。</li><li>如果第四名为 B1，那么第五名为 A4、B2 或者 C1。</li></ol><p>所以用 [A4, B1, A5, B2, C1] 即可确定出第 4，5名，一共需要 8 次。</p></li><li><p>第二名 &#x3D; A2，第三名 &#x3D; B1，那么第四名为 A3 或者 B2 或者 C1。</p><ol><li>如果第四名为 A3，那么第五名为 A4 或者 B2。</li><li>如果第四名为 B2，那么第五名为 B3 或者 A3。  </li><li>如果第四名为 C1，那么第五名从 A3, B2, C2, D1 中产生。</li></ol><p>综上，用 [A3, B2, B3, C1, A4, C2, D1] 七匹马才可以确定4， 5名，而一次比赛最多只能有 5      匹马，所以需要比赛 2 次，一共需要 9 次。</p></li><li><p>第二名 &#x3D; B1，第三名 &#x3D; B2，那么第四名为 B3、A2 或者 C1。</p><ol><li>如果第四名为 B3，那么第五名为 B4、A2、C1。</li><li>如果第四名为 A2，那么第五名为 A3、B3，C1。</li><li>如果第四名为 C1，那么第五名为 A2、B3、C2、D1。</li></ol><p>综上，用 [A2, B3, B4, C1, A3, C2, D1] 七匹马才可以确定4， 5名，而一次比赛最多只能有 5      匹马，所以需要比赛 2 次，一共需要 9 次。</p></li><li><p>第2名&#x3D;B1，第3名&#x3D;A2，和情况 2 一样。</p></li><li><p>第2名&#x3D;B1，第3名&#x3D;C1。那么此种情况下第4名只能在A2、B2、C2、D1中产生。</p><ol><li><p>如果第4名&#x3D;A2，那么第5名只能在A3、B2、C2、D1中产生。</p></li><li><p>如果第4名&#x3D;B2，那么第5名只能在A2、B3、C2、D1中产生。</p></li><li><p>如果第4名&#x3D;C2，那么第5名只能在A2、B2、C3、D1中产生。</p></li><li><p>如果第4名&#x3D;D1，那么第5名只能在A2、B2、C2、D2、E2中产生。</p><p>那么，第4、5名需要在马匹[A2、B2、C2、D1、A3、B3、C3、D2、E1]九匹马中产生，因此也必须比赛两场，也就是到第 9 场决出胜负。</p></li></ol></li></ol><p>综上，确定前 5 名最少需要 8 或 9 次。</p><p>参考：<a href="https://www.iteye.com/blog/hxraid-662643%EF%BC%8C%E8%BF%99%E7%AF%87%E5%8D%9A%E6%96%87%E8%AE%B2%E8%A7%A3%E7%9A%84%E9%9D%9E%E5%B8%B8%E6%A3%92%EF%BC%8C%E6%88%91%E8%BF%99%E9%87%8C%E5%8F%AA%E6%98%AF%E5%B0%86%E5%85%B6%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E8%AF%9D%E5%86%8D%E5%8F%99%E8%BF%B0%E4%BA%86%E4%B8%80%E9%81%8D%EF%BC%8C%E4%BB%A5%E5%8A%A0%E6%B7%B1%E7%90%86%E8%A7%A3%E3%80%82">https://www.iteye.com/blog/hxraid-662643，这篇博文讲解的非常棒，我这里只是将其用自己的话再叙述了一遍，以加深理解。</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>智力题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【两万字长文带你深入Go语言GC源码——腾讯技术工程】阅读笔记</title>
    <link href="/2021/06/04/liang-wan-zi-chang-wen-dai-ni-shen-ru-go-yu-yan-gc-yuan-ma-teng-xun-ji-zhu-gong-cheng-yue-du-bi-ji/"/>
    <url>/2021/06/04/liang-wan-zi-chang-wen-dai-ni-shen-ru-go-yu-yan-gc-yuan-ma-teng-xun-ji-zhu-gong-cheng-yue-du-bi-ji/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：luozhiyun<br>博客：<a href="https://www.luozhiyun.com/archives/475">https://www.luozhiyun.com/archives/475</a><br>本文使用的 Go 的源码1.15.7</p></blockquote><p>原文地址：<a href="https://www.luozhiyun.com/archives/475">https://www.luozhiyun.com/archives/475</a></p><h1 id="1-三色标记法"><a href="#1-三色标记法" class="headerlink" title="1. 三色标记法"></a>1. 三色标记法</h1><h2 id="1-1-三种颜色"><a href="#1-1-三种颜色" class="headerlink" title="1.1 三种颜色"></a>1.1 三种颜色</h2><ul><li><p>黑色：该对象已经被标记过了，且该对象下的属性【这里不是很明白，是指该对象引用的对象？？】也全部都被标记过了（程序所需要的对象）</p><blockquote><p>说明：仅是该对象下的属性，其之下的属性的下面的属性不考虑在内。</p><p>例如：A -&gt; B -&gt; C，当 A 已被标记，且 B 也被标记时，A 就会变成黑色，不需考虑 C 是否被标记，C 是否被标记影响的是 B 能否变成黑色，与 A 无关。</p></blockquote></li><li><p>灰色：该对象已经被标记过了，但该对象下的属性没有全被标记完（GC需要从此对象中去寻找垃圾）；</p></li><li><p>白色：该对象没有被标记过（对象垃圾）；</p></li></ul><p>在垃圾收集器开始工作时，从 GC Roots 开始进行遍历访问，访问步骤可以分为下面几步：</p><ol><li>GC Roots 根对象会被标记成灰色；</li><li>然后从灰色集合中获取对象，将其标记为黑色，将该对象引用到的对象标记为灰色；【只会标记一次，不会递归标记，即不会标记引用对象所引用的对象】</li><li>重复步骤2，直到没有灰色集合可以标记为止；</li><li>结束后，剩下的没有被标记的白色对象即为 GC Roots 不可达，可以进行回收。</li></ol><h2 id="1-2-三色标记存在的问题"><a href="#1-2-三色标记存在的问题" class="headerlink" title="1.2 三色标记存在的问题"></a>1.2 三色标记存在的问题</h2><h3 id="多标-浮动垃圾问题"><a href="#多标-浮动垃圾问题" class="headerlink" title="多标-浮动垃圾问题"></a>多标-浮动垃圾问题</h3><p>文章中已经说的比较清楚了，注意的是，因为一个引用对象被错误的标记为灰色，会导致继续遍历扫描，导致该对象所引用的对象都会被错误标记，最终导致的可能不仅仅是一个对象而是一批对象未被正确回收。</p><h3 id="漏标-悬挂指针问题"><a href="#漏标-悬挂指针问题" class="headerlink" title="漏标-悬挂指针问题"></a>漏标-悬挂指针问题</h3><p>文章中也比较清楚的说明了。</p><blockquote><p>疑问：</p><p>上面两个问题产生的原因在于：在垃圾回收中途，程序又改变了对象之间的引用。为什么允许程序和垃圾回收同时执行？</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>gc</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 78. 子集</title>
    <link href="/2021/06/03/leetcode-78-zi-ji/"/>
    <url>/2021/06/03/leetcode-78-zi-ji/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集不能包含重复的子集。你可以按 任意顺序 返回解集。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p><p>示例 2：</p><p>输入：nums &#x3D; [0]<br>输出：[[],[0]]</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10<br>nums 中的所有元素 互不相同</p></blockquote><h2 id="方法1-回溯"><a href="#方法1-回溯" class="headerlink" title="方法1 回溯"></a>方法1 回溯</h2><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1622713584434.png"></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>        <span class="hljs-built_in">backtrack</span>(nums, res, temp, <span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, </span></span><br><span class="hljs-params"><span class="hljs-function">                   vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res, </span></span><br><span class="hljs-params"><span class="hljs-function">                   vector&lt;<span class="hljs-type">int</span>&gt; &amp;temp,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        res.<span class="hljs-built_in">emplace_back</span>(temp);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            temp.<span class="hljs-built_in">emplace_back</span>(nums[i]);<br>            <span class="hljs-comment">// i+1      ok</span><br>            <span class="hljs-comment">// start+1  !ok</span><br>            <span class="hljs-built_in">backtrack</span>(nums, res, temp, i+<span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Linux 高性能服务器编程】阅读笔记 第五章 -- Linux 网络编程基础 api</title>
    <link href="/2021/05/29/linux-gao-xing-neng-fu-wu-qi-bian-cheng-yue-du-bi-ji-di-wu-zhang-linux-wang-luo-bian-cheng-ji-chu-api/"/>
    <url>/2021/05/29/linux-gao-xing-neng-fu-wu-qi-bian-cheng-yue-du-bi-ji-di-wu-zhang-linux-wang-luo-bian-cheng-ji-chu-api/</url>
    
    <content type="html"><![CDATA[<h1 id="1-字节序"><a href="#1-字节序" class="headerlink" title="1. 字节序"></a>1. 字节序</h1><p><strong>字节序</strong>：内存中存储多个字节的方式。</p><p>例如一个 16 进制数，它由两个字节组成，内存中存储这两个字节有两种方式，分别为<strong>大端</strong>字节序和<strong>小端</strong> 字节序。</p><p><strong>大端</strong>：高位字节存放在低地址，低位字节存放在高地址。</p><p><strong>小端</strong>：高位字节存放在高地址，低位字节存放在低地址。</p><p>如何区分字节的高低位和地址的高低位？</p><p>0x12            0x34<br>高位字节     低位字节          ← 字节增长方向<br>低地址         高地址             → 内存增长方向</p><h2 id="1-1-网络字节序和主机字节序"><a href="#1-1-网络字节序和主机字节序" class="headerlink" title="1.1  网络字节序和主机字节序"></a>1.1  网络字节序和主机字节序</h2><p><strong>主机字节序</strong>：某个给定系统所用的字节序称为主机字节序。不同的操作系统采用的字节序不同，比如 macos 采用的是大端，而 linux 采用的是小端。</p><p><strong>网络字节序</strong>：为了在信息传输时，屏蔽掉不同硬件结构上的字节序的差异，TCP&#x2F;IP协议规定，所有在网络上传输的多字节整数都以大端序编码，所以大端序就是<code>网络字节序</code>。</p><p>字节序转换的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><br><span class="hljs-comment">// 主机字节序转网络字节序，两个函数的区别在于长度不同</span><br><span class="hljs-comment">// 较短的函数可以用来转换端口号，较长的可以转换 ip 地址</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> host16bitvalue)</span>;<br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">htonl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> host32bitvalue)</span>;<br><br><span class="hljs-comment">// 网络字节序转主机字节序</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">ntonhs</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> net16bitvalue)</span>;<br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ntonhs</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> net32bitvalue)</span>;<br></code></pre></td></tr></table></figure><h1 id="2-socket-api"><a href="#2-socket-api" class="headerlink" title="2. socket api"></a>2. socket api</h1><h2 id="2-1-创建-socket"><a href="#2-1-创建-socket" class="headerlink" title="2.1 创建 socket"></a>2.1 创建 socket</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> family, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span>;<br><br><span class="hljs-comment">// 返回：若成功则为非负描述符，出错则为 -1</span><br></code></pre></td></tr></table></figure><p>参数描述：</p><ol><li><p><strong>family</strong> 用来选择通信协议，参数主要有以下一些常用类型</p><ul><li><p><strong>AF_UNIX, AF_LOCAL</strong>：用于本地通信，Unix Domain Socket</p></li><li><p><strong>AF_INET</strong>：用于 IP4</p></li><li><p><strong>AF_INET6</strong>：用于 IP6</p></li></ul></li><li><p><strong>type</strong> 指明套接字类型</p><ul><li><p><strong>SOCK_STREAM</strong>      字节流套接字，即 tcp</p></li><li><p><strong>SOCK_DGRAM</strong>           数据包套接字，即 udp</p></li></ul><ul><li><strong>SOCK_NONBLOCK</strong>   将 socket 设置为非阻塞</li><li><strong>SOCK_CLOEXEC</strong>        fork 子进程中关闭该 socket</li></ul></li><li><p><strong>protocol</strong> 在前两个参数构成的协议集合下，再选择一个具体的协议，通常设置为 0 即可（代表默认协议）</p></li></ol><h2 id="2-2-命名-socket"><a href="#2-2-命名-socket" class="headerlink" title="2.2 命名 socket"></a>2.2 命名 socket</h2><p><strong>socket 命名</strong>：将一个 socket 和 socket 地址绑定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> *myaddr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br><br><span class="hljs-comment">// 成功返回 0，出错返回 -1</span><br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">servaddr</span>;</span><br><br>bzero(&amp;servaddr, <span class="hljs-keyword">sizeof</span>(servaddr));<span class="hljs-comment">// 初始化结构体</span><br><br>servaddr.sin_family = AF_INEF; <span class="hljs-comment">// ip4</span><br>servaddr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="hljs-comment">// 指定 ip，并转换为网络序</span><br>servaddr.port = htons(<span class="hljs-number">13</span>);<span class="hljs-comment">// 指定端口号，并转换为网络序</span><br><br><span class="hljs-comment">// 第二个参数需要强转成 struct sockaddr，sockaddr 是一个通用的套接字地址结构</span><br>bind(&amp;servaddr, (<span class="hljs-keyword">struct</span> sockaddr*) &amp;servaddr, <span class="hljs-keyword">sizeof</span>(servaddr));<br></code></pre></td></tr></table></figure><h2 id="2-3-监听-socket"><a href="#2-3-监听-socket" class="headerlink" title="2.3 监听 socket"></a>2.3 监听 socket</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> backlog)</span>;<br><br><span class="hljs-comment">// 成功返回 0，出错返回 -1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</title>
    <link href="/2021/05/09/jian-zhi-offer-68-i-er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian/"/>
    <url>/2021/05/09/jian-zhi-offer-68-i-er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，<br>满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png"></p><p>示例 1:</p><p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。</p><p>示例 2:</p><p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。<br> &gt;</p><p>说明:</p><p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>方法类似于 <strong>二叉树的最近公共祖先</strong>，但是因为是二叉搜索树，所以难度会降低很多，只要利用搜索树的性质即可。</p><h2 id="方法-1-找到-p-和-q-的路径"><a href="#方法-1-找到-p-和-q-的路径" class="headerlink" title="方法 1 找到 p 和 q 的路径"></a>方法 1 找到 p 和 q 的路径</h2><p>分别找出根节点到 p 的路径和根节点到 q 的路径，再求两条路径中的最后一个相同的节点即可，在普通二叉树中寻找路径需要通过全排列的方式，但是在搜索树中就非常简单了，利用好搜索树的性质即可。</p><p>代码如下（这道题不支持 go，所以用 c++ 实现）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> print(name) for (auto v : name) &#123;cout <span class="hljs-string">&lt;&lt; v-&gt;</span>val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;; cout &lt;&lt; endl;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        vector&lt;TreeNode*&gt; pv, qv;<br>        <span class="hljs-built_in">get_path</span>(pv, root, p);<br>        <span class="hljs-built_in">get_path</span>(qv, root, q);<br><br>        <span class="hljs-comment">//print(pv);</span><br>        <span class="hljs-comment">//print(qv);</span><br>        TreeNode *res = <span class="hljs-built_in">find_last_same</span>(pv, qv);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_path</span><span class="hljs-params">(vector&lt;TreeNode*&gt; &amp;vec, TreeNode* root, TreeNode* need)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        TreeNode *cur = root;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">//cout &lt;&lt; cur-&gt;val &lt;&lt; p-&gt;val &lt;&lt; endl;</span><br>            <span class="hljs-keyword">if</span> (need-&gt;val &gt; cur-&gt;val) &#123;<br>                vec.<span class="hljs-built_in">emplace_back</span>(cur);<br>                cur = cur-&gt;right;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (need-&gt;val &lt; cur-&gt;val) &#123;<br>                vec.<span class="hljs-built_in">emplace_back</span>(cur);<br>                cur = cur-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                vec.<span class="hljs-built_in">emplace_back</span>(cur);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">find_last_same</span><span class="hljs-params">(vector&lt;TreeNode*&gt; &amp;v1, vector&lt;TreeNode*&gt; &amp;v2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = <span class="hljs-built_in">min</span>(v1.<span class="hljs-built_in">size</span>(), v2.<span class="hljs-built_in">size</span>());<br>        TreeNode* res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (v1.<span class="hljs-built_in">at</span>(i)-&gt;val == v2.<span class="hljs-built_in">at</span>(i)-&gt;val) &#123;<br>                res = v1.<span class="hljs-built_in">at</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这种方法虽然可以通过，但是较为繁琐，还有更简洁的写法。</p><h2 id="方法-2-迭代"><a href="#方法-2-迭代" class="headerlink" title="方法 2 迭代"></a>方法 2 迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) &#123;<br>                root = root-&gt;right;            <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) &#123;<br>                root = root-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这种方法就和 <strong>二叉树的最近公共祖先</strong> 类似了，通过判断 p 和 q 在同侧还是异侧，来决定父节点的值，具体可以参考<a href="https://zengh1.github.io/post/2021-4-3-offer-68-lowest-common-ancestor/">这篇文章</a></p><h2 id="方法3-递归"><a href="#方法3-递归" class="headerlink" title="方法3 递归"></a>方法3 递归</h2><p>方法和迭代一样，只是换成了递归的方式，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 57 - II. 和为s的连续正数序列</title>
    <link href="/2021/05/04/jian-zhi-offer-57-ii-he-wei-s-de-lian-xu-zheng-shu-xu-lie/"/>
    <url>/2021/05/04/jian-zhi-offer-57-ii-he-wei-s-de-lian-xu-zheng-shu-xu-lie/</url>
    
    <content type="html"><![CDATA[<blockquote><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p>示例 1：</p><p>输入：target &#x3D; 9<br>输出：[[2,3,4],[4,5]]</p><p>示例 2：</p><p>输入：target &#x3D; 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p><p>限制：</p><p>1 &lt;&#x3D; target &lt;&#x3D; 10^5</p></blockquote><h2 id="方法-1-滑动窗口"><a href="#方法-1-滑动窗口" class="headerlink" title="方法 1 滑动窗口"></a>方法 1 滑动窗口</h2><p>通过双指针维护一个窗口，并根据窗口中的和值，来进行相应的移动处理，具体为下：</p><ol><li>和值小于所需的值，扩大窗口，操作为右指针 + 1</li><li>和值大于所需的值，缩小窗口，操作为左指针 + 1</li><li>和值等于所需的值，记录结果，左右指针同时 + 1</li></ol><p>流程如下图所示：</p><p><img src="https://zengh1.github.io/post-images/1620101569463.png"></p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findContinuousSequence</span><span class="hljs-params">(target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span><br>    <span class="hljs-comment">// 构建一个数组用于滑动窗口</span><br>n := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, (target&gt;&gt;<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(n); i++ &#123;<br>n[i] = i + <span class="hljs-number">1</span><br>&#125;<br><br>i, j := <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>sum := n[i] + n[j]<br><span class="hljs-keyword">for</span> i &lt; j &#123;<br><span class="hljs-keyword">if</span> sum &lt; target &#123;<br>j++<br>sum += n[j]<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum &gt; target &#123;<br>sum -= n[i]<br>i++<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum == target &#123; <br><span class="hljs-keyword">var</span> temp []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i1 := i; i1 &lt;= j; i1++ &#123;<br>temp = <span class="hljs-built_in">append</span>(temp, n[i1])<br>&#125;<br>res = <span class="hljs-built_in">append</span>(res, temp)<br>sum -= n[i]<br>i++<br>            <span class="hljs-comment">// j 不是最后一个元素时，才执行下面的操作，</span><br>            <span class="hljs-comment">// 否则 j++ 后会导致 n[j] 越界</span><br><span class="hljs-keyword">if</span> j &lt; <span class="hljs-built_in">len</span>(n)<span class="hljs-number">-1</span> &#123;<br>j++<br>sum += n[j]<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有以下几点需要注意：</p><ol><li><p>如果需要移动 j 指针，则更新和值操作需要在移动后进行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"> j++<br>sum += n[j]<br></code></pre></td></tr></table></figure></li><li><p>如果需要移动 i 指针，需要在移动前更新和值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">sum -= n[i]<br>i++<br></code></pre></td></tr></table></figure></li><li><p>sum &#x3D;&#x3D; target 时 防止 j 越界</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// j 不是最后一个元素时，才执行下面的操作，</span><br><span class="hljs-comment">// 否则 j++ 后会导致 n[j] 越界</span><br><span class="hljs-keyword">if</span> j &lt; <span class="hljs-built_in">len</span>(n)<span class="hljs-number">-1</span> &#123;<br>j++<br>sum += n[j]<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="优化一下"><a href="#优化一下" class="headerlink" title="优化一下"></a>优化一下</h2><p>虽然结果是正确的，但是在参考了题解后，发现自己的代码还有一些可以优化的地方，首先是最开始的构建数组，这是完全没必要的，因为是连续正整数序列，所以可以直接把指针作为数字，而不是下标。</p><p>此外，对于 sum &#x3D;&#x3D; target 这种情况，我的处理逻辑是 i 和 j 都移动，但是实际上只需要移动 i 即可，这样可以省去越界判断，且可接减少移动次数。</p><p>减少移动次数示例：<br>i 和 j 都移动</p><ol><li>i &#x3D; 4, j &#x3D; 5, s &#x3D; 9 &#x3D;&#x3D; target  </li><li>i++ &#x3D; 5, j++ &#x3D; 6, sum&#x3D; 11 &gt; 9</li><li>i++ &#x3D; 6，i &#x3D;&#x3D; j ，break</li></ol><p>只移动 i</p><ol><li>i &#x3D; 4, j &#x3D; 5, s &#x3D; 9 &#x3D;&#x3D; target  </li><li>i &#x3D;5, j &#x3D; 5, i &#x3D;&#x3D; j ，break</li></ol><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findContinuousSequence</span><span class="hljs-params">(target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span><br><br>i, j, sum := <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br><span class="hljs-keyword">for</span> i &lt; j &#123;<br><span class="hljs-keyword">if</span> sum &lt; target &#123;<br>j++<br>sum += j<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum &gt; target &#123;<br>sum -= i<br>i++<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum == target &#123; <br><span class="hljs-keyword">var</span> temp []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i1 := i; i1 &lt;= j; i1++ &#123;<br>temp = <span class="hljs-built_in">append</span>(temp, i1)<br>&#125;<br>res = <span class="hljs-built_in">append</span>(res, temp)<br>sum -= i<br>i++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 690. 员工的重要性</title>
    <link href="/2021/05/02/leetcode-690-yuan-gong-de-chong-yao-xing/"/>
    <url>/2021/05/02/leetcode-690-yuan-gong-de-chong-yao-xing/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给定一个保存员工信息的数据结构，它包含了员工 <strong>唯一的 id</strong> ，<strong>重要度</strong> 和 <strong>直系下属的 id</strong></p><p>比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么<br>员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是<br>[3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 并不是直系 下属，因此没有体现在<br>员工 1 的数据结构中。</p><p>现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。</p><p>示例：</p><p>输入：[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1<br>输出：11<br>解释：<br>员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1<br>的总重要度是 5 + 3 + 3 &#x3D; 11 。</p><p>提示：</p><p>一个员工最多有一个 <strong>直系</strong> 领导，但是可以有多个 <strong>直系</strong> 下属<br>员工数量不超过 2000 。</p></blockquote><h2 id="方法1-普通递归"><a href="#方法1-普通递归" class="headerlink" title="方法1  普通递归"></a>方法1  普通递归</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for Employee.</span><br><span class="hljs-comment"> * type Employee struct &#123;</span><br><span class="hljs-comment"> *     Id int</span><br><span class="hljs-comment"> *     Importance int</span><br><span class="hljs-comment"> *     Subordinates []int</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getImportance</span><span class="hljs-params">(employees []*Employee, id <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><br>dfs(employees, id, &amp;res)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(emp []*Employee, id <span class="hljs-type">int</span>, res *<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> emp &#123;<br><span class="hljs-keyword">if</span> v.Id == id &#123;<br>*res += v.Importance<br><span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> v.Subordinates &#123;<br>dfs(emp, s, res)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">执行用时: <span class="hljs-number">8</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">内存消耗: 6</span>.<span class="hljs-number">6</span> MB<br></code></pre></td></tr></table></figure><h2 id="方法2-递归-哈希表"><a href="#方法2-递归-哈希表" class="headerlink" title="方法2  递归 + 哈希表"></a>方法2  递归 + 哈希表</h2><p>通过哈希表可以在 O(1) 内通过 id 查找到对象，而无需遍历数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for Employee.</span><br><span class="hljs-comment"> * type Employee struct &#123;</span><br><span class="hljs-comment"> *     Id int</span><br><span class="hljs-comment"> *     Importance int</span><br><span class="hljs-comment"> *     Subordinates []int</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getImportance</span><span class="hljs-params">(employees []*Employee, id <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*Employee)<br>    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><br>    <br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> employees &#123;<br>        m[v.Id] = v<br>    &#125;<br>    <br>    dfs(m, id, &amp;res)<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*Employee, id <span class="hljs-type">int</span>, res *<span class="hljs-type">int</span>)</span></span> &#123;<br>    e := m[id]<br>    *res += e.Importance<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> e.Subordinates &#123;<br>        dfs(m, v, res)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">执行用时: <span class="hljs-number">16</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">内存消耗: 6</span>.<span class="hljs-number">8</span> MB<br></code></pre></td></tr></table></figure><p>为什么反而更慢了。。。</p><h2 id="方法3-迭代"><a href="#方法3-迭代" class="headerlink" title="方法3 迭代"></a>方法3 迭代</h2><p>通过队列 + 哈希表来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for Employee.</span><br><span class="hljs-comment"> * type Employee struct &#123;</span><br><span class="hljs-comment"> *     Id int</span><br><span class="hljs-comment"> *     Importance int</span><br><span class="hljs-comment"> *     Subordinates []int</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getImportance</span><span class="hljs-params">(employees []*Employee, id <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*Employee)<br>    <span class="hljs-keyword">for</span> _, e := <span class="hljs-keyword">range</span> employees &#123;<br>        m[e.Id] = e<br>    &#125;<br>    <br>    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><br>    queue := list.New()<br>    queue.PushBack(m[id])<br>    <br>    <span class="hljs-keyword">for</span> queue.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        pop := queue.Remove(queue.Front()).(*Employee)<br>        res += pop.Importance<br>        <span class="hljs-keyword">for</span> _, e := <span class="hljs-keyword">range</span> pop.Subordinates &#123;<br>            queue.PushBack(m[e])<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">执行用时: <span class="hljs-number">12</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">内存消耗: 6</span>.<span class="hljs-number">7</span> MB<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Parallels Desktop 16 网络初始化失败和不能连接USB设备解决方法</title>
    <link href="/2021/05/01/parallels-desktop-16-wang-luo-chu-shi-hua-shi-bai-he-bu-neng-lian-jie-usb-she-bei-jie-jue-fang-fa/"/>
    <url>/2021/05/01/parallels-desktop-16-wang-luo-chu-shi-hua-shi-bai-he-bu-neng-lian-jie-usb-she-bei-jie-jue-fang-fa/</url>
    
    <content type="html"><![CDATA[<p>Parallels Desktop 16 在最新的macOS Big Sur 11.0系统上无法联网，并且无法连接USB设备。之前解决联网的办法是在终端通过命令启动parallels desktop的方法解决联网的问题，但是相对比较麻烦，而且还是无法解决Parallels Desktop 16 不能连接USB设备的问题。</p><p>今天小编为大家提供一个更好的方法解决Parallels Desktop 16 不能联网与连接USB设备的问题。详细操作步骤如下：</p><p>1、打开访达，按下shift+command+G 三个键，前往文件夹：&#x2F;Library&#x2F;Preferences&#x2F;Parallels ；</p><p>2、下载 Sublime Text 打开文件 network.desktop.xml ，找到第5行的 <UseKextless>-1</UseKextless> （也可能是 <UseKextless>1</UseKextless> ），修改为 <UseKextless>0</UseKextless>  保存并退出，保存时会提示输入密码，输入系统密码确定即可；</p><p>3、用 Sublime Text 打开文件 dispatcher.desktop.xml ，按 command + F 查找 <Usb>0</Usb> ，修改为 <Usb>1</Usb> 保存并退出，保存时会提示输入密码，输入系统密码确定即可；    </p><p>4、然后打开Parallels Desktop 16，可能会提示 Parallels需要系统扩展 ，打开 系统偏好设置 ，进入 安全性与隐私 ，点击左下角的锁图标解锁，在点击下方【 来自开发者“Parallels International GmbH”的系统软件已被阻止载入。 】右侧的 允许 按钮，提示需要重启，点击确定重启电脑，再打开Parallels Desktop 16进入Windows系统即可正常上网和连接USB设备了。</p><p>————————————————<br>版权声明：本文为CSDN博主「blank_t」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/blank_t/article/details/111567618">https://blog.csdn.net/blank_t/article/details/111567618</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go：记一次 defer 错误</title>
    <link href="/2021/04/23/goji-yi-ci-defer-cuo-wu/"/>
    <url>/2021/04/23/goji-yi-ci-defer-cuo-wu/</url>
    
    <content type="html"><![CDATA[<h2 id="错误1："><a href="#错误1：" class="headerlink" title="错误1："></a>错误1：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> err := func1(); err != <span class="hljs-literal">nil</span> &#123;     <span class="hljs-comment">// func1() 会产生错误</span><br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;defer func&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的函数不会输出 ”defer func“，因为压根就没有执行到 defer 处，导致 defer 没有注册（或者说是压入栈中？还不了解 defer 的原理）</p><p>正确写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;defer func&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> err := func1(); err != <span class="hljs-literal">nil</span> &#123;     <span class="hljs-comment">// func1() 会产生错误</span><br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>把 defer 定义在前面就好了，这样在一开始就会将 defer 函数注册。<br>看来还是得多写写项目才能发现自己的问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再探 for 循环</title>
    <link href="/2021/04/23/wei-shi-me-bu-neng-yong-bian-liang-bao-cun-die-dai-qi/"/>
    <url>/2021/04/23/wei-shi-me-bu-neng-yong-bian-liang-bao-cun-die-dai-qi/</url>
    
    <content type="html"><![CDATA[<p>有如下 <code>c++</code> 代码，它的功能是删除容器中所有小于 10 的元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">list&lt;<span class="hljs-type">int</span>&gt; l&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>&#125;;<br><span class="hljs-type">int</span> xx = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> f = l.<span class="hljs-built_in">front</span>(); f &lt; xx &amp;&amp; !l.<span class="hljs-built_in">empty</span>(); ) &#123;<br>    l.<span class="hljs-built_in">pop_front</span>();<br>&#125;<br><br>for_each(l.<span class="hljs-built_in">begin</span>(), l.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> v) -&gt; <span class="hljs-type">void</span> &#123;<br>    cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;);<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>这段代码的逻辑是：首先获取 list 的第一个元素的值，用变量 f 保存，再用 f 和 变量 xx 比较，如果 f &lt; xx 且 list 不为空，则移除 list 的第一个元素。</p><p>正确的结果应该是 [12, 13, 15]，但是运行上面的代码，结果却为空，容器里的所有元素都被删掉了。</p><p>将上面的 for 改成下面的代码后，结果正确</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (; l.<span class="hljs-built_in">front</span>() &lt; xx &amp;&amp; !l.<span class="hljs-built_in">empty</span>(); ) &#123;<br>        l.<span class="hljs-built_in">pop_front</span>();<br> &#125;<br></code></pre></td></tr></table></figure><p>原因出在 auto f &#x3D; l.front() 这里了，打印一下该值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">list&lt;<span class="hljs-type">int</span>&gt; l&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>&#125;;<br><span class="hljs-type">int</span> xx = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> f = l.<span class="hljs-built_in">front</span>(); f &lt; xx &amp;&amp; !l.<span class="hljs-built_in">empty</span>(); ) &#123;<br>    l.<span class="hljs-built_in">pop_front</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：<code>1 1 1 1 1 1 1</code></p><p>我希望的是每次 for 都会更新 f 的值，因为执行了 pop_front() 后，l.front() 也随之改变，所以用来保存 front() 的变量 f 也需要改变，但这恰好说明了我的基础不牢固，对 for 循环的理解不到位。</p><p>参见菜鸟教程中对 for 循环的讲解：（<a href="https://www.runoob.com/cplusplus/cpp-for-loop.html%EF%BC%89">https://www.runoob.com/cplusplus/cpp-for-loop.html）</a></p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">for</span> ( init; condition; increment )<br>&gt;&#123;<br> <span class="hljs-built_in">statement</span>(s);<br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>init 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里<br>写任何语句，只要有一个分号出现即可。</p></blockquote><p>for 循环的第一个语句只会执行一次，上面的运行结果可以证明这一点，有这一句话就可以解释上面的所有问题了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 67. 把字符串转换成整数</title>
    <link href="/2021/04/21/jian-zhi-offer-67-ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu/"/>
    <url>/2021/04/21/jian-zhi-offer-67-ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu/</url>
    
    <content type="html"><![CDATA[<blockquote><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为<br>该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造<br>成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符<br>时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超<br>过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p>示例 1:</p><p>输入: “42”<br>输出: 42</p><p>示例 2:</p><p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p><p>示例 3:</p><p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p><p>示例 4:</p><p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>    因此无法执行有效的转换。</p><p>示例 5:</p><p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>因此返回 INT_MIN (−231) 。</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题乍一看好像没什么特殊之处，不就是一个 atoi 嘛，只是这个 28% 的通过率有些不对劲，等到自己写的时候才发现，这道题太 tm 恶心了，有各种各样的特殊情况，比如：</p><ol><li>”          +1“      空格后面紧跟一个符号</li><li>”         +-1“     两个符号在一起</li><li>”   +0 123“      两个数字之间有空格</li><li>”0-1“              两个数字之间右符号</li><li>还有溢出的问题，如果小于 minInt32，则返回 minInt32，maxInt32 同理</li></ol><p>这些条件会导致写出来的代码非常繁琐，而且非常容易出错，往往是解决了一种情况，又导致另一种情况错误，有点像边修 bug 边造 bug。</p><h2 id="方法1-自动机"><a href="#方法1-自动机" class="headerlink" title="方法1 自动机"></a>方法1 自动机</h2><p>自动机表示如下：</p><table><thead><tr><th align="center"></th><th align="center">start</th><th align="center">signed</th><th align="center">in_number</th><th align="center">end</th></tr></thead><tbody><tr><td align="center">start</td><td align="center">start</td><td align="center">signed</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td align="center">signed</td><td align="center">end</td><td align="center">end</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td align="center">in_number</td><td align="center">end</td><td align="center">end</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td align="center">end</td><td align="center">end</td><td align="center">end</td><td align="center">end</td><td align="center">end</td></tr></tbody></table><p>解释：<br>start：代表空格<br>signed：代表 “+” 或者 “-”<br>in_number：代表数字<br>end：代表其他字符</p><p>当 start 遇到 start 时：代表空格遇到空格，状态依然为 start，例如 “      ”<br>当 start 遇到 signed 时：代表空格遇到 + 或 -，状态改变为 signed，例如 “      +”<br>当 start 遇到 in_number 时：代表空格遇到数字，状态改变为 in_number，例如 “       1”<br>当 start 遇到 end 时：代表空格遇到其他字符，状态改变为 end，例如 “         a”</p><p>当 signed 遇到 start 时：代表符号遇到空格，例如 “+     ”，此时为非法，状态改为 end<br>当 signed 遇到 signed 时：代表符号遇到符号：例如 “++”，此时为非法，状态改为 end<br>当 signed 遇到 in_number 时，代表符号遇到数字，例如 “+1”，合法且为一个数字，状态改为 in_number<br>当 signed 遇到 end 时，代表符号遇到其他字符，例如 “+a”，此时为非法，状态改为 end</p><p>下面为简写，x -&gt; y 表示为 x 遇到 y，” “ 为示例，stat 为更新后的状态</p><p>in_number -&gt; start：”1     “，stat &#x3D; end<br>in_number -&gt; signed：”1+”，stat &#x3D; end<br>in_number -&gt;  in_number：”12”，stat &#x3D; in_number<br>in_number -&gt; end：”1a”，stat &#x3D; end</p><p>end -&gt; start：”a “，stat &#x3D; end<br>end -&gt; signed：”a+”，stat &#x3D; end<br>end -&gt; in_number：”a1”，stat &#x3D; end<br>end -&gt; end：”ab”，stat &#x3D; end</p><p>理解了自动机以后，也就有了一些写代码的思路了，不得不说这种方法真的十分巧妙，能够轻松化解各种繁杂的 if else 条件和边界判断。</p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 对应之前的自动机图表</span><br><span class="hljs-keyword">var</span> stat = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-string">&quot;start&quot;</span>: &#123;<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;sign&quot;</span>, <span class="hljs-string">&quot;num&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;sign&quot;</span>: &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;num&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;num&quot;</span>: &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;num&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;end&quot;</span>: &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-comment">// 对应自动机图表的表头</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getStat</span><span class="hljs-params">(c <span class="hljs-type">rune</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> unicode.IsSpace(c) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> unicode.IsDigit(c) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    is := <span class="hljs-string">&quot;start&quot;</span><br>    sign := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><br>    <br>    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> s &#123;<br>        is = stat[is][getStat(c)]<br>        <span class="hljs-keyword">if</span> is == <span class="hljs-string">&quot;num&quot;</span> &#123;<br>            res = res*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(c-<span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-comment">// math.MinInt32: -2147483648</span><br>            <span class="hljs-comment">// math.MaxInt32: 2147483647</span><br>            <span class="hljs-keyword">switch</span> sign &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                res = min(res, math.MaxInt32)<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>                <span class="hljs-comment">// min(res, math.MaxInt32)</span><br>                <span class="hljs-comment">// 输入：&quot;-91283472332&quot;</span><br>                <span class="hljs-comment">// 输出：-2147483647</span><br>                <span class="hljs-comment">// 预期：-2147483648</span><br>                <span class="hljs-comment">// -math.MinInt32 ????</span><br>                res = min(res, -math.MinInt32)    <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> is == <span class="hljs-string">&quot;sign&quot;</span> &#123;<br>            <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;+&#x27;</span> &#123;<br>                sign = <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sign = <span class="hljs-number">-1</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res * sign<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; y &#123;<br>       <span class="hljs-keyword">return</span> y<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要说明一下 <code>sign = -1</code> 时的溢出判断 <code>res = min(res, -math.MinInt32)</code> ，为什么要加负号呢？以测试用例 <code>-91283472332</code> 为例，正确的结果为 <code>-2147483648</code>：</p><p>(注：math.MinInt32: -2147483648    math.MaxInt32: 2147483647)</p><p>因为有负号，所以 sign 的值更新为 -1，而最后返回的的结果为 res * sign，即 - res，所以需要为 math.MinInt32 添加一个符号，将其变为 2147483648，这样再与 sign 相乘，得到的就是一个负数了。</p><p>此外，如果条件为 min(res, math.MinInt32)，那么当 res 为 -42 时，并没有溢出，但是会错误的返回 MinInt32，如果改为 -math.MinInt32 则会正确的返回 -42 了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>剑指offer</tag>
      
      <tag>自动机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 394. 字符串解码</title>
    <link href="/2021/04/19/leetcode-394-zi-fu-chuan-jie-ma/"/>
    <url>/2021/04/19/leetcode-394-zi-fu-chuan-jie-ma/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k<br>保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] <br>的输入。</p><p>示例 1：</p><p>输入：s &#x3D; “3[a]2[bc]”<br>输出：”aaabcbc”</p><p>示例 2：</p><p>输入：s &#x3D; “3[a2[c]]”<br>输出：”accaccacc”</p><p>示例 3：</p><p>输入：s &#x3D; “2[abc]3[cd]ef”<br>输出：”abcabccdcdcdef”</p><p>示例 4：</p><p>输入：s &#x3D; “abc3[cd]xyz”<br>输出：”abccdcdcdxyz”</p></blockquote><h1 id="方法1-两个辅助栈"><a href="#方法1-两个辅助栈" class="headerlink" title="方法1 两个辅助栈"></a>方法1 两个辅助栈</h1><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1619947305597.png"></p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodeString</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    resStack := list.New()<br>    culStack := list.New()<br>    <br>    mul, res := <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span><br>    <br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> s &#123;<br>        c := <span class="hljs-type">byte</span>(char)<br>        <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;[&#x27;</span> &#123;<br>            resStack.PushBack(res)<br>            culStack.PushBack(mul)<br>            mul = <span class="hljs-number">0</span><br>            res = <span class="hljs-string">&quot;&quot;</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;]&#x27;</span> &#123;<br>            <span class="hljs-keyword">var</span> temp <span class="hljs-type">string</span><br>            cpop := culStack.Remove(culStack.Back()).(<span class="hljs-type">int</span>)<br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; cpop; i++ &#123;<br>                temp += res<br>            &#125;<br>            rpop := resStack.Remove(resStack.Back()).(<span class="hljs-type">string</span>)<br>            res = rpop + temp<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &#123;<br>            mul = mul*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(c-<span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res += <span class="hljs-type">string</span>(c)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res            <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>栈</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go：http.Request.Body 第二次读取为空 </title>
    <link href="/2021/04/17/goiocopy-de-keng/"/>
    <url>/2021/04/17/goiocopy-de-keng/</url>
    
    <content type="html"><![CDATA[<p>有如下代码，先使用 io.Copy 将 request.Body copy 到 stdout 标准输出，再使用 io.ReadAll 再次读取 request.Body：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>io.WriteString(os.Stdout, <span class="hljs-string">&quot;read request body from io.Copy: &quot;</span>)<br>io.Copy(os.Stdout, r.Body)<br>io.WriteString(os.Stdout, <span class="hljs-string">&quot;\n&quot;</span>)<br>    <br>body, err := io.ReadAll(r.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;read request body error: &quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;read request body from io.ReadAll: &quot;</span>, body)<br>&#125;)<br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 curl 访问接口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl localhost:8080 -d <span class="hljs-string">&quot;user=admin&amp;passwd=12345678&quot;</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">http server 这边的输出：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run http_readcloser.go</span><br>read request body from io.Copy: user=admin&amp;passwd=12345678<br>read request body from io.ReadAll:  []<br></code></pre></td></tr></table></figure><p>执行时发现 io.ReadAll() 读出来的内容始终为空。</p><p>原因：<br><del>【猜测】copy() 会将 src 清空而不是 copy，这和它的函数名不符，</del></p><p>copy 函数没有问题，对于这种标准库的东西也不可能犯这种低级错误，真正的原因在于 http.Request.Body。</p><p>http.request.Body 是 readCloser 类型的，我们使用 ReadAll 读取 http.request.Body 后将无法再次读取 http.request.Body 里面的信息</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">  <span class="hljs-keyword">var</span> bodyB []<span class="hljs-type">byte</span><br>bodyB, _ = io.ReadAll(r.Body)<br>fmt.Println(bodyB)<br><br>  <span class="hljs-comment">// 把刚刚读出来的再写进去</span><br>r.Body = io.NopCloser(bytes.NewReader(bodyB))<br>all, _ := io.ReadAll(r.Body)<br>fmt.Println(all)<br></code></pre></td></tr></table></figure><h2 id="为什么-Request-Body-只能读取一次（未解决）"><a href="#为什么-Request-Body-只能读取一次（未解决）" class="headerlink" title="为什么 Request.Body 只能读取一次（未解决）"></a>为什么 Request.Body 只能读取一次（未解决）</h2><h2 id="NopCloser"><a href="#NopCloser" class="headerlink" title="NopCloser()"></a>NopCloser()</h2><p>该函数将一个 reader 类型包装成 readCloser 类型，而相应的 Close 方法啥也不做，只是返回 nil。</p><p>源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NopCloser returns a ReadCloser with a no-op Close method wrapping</span><br><span class="hljs-comment">// the provided Reader r.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NopCloser</span><span class="hljs-params">(r Reader)</span></span> ReadCloser &#123;<br><span class="hljs-keyword">return</span> nopCloser&#123;r&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> nopCloser <span class="hljs-keyword">struct</span> &#123;<br>Reader<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go：ioutil.ReadAll() 引发的 out of memory </title>
    <link href="/2021/04/16/goioutilreadall-yin-fa-de-out-of-memory/"/>
    <url>/2021/04/16/goioutilreadall-yin-fa-de-out-of-memory/</url>
    
    <content type="html"><![CDATA[<h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>某天突发奇想，写了一个在线阅读的 http 小程序，当访问某一路由时会读取电子书文件，并写入到 response 中，其中封装了一个读取文件的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadFile</span><span class="hljs-params">(src <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>file, err := os.Open(src)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>b, err := io.ReadAll(file)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br><br><span class="hljs-keyword">return</span> b, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>很简单的一个函数，使用 io.ReadAll() （在 go 1.16 中废弃了 ioutil包，将其中的函数全部移到了 io 包下）读取文件为字节切片并返回，这里读取的文件是电子书。</p><p>但是当部署到服务器上（1核 2g 的学生服务器）并访问路由时，产生了 out of memory  异常，致使程序中指，这是一个我还未曾见过的错误，同时也比较诧异，这样一个简单的小程序为什么会内存溢出呢？</p><p>从错误的提示信息中，定位到了问题的所在为：io.ReadAll()，早就听说过这个函数是一次性将文件全部读取的，在文件较大时不建议使用（go 语言圣经中有提到），但也没太当回事，毕竟这个所谓的“文件较大”过于宽泛，但经过这次的错误后，我对文件较大这个概念有了新的认识，在我这台土豆服务器上，读取一个 300m 的文件会直接导致内存溢出，服务器的内存使用情况：<code>KiB Mem :  1882892 total,    70112 free,  1347204 used</code> ，也就是说使用 ReadAll() 读取一个 300m 的文件，会占用超过 700m 的内存。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>将 ReadAll() 替换为 io.Copy() 即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go 字节数组错误：&#92;u0001</title>
    <link href="/2021/04/16/2021-3-13-byte-array/"/>
    <url>/2021/04/16/2021-3-13-byte-array/</url>
    
    <content type="html"><![CDATA[<p>在做 <code>压缩字符串</code> 这道题时，提交的输出结果十分诡异，如下：</p><p>输入：</p><p>[“a”,”a”,”b”,”b”,”c”,”c”,”c”]</p><p>输出：</p><p>[“a”,”\u0002”,”b”,”\u0002”,”c”,”\u0003”]</p><p>预期：</p><p>[“a”,”2”,”b”,”2”,”c”,”3”]</p><p>可以看到结果中的数字部分是对的，但是多了 \u000 这部分，这个结果令我百思不得其解，在 ide 中运行时正常的，但在力扣上运行一直都会有 <code>\u000</code> ，起初还以为是力扣的问题，在查阅资料以后终于找到了原因所在，是一个比较低级的错误。</p><p>大概是力扣会将运行的字节数组转换为字符串，而字符数组转字符串会根据 <code>ascii</code> 来映射转换，问题来了，我的字节数组里存储的全部都是 1 - 9 的数字，而不是数字对应的 ascii 码，所以在转换后无法输出有效字符，解决的方法也很简单，只要在存储的值上加 ‘0’ 即可（ascii 为48）</p><p>比如，原先的字节数组是 [2, 2, 3]，再加 48 以后，变成了 [50, 50, 51]，ascii 50 对应十进制 2，ascii 51 对应十进制 3，此时转换后的结果就是正确的了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang GDB 调试提示 No symbol table is loaded. Use the &quot;file&quot; command</title>
    <link href="/2021/04/16/2021-4-10-golang-gdb/"/>
    <url>/2021/04/16/2021-4-10-golang-gdb/</url>
    
    <content type="html"><![CDATA[<p>背景：</p><blockquote><p>本地 MacOS 上通过 GDB 调试 golang 程序，结果提示 No symbol table is loaded. Use the “file”<br>command.</p></blockquote><p>解决方法：</p><blockquote><p>打包时加上 -ldflags&#x3D;-compressdwarf&#x3D;false 参数即可 比如在作者本地就是 go build -gcflags “-N -l”<br>-ldflags&#x3D;-compressdwarf&#x3D;false gdb&#x2F;main.go 然后通过命令 gdb main 即可调试</p></blockquote><p>参考：<a href="https://kaijuan.co/topics/25/no-symbol-table-is-loaded-use-the-file-command">https://kaijuan.co/topics/25/no-symbol-table-is-loaded-use-the-file-command</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>gdb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++：iterator.begin() 和 *iterator.begin() 的区别</title>
    <link href="/2021/04/16/2021-4-14-whats-different-in-cpp-iterator-var/"/>
    <url>/2021/04/16/2021-4-14-whats-different-in-cpp-iterator-var/</url>
    
    <content type="html"><![CDATA[<h1 id="情景描述"><a href="#情景描述" class="headerlink" title="情景描述"></a>情景描述</h1><p>有如下 <code>c++</code> 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">auto</span> b = vec.<span class="hljs-built_in">begin</span>();<br>    *b = <span class="hljs-number">99999</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;i : vec) &#123;<br>        std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;   <span class="hljs-comment">// Output: 99999 2 3 4 5</span><br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">auto</span> bb = *vec.<span class="hljs-built_in">begin</span>(); <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;bb: &quot;</span> &lt;&lt; bb &lt;&lt; std::endl;<span class="hljs-comment">// Output: bb: 99999</span><br>    bb = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp; i : vec) &#123;<br>        std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;   <span class="hljs-comment">// Output: 99999 2 3 4 5</span><br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过 <code>*b</code> 的方式可以更改元素的值，而 bb 则不行。这里我比较疑惑的是，<code>*b</code> 和 <code>*vec.begin()</code> 难道不一样吗？</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>通过编译器查看得知，b 的类型是 <code>__wrap_iter&lt;vector&lt;int, allocator&lt;_Tp&gt;&gt;::pointer&gt;</code>，bb 的类型是 <code>int</code>，这让我有了一些思路。</p><p>举一个指针的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> *p = &amp;i;<br><br>    <span class="hljs-comment">// 类似上面的 b</span><br>    <span class="hljs-type">int</span> *b = p;<br>    *b = <span class="hljs-number">555</span>;<br>    cout &lt;&lt; i &lt;&lt; endl;  <span class="hljs-comment">// Output: 555，修改成功了</span><br>    <br>    <span class="hljs-comment">// 类似上面的 bb</span><br>    <span class="hljs-type">int</span> bb = *p;<br>    bb = <span class="hljs-number">666</span>;<br>    cout &lt;&lt; i &lt;&lt; endl; <span class="hljs-comment">// Output: 555，没有修改成功</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>b 保存的是 p 指向的地址，也就是 i，所以通过解引用 *b 的方式可以更改掉 i 的值，而 bb 保存的是 p 解引用的值，仅仅是一个 int 变量，而不是地址，自然也不会对 i 产生任何影响。</p><p>同理，每个迭代器实际保存的是对某个元素的引用，所以 *vec.begin() 相当于解引用拿到实际的值。</p><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p><del>鉴于还处于初学 c++ 的阶段，对迭代器以及语言本身都不熟悉，所以以上仅仅是猜想，本文仅做保存记录，方便以后的回看。</del></p><p>更新：没啥毛病，就是这个原因，比较初级的一个问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcd 错误：context deadline exceeded</title>
    <link href="/2021/04/16/2020-10-17-etcd-error/"/>
    <url>/2021/04/16/2020-10-17-etcd-error/</url>
    
    <content type="html"><![CDATA[<h1 id="etcd-远程操作失败：Error-context-deadline-exceeded"><a href="#etcd-远程操作失败：Error-context-deadline-exceeded" class="headerlink" title="etcd 远程操作失败：Error: context deadline exceeded"></a>etcd 远程操作失败：Error: context deadline exceeded</h1><p>在服务器启动 etcd，并在本地机器通过 <strong>etcdctl –endpoints&#x3D;<a href="http://ip:2379/">http://ip:2379</a> put name “123”</strong> 命令，在服务器的 etcd 中创建一对键值对， 如下图所示：</p><p><img src="https://zengh1.github.io/post-images/1618573630890.jpg"></p><p>服务端 etcd 的启动命令如下：</p><p><img src="https://zengh1.github.io/post-images/1618573644827.jpg"></p><p>但是在执行 etcdctl 命令后发生了错误：</p><p><img src="https://zengh1.github.io/post-images/1618573652525.jpg"></p><p>经过网上查阅资料，终于找到了解决方法，在启动 etcd 时，需要添加一些参数，否则远程连接无法执行，</p><p>完整命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./etcd --listen-client-urls http://0.0.0.0:2379 --advertise-client-urls http://0.0.0.0:2379 --listen-peer-urls http://0.0.0.0:2380 --initial-advertise-peer-urls http://0.0.0.0:2380  --initial-cluster my-etcd-1=http://0.0.0.0:2380</span><br></code></pre></td></tr></table></figure><p>将ip为0.0.0.0可以理解为不限制连接机器（真正的生产不推荐这样设置）。 </p><p>使用上面的命令启动 etcd 后，本地机就可以正常的对其执行操作了</p><p><img src="https://zengh1.github.io/post-images/1618573663493.jpg"></p><p>参考：<a href="https://github.com/yuedun/micro-service/blob/master/README.md">https://github.com/yuedun/micro-service/blob/master/README.md</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题 01.06. 字符串压缩</title>
    <link href="/2021/04/16/2021-3-13-ctcl-0106-compress-string/"/>
    <url>/2021/04/16/2021-3-13-ctcl-0106-compress-string/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p><p>示例1:</p><p>输入：”aabcccccaaa”<br> 输出：”a2b1c5a3”<br>示例2:</p><p>输入：”abbccd”<br> 输出：”abbccd”<br> 解释：”abbccd”压缩后为”a1b2c2d1”，比原字符串长度更长。<br>提示：</p><p>字符串长度在[0, 50000]范围内。</p></blockquote><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p><img src="https://zengh1.github.io/post-images/1618573324644.png"></p><p>代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compressString</span><span class="hljs-params">(S <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">var</span> sb strings.Builder<br>    p, l := <span class="hljs-number">0</span>, <span class="hljs-number">1</span>    <span class="hljs-comment">// l 记录长度，初始值为 1</span><br>    <span class="hljs-keyword">var</span> cur <span class="hljs-type">byte</span><br><br>    <span class="hljs-comment">// 指针 p 从 0 开始，i 从 1 开始</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(S); i++ &#123;<br>        cur = S[p]<br>        <span class="hljs-keyword">if</span> S[i] == cur &#123;<br>            l++<br>        &#125; <span class="hljs-keyword">else</span>  &#123;<br>            sb.WriteByte(cur)<br>            sb.WriteString(strconv.Itoa(l))<br>            l = <span class="hljs-number">1</span>   <span class="hljs-comment">// 重置 l</span><br>        &#125; <br>        <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(S) - <span class="hljs-number">1</span> &#123;    <span class="hljs-comment">// 到最后一个 char 了</span><br>            sb.WriteByte(S[i])  <br>            sb.WriteString(strconv.Itoa(l))<br>        &#125;<br>        p++<br>    &#125;<br><br>    <span class="hljs-comment">// 压缩后没有变短则返回原先的字符串</span><br>    <span class="hljs-comment">// 长度为 1 的也直接返回</span><br>    <span class="hljs-keyword">if</span> sb.Len() &gt;= <span class="hljs-built_in">len</span>(S) || <span class="hljs-built_in">len</span>(S) &lt;= <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> S<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.String()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>程序员面试金典</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 53 - I. 在排序数组中查找数字 I</title>
    <link href="/2021/04/16/2021-3-17-offer-53-search-sort-array1/"/>
    <url>/2021/04/16/2021-3-17-offer-53-search-sort-array1/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>统计一个数字在排序数组中出现的次数。</p><p>示例 1:</p><p>输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出: 2<br>示例 2:</p><p>输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出: 0</p><p>限制：</p><p>0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</p></blockquote><h4 id="方法1：二分查找"><a href="#方法1：二分查找" class="headerlink" title="方法1：二分查找"></a>方法1：二分查找</h4><p>这道题最简单粗暴的方法就是从头遍历，当获取到值等于 target 的元素时开始累加次数，直到当前值不等于 target，但是这样做的话时间复杂度为 O(n)，此外像这种暴力法也显然不是一个合格的解决方案。</p><p>解决这道题的另一种方式是 <code>二分查找</code>，这道题属于二分查找的一个变种，常规的二分查找，在 nums[mid] &#x3D;&#x3D; target 时返回，但是这道题要求的是寻找出 target 出现的次数，所以区别就在于 nums[mid] &#x3D;&#x3D; target 时的处理。</p><p>整道题的思路可以是这样：先查找出 target 最后出现的位置，记为 leftIndex，再查找出 target 第一次出现的位置，记为 rightIndex，然后用 leftIndex - rightIndex + 1 即可求出出现的次数。</p><p>至于二分查找的特殊处理，可以将 [mid] &#x3D;&#x3D; target 时处理为 left &#x3D; mid + 1。</p><p>具体的流程如下图：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618573278487.png"></p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    leftIndex := binarySearch(nums, target)<br>    rightIndex := binarySearch(nums, target<span class="hljs-number">-1</span>)<br><br>    <span class="hljs-keyword">return</span> leftIndex - rightIndex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    l, r := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br><br>    <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>        m := (l + r) &gt;&gt; <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> nums[m] &lt;= target &#123;<br>            l = m + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r = m - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> l<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>剑指offer</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 52. 两个链表的第一个公共节点</title>
    <link href="/2021/04/16/2021-3-23-offer-52-get-intersection-node/"/>
    <url>/2021/04/16/2021-3-23-offer-52-get-intersection-node/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>输入两个链表，找出它们的第一个公共节点。编写一个程序，找到两个单链表相交的起始节点。</p><pre><code class="hljs">如下面的两个链表：  a1 -&gt; a2 ↘                    c1 -&gt; c2 -&gt; c3    b1 -&gt; b2 -&gt; b3 ↗在节点 c1 开始相交。示例 1：         4 -&gt; 1 ↘                 8 -&gt; 4 -&gt; 5    5 -&gt; 0 -&gt; 1 ↗输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5],     skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。        从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。        在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。示例 2：2 -&gt; 6 -&gt; 41 -&gt; 5输入：intersectVal = 0, listA = [2,6,4], listB = [1,5],     skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。</code></pre><p>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。<br>本题与主站 160 题相同：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p></blockquote><h2 id="方法1-双指针法"><a href="#方法1-双指针法" class="headerlink" title="方法1 双指针法"></a>方法1 双指针法</h2><p>具体的方法如下图所示：</p><p><img src="https://zengh1.github.io/post-images/1618573213021.jpg"></p><p>对应代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 不需要边界检查</span><br>    <span class="hljs-comment">// if headA == nil || headB == nil &#123;</span><br>    <span class="hljs-comment">//     return nil</span><br>    <span class="hljs-comment">// &#125;</span><br>    hha, hhb := headA, headB<br>    <span class="hljs-comment">//pa, pb := headA, headB</span><br><br>    <span class="hljs-keyword">for</span> headA != headB &#123;<br>        <span class="hljs-keyword">if</span> headA == <span class="hljs-literal">nil</span> &#123;<br>            headA = hhb<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            headA = headA.Next<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> headB == <span class="hljs-literal">nil</span> &#123;<br>            headB = hha<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            headB = headB.Next<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> headA<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h2><h3 id="1-超出时间限制"><a href="#1-超出时间限制" class="headerlink" title="1.超出时间限制"></a>1.超出时间限制</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    hha, hhb := headA, headB<br>    pa, pb := headA, headB<br><br>    <span class="hljs-keyword">for</span> pa != pb &#123;<br>        pa = pa.Next<br>        <span class="hljs-keyword">if</span> pa == <span class="hljs-literal">nil</span> &#123;<br>            pa = hhb<br>        &#125;<br><br>        pb = pb.Next<br>        <span class="hljs-keyword">if</span> pb == <span class="hljs-literal">nil</span> &#123;<br>            pb = hha<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> pa<br>&#125;<br></code></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">0</span><br>[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]<br>[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]<br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>分析：两个链表分别为 2 -&gt; 6 -&gt; 4 和 1 -&gt; 5，且没有交点，而上面代码的问题在于，当某个指针为 null 时，会继续跳转到另一个链表的头部，而不会停留。对应代码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">pa = pa.Next<br><span class="hljs-keyword">if</span> pa == <span class="hljs-literal">nil</span> &#123;<br>    pa = hhb<br>&#125;<br></code></pre></td></tr></table></figure><p>对于两个不相交的链表而言，退出 while 的条件是两个指针都为 null，而上面的代码会导致指针永远不为 null， while 条件 pa !&#x3D; pb 永远不会成立，所以会进入死循环。</p><h3 id="2-其中一个链表为空"><a href="#2-其中一个链表为空" class="headerlink" title="2.其中一个链表为空"></a>2.其中一个链表为空</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    hha, hhb := headA, headB<br>    pa, pb := headA, headB<br><br>    <span class="hljs-keyword">for</span> pa != pb &#123;<br>        <span class="hljs-keyword">if</span> pa == <span class="hljs-literal">nil</span> &#123;<br>            pa = hhb<br>        &#125;<br>        pa = pa.Next<br>        <br>        <span class="hljs-keyword">if</span> pb == <span class="hljs-literal">nil</span> &#123;<br>            pb = hha<br>        &#125;<br>        pb = pb.Next<br>        <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> pa<br>&#125;<br><span class="hljs-string">``</span><span class="hljs-string">`    </span><br><span class="hljs-string"></span><br><span class="hljs-string">测试用例：</span><br></code></pre></td></tr></table></figure><p>0<br>[1,3]<br>[]<br>2<br>0</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><br>分析：解决之前的 `超出时间` 问题很简单，只要调换一下 pa == nil 和 pa = pa.<span class="hljs-keyword">Next</span> 的位置即可，现在指针会停留在 <span class="hljs-literal">null</span> 上了。<br><br>但又有了新的问题：如果两个链表有一个为空，如这里的测试用例 <span class="hljs-number">1</span> -&gt; <span class="hljs-number">3</span> 和 <span class="hljs-literal">null</span>，此时第一个指针移动到 <span class="hljs-number">3</span>，第二个链表的指针会直接移动到第一个链表的 <span class="hljs-number">1</span> 处，接着又会执行 pa = pa.<span class="hljs-keyword">Next</span> 移动到 <span class="hljs-number">3</span>，两个指针的节点相同，返回结果 <span class="hljs-number">3</span><br><br>这个结果明显是错误的，有一个空链表，怎么可能会有交点呢，错误的原因在于：pa = pa.<span class="hljs-keyword">Next</span> 这句话是一定会执行的，解决这个问题只需要为 pa = pa.<span class="hljs-keyword">Next</span> 加一个 <span class="hljs-keyword">else</span>，让 pa = hhb 和 pa = pa.<span class="hljs-keyword">Next</span> 只有一个能执行即可，更改后如下。<br><br>```go<br><span class="hljs-keyword">if</span> pa == nil &#123;<br>    pa = hhb<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    pa = pa.<span class="hljs-keyword">Next</span>  <br>&#125;<br>        <br></code></pre></td></tr></table></figure><p>起初还以为是边界判断的问题，为此加上了判断语句</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-keyword">if</span> headA == <span class="hljs-literal">nil</span> || headB == <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>后来分析了以后才发现，这道题并不需要边界检查。</p><h2 id="一个特殊的测试用例"><a href="#一个特殊的测试用例" class="headerlink" title="一个特殊的测试用例"></a>一个特殊的测试用例</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">3</span><br><span class="hljs-string">[3]</span><br><span class="hljs-string">[2,3]</span><br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>两个链表分别为 3 和 2 -&gt; 3，在 3 处相交。</p><p>按照上面的步骤：<br>第 1 次<br>p1 &#x3D; 3.Next &#x3D; null （链表1）<br>p2 &#x3D; 2.Next &#x3D; 3    （链表2）</p><p>第 2 次<br>p1 &#x3D; 2              （链表2）<br>p2 &#x3D; 3.Next &#x3D; null  （链表2）</p><p>第 3 次<br>p1 &#x3D; 2.Next &#x3D; 3     （链表2）<br>p2 &#x3D; 3              （链表1）</p><p>此时虽然两个指针都为 3，但是并不是同一个节点，一个在链表1，一个在链表2，按照逻辑，如果继续往下执行，两个指针则都为 null，会返回错误结果 无交点。</p><p>但返回的却是正确结果 3，造成这一结果的原因，只可能是两个链表的 3 节点是相同的地址，为了验证这一猜想，打印一下两个结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;h1:%p %v h2:%p %v\n&quot;</span>, <br>        headA, headA, headB, headB)<br><br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// h1:0xc00008a320 &amp;&#123;3 &lt;nil&gt;&#125;   h2:0xc00008a340 &amp;&#123;2 0xc00008a320&#125;        </span><br></code></pre></td></tr></table></figure><p>果真如此，两个链表的 3 节点地址都为 0xc00008a320</p>]]></content>
    
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 15. 三数之和</title>
    <link href="/2021/04/16/2021-3-24-leet-15-three-sum/"/>
    <url>/2021/04/16/2021-3-24-leet-15-three-sum/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三<br>个元素 a，b，c ，使得 a + b + c &#x3D; 0<br>请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p> <br>示例 1：</p><p>输入：nums &#x3D; [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>示例 2：</p><p>输入：nums &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：nums &#x3D; [0]<br>输出：[] </p><p>提示：</p><p>0 &lt;&#x3D; nums.length &lt;&#x3D; 3000<br>-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105</p></blockquote><h2 id="方法1：排序-双指针"><a href="#方法1：排序-双指针" class="headerlink" title="方法1：排序 + 双指针"></a>方法1：排序 + 双指针</h2><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>大致流程：</p><ol><li>首先将数组按 <code>升序</code> 排序</li><li>准备三个指针 k、i、j</li><li>初始化，将 k 放置在第一个元素，i 放置在 k+1 处，j 放置在最后一个元素处</li><li>开始循环，条件为 k &lt; len(nums)-2</li><li>如果当前 <code>nums[k]</code> &gt; 0，则 break</li><li>如果 <code>nums[k-1]</code> 和 <code>nums[k]</code> 相同，则 continue 跳过本轮循环，达到去重的效果</li><li>固定 k（外层 for 循环） ，先移动 i 和 j （内层 for 循序），当 i &#x3D;&#x3D; j 时 break 掉内层 for 循环，让外层 for 循环 k 继续移动 </li><li>在移动 i 和 j 时计算 <code>nums[k] + nums[j] + nums[i]</code> 的值，记为 s<ol><li>如果 s &lt; 0，先判断是否重复，即 <code>for nums[i++] == nums[i] &#123;i++&#125;</code> 进行去重，然后再 <code>i++</code> 将指针 i 向后移动，<strong>这里一定要注意顺序，先去重，再移动指针 <code>i++</code>，原因后面会说明。</strong></li><li>如果 s &gt; 0，与上面类似，也是先判断是否重复，再执行 <code>j--</code></li><li>如果 s &#x3D;&#x3D; 0，记录当前的三个数字，之后移动 i 和 j 两个指针，将 i++，<code>j--</code>，和上面一样，也是先去重，再移动。</li></ol></li></ol><p>分析：</p><p>因为数组是排好序的，所以 k 指向的是最小元素，i 指向次小元素，j 指向最大元素（排除一些特殊情况比如 [0, 0, 0, 0]）</p><p>这里的 k 起的是固定作用，目的是枚举全部情况，当三个值的和小于 0 时，可以将 i++ 使和增大，同理当和大于 0 时，可以将 j– 将和减小，当和等于 0 时，说明此时已经搜集到了结果，可以将 k++ 进行下个数的枚举</p><p>第 5 步的原因是：因为 nums[j] &gt;&#x3D; nums[i] &gt;&#x3D; nums[k]，而当前 nums[k] &gt; 0，则代表 3 个数字都大于 0 ，必然不可能再找到结果了。</p><p>第 4 步的条件为 k &lt; len(nums)-2，原因是 i 和 j 都在 k 之后，当 k 在 len(nums)-2-1 处时，j 在最后一个，i 在倒数第二个，k，i，j 刚好对应最后三个数，所以可以作为最后一次判断。这只是一个优化，可以减少 2 次不必要的循环，k &lt; len(nums) 依然是正确的。</p><p>关于去重的条件 <code>i &lt; j &amp;&amp; nums[i] == nums[i+1]</code> 中需要首先判断 i &lt; j 的原因是防止越界，例如：</p><p>测试用例 [0, 0, 0]，k 在 [0]，i 在 [1]，j 在 [2]，sum &#x3D; 0，此时因为 nums[i] &#x3D;&#x3D; nums[i+1]，所以执行 i++ 到 [1]，还是重复，继续 i++ 到 [2]，如果没有 i &lt; j 的条件，这里会执行判断语句 nums[i] &#x3D;&#x3D; nums[i+1] 即 nums[2] &#x3D;&#x3D; nums[3]，而这个 nums[3] 就会导致越界致使程序错误，但加了 i &lt; j 会导致短路，使得后面的 nums[i] &#x3D;&#x3D; nums[i+1] 不执行。</p><p>对于 <code>i &lt; j &amp;&amp; nums[j] == nums[j-1]</code> 也是一样的道理，还是测试用例 [0, 0, 0]，如果没有 i &lt; j 的约束，则 j 会一直执行 j–，当 j 到达 0 时，[j-1] 就会发生数组越界问题。</p><p><strong>为什么在判断 sum 的分支中，都需要先去重，再移动指针呢？考虑如下情况：</strong></p><p>[ (k) -2, (i) 0, 1, 1, (j) 2]</p><p>此时 nums[k] + nums[i] + nums[j] &#x3D;&#x3D; 0，按照分支的流程，应该是先去重，再移动指针，那如果我反着来会发生什么情况呢？</p><p>如果先 i++，再去重，那么：</p><ol><li>i++，变为 &#x3D;&gt; [ (k) -2, 0, (i) 1, 1, (j) 2]</li><li>此时再去重，nums[i] &#x3D;&#x3D; nums[i+1]，导致 i 又要 +1，变为 [ (k) -2, 0, 1, (i) 1, (j) 2]，这将导致一种正确结果 [-2, 1, 1] 无法获得了</li></ol><p><strong>整个算法的流程如下图所示。</strong></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618573149147.png"></p><p>代码如下：</p><p>未优化版，是我根据上面思路写的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>res := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br>sort.Slice(nums, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> nums[i] &lt; nums[j]<br>&#125;)<br><br>k := <span class="hljs-number">0</span><br>i, j := k+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> k &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span> &#123;<br>count++<br>s := <span class="hljs-number">0</span><br><span class="hljs-comment">// [-1, 0, 0]</span><br><span class="hljs-keyword">if</span> i &gt;= j &#123;<br>k++<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-keyword">if</span> nums[k] &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-comment">//fmt.Println(k, i, j)</span><br>s = nums[k] + nums[i] + nums[j]<br><span class="hljs-keyword">if</span> s &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> i &lt; j &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>] &#123;<br>j--<br>&#125;<br>j--<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> i &lt; j &amp;&amp; nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;<br>i++<br>&#125;<br>i++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>r := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>r = <span class="hljs-built_in">append</span>(r, nums[k], nums[i], nums[j])<br>res = <span class="hljs-built_in">append</span>(res, r)<br><span class="hljs-keyword">for</span> i &lt; j &amp;&amp; nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;<br>i++<br>&#125;<br><span class="hljs-keyword">for</span> i &lt; j &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>] &#123;<br>j--<br>&#125;<br>i++<br>j--<br><br>&#125;<br><br><span class="hljs-keyword">if</span> i &gt;= j &#123;<br><span class="hljs-keyword">for</span> k &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span> &amp;&amp; nums[k] == nums[k+<span class="hljs-number">1</span>] &#123;<br>k++<br>&#125;<br>k++<br>i, j = k+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>优化版，来自题解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum1</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>sort.Slice(nums, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> nums[i] &lt; nums[j]<br>&#125;)<br>res := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>; k++ &#123;<br>count++<br><span class="hljs-keyword">if</span> nums[k] &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> k &gt; <span class="hljs-number">0</span> &amp;&amp; nums[k] == nums[k<span class="hljs-number">-1</span>] &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>i, j := k+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br><br><span class="hljs-keyword">for</span> i &lt; j &#123;<br>count++<br>sum := nums[i] + nums[j] + nums[k]<br><span class="hljs-keyword">if</span> sum &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> i &lt; j &amp;&amp; nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;<br>i++<br>&#125;<br>i++<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> i &lt; j &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>] &#123;<br>j--<br>&#125;<br>j--<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>r := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>r = <span class="hljs-built_in">append</span>(r, nums[k], nums[i], nums[j])<br>res = <span class="hljs-built_in">append</span>(res, r)<br><br><span class="hljs-keyword">for</span> i &lt; j &amp;&amp; nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;<br>i++<br>&#125;<br>i++<br><span class="hljs-keyword">for</span> i &lt; j &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>] &#123;<br>j--<br>&#125;<br>j--<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>经过测试，这两个函数的执行时间相差了三十倍！不知道为何性能差距会如此之大，可能是我写的冗余判断条件太多了，暂时也没有去仔细分析的想法，只能说明自己的逻辑能力还是菜的抠脚，还需要多多去练习才行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 56. 合并区间</title>
    <link href="/2021/04/16/2021-3-26-leet-56-merge-interval/"/>
    <url>/2021/04/16/2021-3-26-leet-56-merge-interval/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。<br>请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><p>示例 1：</p><p>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p><p>示例 2：</p><p>输入：intervals &#x3D; [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如何判断区间是否重叠，需要比较第二个数组的首元素是否小于前一个数组的尾元素，例如 [1,5],[2,6]，2 是小于 6 的，所以存在重叠，<br>而 [2,6],[8,10] 中，8 大于 6，所以区间不重叠。判断是否重叠并不难，难的在于合并。</p><p>考虑如下几种情况：</p><ol><li>重叠，两个数组的尾元素<code>相同</code>，例如：[[1,4],[0,4]] &#x3D;&gt; [0, 4]</li><li>重叠，第二个数组的尾元素<code>大于</code>第一个数组的尾元素：[[1,5],[2,6]] &#x3D;&gt; [1, 6]</li><li>重叠，第二个数组的尾元素<code>小于</code>第一个数组的尾元素：[[1,5],[2,4]] &#x3D;&gt; [1, 5]</li><li>重叠，第一个数组的首元素<code>大于</code>第二个数组的首元素：[[1,4],[0,1]] &#x3D;&gt; [1, 4]</li><li>重叠，第一个数组的首元素<code>小于</code>第二个数组的首元素：[[0,4],[1,2]] &#x3D;&gt; [1, 4]</li><li>比较特殊的，[[1,4],[0,0]] &#x3D;&gt; [[0,0],[1,4]]</li><li>等等其他情况</li></ol><p>可以看到情况有很多种，而我的第一想法也是粗暴的 if else，于是写出了下面的丑陋代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>    res = <span class="hljs-built_in">append</span>(res, intervals[<span class="hljs-number">0</span>])<br>    <span class="hljs-comment">// 上一个数组的下标</span><br>    prev := <span class="hljs-number">0</span><br>    <span class="hljs-comment">//start, end := intervals[0][0], intervals[0][1]</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(intervals); i++ &#123;<br>        <span class="hljs-comment">// 上一个数组的 [0] 和 [1]</span><br>        prevs, preve := intervals[prev][<span class="hljs-number">0</span>], intervals[prev][<span class="hljs-number">1</span>]<br>        <span class="hljs-comment">// 当前数组的 [0] 和 [1]</span><br>        curs, cure := intervals[i][<span class="hljs-number">0</span>], intervals[i][<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> curs &lt;= preve &amp;&amp; cure &gt; preve &#123;  <span class="hljs-comment">// [[1,5],[2,6]]</span><br>            <span class="hljs-keyword">if</span> curs &lt; prevs &#123;   <span class="hljs-comment">// [[1,4],[0,5]]</span><br>                r := []<span class="hljs-type">int</span>&#123;curs, cure&#125;<br>                res[i<span class="hljs-number">-1</span>] = r<br>                prev = i - <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r := []<span class="hljs-type">int</span>&#123;prevs, cure&#125;<br>                res[i<span class="hljs-number">-1</span>] = r<br>                prev = i - <span class="hljs-number">1</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> curs &lt;= preve &amp;&amp; cure &lt;= preve &#123; <span class="hljs-comment">// [[1,5],[2,4]]</span><br>            <span class="hljs-keyword">if</span> curs &lt; prevs   &#123;   <span class="hljs-comment">// [[1,4],[0,4]]  [[1,4],[0,1]]</span><br>                r := []<span class="hljs-type">int</span>&#123;curs, preve&#125;<br>                res[i<span class="hljs-number">-1</span>] = r<br>                prev = i - <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> cure &lt; prevs &#123;    <span class="hljs-comment">// [[1,4],[0,0]]</span><br>                res = <span class="hljs-built_in">append</span>(res, intervals[i])<br>                swap(res, i, prev)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>        &#125;  <span class="hljs-keyword">else</span> &#123;<br>            res = <span class="hljs-built_in">append</span>(res, intervals[i])<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(nums [][]<span class="hljs-type">int</span>, i, j <span class="hljs-type">int</span>)</span></span> &#123;<br>    nums[i], nums[j] = nums[j], nums[i]<br>&#125;<br></code></pre></td></tr></table></figure><p>这是在提交失败了 n 次的基础上不断修改的，每个 if 分支都标明了对应的情况，但是，还是遇到了一种特殊的测试用例：[[1,4],[0,0]]，我的代码运行的结果是 [0,4]，但是正确答案是 [[0,0],[1,4]]，为了对付这种情况，我又写了一个 swap 函数来应对。考虑的情况越来越多，代码也越来越丑，最关键的是，提交还始终无法通过。无奈只能看题解了，</p><h2 id="方法-排序-双指针"><a href="#方法-排序-双指针" class="headerlink" title="方法 排序 + 双指针"></a>方法 排序 + 双指针</h2><p>这个排序我是万万没想到的，根据数组的左元素进行排序，这样一来，就可以完美处理 [[1,4],[0,0]] 这种情况了。</p><p>这里直接贴上来自题解中的代码，非常直观易懂且简洁，巧妙的使用了 max 函数来合并区间，比我傻傻的写的一堆 if else 优雅多了。<br>（来自 <a href="https://leetcode-cn.com/problems/merge-intervals/solution/shou-hua-tu-jie-56he-bing-qu-jian-by-xiao_ben_zhu/%EF%BC%89">https://leetcode-cn.com/problems/merge-intervals/solution/shou-hua-tu-jie-56he-bing-qu-jian-by-xiao_ben_zhu/）</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>sort.Slice(intervals, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>] &lt; intervals[j][<span class="hljs-number">0</span>]<br>&#125;)<br>res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>prev := intervals[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(intervals); i++ &#123;<br>cur := intervals[i]<br><span class="hljs-keyword">if</span> prev[<span class="hljs-number">1</span>] &lt; cur[<span class="hljs-number">0</span>] &#123; <span class="hljs-comment">// 没有一点重合</span><br>res = <span class="hljs-built_in">append</span>(res, prev)<br>prev = cur<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 有重合</span><br>prev[<span class="hljs-number">1</span>] = max(prev[<span class="hljs-number">1</span>], cur[<span class="hljs-number">1</span>])<br>&#125;<br>&#125;<br>res = <span class="hljs-built_in">append</span>(res, prev)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> a &#125;<br><span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用 prev 来保存上一个数组，初始保存的是第 0 个，然后 for 从 1 开始，即用第 1 个和第 0 个进行比较，如果没有重合，则 append 并更新 prev 为当前数组，有重合，则对 prev 进行合并，因为已经排好序了，所以前一个的 [0] 是一定小于后一个的 [0]，只需要比较 前一个的[1] 和后一个的 [1] 即可，这里用了 max 函数来比较。</p><p>特别注意一下最后的 <code>res = append(res, prev)</code> ，没有这句话会导致错误。</p><p>原因：for 是从第二个数组开始判断的，并不断与前一个数组比较，如果不在 for 外面再定义一次 <code>res = append(res, prev)</code>，则会导致结果缺失的情况。</p><p>例如：[[1,3]]，此时都不会进入 for ，如果没有末尾的这句话，会直接导致结果为空。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求二叉树根节点到指定节点的路径</title>
    <link href="/2021/04/16/2021-3-27-find-binaryTree-root-to-node-path/"/>
    <url>/2021/04/16/2021-3-27-find-binaryTree-root-to-node-path/</url>
    
    <content type="html"><![CDATA[<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>这不是一道力扣或者剑指上的原题，但却是二叉树问题的一个基础核心算法，适用于许多二叉树类型的题目，比如 <code>剑指 Offer 68 - II. 二叉树的最近公共祖先</code>，因为这里有必要记录一下，大致的说明如下：</p><p>例如如下一颗二叉树：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618572928978.png"></p><p>当指定节点为 4 时，输出 [3,5,2,4]</p><h2 id="方法1-回溯，有返回值"><a href="#方法1-回溯，有返回值" class="headerlink" title="方法1 回溯，有返回值"></a>方法1 回溯，有返回值</h2><p>代码如下，<a href="https://blog.csdn.net/shizheng_li/article/details/104675990">参考</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 找到根节点到某一节点的路径</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPath</span><span class="hljs-params">(node, need *TreeNode, // node: 当前节点，need: 指定节点</span></span><br><span class="hljs-params"><span class="hljs-function">              path, res *[]*TreeNode, // path: 记录当前路径 res: 保存结果路径</span></span><br><span class="hljs-params"><span class="hljs-function">              flag *<span class="hljs-type">bool</span>)</span></span> []*TreeNode &#123;<span class="hljs-comment">// flag: 用来标识是否已经找到结果，作为递归终止的条件</span><br><br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> || *flag &#123;<br>        <span class="hljs-keyword">return</span> *res<br>    &#125;<br>    *path = <span class="hljs-built_in">append</span>(*path, node)<br><span class="hljs-comment">// 找到指定的节点了，将 flag 更改为 true，同时将当前路径添加到 res 作为结果</span><br>    <span class="hljs-keyword">if</span> node == need &#123;<br>        *flag = <span class="hljs-literal">true</span><br>        *res = *path<br>    &#125;<br><span class="hljs-comment">// 先找左子树，再找右子树</span><br>    findPath(node.Left, need, path, res, flag)<br>    findPath(node.Right, need, path, res, flag)<br><span class="hljs-comment">// 回溯，在 path 中移除当前节点</span><br>    *path = (*path)[:<span class="hljs-built_in">len</span>(*path)<span class="hljs-number">-1</span>]<br><br>    rr := <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-built_in">len</span>(*res))<br>    <span class="hljs-comment">// 因为 slice 共用一个底层数组，第二次会更改第一次的结果，</span><br>    <span class="hljs-comment">// 所以需要 copy 一个新 slice</span><br>    <span class="hljs-built_in">copy</span>(rr, *res)  <br>    <br>    <span class="hljs-keyword">return</span> rr<br>&#125;<br></code></pre></td></tr></table></figure><p>path 和 res 都需要为指针切片，因为 append 会导致地址变更，flag 为了保证递归参数传递的状态一致，也需要为指针类型，其他的都写在注释中了，特别需要说明的是最后的 <code>copy</code>，这也是我踩的一个坑，特此记录一下：</p><p>引用 <code>算法</code> 中的二叉树，求 1 和 4 两个节点的路径，正确结果应该为 [3,1] 和 [3,5,2,4]但是最后运行的结果却是 [3,5] 和 [3,5,2,4]，测试代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// p = 1</span><br>pr := findPath(root, p, &amp;path, &amp;res, &amp;flag)<br>flag = <span class="hljs-literal">false</span><br><span class="hljs-comment">// p = 4</span><br>qr := findPath(root, q, &amp;path, &amp;res, &amp;flag)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(pr); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v &quot;</span>, pr[i]) <span class="hljs-comment">// Output: [3, 5]</span><br>&#125;<br>fmt.Println()<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(qr); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v &quot;</span>, qr[i]) <span class="hljs-comment">// Output: [3,5,2,4]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我又尝试将 pr 的输出语句移动至 qr 前，结果是正确的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// p = 1</span><br>pr := findPath(root, p, &amp;path, &amp;res, &amp;flag)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(pr); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v &quot;</span>, pr[i]) <span class="hljs-comment">// Output: [3, 1]</span><br>&#125;<br>fmt.Println()<br><br>flag = <span class="hljs-literal">false</span><br><span class="hljs-comment">// p = 4</span><br>qr := findPath(root, q, &amp;path, &amp;res, &amp;flag)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(qr); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v &quot;</span>, qr[i]) <span class="hljs-comment">// Output: [3,5,2,4]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>原因是因为我刚开始在函数中返回的是 *res，而 *res &#x3D; *path ，即让 res 的底层数组指针指向了 path 的底层数组， 传入的 path 都是同一个，这样第二次寻找路径时，path 会改变，这会使得指向 path 的 res 也跟着改变，所以第二次运行时会将 res 的 [1] 改为 [5]，解决方法就是新定义一个 slice，并 copy，再返回这个新 slice 即可。</p><p>此外，flag 参数也不需要传递指针类型，只要 bool 即可。</p><h2 id="方法2-回溯，无返回值"><a href="#方法2-回溯，无返回值" class="headerlink" title="方法2 回溯，无返回值"></a>方法2 回溯，无返回值</h2><p>方法 1 中的返回值其实完全是多余的，参数 res 已经保存了结果，完全可以不需要返回值，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPath</span><span class="hljs-params">(root, need *TreeNode, path, res *[]*TreeNode, flag *<span class="hljs-type">bool</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> || *flag &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>*path = <span class="hljs-built_in">append</span>(*path, root)<br><span class="hljs-keyword">if</span> root == need &#123;<br>*flag = <span class="hljs-literal">true</span><br><span class="hljs-comment">// copy 一个新切片，防止多个 res 指向同一个 path</span><br>news := <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-built_in">len</span>(*path))<br><span class="hljs-built_in">copy</span>(news, *path)<br>*res = news<br><span class="hljs-keyword">return</span><br>&#125;<br><br>findPath(root.Left, need, path, res, flag)<br>findPath(root.Right, need, path, res, flag)<br><br>*path = (*path)[:<span class="hljs-built_in">len</span>(*path)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> path, pp, qq []*TreeNode<br><span class="hljs-keyword">var</span> flag <span class="hljs-type">bool</span><br>findPath(root, p, &amp;path, &amp;pp, &amp;flag)<br><span class="hljs-comment">// 重置参数</span><br>flag = <span class="hljs-literal">false</span><br>path = path[<span class="hljs-number">0</span>:<span class="hljs-number">0</span>]<br>findPath(root, q, &amp;path, &amp;qq, &amp;flag)<br><span class="hljs-comment">// 此时 pp 和 qq 已经保存了结果</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="有无返回值的性能差异"><a href="#有无返回值的性能差异" class="headerlink" title="有无返回值的性能差异"></a>有无返回值的性能差异</h2><p>在 <code>剑指 Offer 68 - II. 二叉树的最近公共祖先</code> 这道题中，有一个非常长的测试用例（可能有上万个节点），这里使用有返回值的方法会超时，即使返回指针也一样超时，而无返回值则正常，可能是因为返回值需要拷贝的缘故，而且方法 1 的返回值本身就是一个冗余的东西，既然都已经提供了 res 参数用来保存结果，就不需要再返回了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>算法</tag>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode165.比较版本号</title>
    <link href="/2021/04/16/2021-3-5-leet-165-compare-version-numbers/"/>
    <url>/2021/04/16/2021-3-5-leet-165-compare-version-numbers/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>给你两个版本号 version1 和 version2 ，请你比较它们。</p><p>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p><p>返回规则如下：</p><p>如果 version1 &gt; version2 返回 1，<br>如果 version1 &lt; version2 返回 -1，<br>除此之外返回 0。</p><p>示例 1：</p><p>输入：version1 &#x3D; “1.01”, version2 &#x3D; “1.001”<br>输出：0<br>解释：忽略前导零，”01” 和 “001” 都表示相同的整数 “1”<br>示例 2：</p><p>输入：version1 &#x3D; “1.0”, version2 &#x3D; “1.0.0”<br>输出：0<br>解释：version1 没有指定下标为 2 的修订号，即视为 “0”<br>示例 3：</p><p>输入：version1 &#x3D; “0.1”, version2 &#x3D; “1.1”<br>输出：-1<br>解释：version1 中下标为 0 的修订号是 “0”，version2 中下标为 0 的修订号是 “1” 。0 &lt; 1，所以 version1 &lt; version2<br>示例 4：</p><p>输入：version1 &#x3D; “1.0.1”, version2 &#x3D; “1”<br>输出：1<br>示例 5：</p><p>输入：version1 &#x3D; “7.5.2.4”, version2 &#x3D; “7.5.3”<br>输出：-1</p><p>提示：</p><p>1 &lt;&#x3D; version1.length, version2.length &lt;&#x3D; 500<br>version1 和 version2 仅包含数字和 ‘.’<br>version1 和 version2 都是 有效版本号<br>version1 和 version2 的所有修订号都可以存储在 32 位整数 中</p></blockquote><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><h3 id="1-切割比较"><a href="#1-切割比较" class="headerlink" title="1.切割比较"></a>1.切割比较</h3><p>思路：使用 strings.split() 函数，按 <code>.</code> 切割，再使用 atoi() 将切割好的字符转换为整形，并一一比较。</p><p>上面的问题：如果两个版本号长度不同，例如 1.0 和 1.0.0，切割出的数组分别为 [1, 0] 和 [1, 0, 0]，按下标逐一比较，会有一个出现越界异常</p><p>解决方法：对较短的数组进行扩充，使二者长度相同，扩充元素为 0，因为 0 不会对结果产生影响，例如上面的例子，可以将 1 扩充为 [1, 0, 0]，这样就可以安全比较了。</p><p><img src="https://zengh1.github.io/post-images/1618572799885.png"></p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compareVersion</span><span class="hljs-params">(version1 <span class="hljs-type">string</span>, version2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    v1arr := strings.Split(version1, <span class="hljs-string">&quot;.&quot;</span>)<br>    v2arr := strings.Split(version2, <span class="hljs-string">&quot;.&quot;</span>)<br>    <br>  <span class="hljs-comment">// 为较短数组填充 0，使两个数组的长度相同</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(v1arr) &gt; <span class="hljs-built_in">len</span>(v2arr) &#123;<br>        sub := <span class="hljs-built_in">len</span>(v1arr) - <span class="hljs-built_in">len</span>(v2arr)<br>        <span class="hljs-keyword">for</span> sub &gt; <span class="hljs-number">0</span> &#123;<br>            v2arr = <span class="hljs-built_in">append</span>(v2arr, <span class="hljs-string">&quot;0&quot;</span>)<br>            sub--<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(v1arr) &lt; <span class="hljs-built_in">len</span>(v2arr) &#123;<br>        sub := <span class="hljs-built_in">len</span>(v2arr) - <span class="hljs-built_in">len</span>(v1arr)<br>        <span class="hljs-keyword">for</span> sub &gt; <span class="hljs-number">0</span> &#123;<br>            v1arr = <span class="hljs-built_in">append</span>(v1arr, <span class="hljs-string">&quot;0&quot;</span>)<br>            sub--<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(v1arr); i++ &#123;<br>        <span class="hljs-comment">// 转换为整形比较，无需担心 001 这样的字符串，atoi() 会智能的将其转换为 1</span><br>        v1i, _ := strconv.Atoi(v1arr[i])<br>        v2i, _ := strconv.Atoi(v2arr[i])<br>        <span class="hljs-keyword">if</span> v1i &gt; v2i &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> v1i &lt; v2i &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-双指针"><a href="#2-双指针" class="headerlink" title="2.双指针"></a>2.双指针</h3><p>第一种方法比较直观易懂，但是需要额外的空间，还需要多次遍历，效率不是很高，而双指针法可以解决上述的问题。</p><p>思路：准备两个指针，分别置于两个版本号的开头，之后不断移动两个指针，直到都到达末尾。在移动的过程中，初始化两个变量 v1，v2 用于保存当前小版本号的值，如何获取小版本号的值呢？只需要使用 while 循环不断移动指针，当指针值为 <code>.</code> 时停止，每次循环都将 v1 &#x3D; v1 + 指针值 - ‘0’，</p><p><img src="https://zengh1.github.io/post-images/1618572818859.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compareVersion</span><span class="hljs-params">(version1 <span class="hljs-type">string</span>, version2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    l1, l2 := <span class="hljs-built_in">len</span>(version1), <span class="hljs-built_in">len</span>(version2)<br>    p1, p2 := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>  <span class="hljs-comment">// 获取最大值 </span><br>    <span class="hljs-keyword">var</span> maxFunc = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> x &gt; y &#123;<br>            <span class="hljs-keyword">return</span> x<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> y<br>        &#125;<br>    &#125;<br><br>    max := maxFunc(l1, l2)<br>    <span class="hljs-keyword">for</span> p1 &lt; max || p2 &lt; max &#123;<br>        <span class="hljs-keyword">var</span> v1, v2 <span class="hljs-type">int</span><br>      <span class="hljs-comment">// 使用 while 来循环读取一个小版本号（例如 1.111 中的 1 和 111 就是小版本号），</span><br> <span class="hljs-comment">// 遇到 . 停止，此时 vv1, vv2 的值即是小版本号，vv1 和 vv2 定义在外层 for 内，</span><br>        <span class="hljs-comment">// 每次比较后都会清零</span><br>        <span class="hljs-keyword">for</span> p1 &lt; l1 &amp;&amp; version1[p1] != <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br>            v1 = v1*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(version1[p1]) - <span class="hljs-string">&#x27;0&#x27;</span><br>            p1++<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> p2 &lt; l2 &amp;&amp; version2[p2] != <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br>            v2 = v2*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(version2[p2]) - <span class="hljs-string">&#x27;0&#x27;</span><br>            p2++<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> v1 &gt; v2 &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> v1 &lt; v2 &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        &#125;<br>        p1++<br>        p2++<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h2><h3 id="1-超出时间限制"><a href="#1-超出时间限制" class="headerlink" title="1. 超出时间限制"></a>1. 超出时间限制</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compareVersion</span><span class="hljs-params">(version1 <span class="hljs-type">string</span>, version2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    p1, p2 := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> p1 &lt; <span class="hljs-built_in">len</span>(version1) || p2 &lt; <span class="hljs-built_in">len</span>(version2) &#123;<br>        v1, v2 := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> p1 &lt; <span class="hljs-built_in">len</span>(version1) &amp;&amp; version1[p1] != <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br>            v, _ := strconv.Atoi(<span class="hljs-type">string</span>(version1[p1]))<br>            v1 += v<br>            p1++<br>        &#125;<br>        <span class="hljs-keyword">for</span> p2 &lt; <span class="hljs-built_in">len</span>(version2) &amp;&amp; version1[p2] != <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br>            v, _ := strconv.Atoi(<span class="hljs-type">string</span>(version1[p2]))<br>            v2 += v<br>            p2++<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> v1 &gt; v2 &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> v1 &lt; v2 &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里超时的原因是末尾没有 p1++ 和 p2++，当 p1 和 p2 都为 ‘.’ 时，p1 和 p2 将不会有任何改变，这会导致 while 条件一直满足，从而陷入死循环。</p><p>所以末尾的 p1++ 和 p2++ 就是用来保证当 p1，p2 都为 ‘.’ 时仍然会移动，防止死循环的发生。</p><h3 id="2-解答错误"><a href="#2-解答错误" class="headerlink" title="2. 解答错误"></a>2. 解答错误</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compareVersion</span><span class="hljs-params">(version1 <span class="hljs-type">string</span>, version2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    p1, p2 := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> p1 &lt; <span class="hljs-built_in">len</span>(version1) || p2 &lt; <span class="hljs-built_in">len</span>(version2) &#123;<br>        v1, v2 := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> p1 &lt; <span class="hljs-built_in">len</span>(version1) &amp;&amp; version1[p1] != <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br>            v, _ := strconv.Atoi(<span class="hljs-type">string</span>(version1[p1]))<br>            v1 += v<br>            p1++<br>        &#125;<br>        <span class="hljs-keyword">for</span> p2 &lt; <span class="hljs-built_in">len</span>(version2) &amp;&amp; version2[p2] != <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br>            v, _ := strconv.Atoi(<span class="hljs-type">string</span>(version2[p2]))<br>            v2 += v<br>            p2++<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> v1 &gt; v2 &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> v1 &lt; v2 &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        &#125;<br>        p1++<br>        p2++<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;1.1&quot;</span><br><span class="hljs-string">&quot;1.10&quot;</span><br></code></pre></td></tr></table></figure><p>这里错误的原因是因为对于小版本号只是单纯的相加操作，对于 1.10 的第二个小版本而言，结果为 1 + 0 &#x3D; 1，从而导致错误结果 1.1 &#x3D; 1.10，解决方法是将对应小版本号从 string 转为 int，具体方法是 v &#x3D; v*10 + s[i] - ‘0’。</p>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 11. 旋转数组的最小数字</title>
    <link href="/2021/04/16/2021-3-6-offer-11-retate-array-min-num/"/>
    <url>/2021/04/16/2021-3-6-offer-11-retate-array-min-num/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><p>示例 1：</p><p>输入：[3,4,5,1,2]<br>输出：1<br>示例 2：</p><p>输入：[2,2,2,0,1]<br>输出：0</p></blockquote><p>图片来源：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/</a></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618572544771.png"></p><p>从上图可以看出来，所谓的旋转数组，实质上是变成了两个有序数组，且左边的有序数组要大于右边的有序数组，所以右边的有序数组的第一个值，就是整个数组中的最小值。</p><p>二分查找，是通过每次缩短查找区间来减少查找的次数，但前提是数组必须是有序的，而旋转数组恰好破坏了数组的有序性，但这并不代表旋转数组就不能使用二分查找来解决问题了。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>还是和常规的二分查找一样，先创建两个指针（left 和 right），分别置于数组的第一个数（left）和最后一个数（right），并相加除以二求出中位</li><li>接下来判断中位属于哪个有序数组，是左边的还是右边的，具体的判断方法后面会提到</li><li>在确定了属于哪个有序数组后，就可以像普通的二分查找一样，去掉一部分的查找区间了，如何去除，后面会提到</li><li>不断更新指针，直到两个指针在同一位置</li></ol><p>1.如何判断中位属于左边还是右边？</p><p>如果中位值 <strong>大于</strong> right 的值，说明在左边数组<br>如果中位值 <strong>小于</strong> right 的值，说明在右边数组</p><p>例如：<br>[4, 5, 1, 2, 3]，中位值为 1，小于 right 3，所以在右边数组<br>[3, 4, 5, 1, 2]，中位值为 5，大于 right 2，所以在左边数组</p><p>2.在确定了中位所属数组后，如何缩短查找空间？</p><p>因为左数组要大于右数组，所以：</p><p><del>如果中位在右数组，那么可以直接去掉左数组，例如 [4, 5, <strong>1</strong>, 2, 3]，左数组 [4, 5] 是要大于右数组 [1, 2, 3] 的，所以可以直接去掉 4, 5 这两个元素，但其本身有可能是最小元素，所以不能去除。</del></p><p>如果中位在左数组，那么可以去掉其左边的所有元素以及它自己，因为左数组是要大于右数组的，例如 [3, 4, <strong>5</strong>, 1, 2]，可以直接将 3，4，5全部去掉  </p><p>如果中位在右数组，那么可以去掉其右边的所有元素，因为这些元素是一定比它大的，例如 [5, 1, <strong>2</strong>, 3, 4]，中位所处数组为 [1, 2, 3, 4]，它右边的 3 和 4 可以直接去除掉。</p><p>一种特殊情况：<br>[1, 0, <strong>1</strong>, 1, 1]，中位的值和 right 值相等，这时该如何处理呢？参照力扣的题解说法：遇到 <code>nums[mid] == nums[right]</code> 的时候，不能草率地下定结论最小数字在哪一边，但是可以确定的是，把 <code>right</code> 舍弃掉，并不影响结果。</p><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p>图片来源：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/</a></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618572639234.jpg"></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618572646946.jpg"></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618572651504.jpg"></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618572659962.jpg"></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618572665167.jpg"></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618572675768.jpg"></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618572683253.jpg"></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618572690139.jpg"></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618572697498.jpg"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minArray</span><span class="hljs-params">(numbers []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(numbers)<span class="hljs-number">-1</span><br><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        mid := (left + right) &gt;&gt; <span class="hljs-number">1</span><br>        <span class="hljs-comment">// 在第一个数组</span><br>        <span class="hljs-keyword">if</span> numbers[mid] &gt; numbers[right] &#123;<br>            left = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> numbers[mid] &lt; numbers[right] &#123;   <span class="hljs-comment">// 在第二个</span><br>            right = mid<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> numbers[left]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="错误记录-x2F-思考"><a href="#错误记录-x2F-思考" class="headerlink" title="错误记录&#x2F;思考"></a>错误记录&#x2F;思考</h2><p>为什么判断是否在第一个数组，必须用 mid 和 right 比较，而不能和 left 比较？比如 [3, 4, 5, 1, 2]，可以通过 mid &gt; right 得到在第一个数组，但同样也可以用 mid &gt; left 判断出同样的结果。</p><p>首先可以确定的是，mid 和 left 比较会出错，比如这个测试用例 [1, 1, 0, 1, 1]，两种比较方式结果如下图：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618572745215.png"></p><p>对于这样一种特殊旋转数组 [1, 2, 3, 4, 5] （即旋转了 0 个数），此时 mid 无法确定属于哪个数组，且也不符合之前的<strong>左数组大于右数组</strong>的条件，这种情况下，与 right 比较是安全的，这会将其分配到右数组 [3, 4, 5]，并将搜索区间转移到左部分 [1, 2, 3]。</p><p>如果与 left 比较，会错误的分配到右数组 [1, 2, 3]，并将这部分从搜索区间中去除，留下 [4, 5]，结果也显然意见是错误的。</p><p>综上，要避免与 left 比较。</p>]]></content>
    
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 68 - II. 二叉树的最近公共祖先</title>
    <link href="/2021/04/16/2021-4-3-offer-68-lowest-common-ancestor/"/>
    <url>/2021/04/16/2021-4-3-offer-68-lowest-common-ancestor/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点<br>p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖<br>先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:<br>root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618572470707.png"></p><p>示例 1:</p><p>输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4],<br>p &#x3D; 5, q &#x3D; 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p><p>示例 2:</p><p>输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4],<br>p &#x3D; 5, q &#x3D; 4<br>输出: 5<br>解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定<br>义最近公共祖先节点可以为节点本身。</p></blockquote><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><h3 id="方法1-递归"><a href="#方法1-递归" class="headerlink" title="方法1. 递归"></a>方法1. 递归</h3><p>这次不多 bb 直接上代码：</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> || root == p || root == q &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <span class="hljs-comment">// 记录左子树部分是否有 p 或 q，如果有，则 left 的值为 p 或 q 的某</span><br>    <span class="hljs-comment">// 一父节点（也有可能是 p 或 q本身），如果没有则为 null</span><br>    left := lowestCommonAncestor(root.Left, p, q)<br>    <span class="hljs-comment">// 记录右子树部分是否有 p 或 q，如果有，则 left 的值为 p 或 q 的某</span><br>    <span class="hljs-comment">// 一父节点（也有可能是 p 或 q本身），如果没有则为 null</span><br>    right := lowestCommonAncestor(root.Right, p, q)<br><br>    <span class="hljs-comment">// left 为空，说明左子树部分没有 p，q，返回 right，即在右子树部分</span><br>    <span class="hljs-comment">// 找到的结果</span><br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> right<br>    <span class="hljs-comment">// 同理如上    </span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> left<br>    &#125;<br>    <span class="hljs-comment">// left 和 right 都不为空，说明 p，q 在异侧，此时当前节点 root </span><br>    <span class="hljs-comment">// 就是它们的公共父节点</span><br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="递归分析"><a href="#递归分析" class="headerlink" title="递归分析"></a>递归分析</h4><h5 id="递归流程图"><a href="#递归流程图" class="headerlink" title="递归流程图"></a>递归流程图</h5><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618572490386.png"></p><h5 id="递归过程"><a href="#递归过程" class="headerlink" title="递归过程"></a>递归过程</h5><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618572503501.png"></p><p>（勘误：p&#x3D;7，q&#x3D;4 这一步的图片流程的第 2 步，应该是：说明该节点在其右子树，图片中错误的写成了：说明该节点在其左子树，这里懒得再修改图片了，直接文字说明）</p><h5 id="文字分析"><a href="#文字分析" class="headerlink" title="文字分析"></a>文字分析</h5><p>递归解析：</p><ol><li>终止条件：<ol><li>当越过叶节点，则直接返回 null；</li><li>当 root 等于 p, q，则直接返回 root；</li></ol></li><li>递推工作：<ol><li>开启递归左子节点，返回值记为 left；</li><li>开启递归右子节点，返回值记为 right；</li></ol></li><li>返回值： 根据 left 和 right ，可展开为四种情况；<ol><li>当 left 和 right 同时为空 ：说明 root 的左 &#x2F; 右子树中都不包含 p,q ，返回 null；</li><li>当 left 和 right 同时不为空 ：说明 p, q 分列在 root 的 异侧 （分别在 左 &#x2F; 右子树），因此 root 为最近公共祖先，返回 root；</li><li>当 left 为空 ，right 不为空 ：p,q 都不在 root 的左子树中，直接返回 right 。具体可分为两种情况：<ol><li>p,q 其中一个在 root 的 右子树 中，此时 right 指向 pp（假设为 pp ）；</li><li>p,q 两节点都在 root 的 右子树 中，此时的 right 指向 最近公共祖先节点 ；</li></ol></li></ol></li><li>当 left 不为空 ， right 为空 ：与情况 3. 同理；</li></ol><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/">参考</a></p><p>递归在向上<code>归</code>时，会不断根据当前条件，更新返回的信息（参考递归过程图）</p><h3 id="方法2-搜索根节点到-p，q-的路径，再求两条路径的最后一个相同节点"><a href="#方法2-搜索根节点到-p，q-的路径，再求两条路径的最后一个相同节点" class="headerlink" title="方法2. 搜索根节点到 p，q 的路径，再求两条路径的最后一个相同节点"></a>方法2. 搜索根节点到 p，q 的路径，再求两条路径的最后一个相同节点</h3><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go">    <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">var</span> path, pp, qq []*TreeNode<br>    <span class="hljs-keyword">var</span> flag <span class="hljs-type">bool</span><br>    findPath(root, p, &amp;path, &amp;pp, &amp;flag)<br>    <br>    flag = <span class="hljs-literal">false</span><br>    path = path[<span class="hljs-number">0</span>:<span class="hljs-number">0</span>]<br>    findPath(root, q, &amp;path, &amp;qq, &amp;flag)<br><br>    size := min(<span class="hljs-built_in">len</span>(pp), <span class="hljs-built_in">len</span>(qq))<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> ; i &lt; size; i++ &#123;<br>        <span class="hljs-keyword">if</span> pp[i] == qq[i] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pp[i<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPath</span><span class="hljs-params">(root, need *TreeNode, path, res *[]*TreeNode,</span></span><br><span class="hljs-params"><span class="hljs-function">              flag *<span class="hljs-type">bool</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> || *flag &#123;<br>        <span class="hljs-keyword">return</span> <br>    &#125; <br>    *path = <span class="hljs-built_in">append</span>(*path, root)<br>    <span class="hljs-keyword">if</span> root == need &#123;<br>        *flag = <span class="hljs-literal">true</span><br>        <span class="hljs-comment">//*res = *path</span><br>        <span class="hljs-comment">//fmt.Println(res)</span><br>        news := <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-built_in">len</span>(*path))<br>        <span class="hljs-built_in">copy</span>(news, *path)<br>        <span class="hljs-comment">//fmt.Println(news)</span><br>        *res = news<br>        <span class="hljs-keyword">return</span> <br>    &#125;<br>    <br>    findPath(root.Left, need, path, res, flag)<br>    findPath(root.Right, need, path, res, flag)<br><br>    *path = (*path)[:<span class="hljs-built_in">len</span>(*path)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; y &#123;<br>        <span class="hljs-keyword">return</span> x<br>    &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br></code></pre></td></tr></table></figure><p>算法的思路已经写在标题里了，分析可以参考文章 <a href="https://autsu.github.io/post/2021-3-27-find-binaryTree-root-to-node-path/">求二叉树根节点到指定节点的路径</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>二叉树</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 46.全排列【未完】</title>
    <link href="/2021/04/16/2021-4-6-leet-46-quan-pai-lie/"/>
    <url>/2021/04/16/2021-4-6-leet-46-quan-pai-lie/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><h3 id="方法1-回溯法，使用-bool-数组记录每个数是否被访问"><a href="#方法1-回溯法，使用-bool-数组记录每个数是否被访问" class="headerlink" title="方法1 回溯法，使用 bool 数组记录每个数是否被访问"></a>方法1 回溯法，使用 bool 数组记录每个数是否被访问</h3><p>（比较抽象的一张图，是我第一次学习全排列时边学边画的，当时对递归这个东西还完全理解不了，不过通过画这张图总算是理解一些了，感觉学算法画画图还是挺有助于理解的）</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618572434875.png"></p><p>cpp 版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">bool</span>&gt; visit;<br>        <span class="hljs-comment">// error: load of null pointer of type &#x27;std::_Bit_type&#x27;</span><br>        <span class="hljs-comment">// need init bool vector</span><br>        visit.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>); <br>        vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>        <span class="hljs-built_in">backtrack</span>(nums, temp, visit, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; temp, </span></span><br><span class="hljs-params"><span class="hljs-function">                   vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visit, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (temp.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (visit[i]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            temp.<span class="hljs-built_in">emplace_back</span>(nums[i]);<br>            visit[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtrack</span>(nums, temp, visit, res);<br>            visit[i] = <span class="hljs-literal">false</span>;<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>go 版本：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br>    temp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>    isvisited := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(nums))<br>    BackTrack(isvisited, temp, nums, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BackTrack</span><span class="hljs-params">(isvisited []<span class="hljs-type">bool</span>, temp []<span class="hljs-type">int</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">               nums []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(temp) == <span class="hljs-built_in">len</span>(nums) &#123;<br>        newTemp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(temp))<br>        <span class="hljs-built_in">copy</span>(newTemp, temp)<br>        *res = <span class="hljs-built_in">append</span>(*res, newTemp)<br>        <span class="hljs-keyword">return</span>  <span class="hljs-comment">// 这里可以直接 return 了，没必要再走下面的循环了</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> isvisited[i] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        temp = <span class="hljs-built_in">append</span>(temp, nums[i])<br>        isvisited[i] = <span class="hljs-literal">true</span><br>        BackTrack(isvisited, temp, nums, res)<br>        temp = temp[:<span class="hljs-built_in">len</span>(temp)<span class="hljs-number">-1</span>]<br>        isvisited[i] = <span class="hljs-literal">false</span>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法2-回溯法，使用-swap"><a href="#方法2-回溯法，使用-swap" class="headerlink" title="方法2 回溯法，使用 swap"></a>方法2 回溯法，使用 swap</h3><p>swap 的方式相比方法 1 要简洁一些，也比较好理解，效率也高一些。</p><p>代码如下：</p><p>cpp 版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> first, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (first == vec.<span class="hljs-built_in">size</span>()) &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = first; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-built_in">swap</span>(vec.<span class="hljs-built_in">at</span>(i), vec.<span class="hljs-built_in">at</span>(first));<br>            <span class="hljs-built_in">backtrack</span>(vec, first+<span class="hljs-number">1</span>, res);<br>            <span class="hljs-built_in">swap</span>(vec.<span class="hljs-built_in">at</span>(i), vec.<span class="hljs-built_in">at</span>(first));<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>go 版本：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span><br>    backtrack(nums, <span class="hljs-number">0</span>, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, first <span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> first == <span class="hljs-built_in">len</span>(nums) &#123;<br>        news := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br>        <span class="hljs-built_in">copy</span>(news, nums)<br>        *res = <span class="hljs-built_in">append</span>(*res, news)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := first; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        swap(nums, first, i)<br>        backtrack(nums, first+<span class="hljs-number">1</span>, res)<br>        swap(nums, first, i)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, i, j <span class="hljs-type">int</span>)</span></span> &#123;<br>    nums[i], nums[j] = nums[j], nums[i]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>采用 go test benchmark，结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// BenchmarkBool-8    2581156       437.1 ns/op</span><br><span class="hljs-comment">// BenchmarkSwap-8    1999869       573.2 ns/op</span><br><span class="hljs-comment">// BenchmarkSwap-8    2313684       440.1 ns/op</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkSwap</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>n := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>permute(n)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// BenchmarkBool-8     999951      1029 ns/op</span><br><span class="hljs-comment">// BenchmarkBool-8    1098356       963.6 ns/op</span><br><span class="hljs-comment">// BenchmarkBool-8    1248417       927.0 ns/op</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkBool</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>n := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>permute1(n)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>回溯法</tag>
      
      <tag>全排列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 04. 二维数组中的查找</title>
    <link href="/2021/04/16/jian-zhi-offer-04-er-wei-shu-zu-zhong-de-cha-zhao/"/>
    <url>/2021/04/16/jian-zhi-offer-04-er-wei-shu-zu-zhong-de-cha-zhao/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例：</strong></p><p>现有矩阵 matrix 如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,   4,  7, 11, 15]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,   5,  8, 12, 19]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,   6,  9, 16, 22]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[10, 13, 14, 17, 24]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[18, 21, 23, 26, 30]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p>给定 target &#x3D; 5，返回 true。</p><p>给定 target &#x3D; 20，返回 false。</p><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= n &lt;= <span class="hljs-number">1000</span><br><span class="hljs-symbol">0 </span>&lt;= m &lt;= <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>因为矩阵是从上往下、从左往右递增的，所以可以选择左下角或者右上角为起始点：</p><p><img src="https://zengh1.github.io/post-images/1618571896492.png"></p><p>算法流程：</p><p>从起始点 m[a] [b]  开始判断，如果是 <strong>右上角</strong>，若当前值 <strong>大于</strong> target，则可以 b– 去掉 <strong>当前列</strong> ，若当前值 <strong>小于</strong>  target，可以 a++ 去掉 <strong>当前行</strong> ，左下角也类似</p><p>图解，这里借用一下别人的：</p><p>作者：jyd<br>链接：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/</a></p><p><img src="https://zengh1.github.io/post-images/1618571965271.jpg"></p><p><img src="https://zengh1.github.io/post-images/1618571980921.jpg"></p><p><img src="https://zengh1.github.io/post-images/1618571989060.jpg"></p><p><img src="https://zengh1.github.io/post-images/1618571995996.jpg"></p><p><img src="https://zengh1.github.io/post-images/1618572003332.jpg"></p><p><img src="https://zengh1.github.io/post-images/1618572009814.jpg"></p><p>结合上面的图示，这道题的思路还是比较好理解的，但是代码并不好写，主要是 while 条件比较难把握，很容易出错，比如对于以下测试用例： </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">// 越界<br><span class="hljs-string">[[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]]</span><br><span class="hljs-number">20</span><br><br>// 不执行 <span class="hljs-keyword">while</span>，直接返回 <span class="hljs-literal">false</span><br><span class="hljs-string">[[-5]]</span><br><span class="hljs-number">-5</span><br></code></pre></td></tr></table></figure><p>具体分析如下：</p><p><img src="https://zengh1.github.io/post-images/1618572038320.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>起始点在左下角：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(matrix) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <br>    i, j := <span class="hljs-built_in">len</span>(matrix)<span class="hljs-number">-1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> flag <span class="hljs-type">int</span><br><br>    <br>    <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) &#123;<br>        flag = matrix[i][j]<br>        <span class="hljs-keyword">if</span> flag &gt; target &#123;<br>            i--<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> flag &lt; target &#123;<br>            j++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>起始点在右上角：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(matrix) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">var</span> flag <span class="hljs-type">int</span><br><br>    <span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(matrix) &amp;&amp; j &gt;= <span class="hljs-number">0</span> &#123;<br>        flag = matrix[i][j]<br>        <span class="hljs-keyword">if</span> flag &gt; target &#123;<br>            j--<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> flag &lt; target &#123;<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        <span class="hljs-comment">//fmt.Printf(&quot;i -&gt; %d  j -&gt; %d\n&quot;, i, j)</span><br>        <span class="hljs-comment">//fmt.Println(&quot;flag: &quot;, flag)</span><br>        <span class="hljs-comment">//flag = matrix[i][j]</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>数组</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 48. 最长不含重复字符的子字符串</title>
    <link href="/2021/04/16/jian-zhi-offer-48-zui-chang-bu-han-chong-fu-zi-fu-de-zi-zi-fu-chuan/"/>
    <url>/2021/04/16/jian-zhi-offer-48-zui-chang-bu-han-chong-fu-zi-fu-de-zi-zi-fu-chuan/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p>示例 1:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>         请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串<br></code></pre></td></tr></table></figure><p>提示：</p><p>s.length &lt;&#x3D; 40000</p></blockquote><h4 id="方法1：滑动窗口"><a href="#方法1：滑动窗口" class="headerlink" title="方法1：滑动窗口"></a>方法1：滑动窗口</h4><p>通过双指针 + 哈希表实现，算法思路如下：</p><ol><li>初始化两个指针 i 和 j，同时指向第一个字符</li><li>i 指针不动，j 指针不断前进，每次前进都更新其在 map 中的值（值是下标），同时计算最大窗口值</li><li>如果 j 在移动过程中遇到重复元素（在 map 中已存在），则将 i 移动到 max(i, map[重复元素]+1) 处，这里为什么要比较大小，后面会解释</li><li>当 j 大于字符串长度时，结束循环，返回最大窗口值</li></ol><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618559975600.png"></p><p>对应代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>i, j, maxl := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>)<br><br><span class="hljs-keyword">for</span> j &lt; <span class="hljs-built_in">len</span>(s) &#123;<br>cur := s[j]<br><span class="hljs-comment">// 当前字符重复</span><br><span class="hljs-keyword">if</span> _, ok := m[cur]; ok &#123;<br><span class="hljs-comment">// 移动 i 到重复元素下标+1 处，如果当前位置下标大于 m[cur]+1，则不移动</span><br>i = max(i, m[cur]+<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-comment">// 如果当前长度更大，则更新最大长度</span><br>maxl = max(maxl, j-i+<span class="hljs-number">1</span>)<br>m[cur] = j<br>j++<br>&#125;<br><span class="hljs-keyword">return</span> maxl<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123;<br><span class="hljs-keyword">return</span> a<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> b<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 执行用时: 8 ms</span><br><span class="hljs-comment">// 内存消耗: 3.1 MB</span><br><br></code></pre></td></tr></table></figure><h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><p>当元素重复时，为什么 i 要移动到 max(i, m[cur]+1) 处，而不是直接移动到 m[cur]+1 处？</p><p>刚开始写的时候，我就犯了这个错误，写下了如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    i, j := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>)<br>    maxl := <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> j &lt; <span class="hljs-built_in">len</span>(s) &#123;<br>        char := s[j]<br>        <span class="hljs-keyword">if</span> _, ok := m[char]; ok &#123;<br>            i = m[char] + <span class="hljs-number">1</span><br>        &#125; <br>      maxl = max(maxl, j-i)<br>        m[char] = j<br>        j++<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> maxl<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试用例：abba，正确结果应该是 2 ，但是上面代码执行却诡异的返回了 3，通过画图分析后才知道了原因所在：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618560095136.png"></p><h4 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    i, j := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>)<br>    maxl := <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> j &lt; <span class="hljs-built_in">len</span>(s) &#123;<br>        char := s[j]<br>        <span class="hljs-keyword">if</span> _, ok := m[char]; ok &#123;<br>            maxl = max(maxl, j-i)<br>            i = m[char] + <span class="hljs-number">1</span><br>        &#125; <br>        m[char] = j<br>        j++<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> maxl<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试用例：</p><p>au预期：2输出：0</p><p>原因：更新最大长度语句写在了 if 内，只有字符重复时才会执行，对于 au 这个没有重复字符的 string，该语言始终不会执行，所以最后会返回 0</p><p>“ “预期：1输出：0</p><p>原因：还是和上面一样的情况。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第一次做这道题的时候是毫无头绪的，因为当时并不知道滑动窗口是什么东西，在看了题解后，照猫画虎，大致摸清了算法思路，但对于一些特殊语句，比如 if 中的 max(i, m[s[j]]+1)，却没有很好的理解，只是知道这句话不这样写，答案就不会正确。</p><p>这次二刷，则是先大致回想一下之前记忆里的思路，并尝试在不看原来正确代码的情况下，先自己写写，结果就发现了很多问题，一些测试用例无法通过，这时再结合之前的正确代码，比较自己写的代码的缺陷并改正，对于特殊语句也理解清楚了。</p><p>所以这道题给我的感悟就是，做题还是得自己动手实践才能真正理解，只是看别人的代码，很有可能会处于半知半解状态。算法题就是这样，往往你以为自己做对了，实际并没有，就是有几个刁钻的测试用例过不去，只要有 1 个测试过不去，就说明这个代码写的是有问题的，这个时候再结合错误仔细分析，查找发现有问题的地方，就能更好的理解代码。如果只是看别人的，少了发现并改正错误的过程，对代码的理解也会不够透彻，。</p><p>总的来说，在不会做的情况下可以看别人的题解，学习方法和思路，但不能只看不写，要试着将别人的思路转换成自己的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>剑指offer</tag>
      
      <tag>哈希表</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 50. 第一个只出现一次的字符（书中为35题）</title>
    <link href="/2021/04/16/jian-zhi-offer-50-di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-shu-zhong-wei-35-ti/"/>
    <url>/2021/04/16/jian-zhi-offer-50-di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-shu-zhong-wei-35-ti/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p><strong>示例:</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abaccdeff&quot;</span><br>返回 <span class="hljs-string">&quot;b&quot;</span><br><br><span class="hljs-attribute">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span> <br>返回 <span class="hljs-string">&quot; &quot;</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= s 的长度 &lt;= <span class="hljs-number">50000</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="方法1：哈希表"><a href="#方法1：哈希表" class="headerlink" title="方法1：哈希表"></a>方法1：哈希表</h4><p>可以将哈希表的 key 定义为 char，用来存储 string 的每个字符；value 定义为 int ，用来记录字符出现的次数，或者定义为 bool，用来标识字符是否重复出现，因为 bool 的方式相对简单明了，也并不需要频繁对变量进行自增操作，所以这里选择 bool，false 代表未重复出现。</p><p>由于 go 的 map 是无序的，遍历出的第一个 value 为 false 的字符，在字符串中未必是第一个，所以只能通过二次遍历字符串，判断每个字符在 map 中对应的值，并返回第一个值为 false 的字符。 </p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">byte</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">rune</span>]<span class="hljs-type">bool</span>)<br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> s &#123;<br>        <span class="hljs-keyword">if</span> _, ok := m[char]; ok &#123;<br>            m[char] = <span class="hljs-literal">true</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        m[char] = <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> s &#123;<br>        <span class="hljs-keyword">if</span> !m[char] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">byte</span>(char)<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">32</span><br>&#125;<br><br><span class="hljs-comment">// 执行用时: 48 ms</span><br><span class="hljs-comment">// 内存消耗: 5.3 MB</span><br></code></pre></td></tr></table></figure><h4 id="方法2：使用数组代替哈希表"><a href="#方法2：使用数组代替哈希表" class="headerlink" title="方法2：使用数组代替哈希表"></a>方法2：使用数组代替哈希表</h4><p>这是 《剑指offer》 中提供的方法，虽然哈希表可以很好地解决问题，但是对于一个只有小写字母的字符串来说（题目中说明了）来说，杀鸡焉用宰牛刀，可以用一个长度为 26 的数组，建立一个简单的哈希表即可，用字符的 ascii 减去 97 作为下标，值为出现的次数，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">byte</span> &#123;<br>    n := [<span class="hljs-number">26</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> s &#123;<br>        n[char<span class="hljs-number">-97</span>]++<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> s &#123;<br>        <span class="hljs-keyword">if</span> n[char<span class="hljs-number">-97</span>] == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">byte</span>(char)<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">32</span><br>&#125;<br><br><span class="hljs-comment">// 执行用时: 8 ms</span><br><span class="hljs-comment">// 内存消耗: 5.3 MB</span><br></code></pre></td></tr></table></figure><p>执行用时只有原来的 1&#x2F;6，这个结果可能不是很准确，但是相对哈希表而言，少了哈希计算、处理哈希冲突等等操作，效率肯定要好一些的。通过这道题也使我明白了，不要无脑使用 map，在一些特殊条件下，往往会有更简单高效的解决方法。</p><h4 id="方法-3：-有序哈希表"><a href="#方法-3：-有序哈希表" class="headerlink" title="方法 3： 有序哈希表"></a>方法 3： 有序哈希表</h4><p>如果哈希表有序，则可以遍历哈希表，找到第一个值为 fasle 的字符，但 go 中没有提供有序 map，所以这里使用一个 slice 来按顺序保存 key ，之后遍历这个 slice 即可，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">byte</span> &#123;<br>    sli := <span class="hljs-built_in">make</span>([]<span class="hljs-type">rune</span>, <span class="hljs-number">0</span>)<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">rune</span>]<span class="hljs-type">bool</span>)<br><br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> s &#123;<br>        <span class="hljs-comment">// map 中没有该 char，则 append 到 slice 中</span><br>        <span class="hljs-keyword">if</span> _, ok := m[char]; !ok &#123;<br>            sli = <span class="hljs-built_in">append</span>(sli, char)<br>        &#125;<br>        <span class="hljs-keyword">if</span> _, ok := m[char]; ok &#123;<br>            m[char] = <span class="hljs-literal">true</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        m[char] = <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-comment">// 遍历 slice</span><br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> sli &#123;<br>        <span class="hljs-keyword">if</span> m[char] == <span class="hljs-literal">false</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">byte</span>(char)<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">32</span><br>&#125;<br><br><span class="hljs-comment">// 执行用时: 48 ms</span><br><span class="hljs-comment">// 内存消耗: 5.3 MB</span><br></code></pre></td></tr></table></figure><p>不过该方法看起来并没有显著提高效率。</p><h4 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">byte</span> &#123;<br>  <span class="hljs-comment">// 这里错误的将 value 设置为 byte 类型，最大值只有 255，255 + 1 会被重置为 0</span><br>  <span class="hljs-comment">// 也就是说如果一个数出现了 257 次，则它的值会变为 1</span><br>    n := [<span class="hljs-number">26</span>]<span class="hljs-type">byte</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> s &#123;<br>        n[char<span class="hljs-number">-97</span>]++<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> s &#123;<br>        <span class="hljs-keyword">if</span> n[char<span class="hljs-number">-97</span>] == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">byte</span>(char)<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">32</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>例如下面这个刁钻的测试用例，它的正确结果应该是 “y”，但是上面的代码却返回了 “n”，原因就是 n 出现了 257 次，值变为了 1，而字符串中 n 又比 y 先出现，导致错误地返回了 n。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;uindrseqbljlhqvlwvgdebeihttirikuahlikgnahvgnptmqwbovmuwesxkvcitcwrwrucsbbfqvldridfviduqvmfcmeiphoqupbitnwdbvevouoaetisdmgvvvwoglwtgjrpcbghxkrkjthetxeexbphbjiehaicuicgnirslhdstgmqcdnlulpdpadjdltfouwhfqicfcqntnpeqaohslwkhbvflxaudembsrsindluthxapnmrqinsivbxmkohubvmmmpmklbfrmeuvdrhptdmelmjjefgbsqqlbqhvsmswwxrlkutadqbbeisbgfrcivvoxmxxptrscxnjjvtajfhqiucdihihcutxhlonlomfdnbwanrcnbarojsajseqrgkuqgkcnvrghxnmbclfomktwfaakodeecsglufvobkgoqsbrhdiuhxqbcndkmxuertupngvnkgwrfwgdbiurbooxariklwarjgavsuddoveipltessrssxwxgvrrtkisnbavkbpaphicxhapjjpkccakepuafjdaswfwfmbdmuuaveukxvnpkgmhcjcpqntssthjlvrngugbhrivtwmbrvrprrlfmvwjdkonfmgnepqoxwfcvefjihisarwskjfmqrjlkbbugfawmkqgfxgpokkxxivqbqimwsccdekjegwcxhmmuhpstxfpofwmrmhrxeptxwbvxsesheijjfsshgrrwckjkmbslpbngnwhokjnujtiepfrdhiwwgbffixaidabacaibummwxgxowsewlqfxrkarjrkqxmxwobqbcoowmbggtpoqadhqdxlhvxrkfuwpxxgnchudreoeuefkqhlrmwwfvjexvbxdhtdngwvoohpjtdbdbesceiafrhenfljleegsencfmbauxlltfueudnjxsiiggsfwiuidgktsbtcvxtdllviocfdbonjciosucbjidwxnogmnveqkcrxbpamfxwxiugjgrfpstromuxxdiodqeoqdlfulttraquskhwfholbrcbchijlgqvuwxvejedikvgetlmrcmeampdgjvmbdovkcjilbralhmniwvbeandldnudkpjvhoqtfdwllridwljfvflfdrbqadvabggwsiexrthrngexpebuhtefkqgkkjoopsmunesfotsprxuaswwenhkdvsspkppulecahkkvccqngeaoijjgvsfqfpvphvhdnkkcqsebhijkvfpqjmarbkpejagtbtisnflrrvawmvfxeccxtrmorihgslxlqrqcmouojjfhcieuwlrcqhevmveookgonxqdbtgqjimsidnaaiuchwkfkpxfptuvhfqemojixqvhgokdekdwbomptqqlfiaiptxvgfmovdqxupjxjpoxuplsagxpgpmvtcpawkrrthvclhdbpqeucchxptdceswhnqocmeocpgthkgxmxggwlnantwwuoqpmnpvgateitxlocmhnihmfgjnvrggenbhnjfubtoteojojjkjpcnwqthxhlfukingjletwnxdnjwrgjopqoxtqcvwsakqxxumbtcblufdmdvxfkshitenmenkxjvblsoiyhjpakinimwxhcebabgsvqftfvwjnstltjawhwipkubadtoxqrutkwxjnmfoowtnvqplvqokcuwlkmxxhboampcdwokjfxggtnojebagxlwaeowtomubtbfsrufkttugfpnxmipkcsphqafjuxovwpcgonhiqmomsweunoeqkpkxxsdksmufowqpmkontccckcdbwrfwamikananakgjkahndrepemcgxecgpltvdbpoexemnrejdephuuxhfcubxlbdrmhvmeqmtdhnbkwnidigxdantmkckijiecavkpumegrbveffclcltmibjcstrrauphfxxssgxkkirapiihnlbrodvfostahqdkajqtrrfwdsemwxlucbbjjspnnqjnpnpmimhulgoskwpsactexmkfdhaihnlggqeunqevxfrpiwskhrhgfluelshqejavomjshfomvgpugqesbtakvxqwrtguuebcgqphocglfrircfvuikfbviomfrsnpvvlftwrkbmjpvdpgvohtmxcxwnuhwojnfvsfwvdlaxxlmafihpussffcawjpaxdwerwfbvsbipljualcnhseealvqiqfiaiskaafufaubvhjglktfhbdsaskmedroxkrxshnggumcbtdcablawkodmnafkjekuiecqlvbxocfcwipaicgndfafjhtjcelakrecmntjxeqjqgxkxapuobbcaxfrpsktjswxdfvugmmgjwiphnsclqwmranthpiueffaxvhplajqsrtoxbixbdpcfkbpkjkelemubwachcpxcniaqmkmasmvlfcubcdkxfkupgcgbrvmbmgnjgfbawmmdritdrkppswatwtdjemhifhmshunkvaivhteqnwkdcrpfxmrafupfhbgligbvrqjkvcgbiqudvtblhfgetffduvsfhsmjimgruxrvbqniluapaoniwhqhltbxvrphmlisfaomqoecmdbbrgujgsbdelkbddcgmpggogfonssxisphbwljlvhwhewmpqugxgbubqfeilobxxhtcxmxvjtbuavxlaghhjiemihvrsjxbleutpuumgndtnocwkpkdaupbmcsahcbwoelmgnwqummmekwhpahtdvehoprfcciwqphfwppscruimikiximhbkdomovbdalsihioncpaclevxawqcqthtmuogolkrvlipropmnmecttmlecpapdlrcqxopfjobgsvhcadqiudqjoscpvjguddnorldkpqtoocrtkcutkvdpbkkekenpqjmxmuxccamkwwxrdrbdmameptvcgsltqdasicoouvdtbranexokmtkioptqblrruaihvfvvebjigkuwwgearxvmimlgmxgpvbnotepprknjxcunheclsvxxmmoufvdhrwxqlrkmvcaxtbiqrjrnrsfrkvttnpxbspnetcofhpcbcphrchivnrskkalsvdllhtisnaerxbcxutcpmnquwrutmmvrtchhheplhdmbfkrrrxalosjbebtdqtsjbdcuuatgldnubigijbkehxsmhsadwtcbwinlnilthiqslvsduspkjuunpetcofujbqhtkmalnjmllhulckqodbgffxdiqjajecbmlekvepkirxnguqnpnfjdptinuphcoxkoqhqrmkkawmngqwvfpcuxgpekkprupplsbwshmsduaitlhcjargacduewtqgnxbtpwrkawpncarxlsnardkftmsdjflmhoplghandjisupacixxthwokctbxekqwbmhtoutgrogxsdnmcaqrsqrpigbigqhsmrksxgkdbdbxkwimpehltcffuhrphbaqgvabjduudbrxgwiljkwijvaugnleamskjijhnvcspagsfnhjielrvxddxqfgaipfflffksmvgaioaclfsjhovcotoaiwhhnmrudsqmsepsgdofnxjjcgdejutmdtgauuvuepajlikebtpgfimudswplfwgaodtwqjuaujlbqqartevsqesmrpknoanfprqcwochqdrcvquovtsogptduvfiaislfvpxwsqitodxwckprpfxtqhbdixklhtsajqgbinfpdqaehrwhnwggmggnbstolrcbmlhpfjurbknpwbrfhvdanrjcwnvsxudagbkhdlwujqvwpbbgmsfrkgutkqwxqfemaaokrfdocsbbktwaugoadgvqcdhmqkworbvxqwdpmbjkqghmapevrsnaaparwnbvcfnhhgfqplfwiswrxxistamulcbxcmvkbcxsgftbmbvqlxrhbmcujkktdvcgnjkfaclxndtjkdbgqvbqxicgmpowbjsfvspvxtrovjwbbkaapfgcqbifdosnmutvfbgdmhiqvflasedhafqnmrlmwbuhmptnkvvojnjngiepmdktewwsuxernpfmktsgwwnxfvmuotpfxfntcrsjpldmringfpkpievvbgbghevlmuticukrfvahrmtkvckjbxxrmkilbeojsxgbvbhsgvkhgtjddoreipbkwiqbkecobfexswiwttlohnfwokixfmfrpadtudrssiobbvhctpbeesiogwhdqojoalxpxikwuheilvsrxbfbnckjeswhkfviihvwrfxkxcomhvsjojhltospooumkstqqnvxmrowlrtufhxkipxnfecchklrqljfwnglxeharemawsbvnuentnapewjhnzbieisjtomdqtjkigisgopmgcfqxcxninrisupchhmfrosxgdtakhrrnbbnxovvbfjgwdgnlxoxswhsfjeijvivqemoekkmrttscthlpglaorarhibrucuhikfkphqmhowloobeumlikqmmlatesupiekwjhdvntnjbakohrbobimmujkbatfxpmgfmmqsgwsffcbenwgdrhlqrsmfghevnjfdlxupihmkptsefubmixhacnxngpjrckxhvhrelolqwevoqklhxbplakmsxdetvpuddmvaodpglmsknbvfftstckjurbntwqenuhcurxqvotrxfpootqkobeatoduihwhpjxxrvboggkcxagnrrfwfuaqplirlnafprumnkcjxlpvanfmqwuoaupqptqeulpwvnhbahbkihustenkbdushjakemufdhjllnowmvgpdxbrhxfonpgcjslvwgdmajicqqmdxubrofvdodfsedjghpbjncgkckeudxwascljlraoodwvgpvojcqgbalntslsfrwnfcdvidsdrvwhscskpalubxeobapkgpdsqcjpwkednraijmbcreplwijofniggavpdlwfmwnvsaridhbppeolakquhamneffnfmbruivassdaaikxiaxupgdpgkfojvkkagcsmqnweofwikvevrsottkbtcldoruakajinnlgxmpddcrmohaktsdrxjelrbmfdthspikxeocqqdordrqwjtaxihswcubtfomksaxddcvtadnrtqkmdnacgduudtdbhsgpfomrdiaotcfwqlxccqeelgtnkflgixpjcriroruhbbgpidwkggdevpfratqebewaxcudseaikqjuuhpsguvtwxniofskkslfnrphatmxngneuituefcxufisrsjitqxwufrgidbwlmkrqojpwpljasaiukwwthrudhcocoguerakhajdncxbrnuavoqeuwsamwdqgutbaoixcgeibpoajhedooqcewiqvddedmanxljjjcbojgbmwabkfbvamgnfpncdcxoaqhmgurifpwpgrpctlqpwmqraknjltneknsphtwbnbiahknxipsovljkivlpggvldeveeopvoqlvfjbratadttlcecomllpkdgiloeedquivsnmxkfcvrkwaohgbrbvjklkktgwtlfgafqgbigheajrvffvvkkmibcedfmnwasopoqgxjohjoqnijeaifuwiwmogkwqlfmibuwecvnulvhkbsukscqlqlsxjulillmlgjkrbmllcunhbqmbujftqgkpwkvemthigednfohxpsduotwfnknfjbexflcfieaosnlhndsorbkcdlahovwbccshmrlcofowrmqajluiqaarnqtxokbaddswftiexiahmstpbonwmhvqgcpmfrocvtwfhjrtsupscfmvwfvaoolanrlgdsvgoseltdnoxrdglockhwlvffaakgrxjfnfbxnbprfvpwmexnhfekjnkenbohhmwlqoteiwgtjsrnceptbgwkfcmtkliwwqskmsoihmnbjsvnmfkwbwemijdtpnajgrousbrdaagenqlgeaiixfgcbfhceaxkwxbpksfouuqcvcerqecpdtvtsubbadmaatdnmnqhladeiapejkxffoagbwqbvppssvvvhlvhntatxlvqgjxbejpvxemqbdjknuogumrwbognklmvjsldrktpeowiuaapbjgktxwfjiferxgmafbcerteqlvpqvxbgdwiufdctkwptadtujmifppudubpmdtiedmqhnihquansnjufpbuumhhmidphkwusjdsdaocavtauhsvtgcoqhufmacwcbxvjmagkounkoqpcnoanhgwsjvgtlwgvbpdbufekosgagfsmadmvbonkrtcbspoabugkcjeebqhqwfjcqlqjvabaqecofgwskqplgup&quot;</span><br></code></pre></td></tr></table></figure><p>总的来说，这是一个愚蠢的错误，但对于我这样的菜鸡来说，也是一个容易忽视的错误，刚开始发现时也确实是比较困惑的，所以特此记录一下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>剑指offer</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 22. 链表中倒数第k个节点</title>
    <link href="/2021/04/16/jian-zhi-offer-22-lian-biao-zhong-dao-shu-di-k-ge-jie-dian/"/>
    <url>/2021/04/16/jian-zhi-offer-22-lian-biao-zhong-dao-shu-di-k-ge-jie-dian/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p><strong>示例：</strong></p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</p><p>返回链表 4-&gt;5.</p></blockquote><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>算法流程：</p><ol><li>定量两个变量 i 和 j，这两个变量初始都指向链表的头结点</li><li>先让 j 向前移动 k 步</li><li>i 和 j 同时向前移动</li><li>当 j 的值为 null 时，i 就是倒数第 k 个节点</li></ol><p><img src="https://zkept-1302605083.cos.ap-nanjing.myqcloud.com/LeetCode/%E5%89%91%E6%8C%87Offer22_%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9.png"></p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    h := head<br>    i, j := h, h<br><br>    <span class="hljs-comment">// j 先走 k 步</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>        <span class="hljs-keyword">if</span> j != <span class="hljs-literal">nil</span> &#123;<br>            j = j.Next<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 之后 i 和 j 同时前进 1 步</span><br>    <span class="hljs-keyword">for</span> j != <span class="hljs-literal">nil</span> &#123;<br>        i = i.Next<br>        j = j.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> i<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
      <tag>剑指offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 18. 删除链表的节点</title>
    <link href="/2021/04/16/jian-zhi-offer-18-shan-chu-lian-biao-de-jie-dian/"/>
    <url>/2021/04/16/jian-zhi-offer-18-shan-chu-lian-biao-de-jie-dian/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>注意：此题对比原题有改动</p><p>示例 1:</p><p>输入: head &#x3D; [4,5,1,9], val &#x3D; 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p><p>输入: head &#x3D; [4,5,1,9], val &#x3D; 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p><p>说明：</p><p>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点。</p></blockquote><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>算法流程：</p><ol><li>定量两个变量 i 和 j，这两个变量初始都指向链表的头结点</li><li>先让 j 向前移动 k 步</li><li>i 和 j 同时向前移动</li><li>当 j 的值为 null 时，i 就是倒数第 k 个节点</li></ol><p><img src="https://zkept-1302605083.cos.ap-nanjing.myqcloud.com/LeetCode/%E5%89%91%E6%8C%87Offer22_%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9.png"></p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    h := head<br>    i, j := h, h<br><br>    <span class="hljs-comment">// j 先走 k 步</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>        <span class="hljs-keyword">if</span> j != <span class="hljs-literal">nil</span> &#123;<br>            j = j.Next<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 之后 i 和 j 同时前进 1 步</span><br>    <span class="hljs-keyword">for</span> j != <span class="hljs-literal">nil</span> &#123;<br>        i = i.Next<br>        j = j.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> i<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>剑指offer</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字</title>
    <link href="/2021/04/16/jian-zhi-offer-03-shu-zu-zhong-chong-fu-de-shu-zi/"/>
    <url>/2021/04/16/jian-zhi-offer-03-shu-zu-zhong-chong-fu-de-shu-zi/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p><p>限制：</p><p>2 &lt;&#x3D; n &lt;&#x3D; 100000</p></blockquote><h4 id="方法1：哈希表"><a href="#方法1：哈希表" class="headerlink" title="方法1：哈希表"></a>方法1：哈希表</h4><p>看到这种寻找重复元素的题目，首先想到的就是哈希表，通过 map 的 key 可以很容易的找到重复元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-keyword">struct</span>&#123;&#125;)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-comment">// 如果该 key 已存在，说明重复</span><br>        <span class="hljs-keyword">if</span> _, ok := m[nums[i]]; ok &#123;<br>            <span class="hljs-keyword">return</span> nums[i]<br>        &#125;<br>        m[nums[i]] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-comment">// 执行用时: 40 ms</span><br><span class="hljs-comment">// 内存消耗: 9.6 MB</span><br></code></pre></td></tr></table></figure><p>复杂度分析：<br>时间复杂度 O(N) ： 遍历数组使用 O(N) ，map 添加与查找元素皆为 O(1) 。<br>空间复杂度 O(N) ： map 占用 O(N) 大小的额外空间。</p><h4 id="方法2：排序"><a href="#方法2：排序" class="headerlink" title="方法2：排序"></a>方法2：排序</h4><p>对数组排序后，看相邻元素是否有相同的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  <span class="hljs-comment">// 先排序</span><br>    sort.Slice(nums, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> nums[i] &lt; nums[j]<br>    &#125;)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;<br>            <span class="hljs-keyword">return</span> nums[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-comment">// 执行用时: 48 ms</span><br><span class="hljs-comment">// 内存消耗: 8.7 MB</span><br></code></pre></td></tr></table></figure><p>复杂度分析：<br>时间复杂度 O(NlogN) ： 排序的时间复杂度为 O(NlogN)<br>空间复杂度 O(1) ： 无需额外空间</p><h4 id="方法3：原地置换、原地哈希"><a href="#方法3：原地置换、原地哈希" class="headerlink" title="方法3：原地置换、原地哈希"></a>方法3：原地置换、原地哈希</h4><p>题干中有一句很重要的话：<em><strong>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内</strong></em>，这说明了每个元素都可以存放在其值下标处（例如 2 可以存在 nums[2]，5 可以存在 nums[5]）,我们可以使用某种方法，将每个元素放到其对应位置，实现一个哈希表，哈希表的 key 是数组下标，value 是与下标相同的值，例如：</p><p><img src="https://zkept-1302605083.cos.ap-nanjing.myqcloud.com/LeetCode/office_03_hash.jpg"></p><p>当 key 发生冲突时，说明该元素是我们要找的重复数，但是用什么方法使每个元素移动到其对应位置呢?</p><p>这里可以使用原地置换法，首先判断 i 是否等于 nums[i]，不是的话则继续判断 nums[i] 是否等于 nums[nums[i]]，如果相等，则说明发生了冲突，该数为重复数，直接返回，否则交换两个位置的值（swap(nums[i], nums[nums[i]]) ），如果 i 等于 nums[i]，则说明 nums[i] 已经放在了对应的位置，此时可以i++，重复上述步骤，直到 i &gt; len(nums) 或者 return。</p><p>算法流程：</p><ol><li>遍历数组 nums ，设索引初始值为 i &#x3D; 0 :<ol><li>若 nums[i] &#x3D; i ： 说明此数字已在对应索引位置，无需交换，因此跳过；</li><li>若 nums[nums[i]] &#x3D; nums[i] ： 代表索引 nums[i] 处和索引 i 处的元素值都为 nums[i] ，即找      到一组重复值，返回此值 nums[i] ；</li><li>否则： 交换索引为 i 和 nums[i] 的元素值，将此数字交换至对应索引位置。</li></ol></li><li>若遍历完毕尚未返回，则返回 -1 。</li></ol><p>文字可能不太好理解，结合下面的图帮助理解：</p><p><img src="https://zkept-1302605083.cos.ap-nanjing.myqcloud.com/LeetCode/office_03.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(nums) &#123;<br>        <span class="hljs-keyword">if</span> i == nums[nums[i]] &#123;<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[i] == nums[nums[i]] &#123;<br>            <span class="hljs-keyword">return</span> nums[i]<br>        &#125;<br>        nums[i], nums[nums[i]] = nums[nums[i]], nums[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-comment">// 执行用时: 36 ms</span><br><span class="hljs-comment">// 内存消耗: 8.7 MB</span><br><br></code></pre></td></tr></table></figure><p>复杂度分析：<br>时间复杂度 O(N) ： 遍历数组使用 O(N)，每轮遍历的判断和交换操作使用 O(1)。<br>空间复杂度 O(1) ： 使用常数复杂度的额外空间。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>剑指offer</tag>
      
      <tag>算法</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode146.LRU 缓存机制</title>
    <link href="/2021/04/16/leetcode146lru-huan-cun-ji-zhi/"/>
    <url>/2021/04/16/leetcode146lru-huan-cun-ji-zhi/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字&#x2F;值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p>示例:</p><p>LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );</p><p>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       &#x2F;&#x2F; 返回  1<br>cache.put(3, 3);    &#x2F;&#x2F; 该操作会使得关键字 2 作废<br>cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)<br>cache.put(4, 4);    &#x2F;&#x2F; 该操作会使得关键字 1 作废<br>cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到)<br>cache.get(3);       &#x2F;&#x2F; 返回  3<br>cache.get(4);       &#x2F;&#x2F; 返回  4</p><p><strong>进阶:</strong></p><p>你是否可以在 <strong>O(1)</strong> 时间复杂度内完成这两种操作？</p></blockquote><p>上面的操作如下图所示：</p><p><img src="https://zengh1.github.io/post-images/1618557307474.jpg"></p><p>通过上图应该可以大致了解 lru 的工作过程了，要想进一步了解 lru，可以自行网上查阅。</p><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><h3 id="低效率版"><a href="#低效率版" class="headerlink" title="低效率版"></a>低效率版</h3><p>如果忽视题目描述中的进阶要求：在 <strong>O(1)</strong> 时间复杂度内完成这两种操作，可以很容易的写出一个 lru 算法，只要通过一个链表，在链表中存储 map 即可实现，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ⚠️ 低效率，get 和 put 时间复杂度非 O(1)</span><br><br><span class="hljs-keyword">type</span> LRUCache <span class="hljs-keyword">struct</span> &#123;<br>Cap <span class="hljs-type">int</span><br>Element *list.List<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> LRUCache &#123;<br>l := LRUCache&#123;<br>Cap:     capacity,<br>Element: list.New(),<br>&#125;<br><span class="hljs-keyword">return</span> l<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *LRUCache)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> i := c.Element.Front(); i != <span class="hljs-literal">nil</span>; i = i.Next() &#123;<br>data := i.Value.(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">if</span> val, ok := data[key]; ok &#123;<br><span class="hljs-comment">// 如果找到，返回的同时将其置于头部</span><br>c.Element.MoveToFront(i)<br><span class="hljs-keyword">return</span> val<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *LRUCache)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>)  &#123;<br>e := c.Element<br><br><span class="hljs-comment">// 如果 key 已存在，则更新值，同时置于头部</span><br><span class="hljs-keyword">for</span> i := e.Front(); i != <span class="hljs-literal">nil</span>; i = i.Next() &#123;<br>data := i.Value.(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">if</span> _, ok := data[key]; ok &#123;<br>data[key] = value<br><span class="hljs-comment">// 置于头部</span><br>c.Element.MoveToFront(i)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 如果已满，则移除最后一个元素</span><br><span class="hljs-keyword">if</span> e.Len() == c.Cap &#123;<br>e.Remove(e.Back())<br>&#125;<br><br>data := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>data[key] = value<br>e.PushFront(data)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zengh1.github.io/post-images/1618558449751.jpg"></p><p>虽然通过了测试，但是效率非常低下，因为每次 get 和 put 都需要遍历链表，并且判断当前链表存储的 map 的 key，时间复杂度会非常高。</p><p>更好的方法：</p><p><img src="https://zengh1.github.io/post-images/1618558464863.jpg"></p><p>要让 put 和 get 方法的时间复杂度为 O(1)，我们可以总结出这个数据结构必要的条件：查找快，插入快，删除快，有顺序之分。</p><p>因为显然 cache 必须有顺序之分，以区分最近使用的和久未使用的数据；而且我们要在 cache 中查找键是否已存在；如果容量满了要删除最后一个数据；每次访问还要把数据插入到队头。</p><p>那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表。</p><p>双链表中存储了一对键值对，并且 键 和 哈希表的 键 保持一致，来达到 哈希表映射双链表的目的。</p><p>哈希表可以使查询相关操作达到 O(1) 时间复杂度，例如 get 操作，以及 put 中 判断该 key 是否以及存在；通过哈希表可以快速找到对应的链表节点，所以可以保证链表的删除操作也为 O(1) （链表删除虽然只需要改变指针，但是还需要找到该节点）。</p><p>具体代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LRUCache <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 最大容量</span><br><span class="hljs-built_in">cap</span> <span class="hljs-type">int</span><br><span class="hljs-comment">// map 映射到 双向链表，实现 O(1) 的时间复杂度</span><br>cache <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*list.Element<br><span class="hljs-comment">// 双向链表实现 lru</span><br>list *list.List<br>&#125;<br><br><span class="hljs-comment">// 该结构体作为链表的节点值，并且 key 与 cache 的 key 保持同步，</span><br><span class="hljs-comment">// 以此实现 map 映射到 list</span><br><span class="hljs-keyword">type</span> kv <span class="hljs-keyword">struct</span> &#123;<br>key   <span class="hljs-type">int</span><br>value <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> LRUCache &#123;<br><span class="hljs-keyword">return</span> LRUCache&#123;<br><span class="hljs-built_in">cap</span>:   capacity,<br>cache: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*list.Element),<br>list:  list.New(),<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *LRUCache)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 通过 cache (map 类型) 查询 key，因为 list 节点 value 的 key 与 cache key 相同，</span><br><span class="hljs-comment">// 所以可以通过 cache 以 O(1) 查询到对应的 list node</span><br><span class="hljs-keyword">if</span> v, ok := c.cache[key]; ok &#123;<br><span class="hljs-comment">// 将查询到的 node 移动到 list 头部</span><br>c.list.MoveToFront(v)<br><span class="hljs-comment">// cache 的 value 是一个 list node，并且 node value 是 struct kv，</span><br><span class="hljs-comment">// 返回 struct kv 的 value</span><br><span class="hljs-keyword">return</span> v.Value.(*kv).value<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *LRUCache)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">// 如果该 key 已经存在，则更新 value，并置于 list 头部</span><br><span class="hljs-keyword">if</span> v, ok := c.cache[key]; ok &#123;<br><span class="hljs-comment">// 更新位置</span><br>c.list.MoveToFront(v)<br><span class="hljs-comment">// 更新 value</span><br>v.Value = &amp;kv&#123;<br>key:   key,<br>value: value,<br>&#125;<br><span class="hljs-comment">// 该 key 不存在</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 如果已经达到最大容量</span><br><span class="hljs-keyword">if</span> c.list.Len() == c.<span class="hljs-built_in">cap</span> &#123;<br><span class="hljs-comment">// 删除 cache 中处于末尾的 key</span><br><span class="hljs-built_in">delete</span>(c.cache, c.list.Back().Value.(*kv).key)<br><span class="hljs-comment">// 删除 list 中最后一个 node</span><br>c.list.Remove(c.list.Back())<br>&#125;<br><span class="hljs-comment">// 还有剩余容量</span><br>e := &amp;kv&#123;<br>key:   key,<br>value: value,<br>&#125;<br><span class="hljs-comment">// 置于 list 头部</span><br>c.list.PushFront(e)<br><span class="hljs-comment">// value 取 list 首元素</span><br>c.cache[key] = c.list.Front()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zengh1.github.io/post-images/1618558477739.jpg"></p><p>可以看到执行耗时缩短了近 7 倍。</p><p>注：go 官方有一个分布式 kv缓存库，里面有 lru 的实现方式，地址如下：</p><p><a href="https://github.com/golang/groupcache/blob/master/lru/lru.go">https://github.com/golang/groupcache/blob/master/lru/lru.go</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>lru</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker 安装 etcd</title>
    <link href="/2020/11/06/2020-11-6-docker-etcd/"/>
    <url>/2020/11/06/2020-11-6-docker-etcd/</url>
    
    <content type="html"><![CDATA[<h1 id="docker-安装-etcd"><a href="#docker-安装-etcd" class="headerlink" title="docker 安装 etcd"></a>docker 安装 etcd</h1><ol><li><p>创建一个 sh 文件</p></li><li><p>粘贴下面内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf /tmp/etcd-data.tmp &amp;&amp; mkdir -p /tmp/etcd-data.tmp &amp;&amp; \<br><span class="hljs-meta prompt_"># </span><span class="language-bash"> docker rmi quay.io/coreos/etcd:v3.3.13 || <span class="hljs-literal">true</span> &amp;&amp; \</span><br><span class="language-bash">  docker run -d \</span><br><span class="language-bash">  -p 2379:2379 \</span><br><span class="language-bash">  -p 2380:2380 \</span><br><span class="language-bash">  --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=/tmp/etcd-data.tmp,destination=/etcd-data \</span><br><span class="language-bash">  --name etcd-gcr-v3.3.13 \</span><br><span class="language-bash">  quay.io/coreos/etcd:v3.3.13 \</span><br><span class="language-bash">  /usr/local/bin/etcd \</span><br><span class="language-bash">  --name s1 \</span><br><span class="language-bash">  --data-dir /etcd-data \</span><br><span class="language-bash">  --listen-client-urls http://0.0.0.0:2379 \</span><br><span class="language-bash">  --advertise-client-urls http://0.0.0.0:2379 \</span><br><span class="language-bash">  --listen-peer-urls http://0.0.0.0:2380 \</span><br><span class="language-bash">  --initial-advertise-peer-urls http://0.0.0.0:2380 \</span><br><span class="language-bash">  --initial-cluster s1=http://0.0.0.0:2380 \</span><br><span class="language-bash">  --initial-cluster-token tkn \</span><br><span class="language-bash">  --initial-cluster-state new</span><br> <br></code></pre></td></tr></table></figure></li><li><p>执行</p></li></ol><p>附：进入容器的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it 容器id /usr/local/bin/etcdctl <br></code></pre></td></tr></table></figure><Vssue :title="$title" />]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker 下的 redis 如何挂载外部配置和数据</title>
    <link href="/2020/11/06/2020-11-7-docker-redis-config/"/>
    <url>/2020/11/06/2020-11-7-docker-redis-config/</url>
    
    <content type="html"><![CDATA[<h1 id="使用docker安装redis，挂载外部配置和数据"><a href="#使用docker安装redis，挂载外部配置和数据" class="headerlink" title="使用docker安装redis，挂载外部配置和数据"></a>使用docker安装redis，挂载外部配置和数据</h1><ol><li><p>mkdir &#x2F;docker</p></li><li><p>mkdir &#x2F;docker&#x2F;redis</p></li><li><p>mkdir &#x2F;docker&#x2F;redis&#x2F;conf</p></li><li><p>mkdir &#x2F;docker&#x2F;redis&#x2F;data</p></li><li><p>创建redis.conf配置文件</p></li><li><p>touch &#x2F;docker&#x2F;redis&#x2F;conf&#x2F;redis.conf</p></li><li><p>cd 到conf下，vi redis.conf</p></li><li><p>i进入插入模式，粘贴配置文件，配置文件中需将<em>daemonize</em>设置为no，#requirepass xx 去掉注释，并设置密码（xx处即为要设置的密码），protected-mode改为no，bind注释掉。</p></li><li><p>esc  :wq保存</p></li><li><p>docker run -d –privileged&#x3D;true -p 6379:6379 -v &#x2F;docker&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -v &#x2F;docker&#x2F;redis&#x2F;data:&#x2F;data –name redis redis redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf –appendonly yes</p><p>mac下：</p><p>docker run -d –privileged&#x3D;true -p 6379:6379 -v &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -v &#x2F;usr&#x2F;local&#x2F;redis&#x2F;data:&#x2F;data –name redis redis redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf –appendonly yes</p><p>创建挂载外部配置的容器</p></li><li><p>参数说明：</p><p>–privileged&#x3D;true：容器内的root拥有真正root权限，否则容器内root只是外部普通用户权限</p><p>-v &#x2F;docker&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf：映射配置文件</p><p>-v &#x2F;docker&#x2F;redis&#x2F;data:&#x2F;data：映射数据目录</p><p>redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf：指定配置文件启动redis-server进程</p><p>–appendonly yes：开启数据持久化</p></li></ol><p>附：已经修改好的配置文件</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br><span class="line">1751</span><br><span class="line">1752</span><br><span class="line">1753</span><br><span class="line">1754</span><br><span class="line">1755</span><br><span class="line">1756</span><br><span class="line">1757</span><br><span class="line">1758</span><br><span class="line">1759</span><br><span class="line">1760</span><br><span class="line">1761</span><br><span class="line">1762</span><br><span class="line">1763</span><br><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br><span class="line">1825</span><br><span class="line">1826</span><br><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br><span class="line">1835</span><br><span class="line">1836</span><br><span class="line">1837</span><br><span class="line">1838</span><br><span class="line">1839</span><br><span class="line">1840</span><br><span class="line">1841</span><br><span class="line">1842</span><br><span class="line">1843</span><br><span class="line">1844</span><br><span class="line">1845</span><br><span class="line">1846</span><br><span class="line">1847</span><br><span class="line">1848</span><br><span class="line">1849</span><br><span class="line">1850</span><br><span class="line">1851</span><br><span class="line">1852</span><br><span class="line">1853</span><br><span class="line">1854</span><br><span class="line">1855</span><br><span class="line">1856</span><br><span class="line">1857</span><br><span class="line">1858</span><br><span class="line">1859</span><br><span class="line">1860</span><br><span class="line">1861</span><br><span class="line">1862</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># Redis configuration file example.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Note that in order to read the configuration file, Redis must be</span><br><span class="hljs-comment"># started with the file path as first argument:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ./redis-server /path/to/redis.conf</span><br><br><span class="hljs-comment"># Note on units: when memory size is needed, it is possible to specify</span><br><span class="hljs-comment"># it in the usual form of 1k 5GB 4M and so forth:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1k =&gt; 1000 bytes</span><br><span class="hljs-comment"># 1kb =&gt; 1024 bytes</span><br><span class="hljs-comment"># 1m =&gt; 1000000 bytes</span><br><span class="hljs-comment"># 1mb =&gt; 1024*1024 bytes</span><br><span class="hljs-comment"># 1g =&gt; 1000000000 bytes</span><br><span class="hljs-comment"># 1gb =&gt; 1024*1024*1024 bytes</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span><br><br><span class="hljs-comment">################################## INCLUDES ###################################</span><br><br><span class="hljs-comment"># Include one or more other config files here.  This is useful if you</span><br><span class="hljs-comment"># have a standard template that goes to all Redis servers but also need</span><br><span class="hljs-comment"># to customize a few per-server settings.  Include files can include</span><br><span class="hljs-comment"># other files, so use this wisely.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Notice option &quot;include&quot; won&#x27;t be rewritten by command &quot;CONFIG REWRITE&quot;</span><br><span class="hljs-comment"># from admin or Redis Sentinel. Since Redis always uses the last processed</span><br><span class="hljs-comment"># line as value of a configuration directive, you&#x27;d better put includes</span><br><span class="hljs-comment"># at the beginning of this file to avoid overwriting config change at runtime.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If instead you are interested in using includes to override configuration</span><br><span class="hljs-comment"># options, it is better to use include as the last line.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># include /path/to/local.conf</span><br><span class="hljs-comment"># include /path/to/other.conf</span><br><br><span class="hljs-comment">################################## MODULES #####################################</span><br><br><span class="hljs-comment"># Load modules at startup. If the server is not able to load modules</span><br><span class="hljs-comment"># it will abort. It is possible to use multiple loadmodule directives.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># loadmodule /path/to/my_module.so</span><br><span class="hljs-comment"># loadmodule /path/to/other_module.so</span><br><br><span class="hljs-comment">################################## NETWORK #####################################</span><br><br><span class="hljs-comment"># By default, if no &quot;bind&quot; configuration directive is specified, Redis listens</span><br><span class="hljs-comment"># for connections from all the network interfaces available on the server.</span><br><span class="hljs-comment"># It is possible to listen to just one or multiple selected interfaces using</span><br><span class="hljs-comment"># the &quot;bind&quot; configuration directive, followed by one or more IP addresses.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Examples:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># bind 192.168.1.100 10.0.0.1</span><br><span class="hljs-comment"># bind 127.0.0.1 ::1</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the</span><br><span class="hljs-comment"># internet, binding to all the interfaces is dangerous and will expose the</span><br><span class="hljs-comment"># instance to everybody on the internet. So by default we uncomment the</span><br><span class="hljs-comment"># following bind directive, that will force Redis to listen only into</span><br><span class="hljs-comment"># the IPv4 loopback interface address (this means Redis will be able to</span><br><span class="hljs-comment"># accept connections only from clients running into the same computer it</span><br><span class="hljs-comment"># is running).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES</span><br><span class="hljs-comment"># JUST COMMENT THE FOLLOWING LINE.</span><br><span class="hljs-comment"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-comment"># bind 127.0.0.1 ::1</span><br><br><span class="hljs-comment"># Protected mode is a layer of security protection, in order to avoid that</span><br><span class="hljs-comment"># Redis instances left open on the internet are accessed and exploited.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># When protected mode is on and if:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1) The server is not binding explicitly to a set of addresses using the</span><br><span class="hljs-comment">#    &quot;bind&quot; directive.</span><br><span class="hljs-comment"># 2) No password is configured.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The server only accepts connections from clients connecting from the</span><br><span class="hljs-comment"># IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain</span><br><span class="hljs-comment"># sockets.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default protected mode is enabled. You should disable it only if</span><br><span class="hljs-comment"># you are sure you want clients from other hosts to connect to Redis</span><br><span class="hljs-comment"># even if no authentication is configured, nor a specific set of interfaces</span><br><span class="hljs-comment"># are explicitly listed using the &quot;bind&quot; directive.</span><br><span class="hljs-attribute">protected</span>-mode no<br><br><span class="hljs-comment"># Accept connections on the specified port, default is 6379 (IANA #815344).</span><br><span class="hljs-comment"># If port 0 is specified Redis will not listen on a TCP socket.</span><br><span class="hljs-attribute">port</span> <span class="hljs-number">6379</span><br><br><span class="hljs-comment"># TCP listen() backlog.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># In high requests-per-second environments you need an high backlog in order</span><br><span class="hljs-comment"># to avoid slow clients connections issues. Note that the Linux kernel</span><br><span class="hljs-comment"># will silently truncate it to the value of /proc/sys/net/core/somaxconn so</span><br><span class="hljs-comment"># make sure to raise both the value of somaxconn and tcp_max_syn_backlog</span><br><span class="hljs-comment"># in order to get the desired effect.</span><br><span class="hljs-attribute">tcp</span>-backlog <span class="hljs-number">511</span><br><br><span class="hljs-comment"># Unix socket.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Specify the path for the Unix socket that will be used to listen for</span><br><span class="hljs-comment"># incoming connections. There is no default, so Redis will not listen</span><br><span class="hljs-comment"># on a unix socket when not specified.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># unixsocket /tmp/redis.sock</span><br><span class="hljs-comment"># unixsocketperm 700</span><br><br><span class="hljs-comment"># Close the connection after a client is idle for N seconds (0 to disable)</span><br><span class="hljs-attribute">timeout</span> <span class="hljs-number">0</span><br><br><span class="hljs-comment"># TCP keepalive.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence</span><br><span class="hljs-comment"># of communication. This is useful for two reasons:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1) Detect dead peers.</span><br><span class="hljs-comment"># 2) Take the connection alive from the point of view of network</span><br><span class="hljs-comment">#    equipment in the middle.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># On Linux, the specified value (in seconds) is the period used to send ACKs.</span><br><span class="hljs-comment"># Note that to close the connection the double of the time is needed.</span><br><span class="hljs-comment"># On other kernels the period depends on the kernel configuration.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># A reasonable value for this option is 300 seconds, which is the new</span><br><span class="hljs-comment"># Redis default starting with Redis 3.2.1.</span><br><span class="hljs-attribute">tcp</span>-keepalive <span class="hljs-number">300</span><br><br><span class="hljs-comment">################################# TLS/SSL #####################################</span><br><br><span class="hljs-comment"># By default, TLS/SSL is disabled. To enable it, the &quot;tls-port&quot; configuration</span><br><span class="hljs-comment"># directive can be used to define TLS-listening ports. To enable TLS on the</span><br><span class="hljs-comment"># default port, use:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># port 0</span><br><span class="hljs-comment"># tls-port 6379</span><br><br><span class="hljs-comment"># Configure a X.509 certificate and private key to use for authenticating the</span><br><span class="hljs-comment"># server to connected clients, masters or cluster peers.  These files should be</span><br><span class="hljs-comment"># PEM formatted.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-cert-file redis.crt </span><br><span class="hljs-comment"># tls-key-file redis.key</span><br><br><span class="hljs-comment"># Configure a DH parameters file to enable Diffie-Hellman (DH) key exchange:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-dh-params-file redis.dh</span><br><br><span class="hljs-comment"># Configure a CA certificate(s) bundle or directory to authenticate TLS/SSL</span><br><span class="hljs-comment"># clients and peers.  Redis requires an explicit configuration of at least one</span><br><span class="hljs-comment"># of these, and will not implicitly use the system wide configuration.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-ca-cert-file ca.crt</span><br><span class="hljs-comment"># tls-ca-cert-dir /etc/ssl/certs</span><br><br><span class="hljs-comment"># By default, clients (including replica servers) on a TLS port are required</span><br><span class="hljs-comment"># to authenticate using valid client side certificates.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If &quot;no&quot; is specified, client certificates are not required and not accepted.</span><br><span class="hljs-comment"># If &quot;optional&quot; is specified, client certificates are accepted and must be</span><br><span class="hljs-comment"># valid if provided, but are not required.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-auth-clients no</span><br><span class="hljs-comment"># tls-auth-clients optional</span><br><br><span class="hljs-comment"># By default, a Redis replica does not attempt to establish a TLS connection</span><br><span class="hljs-comment"># with its master.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Use the following directive to enable TLS on replication links.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-replication yes</span><br><br><span class="hljs-comment"># By default, the Redis Cluster bus uses a plain TCP connection. To enable</span><br><span class="hljs-comment"># TLS for the bus protocol, use the following directive:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-cluster yes</span><br><br><span class="hljs-comment"># Explicitly specify TLS versions to support. Allowed values are case insensitive</span><br><span class="hljs-comment"># and include &quot;TLSv1&quot;, &quot;TLSv1.1&quot;, &quot;TLSv1.2&quot;, &quot;TLSv1.3&quot; (OpenSSL &gt;= 1.1.1) or</span><br><span class="hljs-comment"># any combination. To enable only TLSv1.2 and TLSv1.3, use:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-protocols &quot;TLSv1.2 TLSv1.3&quot;</span><br><br><span class="hljs-comment"># Configure allowed ciphers.  See the ciphers(1ssl) manpage for more information</span><br><span class="hljs-comment"># about the syntax of this string.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">Note:</span> this configuration applies only to &lt;= TLSv1.2.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-ciphers DEFAULT:!MEDIUM</span><br><br><span class="hljs-comment"># Configure allowed TLSv1.3 ciphersuites.  See the ciphers(1ssl) manpage for more</span><br><span class="hljs-comment"># information about the syntax of this string, and specifically for TLSv1.3</span><br><span class="hljs-comment"># ciphersuites.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-ciphersuites TLS_CHACHA20_POLY1305_SHA256</span><br><br><span class="hljs-comment"># When choosing a cipher, use the server&#x27;s preference instead of the client</span><br><span class="hljs-comment"># preference. By default, the server follows the client&#x27;s preference.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-prefer-server-ciphers yes</span><br><br><span class="hljs-comment"># By default, TLS session caching is enabled to allow faster and less expensive</span><br><span class="hljs-comment"># reconnections by clients that support it. Use the following directive to disable</span><br><span class="hljs-comment"># caching.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-session-caching no</span><br><br><span class="hljs-comment"># Change the default number of TLS sessions cached. A zero value sets the cache</span><br><span class="hljs-comment"># to unlimited size. The default size is 20480.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-session-cache-size 5000</span><br><br><span class="hljs-comment"># Change the default timeout of cached TLS sessions. The default timeout is 300</span><br><span class="hljs-comment"># seconds.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-session-cache-timeout 60</span><br><br><span class="hljs-comment">################################# GENERAL #####################################</span><br><br><span class="hljs-comment"># By default Redis does not run as a daemon. Use &#x27;yes&#x27; if you need it.</span><br><span class="hljs-comment"># Note that Redis will write a pid file in /usr/local/var/run/redis.pid when daemonized.</span><br><span class="hljs-attribute">daemonize</span> no<br><br><span class="hljs-comment"># If you run Redis from upstart or systemd, Redis can interact with your</span><br><span class="hljs-comment"># supervision tree. Options:</span><br><span class="hljs-comment">#   supervised no      - no supervision interaction</span><br><span class="hljs-comment">#   supervised upstart - signal upstart by putting Redis into SIGSTOP mode</span><br><span class="hljs-comment">#   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET</span><br><span class="hljs-comment">#   supervised auto    - detect upstart or systemd method based on</span><br><span class="hljs-comment">#                        UPSTART_JOB or NOTIFY_SOCKET environment variables</span><br><span class="hljs-comment"># <span class="hljs-doctag">Note:</span> these supervision methods only signal &quot;process is ready.&quot;</span><br><span class="hljs-comment">#       They do not enable continuous liveness pings back to your supervisor.</span><br><span class="hljs-attribute">supervised</span> no<br><br><span class="hljs-comment"># If a pid file is specified, Redis writes it where specified at startup</span><br><span class="hljs-comment"># and removes it at exit.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># When the server runs non daemonized, no pid file is created if none is</span><br><span class="hljs-comment"># specified in the configuration. When the server is daemonized, the pid file</span><br><span class="hljs-comment"># is used even if not specified, defaulting to &quot;/usr/local/var/run/redis.pid&quot;.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Creating a pid file is best effort: if Redis is not able to create it</span><br><span class="hljs-comment"># nothing bad happens, the server will start and run normally.</span><br><span class="hljs-attribute">pidfile</span> /var/run/redis_6379.pid<br><br><span class="hljs-comment"># Specify the server verbosity level.</span><br><span class="hljs-comment"># This can be one of:</span><br><span class="hljs-comment"># debug (a lot of information, useful for development/testing)</span><br><span class="hljs-comment"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="hljs-comment"># notice (moderately verbose, what you want in production probably)</span><br><span class="hljs-comment"># warning (only very important / critical messages are logged)</span><br><span class="hljs-attribute">loglevel</span> notice<br><br><span class="hljs-comment"># Specify the log file name. Also the empty string can be used to force</span><br><span class="hljs-comment"># Redis to log on the standard output. Note that if you use standard</span><br><span class="hljs-comment"># output for logging but daemonize, logs will be sent to /dev/null</span><br><span class="hljs-attribute">logfile</span> <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment"># To enable logging to the system logger, just set &#x27;syslog-enabled&#x27; to yes,</span><br><span class="hljs-comment"># and optionally update the other syslog parameters to suit your needs.</span><br><span class="hljs-comment"># syslog-enabled no</span><br><br><span class="hljs-comment"># Specify the syslog identity.</span><br><span class="hljs-comment"># syslog-ident redis</span><br><br><span class="hljs-comment"># Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.</span><br><span class="hljs-comment"># syslog-facility local0</span><br><br><span class="hljs-comment"># Set the number of databases. The default database is DB 0, you can select</span><br><span class="hljs-comment"># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span><br><span class="hljs-comment"># dbid is a number between 0 and &#x27;databases&#x27;-1</span><br><span class="hljs-attribute">databases</span> <span class="hljs-number">16</span><br><br><span class="hljs-comment"># By default Redis shows an ASCII art logo only when started to log to the</span><br><span class="hljs-comment"># standard output and if the standard output is a TTY. Basically this means</span><br><span class="hljs-comment"># that normally a logo is displayed only in interactive sessions.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># However it is possible to force the pre-4.0 behavior and always show a</span><br><span class="hljs-comment"># ASCII art logo in startup logs by setting the following option to yes.</span><br><span class="hljs-attribute">always</span>-show-logo yes<br><br><span class="hljs-comment">################################ SNAPSHOTTING  ################################</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Save the DB on disk:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   Will save the DB if both the given number of seconds and the given</span><br><span class="hljs-comment">#   number of write operations against the DB occurred.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   In the example below the behaviour will be to save:</span><br><span class="hljs-comment">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="hljs-comment">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="hljs-comment">#   after 60 sec if at least 10000 keys changed</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   <span class="hljs-doctag">Note:</span> you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   It is also possible to remove all the previously configured save</span><br><span class="hljs-comment">#   points by adding a save directive with a single empty string argument</span><br><span class="hljs-comment">#   like in the following example:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   save &quot;&quot;</span><br><br><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br><br><span class="hljs-comment"># By default Redis will stop accepting writes if RDB snapshots are enabled</span><br><span class="hljs-comment"># (at least one save point) and the latest background save failed.</span><br><span class="hljs-comment"># This will make the user aware (in a hard way) that data is not persisting</span><br><span class="hljs-comment"># on disk properly, otherwise chances are that no one will notice and some</span><br><span class="hljs-comment"># disaster will happen.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If the background saving process will start working again Redis will</span><br><span class="hljs-comment"># automatically allow writes again.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># However if you have setup your proper monitoring of the Redis server</span><br><span class="hljs-comment"># and persistence, you may want to disable this feature so that Redis will</span><br><span class="hljs-comment"># continue to work as usual even if there are problems with disk,</span><br><span class="hljs-comment"># permissions, and so forth.</span><br><span class="hljs-attribute">stop</span>-writes-<span class="hljs-literal">on</span>-bgsave-error yes<br><br><span class="hljs-comment"># Compress string objects using LZF when dump .rdb databases?</span><br><span class="hljs-comment"># For default that&#x27;s set to &#x27;yes&#x27; as it&#x27;s almost always a win.</span><br><span class="hljs-comment"># If you want to save some CPU in the saving child set it to &#x27;no&#x27; but</span><br><span class="hljs-comment"># the dataset will likely be bigger if you have compressible values or keys.</span><br><span class="hljs-attribute">rdbcompression</span> yes<br><br><span class="hljs-comment"># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span><br><span class="hljs-comment"># This makes the format more resistant to corruption but there is a performance</span><br><span class="hljs-comment"># hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span><br><span class="hljs-comment"># for maximum performances.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># RDB files created with checksum disabled have a checksum of zero that will</span><br><span class="hljs-comment"># tell the loading code to skip the check.</span><br><span class="hljs-attribute">rdbchecksum</span> yes<br><br><span class="hljs-comment"># The filename where to dump the DB</span><br><span class="hljs-attribute">dbfilename</span> dump.rdb<br><br><span class="hljs-comment"># Remove RDB files used by replication in instances without persistence</span><br><span class="hljs-comment"># enabled. By default this option is disabled, however there are environments</span><br><span class="hljs-comment"># where for regulations or other security concerns, RDB files persisted on</span><br><span class="hljs-comment"># disk by masters in order to feed replicas, or stored on disk by replicas</span><br><span class="hljs-comment"># in order to load them for the initial synchronization, should be deleted</span><br><span class="hljs-comment"># ASAP. Note that this option ONLY WORKS in instances that have both AOF</span><br><span class="hljs-comment"># and RDB persistence disabled, otherwise is completely ignored.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># An alternative (and sometimes better) way to obtain the same effect is</span><br><span class="hljs-comment"># to use diskless replication on both master and replicas instances. However</span><br><span class="hljs-comment"># in the case of replicas, diskless is not always an option.</span><br><span class="hljs-attribute">rdb</span>-del-sync-files no<br><br><span class="hljs-comment"># The working directory.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The DB will be written inside this directory, with the filename specified</span><br><span class="hljs-comment"># above using the &#x27;dbfilename&#x27; configuration directive.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The Append Only File will also be created inside this directory.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Note that you must specify a directory here, not a file name.</span><br><span class="hljs-attribute">dir</span> /usr/local/var/db/redis/<br><br><span class="hljs-comment">################################# REPLICATION #################################</span><br><br><span class="hljs-comment"># Master-Replica replication. Use replicaof to make a Redis instance a copy of</span><br><span class="hljs-comment"># another Redis server. A few things to understand ASAP about Redis replication.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   +------------------+      +---------------+</span><br><span class="hljs-comment">#   |      Master      | ---&gt; |    Replica    |</span><br><span class="hljs-comment">#   | (receive writes) |      |  (exact copy) |</span><br><span class="hljs-comment">#   +------------------+      +---------------+</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1) Redis replication is asynchronous, but you can configure a master to</span><br><span class="hljs-comment">#    stop accepting writes if it appears to be not connected with at least</span><br><span class="hljs-comment">#    a given number of replicas.</span><br><span class="hljs-comment"># 2) Redis replicas are able to perform a partial resynchronization with the</span><br><span class="hljs-comment">#    master if the replication link is lost for a relatively small amount of</span><br><span class="hljs-comment">#    time. You may want to configure the replication backlog size (see the next</span><br><span class="hljs-comment">#    sections of this file) with a sensible value depending on your needs.</span><br><span class="hljs-comment"># 3) Replication is automatic and does not need user intervention. After a</span><br><span class="hljs-comment">#    network partition replicas automatically try to reconnect to masters</span><br><span class="hljs-comment">#    and resynchronize with them.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><br><span class="hljs-comment"># If the master is password protected (using the &quot;requirepass&quot; configuration</span><br><span class="hljs-comment"># directive below) it is possible to tell the replica to authenticate before</span><br><span class="hljs-comment"># starting the replication synchronization process, otherwise the master will</span><br><span class="hljs-comment"># refuse the replica request.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># masterauth &lt;master-password&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># However this is not enough if you are using Redis ACLs (for Redis version</span><br><span class="hljs-comment"># 6 or greater), and the default user is not capable of running the PSYNC</span><br><span class="hljs-comment"># command and/or other commands needed for replication. In this case it&#x27;s</span><br><span class="hljs-comment"># better to configure a special user to use with replication, and specify the</span><br><span class="hljs-comment"># masteruser configuration as such:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># masteruser &lt;username&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># When masteruser is specified, the replica will authenticate against its</span><br><span class="hljs-comment"># master using the new AUTH form: AUTH &lt;username&gt; &lt;password&gt;.</span><br><br><span class="hljs-comment"># When a replica loses its connection with the master, or when the replication</span><br><span class="hljs-comment"># is still in progress, the replica can act in two different ways:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1) if replica-serve-stale-data is set to &#x27;yes&#x27; (the default) the replica will</span><br><span class="hljs-comment">#    still reply to client requests, possibly with out of date data, or the</span><br><span class="hljs-comment">#    data set may just be empty if this is the first synchronization.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 2) if replica-serve-stale-data is set to &#x27;no&#x27; the replica will reply with</span><br><span class="hljs-comment">#    an error &quot;SYNC with master in progress&quot; to all the kind of commands</span><br><span class="hljs-comment">#    but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,</span><br><span class="hljs-comment">#    SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,</span><br><span class="hljs-comment">#    COMMAND, POST, HOST: and LATENCY.</span><br><span class="hljs-comment">#</span><br><span class="hljs-attribute">replica</span>-serve-stale-data yes<br><br><span class="hljs-comment"># You can configure a replica instance to accept writes or not. Writing against</span><br><span class="hljs-comment"># a replica instance may be useful to store some ephemeral data (because data</span><br><span class="hljs-comment"># written on a replica will be easily deleted after resync with the master) but</span><br><span class="hljs-comment"># may also cause problems if clients are writing to it because of a</span><br><span class="hljs-comment"># misconfiguration.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Since Redis 2.6 by default replicas are read-only.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">Note:</span> read only replicas are not designed to be exposed to untrusted clients</span><br><span class="hljs-comment"># on the internet. It&#x27;s just a protection layer against misuse of the instance.</span><br><span class="hljs-comment"># Still a read only replica exports by default all the administrative commands</span><br><span class="hljs-comment"># such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</span><br><span class="hljs-comment"># security of read only replicas using &#x27;rename-command&#x27; to shadow all the</span><br><span class="hljs-comment"># administrative / dangerous commands.</span><br><span class="hljs-attribute">replica</span>-read-only yes<br><br><span class="hljs-comment"># Replication SYNC strategy: disk or socket.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># New replicas and reconnecting replicas that are not able to continue the</span><br><span class="hljs-comment"># replication process just receiving differences, need to do what is called a</span><br><span class="hljs-comment"># &quot;full synchronization&quot;. An RDB file is transmitted from the master to the</span><br><span class="hljs-comment"># replicas.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The transmission can happen in two different ways:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1) Disk-backed: The Redis master creates a new process that writes the RDB</span><br><span class="hljs-comment">#                 file on disk. Later the file is transferred by the parent</span><br><span class="hljs-comment">#                 process to the replicas incrementally.</span><br><span class="hljs-comment"># 2) Diskless: The Redis master creates a new process that directly writes the</span><br><span class="hljs-comment">#              RDB file to replica sockets, without touching the disk at all.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># With disk-backed replication, while the RDB file is generated, more replicas</span><br><span class="hljs-comment"># can be queued and served with the RDB file as soon as the current child</span><br><span class="hljs-comment"># producing the RDB file finishes its work. With diskless replication instead</span><br><span class="hljs-comment"># once the transfer starts, new replicas arriving will be queued and a new</span><br><span class="hljs-comment"># transfer will start when the current one terminates.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># When diskless replication is used, the master waits a configurable amount of</span><br><span class="hljs-comment"># time (in seconds) before starting the transfer in the hope that multiple</span><br><span class="hljs-comment"># replicas will arrive and the transfer can be parallelized.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># With slow disks and fast (large bandwidth) networks, diskless replication</span><br><span class="hljs-comment"># works better.</span><br><span class="hljs-attribute">repl</span>-diskless-sync no<br><br><span class="hljs-comment"># When diskless replication is enabled, it is possible to configure the delay</span><br><span class="hljs-comment"># the server waits in order to spawn the child that transfers the RDB via socket</span><br><span class="hljs-comment"># to the replicas.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This is important since once the transfer starts, it is not possible to serve</span><br><span class="hljs-comment"># new replicas arriving, that will be queued for the next RDB transfer, so the</span><br><span class="hljs-comment"># server waits a delay in order to let more replicas arrive.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The delay is specified in seconds, and by default is 5 seconds. To disable</span><br><span class="hljs-comment"># it entirely just set it to 0 seconds and the transfer will start ASAP.</span><br><span class="hljs-attribute">repl</span>-diskless-sync-delay <span class="hljs-number">5</span><br><br><span class="hljs-comment"># -----------------------------------------------------------------------------</span><br><span class="hljs-comment"># WARNING: RDB diskless load is experimental. Since in this setup the replica</span><br><span class="hljs-comment"># does not immediately store an RDB on disk, it may cause data loss during</span><br><span class="hljs-comment"># failovers. RDB diskless load + Redis modules not handling I/O reads may also</span><br><span class="hljs-comment"># cause Redis to abort in case of I/O errors during the initial synchronization</span><br><span class="hljs-comment"># stage with the master. Use only if your do what you are doing.</span><br><span class="hljs-comment"># -----------------------------------------------------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Replica can load the RDB it reads from the replication link directly from the</span><br><span class="hljs-comment"># socket, or store the RDB to a file and read that file after it was completely</span><br><span class="hljs-comment"># recived from the master.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># In many cases the disk is slower than the network, and storing and loading</span><br><span class="hljs-comment"># the RDB file may increase replication time (and even increase the master&#x27;s</span><br><span class="hljs-comment"># Copy on Write memory and salve buffers).</span><br><span class="hljs-comment"># However, parsing the RDB file directly from the socket may mean that we have</span><br><span class="hljs-comment"># to flush the contents of the current database before the full rdb was</span><br><span class="hljs-comment"># received. For this reason we have the following options:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># &quot;disabled&quot;    - Don&#x27;t use diskless load (store the rdb file to the disk first)</span><br><span class="hljs-comment"># &quot;on-empty-db&quot; - Use diskless load only when it is completely safe.</span><br><span class="hljs-comment"># &quot;swapdb&quot;      - Keep a copy of the current db contents in RAM while parsing</span><br><span class="hljs-comment">#                 the data directly from the socket. note that this requires</span><br><span class="hljs-comment">#                 sufficient memory, if you don&#x27;t have it, you risk an OOM kill.</span><br><span class="hljs-attribute">repl</span>-diskless-load disabled<br><br><span class="hljs-comment"># Replicas send PINGs to server in a predefined interval. It&#x27;s possible to</span><br><span class="hljs-comment"># change this interval with the repl_ping_replica_period option. The default</span><br><span class="hljs-comment"># value is 10 seconds.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># repl-ping-replica-period 10</span><br><br><span class="hljs-comment"># The following option sets the replication timeout for:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1) Bulk transfer I/O during SYNC, from the point of view of replica.</span><br><span class="hljs-comment"># 2) Master timeout from the point of view of replicas (data, pings).</span><br><span class="hljs-comment"># 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># It is important to make sure that this value is greater than the value</span><br><span class="hljs-comment"># specified for repl-ping-replica-period otherwise a timeout will be detected</span><br><span class="hljs-comment"># every time there is low traffic between the master and the replica.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># repl-timeout 60</span><br><br><span class="hljs-comment"># Disable TCP_NODELAY on the replica socket after SYNC?</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If you select &quot;yes&quot; Redis will use a smaller number of TCP packets and</span><br><span class="hljs-comment"># less bandwidth to send data to replicas. But this can add a delay for</span><br><span class="hljs-comment"># the data to appear on the replica side, up to 40 milliseconds with</span><br><span class="hljs-comment"># Linux kernels using a default configuration.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If you select &quot;no&quot; the delay for data to appear on the replica side will</span><br><span class="hljs-comment"># be reduced but more bandwidth will be used for replication.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default we optimize for low latency, but in very high traffic conditions</span><br><span class="hljs-comment"># or when the master and replicas are many hops away, turning this to &quot;yes&quot; may</span><br><span class="hljs-comment"># be a good idea.</span><br><span class="hljs-attribute">repl</span>-disable-tcp-nodelay no<br><br><span class="hljs-comment"># Set the replication backlog size. The backlog is a buffer that accumulates</span><br><span class="hljs-comment"># replica data when replicas are disconnected for some time, so that when a</span><br><span class="hljs-comment"># replica wants to reconnect again, often a full resync is not needed, but a</span><br><span class="hljs-comment"># partial resync is enough, just passing the portion of data the replica</span><br><span class="hljs-comment"># missed while disconnected.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The bigger the replication backlog, the longer the time the replica can be</span><br><span class="hljs-comment"># disconnected and later be able to perform a partial resynchronization.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The backlog is only allocated once there is at least a replica connected.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># repl-backlog-size 1mb</span><br><br><span class="hljs-comment"># After a master has no longer connected replicas for some time, the backlog</span><br><span class="hljs-comment"># will be freed. The following option configures the amount of seconds that</span><br><span class="hljs-comment"># need to elapse, starting from the time the last replica disconnected, for</span><br><span class="hljs-comment"># the backlog buffer to be freed.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Note that replicas never free the backlog for timeout, since they may be</span><br><span class="hljs-comment"># promoted to masters later, and should be able to correctly &quot;partially</span><br><span class="hljs-comment"># resynchronize&quot; with the replicas: hence they should always accumulate backlog.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># A value of 0 means to never release the backlog.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># repl-backlog-ttl 3600</span><br><br><span class="hljs-comment"># The replica priority is an integer number published by Redis in the INFO</span><br><span class="hljs-comment"># output. It is used by Redis Sentinel in order to select a replica to promote</span><br><span class="hljs-comment"># into a master if the master is no longer working correctly.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># A replica with a low priority number is considered better for promotion, so</span><br><span class="hljs-comment"># for instance if there are three replicas with priority 10, 100, 25 Sentinel</span><br><span class="hljs-comment"># will pick the one with priority 10, that is the lowest.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># However a special priority of 0 marks the replica as not able to perform the</span><br><span class="hljs-comment"># role of master, so a replica with priority of 0 will never be selected by</span><br><span class="hljs-comment"># Redis Sentinel for promotion.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default the priority is 100.</span><br><span class="hljs-attribute">replica</span>-priority <span class="hljs-number">100</span><br><br><span class="hljs-comment"># It is possible for a master to stop accepting writes if there are less than</span><br><span class="hljs-comment"># N replicas connected, having a lag less or equal than M seconds.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The N replicas need to be in &quot;online&quot; state.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The lag in seconds, that must be &lt;= the specified value, is calculated from</span><br><span class="hljs-comment"># the last ping received from the replica, that is usually sent every second.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This option does not GUARANTEE that N replicas will accept the write, but</span><br><span class="hljs-comment"># will limit the window of exposure for lost writes in case not enough replicas</span><br><span class="hljs-comment"># are available, to the specified number of seconds.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For example to require at least 3 replicas with a lag &lt;= 10 seconds use:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># min-replicas-to-write 3</span><br><span class="hljs-comment"># min-replicas-max-lag 10</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Setting one or the other to 0 disables the feature.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default min-replicas-to-write is set to 0 (feature disabled) and</span><br><span class="hljs-comment"># min-replicas-max-lag is set to 10.</span><br><br><span class="hljs-comment"># A Redis master is able to list the address and port of the attached</span><br><span class="hljs-comment"># replicas in different ways. For example the &quot;INFO replication&quot; section</span><br><span class="hljs-comment"># offers this information, which is used, among other tools, by</span><br><span class="hljs-comment"># Redis Sentinel in order to discover replica instances.</span><br><span class="hljs-comment"># Another place where this info is available is in the output of the</span><br><span class="hljs-comment"># &quot;ROLE&quot; command of a master.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The listed IP and address normally reported by a replica is obtained</span><br><span class="hljs-comment"># in the following way:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   IP: The address is auto detected by checking the peer address</span><br><span class="hljs-comment">#   of the socket used by the replica to connect with the master.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   Port: The port is communicated by the replica during the replication</span><br><span class="hljs-comment">#   handshake, and is normally the port that the replica is using to</span><br><span class="hljs-comment">#   listen for connections.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># However when port forwarding or Network Address Translation (NAT) is</span><br><span class="hljs-comment"># used, the replica may be actually reachable via different IP and port</span><br><span class="hljs-comment"># pairs. The following two options can be used by a replica in order to</span><br><span class="hljs-comment"># report to its master a specific set of IP and port, so that both INFO</span><br><span class="hljs-comment"># and ROLE will report those values.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># There is no need to use both the options if you need to override just</span><br><span class="hljs-comment"># the port or the IP address.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># replica-announce-ip 5.5.5.5</span><br><span class="hljs-comment"># replica-announce-port 1234</span><br><br><span class="hljs-comment">############################### KEYS TRACKING #################################</span><br><br><span class="hljs-comment"># Redis implements server assisted support for client side caching of values.</span><br><span class="hljs-comment"># This is implemented using an invalidation table that remembers, using</span><br><span class="hljs-comment"># 16 millions of slots, what clients may have certain subsets of keys. In turn</span><br><span class="hljs-comment"># this is used in order to send invalidation messages to clients. Please</span><br><span class="hljs-comment"># to understand more about the feature check this page:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   https://redis.io/topics/client-side-caching</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># When tracking is enabled for a client, all the read only queries are assumed</span><br><span class="hljs-comment"># to be cached: this will force Redis to store information in the invalidation</span><br><span class="hljs-comment"># table. When keys are modified, such information is flushed away, and</span><br><span class="hljs-comment"># invalidation messages are sent to the clients. However if the workload is</span><br><span class="hljs-comment"># heavily dominated by reads, Redis could use more and more memory in order</span><br><span class="hljs-comment"># to track the keys fetched by many clients.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For this reason it is possible to configure a maximum fill value for the</span><br><span class="hljs-comment"># invalidation table. By default it is set to 1M of keys, and once this limit</span><br><span class="hljs-comment"># is reached, Redis will start to evict keys in the invalidation table</span><br><span class="hljs-comment"># even if they were not modified, just to reclaim memory: this will in turn</span><br><span class="hljs-comment"># force the clients to invalidate the cached values. Basically the table</span><br><span class="hljs-comment"># maximum size is a trade off between the memory you want to spend server</span><br><span class="hljs-comment"># side to track information about who cached what, and the ability of clients</span><br><span class="hljs-comment"># to retain cached objects in memory.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If you set the value to 0, it means there are no limits, and Redis will</span><br><span class="hljs-comment"># retain as many keys as needed in the invalidation table.</span><br><span class="hljs-comment"># In the &quot;stats&quot; INFO section, you can find information about the number of</span><br><span class="hljs-comment"># keys in the invalidation table at every given moment.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">Note:</span> when key tracking is used in broadcasting mode, no memory is used</span><br><span class="hljs-comment"># in the server side so this setting is useless.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tracking-table-max-keys 1000000</span><br><br><span class="hljs-comment">################################## SECURITY ###################################</span><br><br><span class="hljs-comment"># Warning: since Redis is pretty fast an outside user can try up to</span><br><span class="hljs-comment"># 1 million passwords per second against a modern box. This means that you</span><br><span class="hljs-comment"># should use very strong passwords, otherwise they will be very easy to break.</span><br><span class="hljs-comment"># Note that because the password is really a shared secret between the client</span><br><span class="hljs-comment"># and the server, and should not be memorized by any human, the password</span><br><span class="hljs-comment"># can be easily a long string from /dev/urandom or whatever, so by using a</span><br><span class="hljs-comment"># long and unguessable password no brute force attack will be possible.</span><br><br><span class="hljs-comment"># Redis ACL users are defined in the following format:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   user &lt;username&gt; ... acl rules ...</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For example:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   user worker +@list +@connection ~jobs:* on &gt;ffa9203c493aa99</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The special username &quot;default&quot; is used for new connections. If this user</span><br><span class="hljs-comment"># has the &quot;nopass&quot; rule, then new connections will be immediately authenticated</span><br><span class="hljs-comment"># as the &quot;default&quot; user without the need of any password provided via the</span><br><span class="hljs-comment"># AUTH command. Otherwise if the &quot;default&quot; user is not flagged with &quot;nopass&quot;</span><br><span class="hljs-comment"># the connections will start in not authenticated state, and will require</span><br><span class="hljs-comment"># AUTH (or the HELLO command AUTH option) in order to be authenticated and</span><br><span class="hljs-comment"># start to work.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The ACL rules that describe what an user can do are the following:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  on           Enable the user: it is possible to authenticate as this user.</span><br><span class="hljs-comment">#  off          Disable the user: it&#x27;s no longer possible to authenticate</span><br><span class="hljs-comment">#               with this user, however the already authenticated connections</span><br><span class="hljs-comment">#               will still work.</span><br><span class="hljs-comment">#  +&lt;command&gt;   Allow the execution of that command</span><br><span class="hljs-comment">#  -&lt;command&gt;   Disallow the execution of that command</span><br><span class="hljs-comment">#  +@&lt;category&gt; Allow the execution of all the commands in such category</span><br><span class="hljs-comment">#               with valid categories are like @admin, @set, @sortedset, ...</span><br><span class="hljs-comment">#               and so forth, see the full list in the server.c file where</span><br><span class="hljs-comment">#               the Redis command table is described and defined.</span><br><span class="hljs-comment">#               The special category @all means all the commands, but currently</span><br><span class="hljs-comment">#               present in the server, and that will be loaded in the future</span><br><span class="hljs-comment">#               via modules.</span><br><span class="hljs-comment">#  +&lt;command&gt;|subcommand    Allow a specific subcommand of an otherwise</span><br><span class="hljs-comment">#                           disabled command. Note that this form is not</span><br><span class="hljs-comment">#                           allowed as negative like -DEBUG|SEGFAULT, but</span><br><span class="hljs-comment">#                           only additive starting with &quot;+&quot;.</span><br><span class="hljs-comment">#  allcommands  Alias for +@all. Note that it implies the ability to execute</span><br><span class="hljs-comment">#               all the future commands loaded via the modules system.</span><br><span class="hljs-comment">#  nocommands   Alias for -@all.</span><br><span class="hljs-comment">#  ~&lt;pattern&gt;   Add a pattern of keys that can be mentioned as part of</span><br><span class="hljs-comment">#               commands. For instance ~* allows all the keys. The pattern</span><br><span class="hljs-comment">#               is a glob-style pattern like the one of KEYS.</span><br><span class="hljs-comment">#               It is possible to specify multiple patterns.</span><br><span class="hljs-comment">#  allkeys      Alias for ~*</span><br><span class="hljs-comment">#  resetkeys    Flush the list of allowed keys patterns.</span><br><span class="hljs-comment">#  &gt;&lt;password&gt;  Add this passowrd to the list of valid password for the user.</span><br><span class="hljs-comment">#               For example &gt;mypass will add &quot;mypass&quot; to the list.</span><br><span class="hljs-comment">#               This directive clears the &quot;nopass&quot; flag (see later).</span><br><span class="hljs-comment">#  &lt;&lt;password&gt;  Remove this password from the list of valid passwords.</span><br><span class="hljs-comment">#  nopass       All the set passwords of the user are removed, and the user</span><br><span class="hljs-comment">#               is flagged as requiring no password: it means that every</span><br><span class="hljs-comment">#               password will work against this user. If this directive is</span><br><span class="hljs-comment">#               used for the default user, every new connection will be</span><br><span class="hljs-comment">#               immediately authenticated with the default user without</span><br><span class="hljs-comment">#               any explicit AUTH command required. Note that the &quot;resetpass&quot;</span><br><span class="hljs-comment">#               directive will clear this condition.</span><br><span class="hljs-comment">#  resetpass    Flush the list of allowed passwords. Moreover removes the</span><br><span class="hljs-comment">#               &quot;nopass&quot; status. After &quot;resetpass&quot; the user has no associated</span><br><span class="hljs-comment">#               passwords and there is no way to authenticate without adding</span><br><span class="hljs-comment">#               some password (or setting it as &quot;nopass&quot; later).</span><br><span class="hljs-comment">#  reset        Performs the following actions: resetpass, resetkeys, off,</span><br><span class="hljs-comment">#               -@all. The user returns to the same state it has immediately</span><br><span class="hljs-comment">#               after its creation.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ACL rules can be specified in any order: for instance you can start with</span><br><span class="hljs-comment"># passwords, then flags, or key patterns. However note that the additive</span><br><span class="hljs-comment"># and subtractive rules will CHANGE MEANING depending on the ordering.</span><br><span class="hljs-comment"># For instance see the following example:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   user alice on +@all -DEBUG ~* &gt;somepassword</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This will allow &quot;alice&quot; to use all the commands with the exception of the</span><br><span class="hljs-comment"># DEBUG command, since +@all added all the commands to the set of the commands</span><br><span class="hljs-comment"># alice can use, and later DEBUG was removed. However if we invert the order</span><br><span class="hljs-comment"># of two ACL rules the result will be different:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   user alice on -DEBUG +@all ~* &gt;somepassword</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Now DEBUG was removed when alice had yet no commands in the set of allowed</span><br><span class="hljs-comment"># commands, later all the commands are added, so the user will be able to</span><br><span class="hljs-comment"># execute everything.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Basically ACL rules are processed left-to-right.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For more information about ACL configuration please refer to</span><br><span class="hljs-comment"># the Redis web site at https://redis.io/topics/acl</span><br><br><span class="hljs-comment"># ACL LOG</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The ACL Log tracks failed commands and authentication events associated</span><br><span class="hljs-comment"># with ACLs. The ACL Log is useful to troubleshoot failed commands blocked </span><br><span class="hljs-comment"># by ACLs. The ACL Log is stored in memory. You can reclaim memory with </span><br><span class="hljs-comment"># ACL LOG RESET. Define the maximum entry length of the ACL Log below.</span><br><span class="hljs-attribute">acllog</span>-max-len <span class="hljs-number">128</span><br><br><span class="hljs-comment"># Using an external ACL file</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Instead of configuring users here in this file, it is possible to use</span><br><span class="hljs-comment"># a stand-alone file just listing users. The two methods cannot be mixed:</span><br><span class="hljs-comment"># if you configure users here and at the same time you activate the exteranl</span><br><span class="hljs-comment"># ACL file, the server will refuse to start.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The format of the external ACL user file is exactly the same as the</span><br><span class="hljs-comment"># format that is used inside redis.conf to describe users.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># aclfile /etc/redis/users.acl</span><br><br><span class="hljs-comment"># IMPORTANT NOTE: starting with Redis 6 &quot;requirepass&quot; is just a compatiblity</span><br><span class="hljs-comment"># layer on top of the new ACL system. The option effect will be just setting</span><br><span class="hljs-comment"># the password for the default user. Clients will still authenticate using</span><br><span class="hljs-comment"># AUTH &lt;password&gt; as usually, or more explicitly with AUTH default &lt;password&gt;</span><br><span class="hljs-comment"># if they follow the new protocol: both will work.</span><br><span class="hljs-comment">#</span><br><span class="hljs-attribute">requirepass</span> zxvf666<br><br><span class="hljs-comment"># Command renaming (DEPRECATED).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ------------------------------------------------------------------------</span><br><span class="hljs-comment"># WARNING: avoid using this option if possible. Instead use ACLs to remove</span><br><span class="hljs-comment"># commands from the default user, and put them only in some admin user you</span><br><span class="hljs-comment"># create for administrative purposes.</span><br><span class="hljs-comment"># ------------------------------------------------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># It is possible to change the name of dangerous commands in a shared</span><br><span class="hljs-comment"># environment. For instance the CONFIG command may be renamed into something</span><br><span class="hljs-comment"># hard to guess so that it will still be available for internal-use tools</span><br><span class="hljs-comment"># but not available for general clients.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Example:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># It is also possible to completely kill a command by renaming it into</span><br><span class="hljs-comment"># an empty string:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># rename-command CONFIG &quot;&quot;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Please note that changing the name of commands that are logged into the</span><br><span class="hljs-comment"># AOF file or transmitted to replicas may cause problems.</span><br><br><span class="hljs-comment">################################### CLIENTS ####################################</span><br><br><span class="hljs-comment"># Set the max number of connected clients at the same time. By default</span><br><span class="hljs-comment"># this limit is set to 10000 clients, however if the Redis server is not</span><br><span class="hljs-comment"># able to configure the process file limit to allow for the specified limit</span><br><span class="hljs-comment"># the max number of allowed clients is set to the current file limit</span><br><span class="hljs-comment"># minus 32 (as Redis reserves a few file descriptors for internal uses).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Once the limit is reached Redis will close all the new connections sending</span><br><span class="hljs-comment"># an error &#x27;max number of clients reached&#x27;.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># IMPORTANT: When Redis Cluster is used, the max number of connections is also</span><br><span class="hljs-comment"># shared with the cluster bus: every node in the cluster will use two</span><br><span class="hljs-comment"># connections, one incoming and another outgoing. It is important to size the</span><br><span class="hljs-comment"># limit accordingly in case of very large clusters.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># maxclients 10000</span><br><br><span class="hljs-comment">############################## MEMORY MANAGEMENT ################################</span><br><br><span class="hljs-comment"># Set a memory usage limit to the specified amount of bytes.</span><br><span class="hljs-comment"># When the memory limit is reached Redis will try to remove keys</span><br><span class="hljs-comment"># according to the eviction policy selected (see maxmemory-policy).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If Redis can&#x27;t remove keys according to the policy, or if the policy is</span><br><span class="hljs-comment"># set to &#x27;noeviction&#x27;, Redis will start to reply with errors to commands</span><br><span class="hljs-comment"># that would use more memory, like SET, LPUSH, and so on, and will continue</span><br><span class="hljs-comment"># to reply to read-only commands like GET.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This option is usually useful when using Redis as an LRU or LFU cache, or to</span><br><span class="hljs-comment"># set a hard memory limit for an instance (using the &#x27;noeviction&#x27; policy).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># WARNING: If you have replicas attached to an instance with maxmemory on,</span><br><span class="hljs-comment"># the size of the output buffers needed to feed the replicas are subtracted</span><br><span class="hljs-comment"># from the used memory count, so that network problems / resyncs will</span><br><span class="hljs-comment"># not trigger a loop where keys are evicted, and in turn the output</span><br><span class="hljs-comment"># buffer of replicas is full with DELs of keys evicted triggering the deletion</span><br><span class="hljs-comment"># of more keys, and so forth until the database is completely emptied.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># In short... if you have replicas attached it is suggested that you set a lower</span><br><span class="hljs-comment"># limit for maxmemory so that there is some free RAM on the system for replica</span><br><span class="hljs-comment"># output buffers (but this is not needed if the policy is &#x27;noeviction&#x27;).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># maxmemory &lt;bytes&gt;</span><br><br><span class="hljs-comment"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span><br><span class="hljs-comment"># is reached. You can select one from the following behaviors:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># volatile-lru -&gt; Evict using approximated LRU, only keys with an expire set.</span><br><span class="hljs-comment"># allkeys-lru -&gt; Evict any key using approximated LRU.</span><br><span class="hljs-comment"># volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire set.</span><br><span class="hljs-comment"># allkeys-lfu -&gt; Evict any key using approximated LFU.</span><br><span class="hljs-comment"># volatile-random -&gt; Remove a random key having an expire set.</span><br><span class="hljs-comment"># allkeys-random -&gt; Remove a random key, any key.</span><br><span class="hljs-comment"># volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span><br><span class="hljs-comment"># noeviction -&gt; Don&#x27;t evict anything, just return an error on write operations.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># LRU means Least Recently Used</span><br><span class="hljs-comment"># LFU means Least Frequently Used</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Both LRU, LFU and volatile-ttl are implemented using approximated</span><br><span class="hljs-comment"># randomized algorithms.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">Note:</span> with any of the above policies, Redis will return an error on write</span><br><span class="hljs-comment">#       operations, when there are no suitable keys for eviction.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#       At the date of writing these commands are: set setnx setex append</span><br><span class="hljs-comment">#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span><br><span class="hljs-comment">#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span><br><span class="hljs-comment">#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span><br><span class="hljs-comment">#       getset mset msetnx exec sort</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The default is:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># maxmemory-policy noeviction</span><br><br><span class="hljs-comment"># LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated</span><br><span class="hljs-comment"># algorithms (in order to save memory), so you can tune it for speed or</span><br><span class="hljs-comment"># accuracy. For default Redis will check five keys and pick the one that was</span><br><span class="hljs-comment"># used less recently, you can change the sample size using the following</span><br><span class="hljs-comment"># configuration directive.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The default of 5 produces good enough results. 10 Approximates very closely</span><br><span class="hljs-comment"># true LRU but costs more CPU. 3 is faster but not very accurate.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># maxmemory-samples 5</span><br><br><span class="hljs-comment"># Starting from Redis 5, by default a replica will ignore its maxmemory setting</span><br><span class="hljs-comment"># (unless it is promoted to master after a failover or manually). It means</span><br><span class="hljs-comment"># that the eviction of keys will be just handled by the master, sending the</span><br><span class="hljs-comment"># DEL commands to the replica as keys evict in the master side.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This behavior ensures that masters and replicas stay consistent, and is usually</span><br><span class="hljs-comment"># what you want, however if your replica is writable, or you want the replica</span><br><span class="hljs-comment"># to have a different memory setting, and you are sure all the writes performed</span><br><span class="hljs-comment"># to the replica are idempotent, then you may change this default (but be sure</span><br><span class="hljs-comment"># to understand what you are doing).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Note that since the replica by default does not evict, it may end using more</span><br><span class="hljs-comment"># memory than the one set via maxmemory (there are certain buffers that may</span><br><span class="hljs-comment"># be larger on the replica, or data structures may sometimes take more memory</span><br><span class="hljs-comment"># and so forth). So make sure you monitor your replicas and make sure they</span><br><span class="hljs-comment"># have enough memory to never hit a real out-of-memory condition before the</span><br><span class="hljs-comment"># master hits the configured maxmemory setting.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># replica-ignore-maxmemory yes</span><br><br><span class="hljs-comment"># Redis reclaims expired keys in two ways: upon access when those keys are</span><br><span class="hljs-comment"># found to be expired, and also in background, in what is called the</span><br><span class="hljs-comment"># &quot;active expire key&quot;. The key space is slowly and interactively scanned</span><br><span class="hljs-comment"># looking for expired keys to reclaim, so that it is possible to free memory</span><br><span class="hljs-comment"># of keys that are expired and will never be accessed again in a short time.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The default effort of the expire cycle will try to avoid having more than</span><br><span class="hljs-comment"># ten percent of expired keys still in memory, and will try to avoid consuming</span><br><span class="hljs-comment"># more than 25% of total memory and to add latency to the system. However</span><br><span class="hljs-comment"># it is possible to increase the expire &quot;effort&quot; that is normally set to</span><br><span class="hljs-comment"># &quot;1&quot;, to a greater value, up to the value &quot;10&quot;. At its maximum value the</span><br><span class="hljs-comment"># system will use more CPU, longer cycles (and technically may introduce</span><br><span class="hljs-comment"># more latency), and will tollerate less already expired keys still present</span><br><span class="hljs-comment"># in the system. It&#x27;s a tradeoff betweeen memory, CPU and latecy.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># active-expire-effort 1</span><br><br><span class="hljs-comment">############################# LAZY FREEING ####################################</span><br><br><span class="hljs-comment"># Redis has two primitives to delete keys. One is called DEL and is a blocking</span><br><span class="hljs-comment"># deletion of the object. It means that the server stops processing new commands</span><br><span class="hljs-comment"># in order to reclaim all the memory associated with an object in a synchronous</span><br><span class="hljs-comment"># way. If the key deleted is associated with a small object, the time needed</span><br><span class="hljs-comment"># in order to execute the DEL command is very small and comparable to most other</span><br><span class="hljs-comment"># O(1) or O(log_N) commands in Redis. However if the key is associated with an</span><br><span class="hljs-comment"># aggregated value containing millions of elements, the server can block for</span><br><span class="hljs-comment"># a long time (even seconds) in order to complete the operation.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For the above reasons Redis also offers non blocking deletion primitives</span><br><span class="hljs-comment"># such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and</span><br><span class="hljs-comment"># FLUSHDB commands, in order to reclaim memory in background. Those commands</span><br><span class="hljs-comment"># are executed in constant time. Another thread will incrementally free the</span><br><span class="hljs-comment"># object in the background as fast as possible.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.</span><br><span class="hljs-comment"># It&#x27;s up to the design of the application to understand when it is a good</span><br><span class="hljs-comment"># idea to use one or the other. However the Redis server sometimes has to</span><br><span class="hljs-comment"># delete keys or flush the whole database as a side effect of other operations.</span><br><span class="hljs-comment"># Specifically Redis deletes objects independently of a user call in the</span><br><span class="hljs-comment"># following scenarios:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1) On eviction, because of the maxmemory and maxmemory policy configurations,</span><br><span class="hljs-comment">#    in order to make room for new data, without going over the specified</span><br><span class="hljs-comment">#    memory limit.</span><br><span class="hljs-comment"># 2) Because of expire: when a key with an associated time to live (see the</span><br><span class="hljs-comment">#    EXPIRE command) must be deleted from memory.</span><br><span class="hljs-comment"># 3) Because of a side effect of a command that stores data on a key that may</span><br><span class="hljs-comment">#    already exist. For example the RENAME command may delete the old key</span><br><span class="hljs-comment">#    content when it is replaced with another one. Similarly SUNIONSTORE</span><br><span class="hljs-comment">#    or SORT with STORE option may delete existing keys. The SET command</span><br><span class="hljs-comment">#    itself removes any old content of the specified key in order to replace</span><br><span class="hljs-comment">#    it with the specified string.</span><br><span class="hljs-comment"># 4) During replication, when a replica performs a full resynchronization with</span><br><span class="hljs-comment">#    its master, the content of the whole database is removed in order to</span><br><span class="hljs-comment">#    load the RDB file just transferred.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># In all the above cases the default is to delete objects in a blocking way,</span><br><span class="hljs-comment"># like if DEL was called. However you can configure each case specifically</span><br><span class="hljs-comment"># in order to instead release memory in a non-blocking way like if UNLINK</span><br><span class="hljs-comment"># was called, using the following configuration directives.</span><br><br><span class="hljs-attribute">lazyfree</span>-lazy-eviction no<br><span class="hljs-attribute">lazyfree</span>-lazy-expire no<br><span class="hljs-attribute">lazyfree</span>-lazy-server-del no<br><span class="hljs-attribute">replica</span>-lazy-flush no<br><br><span class="hljs-comment"># It is also possible, for the case when to replace the user code DEL calls</span><br><span class="hljs-comment"># with UNLINK calls is not easy, to modify the default behavior of the DEL</span><br><span class="hljs-comment"># command to act exactly like UNLINK, using the following configuration</span><br><span class="hljs-comment"># directive:</span><br><br><span class="hljs-attribute">lazyfree</span>-lazy-user-del no<br><br><span class="hljs-comment">################################ THREADED I/O #################################</span><br><br><span class="hljs-comment"># Redis is mostly single threaded, however there are certain threaded</span><br><span class="hljs-comment"># operations such as UNLINK, slow I/O accesses and other things that are</span><br><span class="hljs-comment"># performed on side threads.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Now it is also possible to handle Redis clients socket reads and writes</span><br><span class="hljs-comment"># in different I/O threads. Since especially writing is so slow, normally</span><br><span class="hljs-comment"># Redis users use pipelining in order to speedup the Redis performances per</span><br><span class="hljs-comment"># core, and spawn multiple instances in order to scale more. Using I/O</span><br><span class="hljs-comment"># threads it is possible to easily speedup two times Redis without resorting</span><br><span class="hljs-comment"># to pipelining nor sharding of the instance.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default threading is disabled, we suggest enabling it only in machines</span><br><span class="hljs-comment"># that have at least 4 or more cores, leaving at least one spare core.</span><br><span class="hljs-comment"># Using more than 8 threads is unlikely to help much. We also recommend using</span><br><span class="hljs-comment"># threaded I/O only if you actually have performance problems, with Redis</span><br><span class="hljs-comment"># instances being able to use a quite big percentage of CPU time, otherwise</span><br><span class="hljs-comment"># there is no point in using this feature.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># So for instance if you have a four cores boxes, try to use 2 or 3 I/O</span><br><span class="hljs-comment"># threads, if you have a 8 cores, try to use 6 threads. In order to</span><br><span class="hljs-comment"># enable I/O threads use the following configuration directive:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># io-threads 4</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Setting io-threads to 1 will just use the main thread as usually.</span><br><span class="hljs-comment"># When I/O threads are enabled, we only use threads for writes, that is</span><br><span class="hljs-comment"># to thread the write(2) syscall and transfer the client buffers to the</span><br><span class="hljs-comment"># socket. However it is also possible to enable threading of reads and</span><br><span class="hljs-comment"># protocol parsing using the following configuration directive, by setting</span><br><span class="hljs-comment"># it to yes:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># io-threads-do-reads no</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Usually threading reads doesn&#x27;t help much.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># NOTE 1: This configuration directive cannot be changed at runtime via</span><br><span class="hljs-comment"># CONFIG SET. Aso this feature currently does not work when SSL is</span><br><span class="hljs-comment"># enabled.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># NOTE 2: If you want to test the Redis speedup using redis-benchmark, make</span><br><span class="hljs-comment"># sure you also run the benchmark itself in threaded mode, using the</span><br><span class="hljs-comment"># --threads option to match the number of Redis theads, otherwise you&#x27;ll not</span><br><span class="hljs-comment"># be able to notice the improvements.</span><br><br><span class="hljs-comment">############################ KERNEL OOM CONTROL ##############################</span><br><br><span class="hljs-comment"># On Linux, it is possible to hint the kernel OOM killer on what processes</span><br><span class="hljs-comment"># should be killed first when out of memory.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Enabling this feature makes Redis actively control the oom_score_adj value</span><br><span class="hljs-comment"># for all its processes, depending on their role. The default scores will</span><br><span class="hljs-comment"># attempt to have background child processes killed before all others, and</span><br><span class="hljs-comment"># replicas killed before masters.</span><br><br><span class="hljs-attribute">oom</span>-score-adj no<br><br><span class="hljs-comment"># When oom-score-adj is used, this directive controls the specific values used</span><br><span class="hljs-comment"># for master, replica and background child processes. Values range -1000 to</span><br><span class="hljs-comment"># 1000 (higher means more likely to be killed).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Unprivileged processes (not root, and without CAP_SYS_RESOURCE capabilities)</span><br><span class="hljs-comment"># can freely increase their value, but not decrease it below its initial</span><br><span class="hljs-comment"># settings.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Values are used relative to the initial value of oom_score_adj when the server</span><br><span class="hljs-comment"># starts. Because typically the initial value is 0, they will often match the</span><br><span class="hljs-comment"># absolute values.</span><br><br><span class="hljs-attribute">oom</span>-score-adj-values <span class="hljs-number">0</span> <span class="hljs-number">200</span> <span class="hljs-number">800</span><br><br><span class="hljs-comment">############################## APPEND ONLY MODE ###############################</span><br><br><span class="hljs-comment"># By default Redis asynchronously dumps the dataset on disk. This mode is</span><br><span class="hljs-comment"># good enough in many applications, but an issue with the Redis process or</span><br><span class="hljs-comment"># a power outage may result into a few minutes of writes lost (depending on</span><br><span class="hljs-comment"># the configured save points).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The Append Only File is an alternative persistence mode that provides</span><br><span class="hljs-comment"># much better durability. For instance using the default data fsync policy</span><br><span class="hljs-comment"># (see later in the config file) Redis can lose just one second of writes in a</span><br><span class="hljs-comment"># dramatic event like a server power outage, or a single write if something</span><br><span class="hljs-comment"># wrong with the Redis process itself happens, but the operating system is</span><br><span class="hljs-comment"># still running correctly.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># AOF and RDB persistence can be enabled at the same time without problems.</span><br><span class="hljs-comment"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span><br><span class="hljs-comment"># with the better durability guarantees.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Please check http://redis.io/topics/persistence for more information.</span><br><br><span class="hljs-attribute">appendonly</span> no<br><br><span class="hljs-comment"># The name of the append only file (default: &quot;appendonly.aof&quot;)</span><br><br><span class="hljs-attribute">appendfilename</span> <span class="hljs-string">&quot;appendonly.aof&quot;</span><br><br><span class="hljs-comment"># The fsync() call tells the Operating System to actually write data on disk</span><br><span class="hljs-comment"># instead of waiting for more data in the output buffer. Some OS will really flush</span><br><span class="hljs-comment"># data on disk, some other OS will just try to do it ASAP.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Redis supports three different modes:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># no: don&#x27;t fsync, just let the OS flush the data when it wants. Faster.</span><br><span class="hljs-comment"># always: fsync after every write to the append only log. Slow, Safest.</span><br><span class="hljs-comment"># everysec: fsync only one time every second. Compromise.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between</span><br><span class="hljs-comment"># speed and data safety. It&#x27;s up to you to understand if you can relax this to</span><br><span class="hljs-comment"># &quot;no&quot; that will let the operating system flush the output buffer when</span><br><span class="hljs-comment"># it wants, for better performances (but if you can live with the idea of</span><br><span class="hljs-comment"># some data loss consider the default persistence mode that&#x27;s snapshotting),</span><br><span class="hljs-comment"># or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than</span><br><span class="hljs-comment"># everysec.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># More details please check the following article:</span><br><span class="hljs-comment"># http://antirez.com/post/redis-persistence-demystified.html</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If unsure, use &quot;everysec&quot;.</span><br><br><span class="hljs-comment"># appendfsync always</span><br><span class="hljs-attribute">appendfsync</span> everysec<br><span class="hljs-comment"># appendfsync no</span><br><br><span class="hljs-comment"># When the AOF fsync policy is set to always or everysec, and a background</span><br><span class="hljs-comment"># saving process (a background save or AOF log background rewriting) is</span><br><span class="hljs-comment"># performing a lot of I/O against the disk, in some Linux configurations</span><br><span class="hljs-comment"># Redis may block too long on the fsync() call. Note that there is no fix for</span><br><span class="hljs-comment"># this currently, as even performing fsync in a different thread will block</span><br><span class="hljs-comment"># our synchronous write(2) call.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># In order to mitigate this problem it&#x27;s possible to use the following option</span><br><span class="hljs-comment"># that will prevent fsync() from being called in the main process while a</span><br><span class="hljs-comment"># BGSAVE or BGREWRITEAOF is in progress.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This means that while another child is saving, the durability of Redis is</span><br><span class="hljs-comment"># the same as &quot;appendfsync none&quot;. In practical terms, this means that it is</span><br><span class="hljs-comment"># possible to lose up to 30 seconds of log in the worst scenario (with the</span><br><span class="hljs-comment"># default Linux settings).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as</span><br><span class="hljs-comment"># &quot;no&quot; that is the safest pick from the point of view of durability.</span><br><br><span class="hljs-attribute">no</span>-appendfsync-<span class="hljs-literal">on</span>-rewrite no<br><br><span class="hljs-comment"># Automatic rewrite of the append only file.</span><br><span class="hljs-comment"># Redis is able to automatically rewrite the log file implicitly calling</span><br><span class="hljs-comment"># BGREWRITEAOF when the AOF log size grows by the specified percentage.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This is how it works: Redis remembers the size of the AOF file after the</span><br><span class="hljs-comment"># latest rewrite (if no rewrite has happened since the restart, the size of</span><br><span class="hljs-comment"># the AOF at startup is used).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This base size is compared to the current size. If the current size is</span><br><span class="hljs-comment"># bigger than the specified percentage, the rewrite is triggered. Also</span><br><span class="hljs-comment"># you need to specify a minimal size for the AOF file to be rewritten, this</span><br><span class="hljs-comment"># is useful to avoid rewriting the AOF file even if the percentage increase</span><br><span class="hljs-comment"># is reached but it is still pretty small.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Specify a percentage of zero in order to disable the automatic AOF</span><br><span class="hljs-comment"># rewrite feature.</span><br><br><span class="hljs-attribute">auto</span>-aof-rewrite-percentage <span class="hljs-number">100</span><br><span class="hljs-attribute">auto</span>-aof-rewrite-min-size <span class="hljs-number">64</span>mb<br><br><span class="hljs-comment"># An AOF file may be found to be truncated at the end during the Redis</span><br><span class="hljs-comment"># startup process, when the AOF data gets loaded back into memory.</span><br><span class="hljs-comment"># This may happen when the system where Redis is running</span><br><span class="hljs-comment"># crashes, especially when an ext4 filesystem is mounted without the</span><br><span class="hljs-comment"># data=ordered option (however this can&#x27;t happen when Redis itself</span><br><span class="hljs-comment"># crashes or aborts but the operating system still works correctly).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Redis can either exit with an error when this happens, or load as much</span><br><span class="hljs-comment"># data as possible (the default now) and start if the AOF file is found</span><br><span class="hljs-comment"># to be truncated at the end. The following option controls this behavior.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If aof-load-truncated is set to yes, a truncated AOF file is loaded and</span><br><span class="hljs-comment"># the Redis server starts emitting a log to inform the user of the event.</span><br><span class="hljs-comment"># Otherwise if the option is set to no, the server aborts with an error</span><br><span class="hljs-comment"># and refuses to start. When the option is set to no, the user requires</span><br><span class="hljs-comment"># to fix the AOF file using the &quot;redis-check-aof&quot; utility before to restart</span><br><span class="hljs-comment"># the server.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Note that if the AOF file will be found to be corrupted in the middle</span><br><span class="hljs-comment"># the server will still exit with an error. This option only applies when</span><br><span class="hljs-comment"># Redis will try to read more data from the AOF file but not enough bytes</span><br><span class="hljs-comment"># will be found.</span><br><span class="hljs-attribute">aof</span>-load-truncated yes<br><br><span class="hljs-comment"># When rewriting the AOF file, Redis is able to use an RDB preamble in the</span><br><span class="hljs-comment"># AOF file for faster rewrites and recoveries. When this option is turned</span><br><span class="hljs-comment"># on the rewritten AOF file is composed of two different stanzas:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   [RDB file][AOF tail]</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># When loading Redis recognizes that the AOF file starts with the &quot;REDIS&quot;</span><br><span class="hljs-comment"># string and loads the prefixed RDB file, and continues loading the AOF</span><br><span class="hljs-comment"># tail.</span><br><span class="hljs-attribute">aof</span>-use-rdb-preamble yes<br><br><span class="hljs-comment">################################ LUA SCRIPTING  ###############################</span><br><br><span class="hljs-comment"># Max execution time of a Lua script in milliseconds.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If the maximum execution time is reached Redis will log that a script is</span><br><span class="hljs-comment"># still in execution after the maximum allowed time and will start to</span><br><span class="hljs-comment"># reply to queries with an error.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># When a long running script exceeds the maximum execution time only the</span><br><span class="hljs-comment"># SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be</span><br><span class="hljs-comment"># used to stop a script that did not yet called write commands. The second</span><br><span class="hljs-comment"># is the only way to shut down the server in the case a write command was</span><br><span class="hljs-comment"># already issued by the script but the user doesn&#x27;t want to wait for the natural</span><br><span class="hljs-comment"># termination of the script.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Set it to 0 or a negative value for unlimited execution without warnings.</span><br><span class="hljs-attribute">lua</span>-time-limit <span class="hljs-number">5000</span><br><br><span class="hljs-comment">################################ REDIS CLUSTER  ###############################</span><br><br><span class="hljs-comment"># Normal Redis instances can&#x27;t be part of a Redis Cluster; only nodes that are</span><br><span class="hljs-comment"># started as cluster nodes can. In order to start a Redis instance as a</span><br><span class="hljs-comment"># cluster node enable the cluster support uncommenting the following:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># cluster-enabled yes</span><br><br><span class="hljs-comment"># Every cluster node has a cluster configuration file. This file is not</span><br><span class="hljs-comment"># intended to be edited by hand. It is created and updated by Redis nodes.</span><br><span class="hljs-comment"># Every Redis Cluster node requires a different cluster configuration file.</span><br><span class="hljs-comment"># Make sure that instances running in the same system do not have</span><br><span class="hljs-comment"># overlapping cluster configuration file names.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># cluster-config-file nodes-6379.conf</span><br><br><span class="hljs-comment"># Cluster node timeout is the amount of milliseconds a node must be unreachable</span><br><span class="hljs-comment"># for it to be considered in failure state.</span><br><span class="hljs-comment"># Most other internal time limits are multiple of the node timeout.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># cluster-node-timeout 15000</span><br><br><span class="hljs-comment"># A replica of a failing master will avoid to start a failover if its data</span><br><span class="hljs-comment"># looks too old.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># There is no simple way for a replica to actually have an exact measure of</span><br><span class="hljs-comment"># its &quot;data age&quot;, so the following two checks are performed:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1) If there are multiple replicas able to failover, they exchange messages</span><br><span class="hljs-comment">#    in order to try to give an advantage to the replica with the best</span><br><span class="hljs-comment">#    replication offset (more data from the master processed).</span><br><span class="hljs-comment">#    Replicas will try to get their rank by offset, and apply to the start</span><br><span class="hljs-comment">#    of the failover a delay proportional to their rank.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 2) Every single replica computes the time of the last interaction with</span><br><span class="hljs-comment">#    its master. This can be the last ping or command received (if the master</span><br><span class="hljs-comment">#    is still in the &quot;connected&quot; state), or the time that elapsed since the</span><br><span class="hljs-comment">#    disconnection with the master (if the replication link is currently down).</span><br><span class="hljs-comment">#    If the last interaction is too old, the replica will not try to failover</span><br><span class="hljs-comment">#    at all.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The point &quot;2&quot; can be tuned by user. Specifically a replica will not perform</span><br><span class="hljs-comment"># the failover if, since the last interaction with the master, the time</span><br><span class="hljs-comment"># elapsed is greater than:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   (node-timeout * replica-validity-factor) + repl-ping-replica-period</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># So for example if node-timeout is 30 seconds, and the replica-validity-factor</span><br><span class="hljs-comment"># is 10, and assuming a default repl-ping-replica-period of 10 seconds, the</span><br><span class="hljs-comment"># replica will not try to failover if it was not able to talk with the master</span><br><span class="hljs-comment"># for longer than 310 seconds.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># A large replica-validity-factor may allow replicas with too old data to failover</span><br><span class="hljs-comment"># a master, while a too small value may prevent the cluster from being able to</span><br><span class="hljs-comment"># elect a replica at all.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For maximum availability, it is possible to set the replica-validity-factor</span><br><span class="hljs-comment"># to a value of 0, which means, that replicas will always try to failover the</span><br><span class="hljs-comment"># master regardless of the last time they interacted with the master.</span><br><span class="hljs-comment"># (However they&#x27;ll always try to apply a delay proportional to their</span><br><span class="hljs-comment"># offset rank).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Zero is the only value able to guarantee that when all the partitions heal</span><br><span class="hljs-comment"># the cluster will always be able to continue.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># cluster-replica-validity-factor 10</span><br><br><span class="hljs-comment"># Cluster replicas are able to migrate to orphaned masters, that are masters</span><br><span class="hljs-comment"># that are left without working replicas. This improves the cluster ability</span><br><span class="hljs-comment"># to resist to failures as otherwise an orphaned master can&#x27;t be failed over</span><br><span class="hljs-comment"># in case of failure if it has no working replicas.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Replicas migrate to orphaned masters only if there are still at least a</span><br><span class="hljs-comment"># given number of other working replicas for their old master. This number</span><br><span class="hljs-comment"># is the &quot;migration barrier&quot;. A migration barrier of 1 means that a replica</span><br><span class="hljs-comment"># will migrate only if there is at least 1 other working replica for its master</span><br><span class="hljs-comment"># and so forth. It usually reflects the number of replicas you want for every</span><br><span class="hljs-comment"># master in your cluster.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Default is 1 (replicas migrate only if their masters remain with at least</span><br><span class="hljs-comment"># one replica). To disable migration just set it to a very large value.</span><br><span class="hljs-comment"># A value of 0 can be set but is useful only for debugging and dangerous</span><br><span class="hljs-comment"># in production.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># cluster-migration-barrier 1</span><br><br><span class="hljs-comment"># By default Redis Cluster nodes stop accepting queries if they detect there</span><br><span class="hljs-comment"># is at least an hash slot uncovered (no available node is serving it).</span><br><span class="hljs-comment"># This way if the cluster is partially down (for example a range of hash slots</span><br><span class="hljs-comment"># are no longer covered) all the cluster becomes, eventually, unavailable.</span><br><span class="hljs-comment"># It automatically returns available as soon as all the slots are covered again.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># However sometimes you want the subset of the cluster which is working,</span><br><span class="hljs-comment"># to continue to accept queries for the part of the key space that is still</span><br><span class="hljs-comment"># covered. In order to do so, just set the cluster-require-full-coverage</span><br><span class="hljs-comment"># option to no.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># cluster-require-full-coverage yes</span><br><br><span class="hljs-comment"># This option, when set to yes, prevents replicas from trying to failover its</span><br><span class="hljs-comment"># master during master failures. However the master can still perform a</span><br><span class="hljs-comment"># manual failover, if forced to do so.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This is useful in different scenarios, especially in the case of multiple</span><br><span class="hljs-comment"># data center operations, where we want one side to never be promoted if not</span><br><span class="hljs-comment"># in the case of a total DC failure.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># cluster-replica-no-failover no</span><br><br><span class="hljs-comment"># This option, when set to yes, allows nodes to serve read traffic while the</span><br><span class="hljs-comment"># the cluster is in a down state, as long as it believes it owns the slots. </span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This is useful for two cases.  The first case is for when an application </span><br><span class="hljs-comment"># doesn&#x27;t require consistency of data during node failures or network partitions.</span><br><span class="hljs-comment"># One example of this is a cache, where as long as the node has the data it</span><br><span class="hljs-comment"># should be able to serve it. </span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The second use case is for configurations that don&#x27;t meet the recommended  </span><br><span class="hljs-comment"># three shards but want to enable cluster mode and scale later. A </span><br><span class="hljs-comment"># master outage in a 1 or 2 shard configuration causes a read/write outage to the</span><br><span class="hljs-comment"># entire cluster without this option set, with it set there is only a write outage.</span><br><span class="hljs-comment"># Without a quorum of masters, slot ownership will not change automatically. </span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># cluster-allow-reads-when-down no</span><br><br><span class="hljs-comment"># In order to setup your cluster make sure to read the documentation</span><br><span class="hljs-comment"># available at http://redis.io web site.</span><br><br><span class="hljs-comment">########################## CLUSTER DOCKER/NAT support  ########################</span><br><br><span class="hljs-comment"># In certain deployments, Redis Cluster nodes address discovery fails, because</span><br><span class="hljs-comment"># addresses are NAT-ted or because ports are forwarded (the typical case is</span><br><span class="hljs-comment"># Docker and other containers).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># In order to make Redis Cluster working in such environments, a static</span><br><span class="hljs-comment"># configuration where each node knows its public address is needed. The</span><br><span class="hljs-comment"># following two options are used for this scope, and are:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># * cluster-announce-ip</span><br><span class="hljs-comment"># * cluster-announce-port</span><br><span class="hljs-comment"># * cluster-announce-bus-port</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Each instruct the node about its address, client port, and cluster message</span><br><span class="hljs-comment"># bus port. The information is then published in the header of the bus packets</span><br><span class="hljs-comment"># so that other nodes will be able to correctly map the address of the node</span><br><span class="hljs-comment"># publishing the information.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If the above options are not used, the normal Redis Cluster auto-detection</span><br><span class="hljs-comment"># will be used instead.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Note that when remapped, the bus port may not be at the fixed offset of</span><br><span class="hljs-comment"># clients port + 10000, so you can specify any port and bus-port depending</span><br><span class="hljs-comment"># on how they get remapped. If the bus-port is not set, a fixed offset of</span><br><span class="hljs-comment"># 10000 will be used as usually.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Example:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># cluster-announce-ip 10.1.1.5</span><br><span class="hljs-comment"># cluster-announce-port 6379</span><br><span class="hljs-comment"># cluster-announce-bus-port 6380</span><br><br><span class="hljs-comment">################################## SLOW LOG ###################################</span><br><br><span class="hljs-comment"># The Redis Slow Log is a system to log queries that exceeded a specified</span><br><span class="hljs-comment"># execution time. The execution time does not include the I/O operations</span><br><span class="hljs-comment"># like talking with the client, sending the reply and so forth,</span><br><span class="hljs-comment"># but just the time needed to actually execute the command (this is the only</span><br><span class="hljs-comment"># stage of command execution where the thread is blocked and can not serve</span><br><span class="hljs-comment"># other requests in the meantime).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># You can configure the slow log with two parameters: one tells Redis</span><br><span class="hljs-comment"># what is the execution time, in microseconds, to exceed in order for the</span><br><span class="hljs-comment"># command to get logged, and the other parameter is the length of the</span><br><span class="hljs-comment"># slow log. When a new command is logged the oldest one is removed from the</span><br><span class="hljs-comment"># queue of logged commands.</span><br><br><span class="hljs-comment"># The following time is expressed in microseconds, so 1000000 is equivalent</span><br><span class="hljs-comment"># to one second. Note that a negative number disables the slow log, while</span><br><span class="hljs-comment"># a value of zero forces the logging of every command.</span><br><span class="hljs-attribute">slowlog</span>-log-slower-than <span class="hljs-number">10000</span><br><br><span class="hljs-comment"># There is no limit to this length. Just be aware that it will consume memory.</span><br><span class="hljs-comment"># You can reclaim memory used by the slow log with SLOWLOG RESET.</span><br><span class="hljs-attribute">slowlog</span>-max-len <span class="hljs-number">128</span><br><br><span class="hljs-comment">################################ LATENCY MONITOR ##############################</span><br><br><span class="hljs-comment"># The Redis latency monitoring subsystem samples different operations</span><br><span class="hljs-comment"># at runtime in order to collect data related to possible sources of</span><br><span class="hljs-comment"># latency of a Redis instance.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Via the LATENCY command this information is available to the user that can</span><br><span class="hljs-comment"># print graphs and obtain reports.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The system only logs operations that were performed in a time equal or</span><br><span class="hljs-comment"># greater than the amount of milliseconds specified via the</span><br><span class="hljs-comment"># latency-monitor-threshold configuration directive. When its value is set</span><br><span class="hljs-comment"># to zero, the latency monitor is turned off.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default latency monitoring is disabled since it is mostly not needed</span><br><span class="hljs-comment"># if you don&#x27;t have latency issues, and collecting data has a performance</span><br><span class="hljs-comment"># impact, that while very small, can be measured under big load. Latency</span><br><span class="hljs-comment"># monitoring can easily be enabled at runtime using the command</span><br><span class="hljs-comment"># &quot;CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;&quot; if needed.</span><br><span class="hljs-attribute">latency</span>-monitor-threshold <span class="hljs-number">0</span><br><br><span class="hljs-comment">############################# EVENT NOTIFICATION ##############################</span><br><br><span class="hljs-comment"># Redis can notify Pub/Sub clients about events happening in the key space.</span><br><span class="hljs-comment"># This feature is documented at http://redis.io/topics/notifications</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For instance if keyspace events notification is enabled, and a client</span><br><span class="hljs-comment"># performs a DEL operation on key &quot;foo&quot; stored in the Database 0, two</span><br><span class="hljs-comment"># messages will be published via Pub/Sub:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># PUBLISH __keyspace@0__:foo del</span><br><span class="hljs-comment"># PUBLISH __keyevent@0__:del foo</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># It is possible to select the events that Redis will notify among a set</span><br><span class="hljs-comment"># of classes. Every class is identified by a single character:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span><br><span class="hljs-comment">#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span><br><span class="hljs-comment">#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span><br><span class="hljs-comment">#  $     String commands</span><br><span class="hljs-comment">#  l     List commands</span><br><span class="hljs-comment">#  s     Set commands</span><br><span class="hljs-comment">#  h     Hash commands</span><br><span class="hljs-comment">#  z     Sorted set commands</span><br><span class="hljs-comment">#  x     Expired events (events generated every time a key expires)</span><br><span class="hljs-comment">#  e     Evicted events (events generated when a key is evicted for maxmemory)</span><br><span class="hljs-comment">#  t     Stream commands</span><br><span class="hljs-comment">#  m     Key-miss events (<span class="hljs-doctag">Note:</span> It is not included in the &#x27;A&#x27; class)</span><br><span class="hljs-comment">#  A     Alias for g$lshzxet, so that the &quot;AKE&quot; string means all the events</span><br><span class="hljs-comment">#        (Except key-miss events which are excluded from &#x27;A&#x27; due to their</span><br><span class="hljs-comment">#         unique nature).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  The &quot;notify-keyspace-events&quot; takes as argument a string that is composed</span><br><span class="hljs-comment">#  of zero or multiple characters. The empty string means that notifications</span><br><span class="hljs-comment">#  are disabled.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  Example: to enable list and generic events, from the point of view of the</span><br><span class="hljs-comment">#           event name, use:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  notify-keyspace-events Elg</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  Example 2: to get the stream of the expired keys subscribing to channel</span><br><span class="hljs-comment">#             name __keyevent@0__:expired use:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  notify-keyspace-events Ex</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  By default all notifications are disabled because most users don&#x27;t need</span><br><span class="hljs-comment">#  this feature and the feature has some overhead. Note that if you don&#x27;t</span><br><span class="hljs-comment">#  specify at least one of K or E, no events will be delivered.</span><br><span class="hljs-attribute">notify</span>-keyspace-events <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment">############################### GOPHER SERVER #################################</span><br><br><span class="hljs-comment"># Redis contains an implementation of the Gopher protocol, as specified in</span><br><span class="hljs-comment"># the RFC 1436 (https://www.ietf.org/rfc/rfc1436.txt).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The Gopher protocol was very popular in the late &#x27;90s. It is an alternative</span><br><span class="hljs-comment"># to the web, and the implementation both server and client side is so simple</span><br><span class="hljs-comment"># that the Redis server has just 100 lines of code in order to implement this</span><br><span class="hljs-comment"># support.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># What do you do with Gopher nowadays? Well Gopher never *really* died, and</span><br><span class="hljs-comment"># lately there is a movement in order for the Gopher more hierarchical content</span><br><span class="hljs-comment"># composed of just plain text documents to be resurrected. Some want a simpler</span><br><span class="hljs-comment"># internet, others believe that the mainstream internet became too much</span><br><span class="hljs-comment"># controlled, and it&#x27;s cool to create an alternative space for people that</span><br><span class="hljs-comment"># want a bit of fresh air.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Anyway for the 10nth birthday of the Redis, we gave it the Gopher protocol</span><br><span class="hljs-comment"># as a gift.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># --- HOW IT WORKS? ---</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The Redis Gopher support uses the inline protocol of Redis, and specifically</span><br><span class="hljs-comment"># two kind of inline requests that were anyway illegal: an empty request</span><br><span class="hljs-comment"># or any request that starts with &quot;/&quot; (there are no Redis commands starting</span><br><span class="hljs-comment"># with such a slash). Normal RESP2/RESP3 requests are completely out of the</span><br><span class="hljs-comment"># path of the Gopher protocol implementation and are served as usually as well.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If you open a connection to Redis when Gopher is enabled and send it</span><br><span class="hljs-comment"># a string like &quot;/foo&quot;, if there is a key named &quot;/foo&quot; it is served via the</span><br><span class="hljs-comment"># Gopher protocol.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># In order to create a real Gopher &quot;hole&quot; (the name of a Gopher site in Gopher</span><br><span class="hljs-comment"># talking), you likely need a script like the following:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   https://github.com/antirez/gopher2redis</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># --- SECURITY WARNING ---</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If you plan to put Redis on the internet in a publicly accessible address</span><br><span class="hljs-comment"># to server Gopher pages MAKE SURE TO SET A PASSWORD to the instance.</span><br><span class="hljs-comment"># Once a password is set:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   1. The Gopher server (when enabled, not by default) will still serve</span><br><span class="hljs-comment">#      content via Gopher.</span><br><span class="hljs-comment">#   2. However other commands cannot be called before the client will</span><br><span class="hljs-comment">#      authenticate.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># So use the &#x27;requirepass&#x27; option to protect your instance.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># To enable Gopher support uncomment the following line and set</span><br><span class="hljs-comment"># the option from no (the default) to yes.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># gopher-enabled no</span><br><br><span class="hljs-comment">############################### ADVANCED CONFIG ###############################</span><br><br><span class="hljs-comment"># Hashes are encoded using a memory efficient data structure when they have a</span><br><span class="hljs-comment"># small number of entries, and the biggest entry does not exceed a given</span><br><span class="hljs-comment"># threshold. These thresholds can be configured using the following directives.</span><br><span class="hljs-attribute">hash</span>-max-ziplist-entries <span class="hljs-number">512</span><br><span class="hljs-attribute">hash</span>-max-ziplist-value <span class="hljs-number">64</span><br><br><span class="hljs-comment"># Lists are also encoded in a special way to save a lot of space.</span><br><span class="hljs-comment"># The number of entries allowed per internal list node can be specified</span><br><span class="hljs-comment"># as a fixed maximum size or a maximum number of elements.</span><br><span class="hljs-comment"># For a fixed maximum size, use -5 through -1, meaning:</span><br><span class="hljs-comment"># -5: max size: 64 Kb  &lt;-- not recommended for normal workloads</span><br><span class="hljs-comment"># -4: max size: 32 Kb  &lt;-- not recommended</span><br><span class="hljs-comment"># -3: max size: 16 Kb  &lt;-- probably not recommended</span><br><span class="hljs-comment"># -2: max size: 8 Kb   &lt;-- good</span><br><span class="hljs-comment"># -1: max size: 4 Kb   &lt;-- good</span><br><span class="hljs-comment"># Positive numbers mean store up to _exactly_ that number of elements</span><br><span class="hljs-comment"># per list node.</span><br><span class="hljs-comment"># The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),</span><br><span class="hljs-comment"># but if your use case is unique, adjust the settings as necessary.</span><br><span class="hljs-attribute">list</span>-max-ziplist-size -<span class="hljs-number">2</span><br><br><span class="hljs-comment"># Lists may also be compressed.</span><br><span class="hljs-comment"># Compress depth is the number of quicklist ziplist nodes from *each* side of</span><br><span class="hljs-comment"># the list to *exclude* from compression.  The head and tail of the list</span><br><span class="hljs-comment"># are always uncompressed for fast push/pop operations.  Settings are:</span><br><span class="hljs-comment"># 0: disable all list compression</span><br><span class="hljs-comment"># 1: depth 1 means &quot;don&#x27;t start compressing until after 1 node into the list,</span><br><span class="hljs-comment">#    going from either the head or tail&quot;</span><br><span class="hljs-comment">#    So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]</span><br><span class="hljs-comment">#    [head], [tail] will always be uncompressed; inner nodes will compress.</span><br><span class="hljs-comment"># 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]</span><br><span class="hljs-comment">#    2 here means: don&#x27;t compress head or head-&gt;next or tail-&gt;prev or tail,</span><br><span class="hljs-comment">#    but compress all nodes between them.</span><br><span class="hljs-comment"># 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]</span><br><span class="hljs-comment"># etc.</span><br><span class="hljs-attribute">list</span>-compress-depth <span class="hljs-number">0</span><br><br><span class="hljs-comment"># Sets have a special encoding in just one case: when a set is composed</span><br><span class="hljs-comment"># of just strings that happen to be integers in radix 10 in the range</span><br><span class="hljs-comment"># of 64 bit signed integers.</span><br><span class="hljs-comment"># The following configuration setting sets the limit in the size of the</span><br><span class="hljs-comment"># set in order to use this special memory saving encoding.</span><br><span class="hljs-attribute">set</span>-max-intset-entries <span class="hljs-number">512</span><br><br><span class="hljs-comment"># Similarly to hashes and lists, sorted sets are also specially encoded in</span><br><span class="hljs-comment"># order to save a lot of space. This encoding is only used when the length and</span><br><span class="hljs-comment"># elements of a sorted set are below the following limits:</span><br><span class="hljs-attribute">zset</span>-max-ziplist-entries <span class="hljs-number">128</span><br><span class="hljs-attribute">zset</span>-max-ziplist-value <span class="hljs-number">64</span><br><br><span class="hljs-comment"># HyperLogLog sparse representation bytes limit. The limit includes the</span><br><span class="hljs-comment"># 16 bytes header. When an HyperLogLog using the sparse representation crosses</span><br><span class="hljs-comment"># this limit, it is converted into the dense representation.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># A value greater than 16000 is totally useless, since at that point the</span><br><span class="hljs-comment"># dense representation is more memory efficient.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The suggested value is ~ 3000 in order to have the benefits of</span><br><span class="hljs-comment"># the space efficient encoding without slowing down too much PFADD,</span><br><span class="hljs-comment"># which is O(N) with the sparse encoding. The value can be raised to</span><br><span class="hljs-comment"># ~ 10000 when CPU is not a concern, but space is, and the data set is</span><br><span class="hljs-comment"># composed of many HyperLogLogs with cardinality in the 0 - 15000 range.</span><br><span class="hljs-attribute">hll</span>-sparse-max-bytes <span class="hljs-number">3000</span><br><br><span class="hljs-comment"># Streams macro node max size / items. The stream data structure is a radix</span><br><span class="hljs-comment"># tree of big nodes that encode multiple items inside. Using this configuration</span><br><span class="hljs-comment"># it is possible to configure how big a single node can be in bytes, and the</span><br><span class="hljs-comment"># maximum number of items it may contain before switching to a new node when</span><br><span class="hljs-comment"># appending new stream entries. If any of the following settings are set to</span><br><span class="hljs-comment"># zero, the limit is ignored, so for instance it is possible to set just a</span><br><span class="hljs-comment"># max entires limit by setting max-bytes to 0 and max-entries to the desired</span><br><span class="hljs-comment"># value.</span><br><span class="hljs-attribute">stream</span>-node-max-bytes <span class="hljs-number">4096</span><br><span class="hljs-attribute">stream</span>-node-max-entries <span class="hljs-number">100</span><br><br><span class="hljs-comment"># Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</span><br><span class="hljs-comment"># order to help rehashing the main Redis hash table (the one mapping top-level</span><br><span class="hljs-comment"># keys to values). The hash table implementation Redis uses (see dict.c)</span><br><span class="hljs-comment"># performs a lazy rehashing: the more operation you run into a hash table</span><br><span class="hljs-comment"># that is rehashing, the more rehashing &quot;steps&quot; are performed, so if the</span><br><span class="hljs-comment"># server is idle the rehashing is never complete and some more memory is used</span><br><span class="hljs-comment"># by the hash table.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The default is to use this millisecond 10 times every second in order to</span><br><span class="hljs-comment"># actively rehash the main dictionaries, freeing memory when possible.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If unsure:</span><br><span class="hljs-comment"># use &quot;activerehashing no&quot; if you have hard latency requirements and it is</span><br><span class="hljs-comment"># not a good thing in your environment that Redis can reply from time to time</span><br><span class="hljs-comment"># to queries with 2 milliseconds delay.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># use &quot;activerehashing yes&quot; if you don&#x27;t have such hard requirements but</span><br><span class="hljs-comment"># want to free memory asap when possible.</span><br><span class="hljs-attribute">activerehashing</span> yes<br><br><span class="hljs-comment"># The client output buffer limits can be used to force disconnection of clients</span><br><span class="hljs-comment"># that are not reading data from the server fast enough for some reason (a</span><br><span class="hljs-comment"># common reason is that a Pub/Sub client can&#x27;t consume messages as fast as the</span><br><span class="hljs-comment"># publisher can produce them).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The limit can be set differently for the three different classes of clients:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># normal -&gt; normal clients including MONITOR clients</span><br><span class="hljs-comment"># replica  -&gt; replica clients</span><br><span class="hljs-comment"># pubsub -&gt; clients subscribed to at least one pubsub channel or pattern</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The syntax of every client-output-buffer-limit directive is the following:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># A client is immediately disconnected once the hard limit is reached, or if</span><br><span class="hljs-comment"># the soft limit is reached and remains reached for the specified number of</span><br><span class="hljs-comment"># seconds (continuously).</span><br><span class="hljs-comment"># So for instance if the hard limit is 32 megabytes and the soft limit is</span><br><span class="hljs-comment"># 16 megabytes / 10 seconds, the client will get disconnected immediately</span><br><span class="hljs-comment"># if the size of the output buffers reach 32 megabytes, but will also get</span><br><span class="hljs-comment"># disconnected if the client reaches 16 megabytes and continuously overcomes</span><br><span class="hljs-comment"># the limit for 10 seconds.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default normal clients are not limited because they don&#x27;t receive data</span><br><span class="hljs-comment"># without asking (in a push way), but just after a request, so only</span><br><span class="hljs-comment"># asynchronous clients may create a scenario where data is requested faster</span><br><span class="hljs-comment"># than it can read.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Instead there is a default limit for pubsub and replica clients, since</span><br><span class="hljs-comment"># subscribers and replicas receive data in a push fashion.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Both the hard or the soft limit can be disabled by setting them to zero.</span><br><span class="hljs-attribute">client</span>-output-buffer-limit normal <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">client</span>-output-buffer-limit replica <span class="hljs-number">256</span>mb <span class="hljs-number">64</span>mb <span class="hljs-number">60</span><br><span class="hljs-attribute">client</span>-output-buffer-limit pubsub <span class="hljs-number">32</span>mb <span class="hljs-number">8</span>mb <span class="hljs-number">60</span><br><br><span class="hljs-comment"># Client query buffers accumulate new commands. They are limited to a fixed</span><br><span class="hljs-comment"># amount by default in order to avoid that a protocol desynchronization (for</span><br><span class="hljs-comment"># instance due to a bug in the client) will lead to unbound memory usage in</span><br><span class="hljs-comment"># the query buffer. However you can configure it here if you have very special</span><br><span class="hljs-comment"># needs, such us huge multi/exec requests or alike.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># client-query-buffer-limit 1gb</span><br><br><span class="hljs-comment"># In the Redis protocol, bulk requests, that are, elements representing single</span><br><span class="hljs-comment"># strings, are normally limited ot 512 mb. However you can change this limit</span><br><span class="hljs-comment"># here, but must be 1mb or greater</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># proto-max-bulk-len 512mb</span><br><br><span class="hljs-comment"># Redis calls an internal function to perform many background tasks, like</span><br><span class="hljs-comment"># closing connections of clients in timeout, purging expired keys that are</span><br><span class="hljs-comment"># never requested, and so forth.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Not all tasks are performed with the same frequency, but Redis checks for</span><br><span class="hljs-comment"># tasks to perform according to the specified &quot;hz&quot; value.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default &quot;hz&quot; is set to 10. Raising the value will use more CPU when</span><br><span class="hljs-comment"># Redis is idle, but at the same time will make Redis more responsive when</span><br><span class="hljs-comment"># there are many keys expiring at the same time, and timeouts may be</span><br><span class="hljs-comment"># handled with more precision.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The range is between 1 and 500, however a value over 100 is usually not</span><br><span class="hljs-comment"># a good idea. Most users should use the default of 10 and raise this up to</span><br><span class="hljs-comment"># 100 only in environments where very low latency is required.</span><br><span class="hljs-attribute">hz</span> <span class="hljs-number">10</span><br><br><span class="hljs-comment"># Normally it is useful to have an HZ value which is proportional to the</span><br><span class="hljs-comment"># number of clients connected. This is useful in order, for instance, to</span><br><span class="hljs-comment"># avoid too many clients are processed for each background task invocation</span><br><span class="hljs-comment"># in order to avoid latency spikes.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Since the default HZ value by default is conservatively set to 10, Redis</span><br><span class="hljs-comment"># offers, and enables by default, the ability to use an adaptive HZ value</span><br><span class="hljs-comment"># which will temporary raise when there are many connected clients.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># When dynamic HZ is enabled, the actual configured HZ will be used</span><br><span class="hljs-comment"># as a baseline, but multiples of the configured HZ value will be actually</span><br><span class="hljs-comment"># used as needed once more clients are connected. In this way an idle</span><br><span class="hljs-comment"># instance will use very little CPU time while a busy instance will be</span><br><span class="hljs-comment"># more responsive.</span><br><span class="hljs-attribute">dynamic</span>-hz yes<br><br><span class="hljs-comment"># When a child rewrites the AOF file, if the following option is enabled</span><br><span class="hljs-comment"># the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="hljs-comment"># in order to commit the file to the disk more incrementally and avoid</span><br><span class="hljs-comment"># big latency spikes.</span><br><span class="hljs-attribute">aof</span>-rewrite-incremental-fsync yes<br><br><span class="hljs-comment"># When redis saves RDB file, if the following option is enabled</span><br><span class="hljs-comment"># the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="hljs-comment"># in order to commit the file to the disk more incrementally and avoid</span><br><span class="hljs-comment"># big latency spikes.</span><br><span class="hljs-attribute">rdb</span>-save-incremental-fsync yes<br><br><span class="hljs-comment"># Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good</span><br><span class="hljs-comment"># idea to start with the default settings and only change them after investigating</span><br><span class="hljs-comment"># how to improve the performances and how the keys LFU change over time, which</span><br><span class="hljs-comment"># is possible to inspect via the OBJECT FREQ command.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># There are two tunable parameters in the Redis LFU implementation: the</span><br><span class="hljs-comment"># counter logarithm factor and the counter decay time. It is important to</span><br><span class="hljs-comment"># understand what the two parameters mean before changing them.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The LFU counter is just 8 bits per key, it&#x27;s maximum value is 255, so Redis</span><br><span class="hljs-comment"># uses a probabilistic increment with logarithmic behavior. Given the value</span><br><span class="hljs-comment"># of the old counter, when a key is accessed, the counter is incremented in</span><br><span class="hljs-comment"># this way:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1. A random number R between 0 and 1 is extracted.</span><br><span class="hljs-comment"># 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).</span><br><span class="hljs-comment"># 3. The counter is incremented only if R &lt; P.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The default lfu-log-factor is 10. This is a table of how the frequency</span><br><span class="hljs-comment"># counter changes with a different number of accesses with different</span><br><span class="hljs-comment"># logarithmic factors:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-comment"># | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span><br><span class="hljs-comment"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-comment"># | 0      | 104        | 255        | 255        | 255        | 255        |</span><br><span class="hljs-comment"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-comment"># | 1      | 18         | 49         | 255        | 255        | 255        |</span><br><span class="hljs-comment"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-comment"># | 10     | 10         | 18         | 142        | 255        | 255        |</span><br><span class="hljs-comment"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-comment"># | 100    | 8          | 11         | 49         | 143        | 255        |</span><br><span class="hljs-comment"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> The above table was obtained by running the following commands:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   redis-benchmark -n 1000000 incr foo</span><br><span class="hljs-comment">#   redis-cli object freq foo</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># NOTE 2: The counter initial value is 5 in order to give new objects a chance</span><br><span class="hljs-comment"># to accumulate hits.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The counter decay time is the time, in minutes, that must elapse in order</span><br><span class="hljs-comment"># for the key counter to be divided by two (or decremented if it has a value</span><br><span class="hljs-comment"># less &lt;= 10).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The default value for the lfu-decay-time is 1. A Special value of 0 means to</span><br><span class="hljs-comment"># decay the counter every time it happens to be scanned.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># lfu-log-factor 10</span><br><span class="hljs-comment"># lfu-decay-time 1</span><br><br><span class="hljs-comment">########################### ACTIVE DEFRAGMENTATION #######################</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># What is active defragmentation?</span><br><span class="hljs-comment"># -------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Active (online) defragmentation allows a Redis server to compact the</span><br><span class="hljs-comment"># spaces left between small allocations and deallocations of data in memory,</span><br><span class="hljs-comment"># thus allowing to reclaim back memory.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Fragmentation is a natural process that happens with every allocator (but</span><br><span class="hljs-comment"># less so with Jemalloc, fortunately) and certain workloads. Normally a server</span><br><span class="hljs-comment"># restart is needed in order to lower the fragmentation, or at least to flush</span><br><span class="hljs-comment"># away all the data and create it again. However thanks to this feature</span><br><span class="hljs-comment"># implemented by Oran Agra for Redis 4.0 this process can happen at runtime</span><br><span class="hljs-comment"># in an &quot;hot&quot; way, while the server is running.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Basically when the fragmentation is over a certain level (see the</span><br><span class="hljs-comment"># configuration options below) Redis will start to create new copies of the</span><br><span class="hljs-comment"># values in contiguous memory regions by exploiting certain specific Jemalloc</span><br><span class="hljs-comment"># features (in order to understand if an allocation is causing fragmentation</span><br><span class="hljs-comment"># and to allocate it in a better place), and at the same time, will release the</span><br><span class="hljs-comment"># old copies of the data. This process, repeated incrementally for all the keys</span><br><span class="hljs-comment"># will cause the fragmentation to drop back to normal values.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Important things to understand:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1. This feature is disabled by default, and only works if you compiled Redis</span><br><span class="hljs-comment">#    to use the copy of Jemalloc we ship with the source code of Redis.</span><br><span class="hljs-comment">#    This is the default with Linux builds.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 2. You never need to enable this feature if you don&#x27;t have fragmentation</span><br><span class="hljs-comment">#    issues.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 3. Once you experience fragmentation, you can enable this feature when</span><br><span class="hljs-comment">#    needed with the command &quot;CONFIG SET activedefrag yes&quot;.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The configuration parameters are able to fine tune the behavior of the</span><br><span class="hljs-comment"># defragmentation process. If you are not sure about what they mean it is</span><br><span class="hljs-comment"># a good idea to leave the defaults untouched.</span><br><br><span class="hljs-comment"># Enabled active defragmentation</span><br><span class="hljs-comment"># activedefrag no</span><br><br><span class="hljs-comment"># Minimum amount of fragmentation waste to start active defrag</span><br><span class="hljs-comment"># active-defrag-ignore-bytes 100mb</span><br><br><span class="hljs-comment"># Minimum percentage of fragmentation to start active defrag</span><br><span class="hljs-comment"># active-defrag-threshold-lower 10</span><br><br><span class="hljs-comment"># Maximum percentage of fragmentation at which we use maximum effort</span><br><span class="hljs-comment"># active-defrag-threshold-upper 100</span><br><br><span class="hljs-comment"># Minimal effort for defrag in CPU percentage, to be used when the lower</span><br><span class="hljs-comment"># threshold is reached</span><br><span class="hljs-comment"># active-defrag-cycle-min 1</span><br><br><span class="hljs-comment"># Maximal effort for defrag in CPU percentage, to be used when the upper</span><br><span class="hljs-comment"># threshold is reached</span><br><span class="hljs-comment"># active-defrag-cycle-max 25</span><br><br><span class="hljs-comment"># Maximum number of set/hash/zset/list fields that will be processed from</span><br><span class="hljs-comment"># the main dictionary scan</span><br><span class="hljs-comment"># active-defrag-max-scan-fields 1000</span><br><br><span class="hljs-comment"># Jemalloc background thread for purging will be enabled by default</span><br><span class="hljs-attribute">jemalloc</span>-bg-thread yes<br><br><span class="hljs-comment"># It is possible to pin different threads and processes of Redis to specific</span><br><span class="hljs-comment"># CPUs in your system, in order to maximize the performances of the server.</span><br><span class="hljs-comment"># This is useful both in order to pin different Redis threads in different</span><br><span class="hljs-comment"># CPUs, but also in order to make sure that multiple Redis instances running</span><br><span class="hljs-comment"># in the same host will be pinned to different CPUs.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Normally you can do this using the &quot;taskset&quot; command, however it is also</span><br><span class="hljs-comment"># possible to this via Redis configuration directly, both in Linux and FreeBSD.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># You can pin the server/IO threads, bio threads, aof rewrite child process, and</span><br><span class="hljs-comment"># the bgsave child process. The syntax to specify the cpu list is the same as</span><br><span class="hljs-comment"># the taskset command:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Set redis server/io threads to cpu affinity 0,2,4,6:</span><br><span class="hljs-comment"># server_cpulist 0-7:2</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Set bio threads to cpu affinity 1,3:</span><br><span class="hljs-comment"># bio_cpulist 1,3</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Set aof rewrite child process to cpu affinity 8,9,10,11:</span><br><span class="hljs-comment"># aof_rewrite_cpulist 8-11</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Set bgsave child process to cpu affinity 1,10,11</span><br><span class="hljs-comment"># bgsave_cpulist 1,10-11</span><br><br></code></pre></td></tr></table></figure><Vssue :title="$title" />]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++：如何理解函数返回一个引用</title>
    <link href="/2020/04/15/2021-4-15-cpp_func_return_reference/"/>
    <url>/2020/04/15/2021-4-15-cpp_func_return_reference/</url>
    
    <content type="html"><![CDATA[<blockquote><p>初学 c++ 时遇到了一个疑问，记录一下</p></blockquote><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>有如下函数，其返回值是一个引用类型，内部逻辑也很简单，只是简单的把参数返回：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> &amp;<span class="hljs-title">ret_val</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个函数用来接收返回的引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 接收一个引用返回</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">receive_refer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> a = <span class="hljs-built_in">ret_val</span>(i); <span class="hljs-comment">// int 接收</span><br>    cout &lt;&lt; a &lt;&lt; endl;  <span class="hljs-comment">// Output: 10</span><br>    a = <span class="hljs-number">50</span>;<br>    cout &lt;&lt; i &lt;&lt; endl;  <span class="hljs-comment">// Output: 10</span><br><br>    <span class="hljs-type">int</span> &amp;a1 = <span class="hljs-built_in">ret_val</span>(i);   <span class="hljs-comment">// int&amp; 接收</span><br>    a1 = <span class="hljs-number">50</span>;<br>    cout &lt;&lt; i &lt;&lt; endl;  <span class="hljs-comment">// Output: 50</span><br><br>    <span class="hljs-built_in">ret_val</span>(i) = <span class="hljs-number">555</span>;<br>    cout &lt;&lt; i &lt;&lt; endl;  <span class="hljs-comment">// Output: 555</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接收引用类型的返回值有两种方式：使用 int 接收，或者使用 int&amp; 接收，分别对应上面的 a 和 a1，并且还发现一个现象：对 a 的修改不能反映到 i ，而 a1 可以。对此我有几点疑问：</p><ol><li>既然返回值是一个引用，那么接收者不应该也得是引用类型吗，就好比一个函数返回的是 int 指针，那么接收者也必须是一个 int 指针，而不能是 int。比如上面的代码用指针改写的话，应该是这样：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">ret_val</span><span class="hljs-params">(<span class="hljs-type">int</span> *a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">receive_</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> a = <span class="hljs-built_in">ret_val</span>(&amp;i);    <span class="hljs-comment">// 错误，不能用 int 接收指针，因为返回值是 int*</span><br>    <span class="hljs-type">int</span> *a1 = <span class="hljs-built_in">ret_val</span>(&amp;a);<br>    *a1 = <span class="hljs-number">50</span>;<br>    <span class="hljs-type">int</span> aa = *a1;     <br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>为什么对 a 的修改不能反映到 i ，而 a1 可以？既然 ret_val 返回的是一个引用，那么理论上它的接收者也应该是一个引用啊？如果是这样的话，a 不就是 i 的引用吗，那为什么修改 a 不能反映到 i？</li></ol><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><p>其实这两个疑问都是因为没搞明白 c++ 引用，后面看了一下 c++ primer，里面 <strong>2.3.1 引用</strong> 以及 <strong>p226 引用返回左值</strong> 这两节的内容就可以解决我上面的疑问了。</p><p>首先，如果一个函数的返回值类型是引用类型，那么调用者得到的将会是一个 <strong>左值</strong>。</p><p>然后，<strong>获取引用的值，实际是获取了与引用绑定的对象的值</strong>。</p><p>那么，这意味着 <code>int a = ret_val(i)</code> 的含义是：用一个 int 类型的变量 a 来获取 ret_val 返回的引用所绑定的对象的值，那么该语句实际上等同于 int a &#x3D; i。</p><p>而 <code>int &amp;a1 = ret_val(i)</code> 代表将 a1 绑定到 ret_val 返回的引用所绑定的对象，也就是说，a1 也是 i 的引用。</p><p>所以，用 int 和 int&amp; 来 ”接收” ret_val 的返回值这个说法似乎不太恰当，应该说 int&amp; 才是接收操作，而 int 是用来获取引用绑定的对象的值，这是两种不同的行为。这也能解释为什么对 a 的修改不能反映到 i ，而 a1 可以，因为 a 只是拷贝了一份引用绑定的对象的值，所以对 a 的修改当然不会反映到 i，而 a1 是 i 的引用，所以对 a1 的修改自然会反映到 i。</p><p>此外，既然引用返回的是左值，那么则意味着其可以出现在赋值运算符的左侧，写成下面这样的形式也就不奇怪了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">ret_val</span>(i) = <span class="hljs-number">555</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go container/list 源码分析【未完】</title>
    <link href="/2020/02/24/2021-2-24-go-container-list-source-code/"/>
    <url>/2020/02/24/2021-2-24-go-container-list-source-code/</url>
    
    <content type="html"><![CDATA[<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// List代表一个双向链表。List零值为一个空的、可用的链表。</span><br><span class="hljs-keyword">type</span> List <span class="hljs-keyword">struct</span> &#123;<br>  <span class="hljs-comment">// 哨兵节点，连接链表的头节点和尾结点，root.next 连接的是第一个结点，root.prev 连接的是最后一// 个结点</span><br>  root Element <br>  <span class="hljs-comment">// 当前列表长度，不包括哨兵节点</span><br><span class="hljs-built_in">len</span>  <span class="hljs-type">int</span>     <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 初始化或清空 list l。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> Init() *List &#123;<br>l.root.next = &amp;l.root<br>l.root.prev = &amp;l.root<br>l.<span class="hljs-built_in">len</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">return</span> l<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> lazyInit() &#123;<br><span class="hljs-keyword">if</span> l.root.next == <span class="hljs-literal">nil</span> &#123;<br>l.Init()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// insert inserts e after at, increments l.len, and returns e.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> insert(e, at *Element) *Element &#123;<br>e.prev = at<br>e.next = at.next<br>e.prev.next = e<br>e.next.prev = e<br>e.list = l<br>l.<span class="hljs-built_in">len</span>++<br><span class="hljs-keyword">return</span> e<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// insertValue is a convenience wrapper for insert(&amp;Element&#123;Value: v&#125;, at).</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> insertValue(v <span class="hljs-keyword">interface</span>&#123;&#125;, at *Element) *Element &#123;<br><span class="hljs-keyword">return</span> l.insert(&amp;Element&#123;Value: v&#125;, at)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// PushBack inserts a new element e with value v at the back of list l and returns e.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> PushBack(v <span class="hljs-keyword">interface</span>&#123;&#125;) *Element &#123;<br>l.lazyInit()<br><span class="hljs-keyword">return</span> l.insertValue(v, l.root.prev)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><h3 id="Front"><a href="#Front" class="headerlink" title="Front()"></a>Front()</h3><p>获取链表的第一个节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 返回列表 l 的第一个元素；如果列表为空，则返回nil。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> Front() *Element &#123;<br><span class="hljs-keyword">if</span> l.<span class="hljs-built_in">len</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>  <span class="hljs-comment">// 这里可以看到是用 root.next 连接第一个结点</span><br><span class="hljs-keyword">return</span> l.root.next<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Back"><a href="#Back" class="headerlink" title="Back()"></a>Back()</h3><p>获取链表的最后一个节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 返回列表l的最后一个元素；如果列表为空，则返回nil。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> Back() *Element &#123;<br><span class="hljs-keyword">if</span> l.<span class="hljs-built_in">len</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>  <span class="hljs-comment">// 这里可以看到是用 root.prev 连接最后一个节点</span><br><span class="hljs-keyword">return</span> l.root.prev<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go 交换 container/list 的值</title>
    <link href="/2020/02/24/2021-2-24-go-container-list-swap/"/>
    <url>/2020/02/24/2021-2-24-go-container-list-swap/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在 <strong>LeetCode 255.用队列实现栈</strong> 这道题里，需要用到两个队列来实现一个栈，并且在算法流程中，需要交换这两个队列的内容，例如：队列 A  &#x3D;&gt; [1, 2, 3]，队列 B &#x3D;&gt; [555]，交换后：A &#x3D;&gt; [555]，B &#x3D;&gt; [1, 2, 3]。</p><p>go 标准库中并没有提供队列的实现，但是提供了 container&#x2F;list 这样一个双向链表，所以可以用 list 来模拟一个队列，定义如下结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStack <span class="hljs-keyword">struct</span> &#123;<br>    Queue1 *list.List<span class="hljs-comment">// 队列 1</span><br>    Queue2 *list.List<span class="hljs-comment">// 队列 2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>push</code> 方法中需要交换两个队列的内容：</p><h3 id="写法1"><a href="#写法1" class="headerlink" title="写法1"></a>写法1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>  <span class="hljs-comment">// 省略其他代码</span><br>  <span class="hljs-comment">// 在这里交换值</span><br>  this.Queue1, this.Queue2 = this.Queue2, this.Queue1<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码是可以正确运行的，这里的交换语句让 Queue1 重新指向了另一个 list，Queue2 也同样如此，例如：Queue1 &#x3D;&gt; 0x0001，Queue2 &#x3D;&gt; 0x0013，交换后：Queue1 &#x3D;&gt; 0x0013，Queue2 &#x3D;&gt; 0x0001，这里仅仅是改变了结构体成员属性的值（指向），并没有对属性 list 内部进行更改。</p><h3 id="写法2"><a href="#写法2" class="headerlink" title="写法2"></a>写法2</h3><p>为了让代码更简洁一些，我尝试用两个变量保存 this.Queue1和 this.Queue2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>  q1 := this.Queue1<br>  q2 := this.Queue2<br>  <span class="hljs-comment">// 省略其他代码</span><br>  <span class="hljs-comment">// 在这里交换值</span><br>  q1, q2 = q2, q1<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码会出错，因为这里的交换的是仅仅两个变量 q1 和 q2 的值，并没有对结构体中的属性造成影响。</p><h3 id="写法3"><a href="#写法3" class="headerlink" title="写法3"></a>写法3</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>  q1 := this.Queue1<br>  q2 := this.Queue2<br>  <span class="hljs-comment">// 省略其他代码</span><br>  <span class="hljs-comment">// 在这里交换值</span><br>  *q1, *q2 = *q2, *q1<br>&#125;<br></code></pre></td></tr></table></figure><p>因为 q1 和 q2 都是指针变量，所以可以通过 *<strong>取内容符</strong> 来交换值，就和交换两个指针参数值一样，看起来也没有任何问题，但是运行结果却诡异的出现了死循环，而且排查了许久都找不到原因。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><strong>Struct ll</strong>  定义一个类似的结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ll <span class="hljs-keyword">struct</span> &#123;<br>l1 *list.List<br>l2 *list.List<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>swap()</strong> 类似 <strong>方法三</strong> 中的取值交换方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(l1, l2 *list.List)</span></span> &#123;<br>*l1, *l2 = *l2, *l1<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>_print</strong> 定义一个输出函数用来友好输出链表，输出值的同时也输出地址值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">print</span><span class="hljs-params">(name <span class="hljs-type">string</span>, l *list.List)</span></span> &#123;<br>fmt.Print(name + <span class="hljs-string">&quot;: &quot;</span>)<br><span class="hljs-keyword">for</span> i := l.Front(); i != <span class="hljs-literal">nil</span>; i = i.Next() &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v[%p] -&gt; \t&quot;</span>, i.Value, i)<br>&#125;<br>fmt.Println()<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建两个 list</span><br>l1 := list.New()<br>l2 := list.New()<br><br><span class="hljs-comment">// 为两个链表添加值，l1: 1 -&gt; 2 -&gt; 3，l2: 666</span><br>l1.PushBack(<span class="hljs-number">1</span>)<br>l1.PushBack(<span class="hljs-number">2</span>)<br>l1.PushBack(<span class="hljs-number">3</span>)<br>l2.PushBack(<span class="hljs-number">666</span>)<br><br><span class="hljs-comment">// 输出交换前的值</span><br>fmt.Println(<span class="hljs-string">&quot;before: &quot;</span>)<br>_print(<span class="hljs-string">&quot;l1&quot;</span>, l1)<br>_print(<span class="hljs-string">&quot;l2&quot;</span>, l2)<br><br><span class="hljs-comment">// 交换函数</span><br>swap(l1, l2)<br><span class="hljs-comment">// 输出交换后的值</span><br>fmt.Println(<span class="hljs-string">&quot;after: &quot;</span>)<br>_print(<span class="hljs-string">&quot;l1&quot;</span>, l1)<br>_print(<span class="hljs-string">&quot;l2&quot;</span>, l2)<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">before</span>: <br><span class="hljs-attribute">l1</span>: <span class="hljs-number">1</span>[<span class="hljs-number">0</span>xc00009cde0] -&gt; <span class="hljs-number">2</span>[<span class="hljs-number">0</span>xc00009ce10] -&gt; <span class="hljs-number">3</span>[<span class="hljs-number">0</span>xc00009ce40] -&gt; <br><span class="hljs-attribute">l2</span>: <span class="hljs-number">666</span>[<span class="hljs-number">0</span>xc00009ce70] -&gt; <br><br><span class="hljs-attribute">after</span>: <br><span class="hljs-attribute">l1</span>: <span class="hljs-number">666</span>[<span class="hljs-number">0</span>xc00009ce70] -&gt; <br><span class="hljs-attribute">l2</span>: <span class="hljs-number">1</span>[<span class="hljs-number">0</span>xc00009cde0] -&gt; <span class="hljs-number">2</span>[<span class="hljs-number">0</span>xc00009ce10] -&gt; <span class="hljs-number">3</span>[<span class="hljs-number">0</span>xc00009ce40] -&gt; <br></code></pre></td></tr></table></figure><p>两个链表的值确实已经发生了改变，但是为什么在 <strong>方法 3</strong> 中会产生诡异的错误呢？继续尝试追加值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 交换完之后 pushback</span><br>fmt.Println(<span class="hljs-string">&quot;after swap pushback: &quot;</span>)<br>l2.PushBack(<span class="hljs-number">555</span>)<br>l1.PushBack(<span class="hljs-number">6</span>)<br><span class="hljs-comment">// 输出两个链表</span><br>_print(<span class="hljs-string">&quot;l1&quot;</span>, l1)<br>_print(<span class="hljs-string">&quot;l2&quot;</span>, l2)<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xl">after swap pushback: <br><span class="hljs-function"><span class="hljs-title">l1</span>: 666[0xc000104e70] -&gt;</span> <span class="hljs-number">6</span>[<span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">xc000104ed0</span>] -&gt;</span> <span class="hljs-number">555</span>[<span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">xc000104ea0</span>] -&gt;</span> &lt;<span class="hljs-function"><span class="hljs-title">nil</span>&gt;[0xc000104db0] -&gt;</span> <br><span class="hljs-function"><span class="hljs-title">l2</span>: 1[0xc000104de0] -&gt;</span> <span class="hljs-number">2</span>[<span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">xc000104e10</span>] -&gt;</span> <span class="hljs-number">3</span>[<span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">xc000104e40</span>] -&gt;</span> <br></code></pre></td></tr></table></figure><p>上面的代码向 l1 尾部添加了 元素 6，向 l2 尾部添加元素 555，正确结果应该是：</p><p>l1:  666 -&gt; 6</p><p>l2:  1 -&gt; 2 -&gt; 3 -&gt; 555</p><p>但运行结果却十分诡异：</p><p>l1:  666 -&gt; 6 -&gt; 555 -&gt; nil</p><p>l2:  1 -&gt; 2 -&gt; 3</p><p>本来应该添加到 l2 的 555 被添加到了 l1，并且 l1 还多了一个 额外的 nil</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>结合源码进行了分析（不一定正确）</p><p><img src="https://zengh1.github.io/post-images/1618573823911.png"></p><p>至于为什么会出现 <strong>测试</strong> 中的诡异情况，发现自己水平有限，画图画的晕头转向，找不出一个合理的原因，只能草草归结于 <strong>list 的环形被破坏，导致产生无法预料的结果</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写法1 <code>this.Queue1, this.Queue2 = this.Queue2, this.Queue1</code>  只是交换了结构体属性 q1 和 q2 的指向，没有对 list 内部进行修改，而 写法3 <code>*this.Queue1, *this.Queue2 = *this.Queue2, *this.Queue1</code> 则是直接对 list 内部进行了修改，所以产生了无法预料的后果，这也充分说明了指针的危险性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go 发送 post 请求</title>
    <link href="/2020/01/24/2021-1-24-go-post-request/"/>
    <url>/2020/01/24/2021-1-24-go-post-request/</url>
    
    <content type="html"><![CDATA[<p>go 基础之使用原生 http 库发送 post 请求</p><span id="more"></span><h2 id="方式-1"><a href="#方式-1" class="headerlink" title="方式 1"></a>方式 1</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 生成请求参数键值对</span><br>data := url.Values&#123;<span class="hljs-string">&quot;propId&quot;</span>: &#123;giftId&#125;, <span class="hljs-string">&quot;propCount&quot;</span>: &#123;count&#125;, <span class="hljs-string">&quot;roomId&quot;</span>: &#123;c.RoomId&#125;&#125;<br><span class="hljs-comment">// Encode() 编码成字符串，并包装成一个 io.Reader</span><br>body := strings.NewReader(data.Encode())<br><br><span class="hljs-comment">// 传到第三个参数</span><br>req, err := http.NewRequest(<span class="hljs-string">&quot;POST&quot;</span>,<br><span class="hljs-string">&quot;https://www.douyu.com/japi/prop/donate/mainsite/v1&quot;</span>,<br>body)<br><br>client := http.Client&#123;&#125;<br>response, err := client.Do(req)<br></code></pre></td></tr></table></figure><h2 id="方式-2"><a href="#方式-2" class="headerlink" title="方式 2"></a>方式 2</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> r http.Request<br>r.ParseForm()<br>r.Form.Add(<span class="hljs-string">&quot;propId&quot;</span>, giftId)<br>r.Form.Add(<span class="hljs-string">&quot;propCount&quot;</span>, count)<br>r.Form.Add(<span class="hljs-string">&quot;roomId&quot;</span>, roomId)<br>body := strings.NewReader(r.Form.Encode())<br><br>req, err := http.NewRequest(<span class="hljs-string">&quot;POST&quot;</span>,<br><span class="hljs-string">&quot;https://www.douyu.com/japi/prop/donate/mainsite/v1&quot;</span>,<br>body)<br><br>client := http.Client&#123;&#125;<br>response, err := client.Do(req)<br></code></pre></td></tr></table></figure><h2 id="方式-3"><a href="#方式-3" class="headerlink" title="方式 3"></a>方式 3</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 直接拼接字符串</span><br>body := strings.NewReader(<span class="hljs-string">&quot;propId=268&amp;propCount=1&amp;roomId=9999&amp;bizExt=%7B%22yzxq%22%3A%7B%7D%7D&quot;</span>)<br>req, err := http.NewRequest(<span class="hljs-string">&quot;POST&quot;</span>,<br><span class="hljs-string">&quot;https://www.douyu.com/japi/prop/donate/mainsite/v1&quot;</span>,<br>body)<br><br>client := http.Client&#123;&#125;<br>response, err := client.Do(req)<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>上面的三种方法，只是创建请求参数键值对的方式不同，最后都是调用了 http.Client.Do() 方法，除此之外，go 还封装了一些 post 方法，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 方法 1</span><br>data := url.Values&#123;<span class="hljs-string">&quot;start&quot;</span>:&#123;<span class="hljs-string">&quot;0&quot;</span>&#125;, <span class="hljs-string">&quot;offset&quot;</span>:&#123;<span class="hljs-string">&quot;xxxx&quot;</span>&#125;&#125;<br>body := strings.NewReader(data.Encode())<br>resp, err := http.Post(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>, body)<br><br><span class="hljs-comment">// 方法 2</span><br><span class="hljs-keyword">var</span> r http.Request<br>r.ParseForm()<br>r.Form.Add(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br>body := strings.NewReader(r.Form.Encode())<br>http.Post(<span class="hljs-string">&quot;xxxx&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>, body)<br><br><span class="hljs-comment">// 方法 3</span><br>data := url.Values&#123;<span class="hljs-string">&quot;start&quot;</span>:&#123;<span class="hljs-string">&quot;0&quot;</span>&#125;, <span class="hljs-string">&quot;offset&quot;</span>:&#123;<span class="hljs-string">&quot;xxxx&quot;</span>&#125;&#125;<br><span class="hljs-comment">// PostForm 的默认 content-type 是 application/x-www-form-urlencoded</span><br>http.PostForm(<span class="hljs-string">&quot;xxxx&quot;</span>, data)<br><br><br></code></pre></td></tr></table></figure><h2 id="发送-json"><a href="#发送-json" class="headerlink" title="发送 json"></a>发送 json</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">bodyJson := <span class="hljs-string">`&#123;&quot;name&quot;:&quot;zhang3 by json&quot;, &quot;id&quot;:&quot;123 by json&quot;&#125;`</span><br>body := bytes.NewReader([]<span class="hljs-type">byte</span>(bodyJson))<br>req, err := http.NewRequest(http.MethodPost, __url__, body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-comment">// 设置 content-type 为 application/json</span><br>req.Header.Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>resp1, _ := http.DefaultClient.Do(req)<br><span class="hljs-keyword">defer</span> resp1.Body.Close()<br>fmt.Println(<span class="hljs-string">&quot;(2)&quot;</span>, <span class="hljs-type">string</span>(read(resp1.Body)))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>硬链接和软链接</title>
    <link href="/2020/01/11/2021-1-19-soft-hard-link/"/>
    <url>/2020/01/11/2021-1-19-soft-hard-link/</url>
    
    <content type="html"><![CDATA[<p>Linux 的硬链接和软链接</p><span id="more"></span><h1 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h1><p>在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)，可以通过 ls -li 查看每个文件的索引节点：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">ls</span> -li<br>total 56<br> 8758859 -rw-r--r--  1 zz  staff   364 12 27 11:57 bufio_read.go<br> 7957721 -rw-r--r--  1 zz  staff   383 12 13 22:30 bufio_scann.go<br>10097171 -rw-r--r--  1 zz  staff   225  1  8 12:04 deferTest.go<br>10164017 -rw-r--r--  1 zz  staff   464  1  8 20:43 inToOut.go<br> 8751290 -rw-r--r--  1 zz  staff   276 12 26 22:13 scanfTest.go<br> 7173127 -rw-r--r--  1 zz  staff   338 12  2 14:45 t1.go<br> 7173519 -rw-r--r--@ 1 zz  staff  1520 12  2 14:59 test.go<br></code></pre></td></tr></table></figure><h1 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h1><p>基本命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">ln</span> f1 f2  <span class="hljs-comment">#创建f1的一个硬连接文件f2</span><br></code></pre></td></tr></table></figure><p><strong>硬链接</strong>可以简单把它想成 C 语言中的指针，它指向了物理硬盘的一个区块，多个硬链接会指向同一个区块，（可以理解为 C 中的多个指针指向了同一块内存空间）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch f &amp;&amp; echo &quot;hello&quot; &gt; f   # 创建一个文件并向其写入内容<br>ln f hard_f                   # 创建 f 的第一条硬链接 hard_f<br>ln f hard_f1                  # 创建 f 的第二条硬链接 hard_f1<br><br>ll -i<br>10966044 -rw-r--r--  3 zz  staff     6B  1 19 11:52 f<br>10966044 -rw-r--r--  3 zz  staff     6B  1 19 11:52 hard_f<br>10966044 -rw-r--r--  3 zz  staff     6B  1 19 11:52 hard_f1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">两个硬链接的 inode index 与源文件相同</span><br></code></pre></td></tr></table></figure><p>因为指向的是同一个硬盘区块，所以通过硬链接更改文件内容时，会导致其他的硬链接及源文件也被更改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> f hard_f hard_f1     <span class="hljs-comment"># 输出三个文件的初始值</span><br>hello<br>hello<br>hello<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;123&quot;</span> &gt; hard_f      <span class="hljs-comment"># 修改 hard_f 的内容</span><br><span class="hljs-built_in">cat</span> f hard_f hard_f1     <span class="hljs-comment"># 三个文件的值已经全部更改了</span><br>123<br>123<br>123<br></code></pre></td></tr></table></figure><p>事实上文件系统会维护一个引用计数，只要有文件指向这个区块，它就不会从硬盘上消失。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">rm</span> f                   <span class="hljs-comment"># 删除源文件</span><br><span class="hljs-built_in">cat</span> hard_f hard_f1     <span class="hljs-comment"># 尝试输出两个链接文件的内容</span><br>123<br>123                    <span class="hljs-comment"># 硬链接文件可以正常输出</span><br><br></code></pre></td></tr></table></figure><p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><h1 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h1><p>基本命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">ln</span> -s f1 soft<br></code></pre></td></tr></table></figure><p><strong>软链接</strong>也称之为符号连接（Symbolic Link），软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个<strong>文本文件</strong>，其中包含有另一文件的<strong>位置信息</strong>，在硬盘上有独立的区块，访问时替换自身路径。</p><p>与硬链接不同，软链接的 inode_index 与源文件是不同的，每个软链接的  inode_index 也不同，如下： </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">ln</span> -s f soft_f1<span class="hljs-comment"># 创建两个软链接</span><br><span class="hljs-built_in">ln</span> -s f soft_f2<br>ll -i<br>10973146 -rw-r--r--  1 zz  staff     4B  1 19 17:19 f<br>10973197 lrwxr-xr-x  1 zz  staff     1B  1 19 17:19 soft_f1 -&gt; f<br>10973203 lrwxr-xr-x  1 zz  staff     1B  1 19 17:20 soft_f2 -&gt; f<br></code></pre></td></tr></table></figure><p>软链接的显示形式也比较特殊，为 软链接文件 -&gt; 源文件。</p><p>删除源文件后，所有关联的的软链接文件仍然存在（因为两个是不同的文件），但指向的是一个无效的链接：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">rm</span> f<span class="hljs-comment"># 删除源文件</span><br><span class="hljs-built_in">cat</span> soft_f1 soft_f2<span class="hljs-comment"># 尝试输出两个软链接文件</span><br><span class="hljs-built_in">cat</span>: soft_f1: No such file or directory<span class="hljs-comment"># 无法输出内容：找不到文件</span><br><span class="hljs-built_in">cat</span>: soft_f2: No such file or directory<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>硬链接是指针，所有的硬链接都是指向同一个磁盘块。 删除一个指针不会真正删除文件，只有把所有的指针都删除才会真正删除文件。 软连接是另外一种类型的文件，保存的是它指向文件的全路径， 访问时会替换成绝对路径</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++ 引用：如何理解&quot;引用被初始化后，不能再指向其他对象&quot;</title>
    <link href="/2020/01/11/2021-1-11-reference_c++/"/>
    <url>/2020/01/11/2021-1-11-reference_c++/</url>
    
    <content type="html"><![CDATA[<p>在 c++ 的引用规则中，有这么一条：<strong>一旦初始化完成 ，引用将和它的初始值对象一直绑定在一起（即不能再指向其他对象）</strong>。抱着初学者的好奇心态，我尝试改变引用的指向，写出了如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义两个 string 变量</span><br>std::string s = <span class="hljs-string">&quot;123&quot;</span>;<br>std::string s2 = <span class="hljs-string">&quot;456&quot;</span>;<br><br><span class="hljs-comment">// 让 s1 引用 s</span><br>std::string &amp;s1 = s;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;修改前：&quot;</span> &lt;&lt; <span class="hljs-string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; std::endl;<br><span class="hljs-comment">// 修改 s1 的引用？</span><br>s1 = s2;  <br>std::cout &lt;&lt; <span class="hljs-string">&quot;修改后：&quot;</span> &lt;&lt; <span class="hljs-string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; std::endl;<br><br><span class="hljs-comment">// output</span><br>修改前：s1: <span class="hljs-number">123</span><br>修改后：s1: <span class="hljs-number">456</span><br><br></code></pre></td></tr></table></figure><p>这里我让 s1 重新指向 s2，并且从输出结果来看，s1 的值也确实被修改了，不对啊，规则中明明说好了不能修改的，怎么实际代码中可以？为了验证引用是否真的被修改，将三个变量的指针打印出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;指针 =&gt; s1: %p | s2: %p | s: %p \n&quot;</span>, &amp;s1, &amp;s2, &amp;s);<br><br><span class="hljs-comment">// output</span><br>指针 =&gt; s1: <span class="hljs-number">0x7ffee199e7c8</span> | s2: <span class="hljs-number">0x7ffee199e7b0</span> | s: <span class="hljs-number">0x7ffee199e7c8</span> <br></code></pre></td></tr></table></figure><p>s1 和 s3 是同一个地址，说明引用并未改变，所以并不是引用被修改了，而是我的理解出现了问题，代码中的 s1 &#x3D; s2，并不是让引用重新指向 s2，而是把值赋给了与引用绑定的对象（等同于 s &#x3D; s2），这里做一个简单验证就很好理解了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义两个 string 变量</span><br>std::string s = <span class="hljs-string">&quot;123&quot;</span>;<br>std::string s2 = <span class="hljs-string">&quot;456&quot;</span>;<br><br><span class="hljs-comment">// 让 s1 引用 s</span><br>std::string &amp;s1 = s;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;修改前：&quot;</span> &lt;&lt; <span class="hljs-string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; std::endl;<br><span class="hljs-comment">// 修改 s1 的引用？</span><br>s1 = s2;  <br><span class="hljs-comment">// 修改 s2 的值，如果 s1 的引用被修改为指向 s2，那么 s1 的值应该也会改为 &quot;666&quot;</span><br>s2 = <span class="hljs-string">&quot;666&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;修改后：&quot;</span> &lt;&lt; <span class="hljs-string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; std::endl;<br><br><br><span class="hljs-comment">// output</span><br>修改前：s1: <span class="hljs-number">123</span><br>修改后：s1: <span class="hljs-number">456</span><br></code></pre></td></tr></table></figure><p>s1 并没有被修改为 “666”，所以可以印证上面的说法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
