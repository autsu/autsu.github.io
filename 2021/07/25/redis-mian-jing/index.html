

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon.png">
  <link rel="icon" href="/img/icon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="void">
  <meta name="keywords" content="">
  
    <meta name="description" content="Redis 的数据类型以及日常的应用PS：这里说的数据类型指的是 value 的类型，Redis 是一个 kv 数据库，它的 key 都是 string 类型的，但是 value 可以是多种类型。 string 字符串类型缓存对象这个没啥好说的，就是存一些字符串，这些字符串可以是各种各样的值，比如可以是常规的 “name”: “zhang3”，也可以是一个序列化为 JSON 的对象 {“XXX”:">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 面试题">
<meta property="og:url" content="https://autsu.github.io/2021/07/25/redis-mian-jing/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Redis 的数据类型以及日常的应用PS：这里说的数据类型指的是 value 的类型，Redis 是一个 kv 数据库，它的 key 都是 string 类型的，但是 value 可以是多种类型。 string 字符串类型缓存对象这个没啥好说的，就是存一些字符串，这些字符串可以是各种各样的值，比如可以是常规的 “name”: “zhang3”，也可以是一个序列化为 JSON 的对象 {“XXX”:">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/autsu/diagrams/master/img/redis_master_slave_sync.webp">
<meta property="article:published_time" content="2021-07-25T02:04:25.000Z">
<meta property="article:modified_time" content="2025-04-12T15:30:04.424Z">
<meta property="article:author" content="void">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/autsu/diagrams/master/img/redis_master_slave_sync.webp">
  
  
  
  <title>Redis 面试题 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"autsu.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":"G-80J26VFWFL","gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"6KXGn05vaODkTMKM7zd5lWwl-gzGzoHsz","app_key":"qIMQwH4WrxTe8ds3Ua4HAbet","server_url":"https://6kxgn05v.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript('https://www.google-analytics.com/analytics.js', function() {
          window.ga = window.ga || function() { (ga.q = ga.q || []).push(arguments) };
          ga.l = +new Date;
          ga('create', 'G-80J26VFWFL', 'auto');
          ga('send', 'pageview');
        });
      }
    </script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>/dev/null</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Redis 面试题"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-07-25 10:04" pubdate>
          2021年7月25日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          18k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          150 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Redis 面试题</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Redis-的数据类型以及日常的应用"><a href="#Redis-的数据类型以及日常的应用" class="headerlink" title="Redis 的数据类型以及日常的应用"></a>Redis 的数据类型以及日常的应用</h1><p>PS：这里说的数据类型指的是 value 的类型，Redis 是一个 kv 数据库，它的 key 都是 string 类型的，但是 value 可以是多种类型。</p>
<h2 id="string-字符串类型"><a href="#string-字符串类型" class="headerlink" title="string 字符串类型"></a>string 字符串类型</h2><h3 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a><strong>缓存对象</strong></h3><p>这个没啥好说的，就是存一些字符串，这些字符串可以是各种各样的值，比如可以是常规的 “name”: “zhang3”，也可以是一个序列化为 JSON 的对象 {“XXX”: “YYY”}。</p>
<h3 id="常规计数"><a href="#常规计数" class="headerlink" title="常规计数"></a>常规计数</h3><p>因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。</p>
<p>虽然存储的是字符串类型，但是可以用 <code>INCR</code>（自增 1），<code>INCRBY</code>（自增指定数值），<code>decr</code>（自减 1），<code>decyby</code>（自减指定数值）对这个数值进行操作，貌似 Redis 会将其转换为 int 进行处理。</p>
<h2 id="hashmap-哈希表"><a href="#hashmap-哈希表" class="headerlink" title="hashmap 哈希表"></a>hashmap 哈希表</h2><p>哈希表本身就没啥好说的了，敲过代码的都知道是干嘛的</p>
<p><code>HSET key field value [field value ...]</code></p>
<p>key 可以看成是哈希表的名字，后面跟着的是 key&#x2F;value。</p>
<h3 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h3><ul>
<li>添加商品：<code>HSET cart:&#123;用户id&#125; &#123;商品id&#125; 1 &#123;商品id2&#125; 2</code> </li>
<li>添加数量：<code>HINCRBY cart:&#123;用户id&#125; &#123;商品id&#125; 1</code></li>
<li>商品总数：<code>HLEN cart:&#123;用户id&#125;</code></li>
<li>删除商品：<code>HDEL cart:&#123;用户id&#125; &#123;商品id&#125;</code></li>
<li>获取购物车所有商品：<code>HGETALL cart:&#123;用户id&#125;</code></li>
</ul>
<h2 id="list-双向链表"><a href="#list-双向链表" class="headerlink" title="list 双向链表"></a>list 双向链表</h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>list 支持 <code>LPUSH</code>（push 到最左端），<code>LPOP</code>（将最左端 pop） 以及同理的 <code>RPUSH</code> 和 <code>RPOP</code> 操作，所以我们可以很容易的实现一个先进先出的队列（LPUSH + RPOP，或者 RPUSH + LPOP），来作为消息队列使用。</p>
<blockquote>
<p>不过感觉用 Redis 做 mq 还是有点太”抽象“了，毕竟这也不是 Redis 的本职工作，而且 Redis 后面提供了一个 stream 类型这个更专业的消息队列。</p>
</blockquote>
<p>不过作为消息队列还需要考虑以下几点：</p>
<ol>
<li>消费者不知道队列里面有没有数据，所以需要通过轮询的方式去不断 Pop ，但如果队列里面长时间没数据，可能会导致 CPU 空转浪费性能，为了解决这个问题，Redis 提供了 BRPOP 命令。<strong>BRPOP 命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据</strong>。和消费者程序自己不停地调用 RPOP 命令相比，这种方式能节省 CPU 开销。</li>
<li>重复消费的问题，这个在 Redis 层面是没有提供相关功能的，只能我们在应用层自行实现。可以让生产者生产的消息携带一个全局 ID，然后消费者那边通过这个全局 ID 来判断是否已经消费过。</li>
<li>如何保证消息可靠性，消费者消费一条消息，意味着这条消息会从 list 中 pop 出去，那如果消费者这边消费失败了，就没有机会去再次消费了，为了留存消息，List 类型提供了 <code>BRPOPLPUSH</code> 命令，这个命令的 <strong>作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存</strong>。</li>
</ol>
<p>此外 <strong>List 不支持多个消费者消费同一条消息</strong>，因为一旦消费者拉取一条消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费。这个问题无解。</p>
<h2 id="set-去重集合"><a href="#set-去重集合" class="headerlink" title="set 去重集合"></a>set 去重集合</h2><h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p>Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章 id，value 是用户 id。</p>
<p><code>uid:1</code> 、<code>uid:2</code>、<code>uid:3</code> 三个用户分别对 article:1 文章点赞了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">uid:1 用户对文章 article:1 点赞</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SADD article:1 uid:1</span><br>(integer) 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">uid:2 用户对文章 article:1 点赞</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SADD article:1 uid:2</span><br>(integer) 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">uid:3 用户对文章 article:1 点赞</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SADD article:1 uid:3</span><br>(integer) 1<br></code></pre></td></tr></table></figure>

<p><code>uid:1</code> 取消了对 article:1 文章点赞。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">&gt; SREM article:1 uid:1<br>(integer) 1<br></code></pre></td></tr></table></figure>

<p>获取 article:1 文章所有点赞用户 :</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SMEMBERS article:1</span><br>1) &quot;uid:3&quot;<br>2) &quot;uid:2&quot;<br></code></pre></td></tr></table></figure>

<p>获取 article:1 文章的点赞用户数量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SCARD article:1</span><br>(integer) 2<br></code></pre></td></tr></table></figure>

<p>判断用户 <code>uid:1</code> 是否对文章 article:1 点赞了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SISMEMBER article:1 uid:1</span><br>(integer) 0  # 返回0说明没点赞，返回1则说明点赞了<br></code></pre></td></tr></table></figure>

<h3 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h3><p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p>
<p>key 可以是用户 id，value 则是已关注的公众号的 id。</p>
<p><code>uid:1</code> 用户关注公众号 id 为 5、6、7、8、9，<code>uid:2</code> 用户关注公众号 id 为 7、8、9、10、11。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">uid:1 用户关注公众号 <span class="hljs-built_in">id</span> 为 5、6、7、8、9</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SADD uid:1 5 6 7 8 9</span><br>(integer) 5<br><span class="hljs-meta prompt_"># </span><span class="language-bash">uid:2  用户关注公众号 <span class="hljs-built_in">id</span> 为 7、8、9、10、11</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SADD uid:2 7 8 9 10 11</span><br>(integer) 5<br></code></pre></td></tr></table></figure>

<p><code>uid:1</code> 和 <code>uid:2</code> 共同关注的公众号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">获取共同关注</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SINTER uid:1 uid:2</span><br>1) &quot;7&quot;<br>2) &quot;8&quot;<br>3) &quot;9&quot;<br></code></pre></td></tr></table></figure>

<p>给 <code>uid:2</code> 推荐 <code>uid:1</code> 关注的公众号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SDIFF uid:1 uid:2</span><br>1) &quot;5&quot;<br>2) &quot;6&quot;<br></code></pre></td></tr></table></figure>

<p>验证某个公众号是否同时被 <code>uid:1</code> 或 <code>uid:2</code> 关注:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SISMEMBER uid:1 5</span><br>(integer) 1 # 返回0，说明关注了<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SISMEMBER uid:2 5</span><br>(integer) 0 # 返回0，说明没关注<br></code></pre></td></tr></table></figure>

<h3 id="抽奖活动"><a href="#抽奖活动" class="headerlink" title="抽奖活动"></a>抽奖活动</h3><p>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</p>
<p>key 为抽奖活动名，value 为员工名称，把所有员工名称放入抽奖箱 ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">SADD lucky Tom Jerry John Sean Marry Lindy Sary Mark</span><br>(integer) 5<br></code></pre></td></tr></table></figure>

<p>如果允许重复中奖，可以使用 SRANDMEMBER 命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">抽取 1 个一等奖：</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SRANDMEMBER lucky 1</span><br>1) &quot;Tom&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">抽取 2 个二等奖：</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SRANDMEMBER lucky 2</span><br>1) &quot;Mark&quot;<br>2) &quot;Jerry&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">抽取 3 个三等奖：</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SRANDMEMBER lucky 3</span><br>1) &quot;Sary&quot;<br>2) &quot;Tom&quot;<br>3) &quot;Jerry&quot;<br></code></pre></td></tr></table></figure>

<p>如果不允许重复中奖，可以使用 SPOP 命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">抽取一等奖1个</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SPOP lucky 1</span><br>1) &quot;Sary&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">抽取二等奖2个</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SPOP lucky 2</span><br>1) &quot;Jerry&quot;<br>2) &quot;Mark&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">抽取三等奖3个</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SPOP lucky 3</span><br>1) &quot;John&quot;<br>2) &quot;Sean&quot;<br>3) &quot;Lindy&quot;<br></code></pre></td></tr></table></figure>



<h2 id="zset-排序-set"><a href="#zset-排序-set" class="headerlink" title="zset 排序 set"></a>zset 排序 set</h2><h4 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h4><p>有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。</p>
<p>我们以博文点赞排名为例，小林发表了五篇博文，分别获得赞为 200、40、100、50、150。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">arcticle:1 文章获得了200个赞</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 200 arcticle:1</span><br>(integer) 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">arcticle:2 文章获得了40个赞</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 40 arcticle:2</span><br>(integer) 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">arcticle:3 文章获得了100个赞</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 100 arcticle:3</span><br>(integer) 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">arcticle:4 文章获得了50个赞</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 50 arcticle:4</span><br>(integer) 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">arcticle:5 文章获得了150个赞</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 150 arcticle:5</span><br>(integer) 1<br></code></pre></td></tr></table></figure>

<p>文章 arcticle:4 新增一个赞，可以使用 ZINCRBY 命令（为有序集合key中元素member的分值加上increment）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ZINCRBY user:xiaolin:ranking 1 arcticle:4</span><br>&quot;51&quot;<br></code></pre></td></tr></table></figure>

<p>查看某篇文章的赞数，可以使用 ZSCORE 命令（返回有序集合key中元素个数）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ZSCORE user:xiaolin:ranking arcticle:4</span><br>&quot;50&quot;<br></code></pre></td></tr></table></figure>

<p>获取小林文章赞数最多的 3 篇文章，可以使用 ZREVRANGE 命令（倒序获取有序集合 key 从start下标到stop下标的元素）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">WITHSCORES 表示把 score 也显示出来</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ZREVRANGE user:xiaolin:ranking 0 2 WITHSCORES</span><br>1) &quot;arcticle:1&quot;<br>2) &quot;200&quot;<br>3) &quot;arcticle:5&quot;<br>4) &quot;150&quot;<br>5) &quot;arcticle:3&quot;<br>6) &quot;100&quot;<br></code></pre></td></tr></table></figure>

<p>获取小林 100 赞到 200 赞的文章，可以使用 ZRANGEBYSCORE 命令（返回有序集合中指定分数区间内的成员，分数由低到高排序）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYSCORE user:xiaolin:ranking 100 200 WITHSCORES</span><br>1) &quot;arcticle:3&quot;<br>2) &quot;100&quot;<br>3) &quot;arcticle:5&quot;<br>4) &quot;150&quot;<br>5) &quot;arcticle:1&quot;<br>6) &quot;200&quot;<br></code></pre></td></tr></table></figure>



<h1 id="Redis-的发布-x2F-订阅的原理"><a href="#Redis-的发布-x2F-订阅的原理" class="headerlink" title="Redis 的发布&#x2F;订阅的原理"></a>Redis 的发布&#x2F;订阅的原理</h1><h1 id="zset-的底层实现"><a href="#zset-的底层实现" class="headerlink" title="zset 的底层实现"></a>zset 的底层实现</h1><p>zset 底层使用跳表 + 哈希表实现。</p>
<p>哈希表存储的是 member 到 score 的映射，这样可以让 ZSCORE 这种根据 member 查询 score 的操作的时间复杂度为 O(1)</p>
<h1 id="数据缓存过期策略"><a href="#数据缓存过期策略" class="headerlink" title="数据缓存过期策略"></a>数据缓存过期策略</h1><h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><p>通常来说，过期缓存有以下几种策略：</p>
<ol>
<li>定时删除：设置带过期时间的 key 的同时创建一个定时事件，然后到期后由这个定时事件进行删除，这样可以保证 key 过期后被尽快删除，对内存友好，但是缺点也很明显，开销太大了，如果 key 很多将会创建大量定时器，对 CPU 不友好。</li>
<li>惰性删除：操作一个 key 时，先检查一下该 key 是否过期，过期则删掉，这样对 CPU 友好，但是一些冷门 key 因为很少被访问到，所以即便过期也会占据内存，造成内存泄露，对内存不友好。</li>
<li>定期删除：每隔一段时间从过期字典（redis 将所有带有过期时间的 key 存在一个 map 中）中抽出来一定数量的 key，然后删掉其中过期的，这种方法相当于是上面两种的中和（内存友好不如定时删除，但优于惰性删除；CPU 友好不如惰性删除，但优于定期删除。），难点是合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）。</li>
</ol>
<p>Redis 采用的是惰性删除 + 定期删除策略，这样可以一定程度平衡使用 CPU 时间和避免内存浪费。</p>
<p>其中，定期删除的流程是：</p>
<ol>
<li>从过期字典中随机取出 20 个键</li>
<li>删除这 20 个键中过期的键</li>
<li>如果过期键的比例超过 25% ，重复步骤 1 和 2</li>
</ol>
<p>为了保证扫描不会出现循环过度，导致线程卡死现象，还增加了扫描时间的上限，默认是 25 毫秒（即默认在慢模式下，如果是快模式，扫描上限是 1 毫秒）</p>
<blockquote>
<p>🤔 疑问：</p>
<p>Redis 定期删除也是跑在单线程的事件循环中的吗？</p>
</blockquote>
<h2 id="AOF、RDB-和复制功能对过期键的处理"><a href="#AOF、RDB-和复制功能对过期键的处理" class="headerlink" title="AOF、RDB 和复制功能对过期键的处理"></a>AOF、RDB 和复制功能对过期键的处理</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p><strong>生成 RDB 文件</strong></p>
<p>在执行 save 命令或 bgsave 命令创建一个新的 RDB文件时，程序会对数据库中的键进行检查，已过期的键就不会被保存到新创建的 RDB文件中</p>
<p><strong>载入 RDB 文件</strong></p>
<p><strong>主服务器</strong>：载入 RDB 文件时，会对键进行检查，过期的键会被忽略</p>
<p><strong>从服务器</strong>：载入 RDB文件时，所有键都会载入。但是会在主从同步的时候，清空从服务器的数据库，所以过期的键载入也不会造成啥影响</p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p><strong>AOF 文件写入</strong></p>
<p>当过期键被惰性删除或定期删除后，程序会向 AOF 文件追加一条 del 命令，来显示的记录该键已经被删除</p>
<p><strong>AOF 重写</strong></p>
<p>重启过程会对键进行检查，如果过期就不会被保存到重写后的 AOF 文件中</p>
<h1 id="Redis-的部署模式"><a href="#Redis-的部署模式" class="headerlink" title="Redis 的部署模式"></a>Redis 的部署模式</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26012495/article/details/120299332">https://blog.csdn.net/qq_26012495/article/details/120299332</a></p>
<h2 id="单节点模式"><a href="#单节点模式" class="headerlink" title="单节点模式"></a>单节点模式</h2><p>最简单粗暴的方式，只跑一个 Redis 节点，所有的操作也只需要使用这一个节点即可，问题也很明显，如果这一个节点挂了服务直接就不可用了，如果是生产环境这种必须高可用的场景，这种部署模式肯定就不行了。</p>
<h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><p>这种部署模式将会部署多个 Redis 节点，并且还将节点分为了主节点和从节点两种类型，其中主节点可以读写，而从节点只能读，然后主节点会复制数据给从节点，这种数据单向复制（只能主同步给从）可以简化主从节点之间数据一致性的实现。</p>
<p>部署多个节点可以提高系统的可用性，如果主节点挂了，可以手动把某个从节点提升为主节点，但因为是手动，所以对运维人员不友好（万一主节点半夜挂了），而且如果主节点全挂了那么整个系统将丧失写能力。</p>
<h3 id="主从复制流程"><a href="#主从复制流程" class="headerlink" title="主从复制流程"></a>主从复制流程</h3><h4 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h4><p>主从节点之间的第一次数据同步使用的是 <strong>全量同步</strong>，全量同步的流程大致如图</p>
<p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/redis_master_slave_sync.webp" srcset="/img/loading.gif" lazyload></p>
<p>主从库间建立连接、协商同步： 从库向主库发起同步请求，从库执行 <code>replicaof</code> 并发送 <code>psync</code> 命令，表示要执行数据同步，主库收到命令后根据参数启动复制。命令包含了<strong>主库的 runID</strong> 和 <strong>复制进度 offset</strong> 两个参数。</p>
<ul>
<li><strong>runID</strong>：每个 Redis 实例启动都会自动生成一个 唯一标识 ID，第一次主从复制，还不知道主库 runID，参数设置为 「?」。</li>
<li><strong>offset</strong>：第一次复制设置为 -1，<strong>表示第一次复制</strong>，记录复制进度偏移量。</li>
</ul>
<p>主库响应请求，返回 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset（每个 redis 启动时）。从库收到响应后，会记录下这两个参数。</p>
<p>主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。</p>
<p><strong>在主库将数据同步给从库的过程中，主库不会被阻塞</strong>，仍然可以正常接收请求。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，<strong>主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作</strong>。当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</p>
<p>准确的说，<strong>主服务器在下面这三个时间间隙中将收到的写操作命令，写入到 replication buffer 缓冲区里</strong>：</p>
<ul>
<li>主服务器生成 RDB 文件期间；</li>
<li>主服务器发送 RDB 文件给从服务器期间；</li>
<li>「从服务器」加载 RDB 文件期间；</li>
</ul>
<p>也就是说，从主服务器开始生成 RDB 文件，到成功发送给从服务器，且从服务加载 RDB 完成后的这段时间呢，新写入到主服务器的命令都会写入到缓冲区。</p>
<blockquote>
<p>疑问：</p>
<p>主库如何知道 RDB 已经发送完成，并且对方已全部接收成功？</p>
<p>下面就会回答这个问题</p>
</blockquote>
<p>在主服务器生成的 RDB 文件发送完，从服务器收到 RDB 文件后，丢弃所有旧数据，将 RDB 数据载入到内存。<strong>完成 RDB 的载入后，会回复一个确认消息给主服务器。</strong></p>
<p>接着，主服务器将 replication buffer 缓冲区里所记录的写操作命令发送给从服务器，从服务器执行来自主服务器 replication buffer 缓冲区里发来的命令，这时主从服务器的数据就一致了。</p>
<p>至此，主从服务器的第一次同步的工作就完成了。</p>
<blockquote>
<p>又有一个疑问：如果主服务器迟迟收不到从服务器发来的确认信息呢？</p>
</blockquote>
<h4 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h4><p>主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 长连接。</p>
<p>后续主服务器可以通过这个连接继续 <strong>将写操作命令传播给从服务器</strong>，然后从服务器执行该命令，使得与主服务器的数据库状态相同。</p>
<h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><p>主从服务器在完成第一次同步后，就会基于长连接进行命令传播，但是如果出现网络问题，就会导致命令无法传播，进而导致主从间数据不一致。为了解决这个问题，Redis 提供了增量复制功能，这样相比全量复制性能更高。</p>
<p>主要有三个步骤：</p>
<ul>
<li>从服务器在恢复网络后，会发送 psync 命令给主服务器，此时的 psync 命令里的 offset 参数不是 -1（不是 -1 表示不是第一次复制，即不是全量复制）；</li>
<li>主服务器收到该命令后，然后用 CONTINUE 响应命令告诉从服务器接下来采用增量复制的方式同步数据；</li>
<li>然后主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。</li>
</ul>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>哨兵模式的出现用于解决主从模式中无法自动升级主节点的问题，一个哨兵是一个节点，用于监控主从节点的健康，当主节点挂掉的时候，自动选择一个最优从节点升级为主节点。</p>
<p>但哨兵如果挂了怎么办？于是哨兵一般都会是一个集群，是集群高可用的心脏，一般由 3-5 个节点组成，即使个别节点挂了，集群还可以正常运行。</p>
<p>客户端连接 Redis，会首先连接 Sentinel，通过 Sentinel 查询 master 地址，然后再连接 master 进行数据交互。当 master 挂了，客户端重新跟 Sentinel 要 master 地址，连接新的 master。</p>
<p>上图中可看，master 挂了，原先的主从复制断开，客户端和 master 也断开。然后一个 slave 变成新的 master，和其余的 slave 进行新的主从复制，客户端通过新的 master 继续交互，Sentinel 持续监控已经挂掉的旧的 master，一旦旧的 master 恢复，集群会变为下图，旧的 master 成为新的 slave，从新的 master 建立主从复制关系。</p>
<h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><p>集群方案真正实现了 Redis 高可用，有很多种实现方式，目前最常用的 Redis Cluster 是 Redis 的亲儿子，是 Redis 作者自己提供的 Redis 集群化方案，从Redis 3.0 版本开始正式提供。</p>
<p>集群由多个 Redis 主从组成，每一个主从代表一个节点，每个节点负责一部分数据，他们之间通过一种特殊的二进制协议交互集群信息。</p>
<p>Redis Cluster 将所有数据分片，分成 16384 个槽位，Redis Cluster 对 key 值使用 crc16 算法进行 hash，然后用除留余数发模除 16384 得到具体的槽位，每个节点负责其中一部分槽位。</p>
<p>当客户端连接集群，会得到一份集群的槽位匹配信息，当客户端要查找 key，可以直接定位到目标节点。</p>
<p>Cluster 去中心化，由多个节点组成，客户端连接时可以只用一个节点的地址，其余节点可通过该节点自动发现，但如果该节点挂了，就必须手动更换地址，因此连接多个地址安全性更高。</p>
<p><strong>容错</strong></p>
<p>Redis Cluster 拥有类似哨兵的功能，每个节点仍需设置若干从节点，主节点发生故障，集群可将 slave 升级为 master；否则如果 master 挂了，集群完全不可用；</p>
<p>且 Redis Cluster 是去中心化，集群内某个节点不可用时，一个节点认为他失联并不代表所以节点都认为他失联，集群要进行一次商议，只有大多数节点认为他失联，才会认为其需要主从切换来容错。</p>
<p><strong>动态扩容</strong></p>
<p>假如原先集群中有 3 个节点，一共 3000 个数据，可能 1-1000 在第一个节点，1001-2000 在第二个节点，2001-3000 在第三个节点。</p>
<p>当新节点加入集群，需要手动将槽和数据迁移到新节点，可以使用 redis-trib 工具或手动命令迁移（略）。</p>
<h1 id="Redis-为什么速度比较快"><a href="#Redis-为什么速度比较快" class="headerlink" title="Redis 为什么速度比较快"></a>Redis 为什么速度比较快</h1><ol>
<li><p>纯内存操作，因为内存的速度远高于磁盘，所以 Redis 的速度也会远快于 Mysql 。</p>
<blockquote>
<p>抬杠式提问</p>
<p>为啥内存速度比硬盘快？</p>
<p>（不知道，基础稀烂）</p>
<p>因为内存直接由 CPU 控制，也就是 CPU 内部集成的内存控制器，所以说内存是直接与 CPU 对接，享受与 CPU 通信的最优带宽。</p>
</blockquote>
</li>
<li><p>单线程 + IO 多路复用</p>
<p>Redis 处理命令的模型使用的是 IO 多路复用，这样就可以一条线程同时监听很多个 socket，当有 socket 发生事件时会唤醒线程进行处理，相当于多个命令其实是在排队同步执行的，因为 Redis 的命令处理操作通常都是一些数据结构相关的 crud 操作，而且都是在内存里面操作，又不涉及网络调用等时间开销大的操作，所以每个命令的执行时间都很短，所以即使排队执行也不会有特别大的延迟问题（一些比较耗时的操作，比如持久化，Redis 是会开一条进程后台处理的），而且因为是单线程，所以避免了并发同步相关的锁开销，实现起来也会简单很多。</p>
</li>
</ol>
<h1 id="Reids-的大-key-相关"><a href="#Reids-的大-key-相关" class="headerlink" title="Reids 的大 key 相关"></a>Reids 的大 key 相关</h1><h2 id="什么是大-key？"><a href="#什么是大-key？" class="headerlink" title="什么是大 key？"></a><strong>什么是大 key？</strong></h2><p>Redis 大 key 问题指的是某个 key 对应的 value 值所占的内存空间比较大，导致 Redis 的性能下降、内存不足、数据不均衡以及主从同步延迟等问题。</p>
<h2 id="多大算大？"><a href="#多大算大？" class="headerlink" title="多大算大？"></a><strong>多大算大？</strong></h2><p>没有固定的判别标准，通常认为字符串类型的 key 对应的 value 值占用空间大于 1M，或者集合类型的 k 元素数量超过 1 万个，就算是大 key，但是具体还要看业务场景、并发量等因素。</p>
<h2 id="大-key-带来的影响"><a href="#大-key-带来的影响" class="headerlink" title="大 key 带来的影响"></a><strong>大 key 带来的影响</strong></h2><ol>
<li>内存占用过高。大 Key 占用过多的内存空间，可能导致可用内存不足，从而触发内存淘汰策略。在极端情况下，可能导致内存耗尽，Redis 实例崩溃，影响系统的稳定性。</li>
<li>性能下降。大 Key 会占用大量内存空间，导致内存碎片增加，进而影响 Redis 的性能。对于大 Key 的操作，如读取、写入、删除等，都会消耗更多的 CPU 时间和内存资源，进一步降低系统性能。</li>
<li>阻塞其他操作。某些对大 Key 的操作可能会导致 Redis 实例阻塞。例如，使用 DEL 命令删除一个大 Key 时，可能会导致 Redis 实例在一段时间内无法响应其他客户端请求，从而影响系统的响应时间和吞吐量。</li>
<li>网络拥塞。每次获取大 key 产生的网络流量较大，可能造成机器或局域网的带宽被打满，同时波及其他服务。例如：一个大 key 占用空间是 1 MB，每秒访问1000次，就有 1000 MB的流量。</li>
<li>主从同步延迟。当 Redis 实例配置了主从同步时，大 Key 可能导致主从同步延迟。由于大 Key 占用较多内存，同步过程中需要传输大量数据，这会导致主从之间的网络传输延迟增加，进而影响数据一致性。</li>
<li>数据倾斜。在 Redis 集群模式中，某个数据分片的内存使用率远超其他数据分片，无法使数据分片的内存资源达到均衡。另外也可能造成 Redis 内存达到maxmemory 参数定义的上限导致重要的 key 被逐出，甚至引发内存溢出。</li>
</ol>
<h2 id="大-key-产生的原因"><a href="#大-key-产生的原因" class="headerlink" title="大 key 产生的原因"></a><strong>大 key 产生的原因</strong></h2><ol>
<li>业务设计不合理。这是最常见的原因，不应该把大量数据存储在一个 key 中，而应该分散到多个 key。例如：把全国数据按照省行政区拆分成 34 个key，或者按照城市拆分成 300 个key，可以进一步降低产生大 key 的概率。</li>
<li>没有预见 value 的动态增长问题。如果一直添加 value 数据，没有删除机制、过期机制或者限制数量，迟早出现大 key。例如：微博明星的粉丝列表、热门评论等。</li>
<li>过期时间设置不当。如果没有给某个 key 设置过期时间，或者过期时间设置较长。随着时间推移，value 数量快速累积，最终形成大 key。</li>
<li>程序 bug。某些异常情况导致某些 key 的生命周期超出预期，或者 value 数量异常增长 ，也会产生大 key。</li>
</ol>
<h2 id="如何排查大-key"><a href="#如何排查大-key" class="headerlink" title="如何排查大 key"></a>如何排查大 key</h2><p>使用 –bigkeys 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">redis-cli --bigkeys -a rootroot</span><br><br>[00.00%] Biggest hash   found so far &#x27;&quot;very_big_key&quot;&#x27; with 2050 fields<br><br>-------- summary -------<br><br>Sampled 1 keys in the keyspace!<br>Total key length in bytes is 12 (avg len 12.00)<br><br>Biggest   hash found &#x27;&quot;very_big_key&quot;&#x27; has 2050 fields<br><br>0 strings with 0 bytes (00.00% of keys, avg size 0.00)<br>0 lists with 0 items (00.00% of keys, avg size 0.00)<br>1 hashs with 2050 fields (100.00% of keys, avg size 2050.00)<br>0 streams with 0 entries (00.00% of keys, avg size 0.00)<br>0 sets with 0 members (00.00% of keys, avg size 0.00)<br>0 zsets with 0 members (00.00% of keys, avg size 0.00)<br></code></pre></td></tr></table></figure>

<p>可以看到找到了一个拥有 2050 个字段的大 key ：very_big_key</p>
<h2 id="怎样解决大-key"><a href="#怎样解决大-key" class="headerlink" title="怎样解决大 key"></a>怎样解决大 key</h2><ol>
<li>拆分成多个小 key。这是最容易想到的办法，降低单 key 的大小，读取可以用 mget 批量读取。</li>
<li>数据压缩。使用 String 类型的时候，使用压缩算法减少 value 大小。或者是使用 Hash 类型存储，因为 Hash 类型底层使用了压缩列表数据结构。</li>
<li>设置合理的过期时间。为每个 key 设置过期时间，并设置合理的过期时间，以便在数据失效后自动清理，避免长时间累积的大 Key 问题。</li>
<li>启用内存淘汰策略。启用 Redis 的内存淘汰策略，例如 LRU（Least Recently Used，最近最少使用），以便在内存不足时自动淘汰最近最少使用的数据，防止大 Key 长时间占用内存。</li>
<li>数据分片。例如使用 Redis Cluster 将数据分散到多个 Redis 实例，以减轻单个实例的负担，降低大 Key 问题的风险。</li>
<li>删除大 key。<strong>使用 UNLINK 命令删除大 key</strong>，UNLINK 命令是 DEL 命令的异步版本，它可以在后台删除 Key，避免阻塞 Redis 实例。</li>
</ol>
<h1 id="Redis-热-key-处理"><a href="#Redis-热-key-处理" class="headerlink" title="Redis 热 key 处理"></a>Redis 热 key 处理</h1><h1 id="如何实现分布式锁的"><a href="#如何实现分布式锁的" class="headerlink" title="如何实现分布式锁的"></a>如何实现分布式锁的</h1><h1 id="持久化策略及其对比"><a href="#持久化策略及其对比" class="headerlink" title="持久化策略及其对比"></a>持久化策略及其对比</h1><h2 id="AOF-1"><a href="#AOF-1" class="headerlink" title="AOF"></a>AOF</h2><p>AOF 会将 Redis 所有的 <strong>写命令</strong> 记录到一个文件内，当要恢复数据时，只要读取这个文件，将里面所有的命令执行一遍即可，原理非常简单。</p>
<p>AOF 记录写命令不是直接以文本的格式，而是以一种特殊的协议，比如如果要保存 <code>set name xiaolin</code> 这个命令，格式将会是下面这样：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-number">*3</span><br><span class="hljs-variable">$3</span><br><span class="hljs-built_in">set</span><br><span class="hljs-variable">$4</span><br>name<br><span class="hljs-variable">$7</span><br>xiaolin<br></code></pre></td></tr></table></figure>

<p>「<code>*3</code>」表示当前命令有三个部分，每部分都是以「<code>$+数字</code>」开头，后面紧跟着具体的命令、键或值。然后，这里的「<code>数字</code>」表示这部分中的命令、键或值一共有多少字节。例如，「<code>$3 set</code>」表示这部分有 3 个字节，也就是「<code>set</code>」命令这个字符串的长度。</p>
<p>Redis 会先执行写命令，然后再写 AOF 文件，这样有以下几点好处：</p>
<ol>
<li>避免额外的检查开销，如果执行的命令有误，那么将会执行失败，从而避免写入到 AOF，这样可以保证 AOF 中保存的都是正确的命令。</li>
<li>不会阻塞当前的命令，因为写命令完成后才会写 AOF，但这样也意味着可能会阻塞下一个写命令。</li>
</ol>
<p>但这种方式也有缺点：</p>
<ol>
<li>如果写 AOF 执行时间过长，那么将会阻塞下一个命令，因为 AOF 操作也是在主循环里面执行的</li>
<li>如果写命令执行完成了，但是 Redis 宕机了，将会导致没有将命令写入到 AOF 文件，从而丢失记录</li>
</ol>
<h3 id="AOF-写入流程"><a href="#AOF-写入流程" class="headerlink" title="AOF  写入流程"></a>AOF  写入流程</h3><p>AOF 的写入流程如下：</p>
<ol>
<li>执行写操作命令</li>
<li>命令追加到 server.aof_buf 缓冲区</li>
<li>执行系统调用 write 函数，将缓存区的内容拷贝到内核缓冲区 page cache，等待内核将数据写入硬盘</li>
<li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定，可能是缓冲区满了再刷到硬盘，也有可能是一定时间后写入</li>
</ol>
<p>为什么要搞一个内核缓冲区？</p>
<p>因为磁盘的 IO 操作是很慢的，如果每次操作都直接写入硬盘，那么会影响性能，所以准备了一个缓冲区，先把数据扔到缓冲区里面，等满了（或者别的情况）再一次性将缓冲区内的内容全部刷到硬盘，这样可以保证一次磁盘 IO 干更多的活，从而提高性能。</p>
<p>但是这样又引出了一个问题，如果系统宕机了，而缓冲区中还存在未刷盘的数据，这样不就导致数据丢失了吗？</p>
<p>为了解决这个问题，系统提供了 <code>fsync</code> 和 <code>fdatasync</code> 两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据刷到硬盘，从而保证数据的安全性。</p>
<h3 id="AOF-刷盘策略"><a href="#AOF-刷盘策略" class="headerlink" title="AOF 刷盘策略"></a>AOF 刷盘策略</h3><p>Redis AOF 提供了以下几种刷盘策略：</p>
<ul>
<li><p><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘（也就是调用 fsync 函数吗？）；</p>
<p>因为 Always 策略每执行一条写操作命令就同步将 AOF 内容写回硬盘，所以它是最安全的一种策略，即使出现故障停机，也只会丢失一个事件循环中所产生的命令数据；但同时它也是最慢的，因为它会产生大量磁盘 IO。</p>
</li>
<li><p><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</p>
<p>从效率上来讲，everysec 模式足够快，并且就算出现故障停机，数据库也只丢失一秒钟的命令数据。所以说这是一种折中的方案，可以保证数据丢失量小于 No 策略，同时保证写入性能高于 Always 策略。</p>
</li>
<li><p><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</p>
<p>这种策略相比于 Always 策略性能较好，但是操作系统写回硬盘的时机是不可预知的，如果 AOF 日志内容没有写回硬盘，一旦服务器宕机，就会丢失不定数量的数据。</p>
</li>
</ul>
<p>大家根据自己的业务场景进行选择：</p>
<ul>
<li>如果要高性能，就选择 No 策略；</li>
<li>如果要高可靠，就选择 Always 策略；</li>
<li>如果允许数据丢失一点，但又想性能高，就选择 Everysec 策略。</li>
</ul>
<h3 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h3><blockquote>
<p> PS：执行 <code>BGREWEITEAOF</code> 命令进行 AOF 重写。</p>
</blockquote>
<p>随着 Redis 运行时间越来越长，AOF 文件记录的写命令也会越来越多，这将会导致文件越来越大，使用 AOF 恢复数据的时间也会越来越长，为了解决这个问题，Redis 提供了 AOF 重写的功能。</p>
<p>什么情况下可以进行重写？</p>
<p>比如如果用户执行了下面的命令：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">set</span> <span class="hljs-keyword">name</span> a<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">name</span> b<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">name</span> c<br></code></pre></td></tr></table></figure>

<p>此时 AOF 文件中将会保存 3 条命令，但是实际上我们可以只保存 <code>set name c</code> 这一条命令，因为前面两条命令都已经被覆盖掉了，所以保存它们并没有什么意义。</p>
<h4 id="AOF-重写如何实现"><a href="#AOF-重写如何实现" class="headerlink" title="AOF 重写如何实现"></a>AOF 重写如何实现</h4><p>实际上和名字不同，Redis 并不会对现有的 AOF 做任何读取、分析、写入等操作，所以也不存在 “重写” 这一说，它会新创建一个文件，然后读取当前 Redis 中 所有 key 的值（忽略过期 key），然后用一条写命令写入到 AOF 文件即可，实现的原理非常简单。</p>
<h4 id="AOF-后台重写"><a href="#AOF-后台重写" class="headerlink" title="AOF 后台重写"></a>AOF 后台重写</h4><p>从上面的 AOF 重写原理我们就可以感觉出，这可能是一个非常耗时的操作，如果 key 很多的话它将触发大量 IO 操作，如果让它在事件循环里执行将会阻塞后续的命令，为了解决这个问题，Redis 将会新开一个子进程来干这件事。使用进程而不是线程，是为了可以在避免使用锁的情况下保证数据的安全性。</p>
<p>不过，使用子进程也有一个问题需要解决，因为子进程在进行 AOF 重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的 AOF 文件所保存的数据库状态不一致。（和主从同步一样的问题）</p>
<p>为了解决这种数据不一致问题，<strong>Redis 服务器设置了一个 AOF 重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用</strong>，当 Redis 服务器执行完一个写命令之后，它会同时将这个写命令发送给 AOF 缓冲区 和 AOF 重写缓冲区（AOF 缓冲区就是我们前面提到的 server.aof_buf，用来拷贝给内核缓冲区进行刷盘的）。</p>
<p><strong>当子进程完成 AOF 重写工作之后，它会向父进程发送一个信号</strong>，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作:</p>
<ol>
<li><p>将 AOF 重写缓冲区中的所有内容写人到新 AOF 文件中，这时新 AOF 文件所保存的数据库状态将和服务器当前的数据库状态一致。</p>
</li>
<li><p>对新的 AOF 文件进行改名 ， 原子地 (atomic) 覆盖现有的 AOF 文件，完成新旧两个 AOF 文件的替换。</p>
<p>这个信号处理函数执行完毕之后，父进程就可以继续像往常一样接受命令请求了。 <strong>在整个 AOF 后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞</strong>，在其他时候，AOF 后台重写都不会阻塞父进程，这将 AOF 重写对服务器性能造成的影响降到了最低。</p>
</li>
</ol>
<h2 id="RDB-1"><a href="#RDB-1" class="headerlink" title="RDB"></a>RDB</h2><p>RDB 是快照，其保存的是 Redis 某一时刻的数据，文件内容为二进制数据，所以相比保存写命令的 AOF 而言，RDB 恢复起来会更快，只需要将 RDB 读取到内存即可，而不需要像 AOF 那样一条条执行命令。</p>
<p>生成 RDB 快照有两种命令：</p>
<ul>
<li>save：在主线程进行快照生成操作，会影响其他命令的执行。</li>
<li>bgsave：新开一条子进程执行快照生成操作，从而避免对其他命令的阻塞。</li>
</ul>
<p>RDB 文件的加载工作是在服务器启动时自动执行的，Redis 并没有提供专门用于加载 RDB 文件的命令。</p>
<p>可以通过配置来指定 Redis 进行定期 RDB 快照备份，比如像下面这样：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span>		# <span class="hljs-number">900</span> 秒之内，对数据库进行了至少 <span class="hljs-number">1</span> 次修改；<br><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span> 	# <span class="hljs-number">300</span> 秒之内，对数据库进行了至少 <span class="hljs-number">10</span> 次修改；<br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span> 	# <span class="hljs-number">60</span> 秒之内，对数据库进行了至少 <span class="hljs-number">10000</span> 次修改。<br></code></pre></td></tr></table></figure>

<p>只要满足上面条件的任意一个，就会执行 bgsave 进行 RDB 持久化。</p>
<p>Redis 的快照是 <strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。</p>
<p>这也意味着 RDB 是一个耗时的操作，所以不能频繁执行。</p>
<p>但是如果执行频率太低，会导致丢失数据更多，比如如果设置至少 5 分钟才保存一次快照，这时如果 Redis 出现宕机等情况，则意味着最多可能丢失 5 分钟数据。比如 Redis 已经在 10:00 的时候执行过一次 RDB，那么其下次执行 RDB 的时间将会是 10:05，如果在 10:04 的时候 Redis 挂掉了，那么就意味着 10:00 - 10:04 这段时间的数据丢失了。</p>
<p>所以这也是 RDB 相较于 AOF 的一个缺点，它丢失的数据会更多。</p>
<h3 id="执行快照时，数据能被修改吗？"><a href="#执行快照时，数据能被修改吗？" class="headerlink" title="执行快照时，数据能被修改吗？"></a>执行快照时，数据能被修改吗？</h3><p>在 bgsave 的过程中，Redis 会使用写时复制，也就是子进程先会避免复制内存，而是和父进程共用同一片内存，只有当父进程对自己的内存执行修改操作时，子进程才会开始复制内存，这样的目的是为了减少创建子进程时的性能损耗，从而加快创建子进程的速度，毕竟创建子进程的过程中，是会阻塞主线程的。</p>
<p>比如当前正在执行 bgsave，子进程此时正与父进程共用同一片内存，然后 Redis 这边执行了 set a b 命令，将原先的 a &#x3D; c 改为了 a &#x3D; b，也就是对父进程的内存进行了修改，这个时候就会触发写时复制，执行 bgsave 的子进程会拷贝一份父进程的内存（拷贝的是修改之前的，也就是 a &#x3D; b 那份），然后用这份拷贝的内存执行后续的操作。</p>
<p>这也意味着 RDB 保存的数据是 bgsave 开始时 Redis 的数据，如果 bgsave 期间对 Redis 进行了修改是无法记录到 RDB 中的，只能由下一次 bgsave 来完成。</p>
<p>此外这还意味着，如果系统恰好在 RDB 快照文件创建完毕后崩溃了，那么 Redis 将会丢失主线程在快照期间修改的数据。</p>
<p>比如我在 10:00 执行了 bgsave，然后 10:01 执行了 set k v，10:02 bgsave 执行完毕，然后 Redis 就挂掉了，此时 set k v 这个数据就丢失了。</p>
<h1 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h1><h1 id="缓存雪崩、缓存击穿、缓存穿透"><a href="#缓存雪崩、缓存击穿、缓存穿透" class="headerlink" title="缓存雪崩、缓存击穿、缓存穿透"></a>缓存雪崩、缓存击穿、缓存穿透</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>什么是</strong></p>
<p>大量的 key 在同一时间过期或者 Redis 宕机，将会导致请求无法命中缓存，如果是高并发系统，将会导致大量的请求打到数据库，导致数据库压力巨大，威胁业务稳定性。</p>
<p><strong>如何解决</strong></p>
<p><strong>针对 同一时间过期 问题</strong></p>
<ol>
<li><p>均匀设置过期时间，可以在设置过期时间时加一个随机数，保证 key 的过期时间相对分散。</p>
</li>
<li><p>互斥锁，类似 go groupcache 里面的 singeflight 机制，如果多个请求请求的是同一个 key，而且这个 key 还过期被删掉了，那么就搞一个互斥锁，让这些请求去抢锁，第一个拿到锁的去构建缓存（查询数据库填充缓存），其他请求阻塞等待，等拿到锁的那个构建完成了再返回，这样就可以避免多个请求全都打到数据库。至于这个锁，应该是需要用分布式锁（关于分布式锁这里不展开）。</p>
</li>
<li><p>业务线程不再负责更新缓存，缓存也不设置有效期，而是 <strong>让缓存“永久有效”，并将更新缓存过期时间的工作交由后台线程定时更新</strong>。</p>
<blockquote>
<p> 后台更新这里暂时还没太搞明白，是开一条线程做 db 和 redis 的数据同步吗？这个策略应该只适用于热 key 吧？</p>
</blockquote>
<p>而且 Redis 还存在内存淘汰策略，那这个 key 虽然不过期了，但依然可能会被干掉</p>
<blockquote>
<p>这个策略没太搞明白，先记录一下 <a target="_blank" rel="noopener" href="https://xiaolincoding.com/redis/cluster/cache_problem.html#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">原文出处</a></p>
</blockquote>
</li>
</ol>
<p><strong>针对 Redis 宕机</strong></p>
<ol>
<li>构建 Redis 缓存高可靠集群：使用主从或者集群等部署模型来保证 Redis 的高可用</li>
<li>增加限流&#x2F;熔断的中间件，当 Redis 宕机时开启熔断&#x2F;限流，来防止大量请求打到数据库。</li>
</ol>
<p>此外还可以曲线救国，既然你数据库这么容易挂，那我就在数据库层面做一些策略，让它变得坚强一点，比如分库分表、读写分离啥的</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>（老是和缓存穿透搞混）</p>
<p>和缓存雪崩类似，也是缓存过期导致请求打到数据库，只不过缓存击穿更侧重描述单个 key 失效，而雪崩则侧重描述大部分 key 失效？</p>
<p>解决方法也和雪崩类似，搞互斥锁或者设置永不过期（热 key 的话）</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>请求一个数据库中不存在的 key，那正常来说这个 key 在缓存中也不存在，然后更严重的问题是缓存还无法构建（数据库中没有，缓存又是基于数据库构建），相当于缓存永久失效了。简单地说，就是请求的 key 既不存在于数据库，又不存在于缓存。</p>
<p>应对缓存穿透的方案，常见的方案有三种。</p>
<ul>
<li><p>第一种方案，非法请求的限制；比如请求的 key 是数据库 ID，然后请求的值是 -1，这显然是非法的。</p>
</li>
<li><p>第二种方案，缓存空值或者默认值；给这些导致穿透的 key 设置一个空值。</p>
</li>
<li><p>第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在；</p>
<p>通过布隆过滤器将用户请求的 key 标记起来，可以在后续快速判断请求的 key 是否存在于数据库，从而避免请求直接打到数据库。</p>
<p>方案大致流程（随便想的，可能存在 bug 且非最优）：</p>
<ol>
<li>准备一个 map，用来记录 key 是否已经被布隆过滤器记录过。</li>
<li>拿到 key 以后，用上面的 map 判断，看是否记录过<ol>
<li>如果没记录过，去查数据库，查到的话就记录到布隆过滤器，然后在 map 中标记该 key ，说明已被记录过，不管数据库中有没有查到，都要执行这一步</li>
<li>如果记录过，直接去查布隆过滤器，看有没有，如果没有，那么代表这个值一定在数据库中也不存在，直接返回。</li>
</ol>
</li>
</ol>
<p>这种方法需要一个额外的 map，如果 key 很多可能会导致内存浪费，看了一下其他的解决方法，还有其他几种方案：</p>
<p><strong>方案 2：</strong></p>
<p>应用启动时，从数据库构建布隆过滤器，然后请求先走布隆过滤器，有的话再走 Redis，然后 Redis 缓存未命中，查数据库同时构建缓存，布隆过滤器没有的话直接返回。感觉这种方法比较简单，不过构建布隆过滤器这里</p>
<p><strong>方案 3：</strong></p>
<p>来源：<a target="_blank" rel="noopener" href="https://github.com/daydreamdev/MeetingFilm/blob/master/note/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.md">https://github.com/daydreamdev/MeetingFilm/blob/master/note/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.md</a></p>
<p>反着来，布隆过滤器记录的是数据库中不存在的 key，比如用 abc 这个 key 去查布隆过滤器，返回结果为 true，则代表这个 key 不存在。</p>
<p>但是感觉有问题？因为布隆过滤器的特性是：它记录存在的数据，实际并不一定存在，因为存在哈希碰撞问题；但是它没记录的则一定不存在。如果布隆过滤器记录的是不存在的 key，那可能存在一种情况，就是用户请求的 key 可能实际存在于数据库，但是因为哈希碰撞导致布隆过滤器这里也有记录（意味着这个 key 将被判断为不存在），然后用户请求被直接打回，导致缓存也无法构建。</p>
<p>而且还有个问题，就是我可以搞一堆非法请求，比如用户 ID 我请求 -1 到 -9999999999，这些 key 数据库里面肯定是没有的，然后就全写到布隆过滤器里面了，内存里装了一大堆无用的垃圾数据。</p>
<p><strong>感觉这个方案不可用</strong></p>
<p>此外还有一个共同的问题：布隆过滤器是否需要定期更新？比如数据库中存在 abc 这个 key，布隆过滤器也记录了，但是后面这个 key 从数据库中删掉了，此时二者数据不一致了，而且布隆过滤器无法删除，这也是一个问题。</p>
<p>可以在操作数据库的同时更新布隆过滤器，使得二者数据一致，但是删除操作暂时无解。</p>
<p>删除操作想到了一种策略：</p>
<p>可以在我方案 1 的基础上，给 map 的 value 再加一种状态：”已删除”，所以一共有这几种状态：”已标记”，”未标记“，”已删除”，当数据库执行删除操作时，查一下这个 map，如果这个 key 存在且状态为 “已标记”，则将其更新为 “已删除”。</p>
<p>然后，key 进来时先用 map 检查一下，如果是 “已删除” 则直接 return。数据库执行插入、更新操作时也要查一下 map，看这个 key 的状态是不是 “已删除”，是的话将其改为 “已标记”，因为 “已删除” 只能由 “已标记” 流转过来，说明其已经存在于布隆过滤器中。</p>
<p>或者用布谷鸟过滤器？听说是支持删除操作，这个数据结构还没了解。</p>
</li>
</ul>
<h1 id="假如我有一个-Redis-集群，该怎么保证缓存的一致性？"><a href="#假如我有一个-Redis-集群，该怎么保证缓存的一致性？" class="headerlink" title="假如我有一个 Redis 集群，该怎么保证缓存的一致性？"></a>假如我有一个 Redis 集群，该怎么保证缓存的一致性？</h1><h1 id="Redis-Cluster-为什么选哈希槽不选一致性哈希？"><a href="#Redis-Cluster-为什么选哈希槽不选一致性哈希？" class="headerlink" title="Redis Cluster 为什么选哈希槽不选一致性哈希？"></a>Redis Cluster 为什么选哈希槽不选一致性哈希？</h1><h1 id="Redis-底层的统一结构体是什么样？让你设计你会怎么做？"><a href="#Redis-底层的统一结构体是什么样？让你设计你会怎么做？" class="headerlink" title="Redis 底层的统一结构体是什么样？让你设计你会怎么做？"></a>Redis 底层的统一结构体是什么样？让你设计你会怎么做？</h1><p>Redis 的底层数据结构是一个统一的结构体 <code>robj</code>，用于表示各种不同类型的数据（字符串、列表、哈希、集合等）。这个结构体定义在 <code>src/object.h</code> 文件中，如下所示：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog">cCopy code<br><span class="hljs-keyword">struct</span> redisObject &#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">type</span>:<span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">unsigned</span> lru:LRU_BITS; <span class="hljs-comment">/* LRU time (relative to server.lruclock) */</span><br>    <span class="hljs-keyword">int</span> refcount;<br>    <span class="hljs-keyword">void</span> *ptr;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>其中，<code>type</code> 表示对象类型，<code>encoding</code> 表示数据编码方式，<code>lru</code> 表示 LRU 时间戳，<code>refcount</code> 表示引用计数，<code>ptr</code> 是指向实际数据的指针。</p>
<p>如果我需要重新设计 Redis 的底层数据结构，我可能会考虑以下几点：</p>
<ol>
<li><strong>灵活性和扩展性</strong>：确保数据结构的设计足够灵活，能够支持不同类型的数据，以及未来的扩展和新增数据类型。</li>
<li><strong>高效存储</strong>：选择适当的数据编码方式，以便在内存中紧凑存储数据，减少空间浪费。</li>
<li><strong>引用计数和内存管理</strong>：引入引用计数机制，确保在多个引用指向同一个数据时能够正确管理内存释放。</li>
<li><strong>LRU 时间戳</strong>：为了支持 LRU 缓存淘汰策略，可以在数据结构中添加时间戳字段，用于记录数据最近的访问时间。</li>
<li><strong>线程安全性</strong>：考虑多线程环境下的数据访问和修改，需要设计合适的并发控制机制。</li>
<li><strong>快速访问</strong>：在结构体中添加必要的元数据，以支持快速访问数据类型和相关信息。</li>
<li><strong>对齐和内存布局</strong>：考虑数据结构的对齐方式和内存布局，以减少内存碎片和提高访问效率。</li>
<li><strong>扩展性和兼容性</strong>：确保设计允许后续新增数据类型和功能，同时保持与现有 Redis 版本的兼容性。</li>
</ol>
<p>需要注意的是，设计 Redis 的底层数据结构是一个复杂的任务，需要考虑很多因素，包括性能、内存管理、并发性等。同时，Redis 的现有设计已经在实践中得到了验证，所以重新设计需要充分考虑到这些因素。</p>
<h1 id="如果-Redis-同时开启-AOF-和-RDB，那恢复时会使用哪个？"><a href="#如果-Redis-同时开启-AOF-和-RDB，那恢复时会使用哪个？" class="headerlink" title="如果 Redis 同时开启 AOF 和 RDB，那恢复时会使用哪个？"></a>如果 Redis 同时开启 AOF 和 RDB，那恢复时会使用哪个？</h1><p>AOF 是基于命令追加，而 RDB 是基于快照，根据策略每隔一段时间保存一份数据快照，相比较之下，AOF 更新频率更高，数据更加完整，所以如果 AOF 和 RDB 同时存在的时候，Redis 会优先使用 AOF 文件来还原数据库状态，如果 AOF 处于关闭状态时，则从 RDB 中恢复。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Redis/">#Redis</a>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">#面试题</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Redis 面试题</div>
      <div>https://autsu.github.io/2021/07/25/redis-mian-jing/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>void</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年7月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/07/25/mysql-mian-jing/" title="MySQL 面试题">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MySQL 面试题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/07/23/epoll-de-lt-he-et/" title="epoll 的 LT 和 ET">
                        <span class="hidden-mobile">epoll 的 LT 和 ET</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"6KXGn05vaODkTMKM7zd5lWwl-gzGzoHsz","appKey":"qIMQwH4WrxTe8ds3Ua4HAbet","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
