

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon.png">
  <link rel="icon" href="/img/icon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="void">
  <meta name="keywords" content="">
  
    <meta name="description" content="1. char 和 varchar 的区别char 是固定长度，varchar 长度可变，存储时，前者不管实际存储数据的长度，直接规定 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的存储空间。 以char(32)和varchar(32)举例：（这里的 32 表示字符数）     char(32) varchar(32)    占用空间 固定32字符（如果数据长度不够32将用">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL 面试题">
<meta property="og:url" content="https://autsu.github.io/2021/07/25/mysql-mian-jing/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1. char 和 varchar 的区别char 是固定长度，varchar 长度可变，存储时，前者不管实际存储数据的长度，直接规定 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的存储空间。 以char(32)和varchar(32)举例：（这里的 32 表示字符数）     char(32) varchar(32)    占用空间 固定32字符（如果数据长度不够32将用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/autsu/diagrams/master/img/redolog.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250417150253.png">
<meta property="article:published_time" content="2021-07-25T02:04:25.000Z">
<meta property="article:modified_time" content="2025-04-18T11:02:57.222Z">
<meta property="article:author" content="void">
<meta property="article:tag" content="mysql">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/autsu/diagrams/master/img/redolog.webp">
  
  
  
  <title>MySQL 面试题 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"autsu.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":"G-80J26VFWFL","gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"6KXGn05vaODkTMKM7zd5lWwl-gzGzoHsz","app_key":"qIMQwH4WrxTe8ds3Ua4HAbet","server_url":"https://6kxgn05v.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript('https://www.google-analytics.com/analytics.js', function() {
          window.ga = window.ga || function() { (ga.q = ga.q || []).push(arguments) };
          ga.l = +new Date;
          ga('create', 'G-80J26VFWFL', 'auto');
          ga('send', 'pageview');
        });
      }
    </script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>/dev/null</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MySQL 面试题"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-07-25 10:04" pubdate>
          2021年7月25日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          24k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          201 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">MySQL 面试题</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="1-char-和-varchar-的区别"><a href="#1-char-和-varchar-的区别" class="headerlink" title="1. char 和 varchar 的区别"></a>1. char 和 varchar 的区别</h1><p>char 是固定长度，varchar 长度可变，存储时，前者不管实际存储数据的长度，直接规定 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的存储空间。</p>
<p>以char(32)和varchar(32)举例：（这里的 32 表示字符数）</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th>char(32)</th>
<th>varchar(32)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">占用空间</td>
<td>固定32字符（如果数据长度不够32将用空格补齐）</td>
<td>跟随实际存储内容长度，但不超过32</td>
</tr>
<tr>
<td align="left">空格处理</td>
<td>检索时会去掉尾部空格（数据本身有空白符也会被去掉）</td>
<td>不会对空格处理</td>
</tr>
<tr>
<td align="left">是否记录字段长度</td>
<td>否</td>
<td>是。额外拿出空间记录字段数据长度（字符数）</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td>存储的数据长度基本一致，不需要空格，eg 手机号、UUID、密码加密后的密文</td>
<td>数据长度不一定，长度范围变化较大的场景</td>
</tr>
</tbody></table>
<p><em>小问题：char(1) 和 varchar(1) 的区别？两个都只能保存单个字符，但是 varchar 要多占一个或两个存储位置用来记录存储长度信息</em></p>
<h1 id="2-建立一个联合索引，问-select-a，b，c-和-select-a，c，b-有什么区别"><a href="#2-建立一个联合索引，问-select-a，b，c-和-select-a，c，b-有什么区别" class="headerlink" title="2. 建立一个联合索引，问 select a，b，c 和 select a，c，b 有什么区别"></a>2. 建立一个联合索引，问 select a，b，c 和 select a，c，b 有什么区别</h1><p>MySQL 的 最左前缀匹配原则</p>
<h1 id="3-varchar-类型，插入的数据超过设置的长度会怎样"><a href="#3-varchar-类型，插入的数据超过设置的长度会怎样" class="headerlink" title="3. varchar 类型，插入的数据超过设置的长度会怎样"></a>3. varchar 类型，插入的数据超过设置的长度会怎样</h1><p>来源： <a target="_blank" rel="noopener" href="https://www.hegongshan.com/2020/04/22/mysql-varchar/">https://www.hegongshan.com/2020/04/22/mysql-varchar/</a></p>
<p>网上基本都说字符串会被自动截断，并报出一个 warning，但是，我在本机上测试时（MySQL 8.0.16），却报了如下错误：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">ERROR </span>1406 (22001): Data too long for column &#x27;name&#x27; at row 1<br></code></pre></td></tr></table></figure>

<p>这是怎么回事呢？后来，我发现，这两种情况是由于SQL模式不同造成的。</p>
<p>在MySQL中，有如下三种最重要的SQL模式（官网称之为<code>The Most Important SQL Modes</code>）</p>
<ol>
<li><p>ANSI </p>
<blockquote>
<p>宽松模式</p>
<p>此模式更改语法和行为，使其更接近标准SQL</p>
</blockquote>
</li>
<li><p>STRICT_TRANS_TABLES</p>
<blockquote>
<p>严格模式</p>
<p>在该模式下,如果一个值不能插入到一个事务表中,则中断当前的操作,对非事务表不做限制</p>
</blockquote>
</li>
<li><p>TRADITIONAL</p>
<blockquote>
<p>在向列中插入错误值时，此模式“给出错误而不是警告”。</p>
<p>TRADITIONAL 是一个组合模式，它包含了 STRICT_TRANS_TABLES</p>
</blockquote>
</li>
</ol>
<p>使用 <code>select @@sql_mode</code> 查看当前的 sql_mode。</p>
<p><code>set @@sql_mode = &#39;traditional&#39;</code> 更改当前 sql_mode。</p>
<p><strong>总结</strong></p>
<p>当 varchar 超过限制长度时，</p>
<p>1.如果当前的 SQL 模式为宽松模式，那么将会按照从前往后的顺序，对字符串进行截断，并提示一个警告；</p>
<p>2.如果当前的 SQL 模式为严格模式，那么将会报出一个错误。</p>
<h1 id="MYSQL-事务的-ACID"><a href="#MYSQL-事务的-ACID" class="headerlink" title="MYSQL 事务的 ACID"></a>MYSQL 事务的 ACID</h1><ul>
<li><p><strong>1. 原子性 (Atomicity)</strong></p>
</li>
<li><p><strong>含义：</strong> 一个事务被视为一个不可分割的、最小的工作单元。事务中的所有操作<strong>要么全部成功执行，要么全部不执行（回滚）</strong>。绝对不会出现事务只执行了一部分的情况。</p>
</li>
<li><p><strong>类比：</strong> 就像原子是物质的最小不可分割单位一样，事务是数据库操作的最小逻辑单元。</p>
</li>
<li><p><strong>目的：</strong> 保证数据的完整性。例如，在一个银行转账事务中，包含两个操作：从账户 A 扣款，给账户 B 存款。原子性确保这两个操作要么都完成，要么如果中间任何一步失败（比如 B 账户不存在或系统崩溃），已经执行的扣款操作也会被撤销（回滚），数据库状态将恢复到事务开始之前的样子，避免了钱凭空消失或产生的情况。</p>
</li>
<li><p><strong>实现机制：</strong> MySQL 主要通过 <strong>Undo Log（回滚日志）</strong> 来实现原子性。在执行数据修改操作之前，会先将原始数据记录到 Undo Log 中。如果事务需要回滚，数据库可以利用 Undo Log 中的信息将数据恢复到事务开始时的状态。</p>
</li>
</ul>
<p><strong>2. 一致性 (Consistency)</strong></p>
<ul>
<li><p><strong>含义：</strong> 事务的执行必须使数据库从一个<strong>一致性状态</strong>转变到另一个<strong>一致性状态</strong>。一致性状态意味着数据库中的数据满足所有的预定约束（如主键约束、外键约束、唯一性约束、数据类型约束以及业务规则定义的约束）。</p>
</li>
<li><p><strong>关键点：</strong></p>
<ul>
<li><p><strong>事务开始前</strong>，数据库处于一致状态。</p>
</li>
<li><p><strong>事务结束后</strong>，无论事务是成功提交还是失败回滚，数据库<strong>也必须</strong>处于一致状态。</p>
</li>
<li><p><strong>事务执行过程中</strong>，数据可能暂时处于不一致状态（例如转账过程中，一个账户已扣款但另一个账户还未收款），但这是中间状态，最终结果必须是一致的。</p>
</li>
</ul>
</li>
<li><p><strong>目的：</strong> 维护数据的正确性和业务规则的有效性。确保不会因为事务的执行而产生无效或矛盾的数据。</p>
</li>
<li><p><strong>实现机制：</strong> 一致性是 ACID 的最终目标，它依赖于其他三个属性（原子性、隔离性、持久性）以及数据库自身的约束机制（如约束检查、触发器等）共同保证。原子性保证了操作的完整性，隔离性防止了并发事务间的干扰，持久性确保了结果的永久性，这些都是实现一致性的基础。数据库还会执行约束检查，确保插入或更新的数据符合规则。</p>
</li>
</ul>
<blockquote>
<p>PS: 一致性不太好理解，简单的说，就是其他三个特性确保了一致性。</p>
</blockquote>
<p><strong>3. 隔离性 (Isolation)</strong></p>
<ul>
<li><p><strong>含义：</strong> 数据库允许多个事务<strong>并发</strong>执行，但一个事务的执行<strong>不应被其他并发执行的事务所干扰</strong>。即，并发执行的事务之间应该相互隔离，使得每个事务都感觉像是在独立地操作数据库。</p>
</li>
<li><p><strong>目的：</strong> 防止并发环境下可能出现的数据问题，如：</p>
<ul>
<li><p><strong>脏读 (Dirty Read):</strong> 一个事务读取了另一个事务尚未提交的修改数据。如果那个事务最终回滚，那么读取到的就是无效的“脏”数据。</p>
</li>
<li><p><strong>不可重复读 (Non-repeatable Read):</strong> 一个事务在同一次执行中，对同一数据进行多次读取，但由于其他事务在此期间修改了该数据并提交，导致两次读取的结果不一致。</p>
</li>
<li><p><strong>幻读 (Phantom Read):</strong> 一个事务在同一次执行中，按相同条件多次查询，但由于其他事务在此期间插入或删除了符合条件的数据并提交，导致两次查询返回的记录<strong>行数</strong>不一致，好像出现了“幻影”行。</p>
</li>
</ul>
</li>
<li><p><strong>实现机制：</strong> MySQL 通过<strong>锁机制 (Locking)</strong> 和 <strong>多版本并发控制 (MVCC - Multi-Version Concurrency Control)</strong> 来实现隔离性。</p>
<ul>
<li><p><strong>锁机制：</strong> 通过对数据行、表等加锁，阻止其他事务进行冲突的操作。</p>
</li>
<li><p><strong>MVCC:</strong> 在 InnoDB 存储引擎中广泛使用。为每一行数据维护多个版本（通过隐藏的版本号和 Undo Log 实现），使得读操作（通常）不需要加锁，可以读取到事务开始时的一个一致性快照，从而避免了读写冲突，提高了并发性能。</p>
</li>
<li><p><strong>隔离级别 (Isolation Levels):</strong> MySQL 提供了四种隔离级别（读未提交 Read Uncommitted, 读已提交 Read Committed, 可重复读 Repeatable Read (默认), 串行化 Serializable），允许用户根据应用需求在并发性能和数据一致性之间进行权衡。不同的隔离级别能解决不同程度的并发问题。</p>
</li>
</ul>
</li>
</ul>
<p><strong>4. 持久性 (Durability)</strong></p>
<ul>
<li><p><strong>含义：</strong> 一旦事务成功<strong>提交 (Commit)<strong>，它对数据库所做的更改就应该是</strong>永久性</strong>的。即使后续发生系统崩溃、断电等故障，这些已提交的更改也<strong>不能丢失</strong>。</p>
</li>
<li><p><strong>目的：</strong> 保证数据的可靠性。用户的操作结果（只要事务成功提交）是值得信赖的，不会因为意外情况而消失。</p>
</li>
<li><p><strong>实现机制：</strong> MySQL 主要通过 <strong>Redo Log（重做日志）</strong> 来实现持久性。</p>
<ul>
<li><p>当事务提交时，其所做的修改会先被写入到 Redo Log 文件中（通常是顺序写入，速度很快）。</p>
</li>
<li><p>只有当 Redo Log 写入成功后，事务才算真正提交。</p>
</li>
<li><p>数据页（Data Page）的修改可能会稍后才被刷新（Flush）到磁盘上的数据文件中（为了性能）。</p>
</li>
<li><p>如果在数据页刷新到磁盘前系统崩溃，数据库在重启后可以通过 Redo Log 中的记录，重新执行那些已提交但未完全落盘的事务操作，将数据库恢复到崩溃前的最后一个一致状态，从而保证了已提交事务的持久性。</p>
</li>
</ul>
</li>
</ul>
<h1 id="MySQL-原子性怎么保证"><a href="#MySQL-原子性怎么保证" class="headerlink" title="MySQL 原子性怎么保证"></a>MySQL 原子性怎么保证</h1><p>MySQL (特别是使用 <strong>InnoDB</strong> 存储引擎时，因为像 MyISAM 这样的引擎不支持事务) 主要通过 <strong>Undo Log (回滚日志)</strong> 来保证事务的原子性（Atomicity）。</p>
<p>以下是详细的保证机制：</p>
<ol>
<li><p><strong>记录反向操作信息 (Undo Log):</strong></p>
<ul>
<li><p>当一个事务开始对数据进行修改（如 INSERT, UPDATE, DELETE）时，在<strong>实际修改数据页 (Data Page) 之前</strong>，InnoDB 会先将用于<strong>撤销</strong>这些操作所需的信息记录到 Undo Log 中。</p>
</li>
<li><p><strong>对于 INSERT 操作：</strong> Undo Log 会记录下新插入数据的主键或其他唯一标识，以便在回滚时可以根据这个标识删除这条记录。</p>
</li>
<li><p><strong>对于 UPDATE 操作：</strong> Undo Log 会记录下被修改行修改<strong>之前</strong>的旧值。如果事务回滚，InnoDB 可以根据 Undo Log 中的旧值将数据恢复原状。</p>
</li>
<li><p><strong>对于 DELETE 操作：</strong> Undo Log 会记录下被删除行的内容。如果事务回滚，InnoDB 可以根据 Undo Log 中的记录将这行数据重新插入回去。</p>
</li>
<li><p>这些 Undo Log 记录会与事务 ID 关联起来，形成一个操作链。</p>
</li>
</ul>
</li>
<li><p><strong>事务提交 (Commit):</strong></p>
<ul>
<li><p>如果事务中的所有操作都成功执行，并且用户发出了 COMMIT 指令。</p>
</li>
<li><p>此时，事务被认为是成功的。虽然数据的最终落盘可能稍后由 Redo Log 保证（为了持久性），但从原子性的角度看，这个事务逻辑上已经完成了“全部执行”的部分。与该事务相关的 Undo Log 在不再被其他事务所需要（例如用于 MVCC 一致性读）之后，可以被清理。</p>
</li>
</ul>
</li>
<li><p><strong>事务回滚 (Rollback):</strong></p>
<ul>
<li><p>如果在事务执行过程中发生任何错误（如违反约束、SQL 错误、死锁牺牲品等），或者用户显式执行了 ROLLBACK 命令。</p>
</li>
<li><p>数据库系统会利用该事务对应的 <strong>Undo Log</strong>。</p>
</li>
<li><p>它会<strong>按照与执行操作相反的顺序</strong>，读取 Undo Log 中的记录，并执行相应的“反向”操作：</p>
<ul>
<li><p>对于之前的 INSERT，执行 DELETE。</p>
</li>
<li><p>对于之前的 UPDATE，使用旧值恢复数据。</p>
</li>
<li><p>对于之前的 DELETE，重新 INSERT 数据。</p>
</li>
</ul>
</li>
<li><p>通过执行这些反向操作，数据库的状态被<strong>精确地恢复到该事务开始执行之前</strong>的样子。</p>
</li>
<li><p>这就实现了原子性的“全部不执行”部分。</p>
</li>
</ul>
</li>
<li><p><strong>系统崩溃恢复:</strong></p>
<ul>
<li><p>如果数据库在事务执行过程中（尚未提交）发生崩溃。</p>
</li>
<li><p>当数据库重启时，它会检查事务日志（特别是 Redo Log 和 Undo Log）。</p>
</li>
<li><p>对于那些已经写入 Redo Log 但尚未标记为 Commit 的<strong>未完成事务</strong>，数据库会利用 Undo Log 将这些事务进行<strong>回滚</strong>，以确保它们没有部分更改留在数据库中，保证了原子性。</p>
</li>
<li><p>（对于已 Commit 但可能未完全刷盘的事务，则会用 Redo Log 来前滚，保证持久性）。</p>
</li>
</ul>
</li>
</ol>
<h2 id="撤销日志（Undo-Log）"><a href="#撤销日志（Undo-Log）" class="headerlink" title="撤销日志（Undo Log）"></a><del>撤销日志（Undo Log）</del></h2><ul>
<li><p><del>作用：记录事务执行前的数据状态</del></p>
</li>
<li><p><del>工作原理：</del></p>
</li>
<li><p><del>事务开始前，将修改的数据原始状态保存在撤销日志中</del></p>
</li>
<li><p><del>若事务需要回滚，系统使用撤销日志将数据恢复到事务前状态</del></p>
</li>
<li><p><del>对每个操作记录反向操作（如INSERT的反向是DELETE）</del></p>
</li>
<li><p><del>实现：InnoDB在回滚段（Rollback Segment）中维护撤销日志</del></p>
</li>
</ul>
<h1 id="redolog-工作原理"><a href="#redolog-工作原理" class="headerlink" title="redolog 工作原理"></a>redolog 工作原理</h1><p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，</p>
<p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/redolog.webp" srcset="/img/loading.gif" lazyload></p>
<p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录（也就是写入到硬盘），把 checkpoint 推进一下（写入成功后只移动 checkpoint，而不会清空数据，后续直接覆盖写即可）。</p>
<h1 id="redolog-中会存在未提交事务产生的内容吗"><a href="#redolog-中会存在未提交事务产生的内容吗" class="headerlink" title="redolog 中会存在未提交事务产生的内容吗"></a>redolog 中会存在未提交事务产生的内容吗</h1><p>是的，<strong>MySQL 的 redo log（重做日志）中</strong>是会存在<strong>未提交事务产生的内容</strong>的。</p>
<hr>
<h3 id="一、为什么-redo-log-中会有未提交事务的内容？"><a href="#一、为什么-redo-log-中会有未提交事务的内容？" class="headerlink" title="一、为什么 redo log 中会有未提交事务的内容？"></a>一、为什么 redo log 中会有未提交事务的内容？</h3><p>MySQL 的 InnoDB 存储引擎使用 <strong>WAL（Write-Ahead Logging）机制</strong>，即：</p>
<ul>
<li><p>修改数据时，<strong>先写 redo log</strong>，再更新内存中的数据（Buffer Pool），</p>
</li>
<li><p>之后再将数据异步刷新到磁盘的 <code>.ibd</code> 文件中（即真正的数据页）。</p>
</li>
</ul>
<blockquote>
<p><strong>redo log 记录的是对数据页的物理更改，用于崩溃恢复（Crash Recovery）</strong></p>
</blockquote>
<p>关键点在于：</p>
<ul>
<li><p><strong>事务在执行过程中就会不断写入 redo log</strong>，但这些日志的 <code>trx id</code>（事务 id）对应的事务可能还没有提交。</p>
</li>
<li><p>所以 redo log 中<strong>包含了尚未提交的事务产生的变更信息</strong>。</p>
</li>
</ul>
<hr>
<h3 id="二、这些未提交的-redo-log-有什么用？"><a href="#二、这些未提交的-redo-log-有什么用？" class="headerlink" title="二、这些未提交的 redo log 有什么用？"></a>二、这些未提交的 redo log 有什么用？</h3><ol>
<li><p><strong>崩溃恢复时会用到</strong></p>
<ul>
<li><p>如果发生宕机，MySQL 会在重启时根据 redo log 执行恢复操作。</p>
</li>
<li><p>InnoDB 会扫描 redo log，根据事务的提交状态：</p>
<ul>
<li><p><strong>已提交的事务</strong> → 做 <strong>重做（redo）</strong></p>
</li>
<li><p><strong>未提交的事务</strong> → 忽略（或做 undo）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>性能优化（提前写入日志）</strong></p>
<ul>
<li><p>事务执行过程中先写日志，不等事务提交，有助于提高写入性能。</p>
</li>
<li><p>不必等所有修改完成、事务提交时才写日志。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="三、redo-log-和事务提交的关系"><a href="#三、redo-log-和事务提交的关系" class="headerlink" title="三、redo log 和事务提交的关系"></a>三、redo log 和事务提交的关系</h3><ul>
<li><p>redo log 分为两部分：</p>
<ul>
<li><p><strong>prepare 阶段</strong>：事务执行时写入 redo log，但未提交。</p>
</li>
<li><p><strong>commit 阶段</strong>：事务提交时写入 commit 标记（特殊日志）。</p>
</li>
</ul>
</li>
</ul>
<p>只有在 redo log 中发现有 <strong>prepare + commit 标志</strong> 的事务，MySQL 才会在恢复时进行重做。</p>
<hr>
<h3 id="四、举个例子"><a href="#四、举个例子" class="headerlink" title="四、举个例子"></a>四、举个例子</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-comment">-- 此时已经写入 redo log（prepare 阶段），但未 commit</span><br><span class="hljs-comment">-- 如果宕机，InnoDB 会发现这两个操作产生的 redo log 是未提交的</span><br><span class="hljs-comment">-- 所以不会做 redo</span><br><span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-comment">-- 写入 redo log 的 commit 标记，此时事务才真正生效</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><table>
<thead>
<tr>
<th>阶段</th>
<th>redo log 中是否存在</th>
<th>redo log 是否生效</th>
</tr>
</thead>
<tbody><tr>
<td>未提交</td>
<td>✅ 有</td>
<td>❌ 不生效</td>
</tr>
<tr>
<td>已提交</td>
<td>✅ 有</td>
<td>✅ 恢复时生效</td>
</tr>
</tbody></table>
<hr>
<p>如你后续还有关于 undo log、binlog 的配合或 crash recovery 流程感兴趣，也可以展开聊聊 👍</p>
<h1 id="宕机后如何保证数据不丢失？"><a href="#宕机后如何保证数据不丢失？" class="headerlink" title="宕机后如何保证数据不丢失？"></a>宕机后如何保证数据不丢失？</h1><p>保证 MySQL (特别是 InnoDB 存储引擎) 在宕机后数据不丢失，主要依赖于<strong>持久性 (Durability)</strong> 的实现，其核心机制是 **Write-Ahead Logging (WAL)**，具体体现在 <strong>Redo Log (重做日志)</strong> 的使用上。</p>
<p>以下是保证数据不丢失的关键步骤和原理：</p>
<ol>
<li><p><strong>Redo Log (重做日志) - 先写日志，再写数据:</strong></p>
<ul>
<li><p><strong>什么是 Redo Log:</strong> 它是一个物理日志，记录的是对数据页（Data Page）所做的<strong>物理修改</strong>，而不是逻辑操作（比如不是记录 UPDATE SET col&#x3D;val WHERE id&#x3D;1，而是记录类似“在表空间 X 的 Y 页的偏移量 Z 处写入字节 W”这样的底层修改）。</p>
</li>
<li><p><strong>写在前面 (Write-Ahead):</strong> 当一个事务修改数据时，InnoDB <strong>首先</strong>会将这些修改操作对应的 Redo Log 记录写入到<strong>内存中的 Redo Log Buffer</strong>。然后，在事务<strong>提交 (Commit)</strong> 时（或根据配置策略），这些 Redo Log 记录<strong>必须先被刷新 (Flush) 到磁盘上的 Redo Log 文件中</strong>，然后事务才算真正成功提交。这个“先写日志”的操作是持久性的关键。</p>
</li>
<li><p><strong>顺序写入:</strong> Redo Log 文件通常是<strong>顺序写入</strong>的，这比向数据文件进行随机写入要快得多。</p>
</li>
</ul>
</li>
<li><p><strong>Buffer Pool (缓冲池) - 内存加速:</strong></p>
<ul>
<li><p>InnoDB 在内存中维护一个 Buffer Pool，用于缓存磁盘上的数据页。</p>
</li>
<li><p>当事务修改数据时，它实际上是先修改<strong>内存中 Buffer Pool 里的数据页</strong>。这些被修改过的页被称为“脏页 (Dirty Pages)”。</p>
</li>
</ul>
</li>
<li><p><strong>数据页延迟写入 (Delayed Write):</strong></p>
<ul>
<li><p>修改后的“脏页”<strong>不一定</strong>会在事务提交时立即被写回到磁盘上的数据文件 (.ibd 文件) 中。</p>
</li>
<li><p>InnoDB 会在后台根据一定的策略（如 Checkpoint 机制、Buffer Pool 空间不足时等）将这些脏页<strong>异步地、批量地</strong>刷新回磁盘。这样做可以合并写入操作，减少随机 I&#x2F;O，提高性能。</p>
</li>
</ul>
</li>
<li><p><strong>事务提交的关键点:</strong></p>
<ul>
<li><p>一个事务被认为成功提交并具有持久性的<strong>充要条件</strong>是：与该事务相关的所有 Redo Log 记录<strong>已经成功写入到磁盘上的 Redo Log 文件中</strong>。</p>
</li>
<li><p>即使此时对应的“脏页”还没有刷新到磁盘数据文件中，数据也是安全的。</p>
</li>
</ul>
</li>
<li><p><strong>宕机后的恢复过程 (Crash Recovery):</strong></p>
<ul>
<li><p>当 MySQL 因宕机（如断电、操作系统崩溃）重启时，InnoDB 会执行恢复流程：</p>
<ul>
<li><p><strong>检查 Redo Log:</strong> InnoDB 会读取磁盘上的 Redo Log 文件。</p>
</li>
<li><p><strong>找到最后检查点 (Checkpoint):</strong> 它会找到最后一个成功的检查点（Checkpoint LSN - Log Sequence Number），这个点表示在此之前的 Redo Log 对应的所有数据页修改都<strong>保证</strong>已经刷新到磁盘数据文件了。</p>
</li>
<li><p><strong>重放 Redo Log (Roll Forward):</strong> 对于检查点<strong>之后</strong>的 Redo Log 记录，InnoDB 会将这些记录代表的物理修改<strong>重新应用</strong>到内存的 Buffer Pool 中（如果需要，会先从磁盘加载对应的数据页）。这会把那些在宕机前已提交但其数据页修改尚未落盘的操作重新做一遍。</p>
</li>
<li><p><strong>(回滚未提交事务):</strong> 同时，InnoDB 也会利用 Undo Log 回滚那些在宕机时还未提交的事务（保证原子性）。</p>
</li>
</ul>
</li>
<li><p><strong>结果:</strong> 通过重放 Redo Log，所有<strong>已成功提交</strong>的事务（即其 Redo Log 已落盘）的效果都被恢复到了数据库中，即使它们的数据页在宕机前没有写入磁盘，也保证了数据的持久性，不会丢失。</p>
</li>
</ul>
</li>
</ol>
<p><strong>配置参数的影响 (innodb_flush_log_at_trx_commit)</strong></p>
<p>这个参数直接影响 Redo Log 的刷盘时机，从而影响持久性的强度和性能：</p>
<ul>
<li><p><strong>1 (默认值):</strong> 最高安全性。每次事务提交时，都会将 Redo Log Buffer 的内容<strong>同步</strong>写入到磁盘上的 Redo Log 文件并完成 fsync 操作。即使操作系统或数据库主机宕机，也最多丢失未提交的事务。这是完全符合 ACID 持久性的设置。</p>
</li>
<li><p><strong>2:</strong> 性能较好。每次事务提交时，仅将 Redo Log Buffer 写入操作系统的文件缓存 (Page Cache)，大约每秒由操作系统将缓存刷新到磁盘。如果仅仅是 MySQL 进程崩溃，数据不会丢失；但如果操作系统也同时崩溃或服务器断电，可能会丢失最后一秒内提交的事务。</p>
</li>
<li><p><strong>0:</strong> 性能最好。大约每秒才将 Redo Log Buffer 写入操作系统的文件缓存，并由操作系统刷新到磁盘。MySQL 进程崩溃或操作系统崩溃&#x2F;断电都可能导致丢失最后一秒的事务。</p>
</li>
</ul>
<p><strong>总结:</strong></p>
<p>MySQL InnoDB 通过 <strong>Write-Ahead Logging (WAL)</strong> 策略，利用 <strong>Redo Log</strong> 实现了持久性。核心在于<strong>强制要求事务提交前必须先将对应的 Redo Log 记录写入磁盘</strong>。这样即使数据页的写入是延迟和异步的，在系统宕机后，也能通过重放 Redo Log 来恢复所有已提交事务的修改，从而保证数据不丢失。配置参数 innodb_flush_log_at_trx_commit 允许在持久性强度和性能之间进行权衡。</p>
<p><del>通过 redolog，MySQL 使用了 WAL，在更新记录时会先将操作写到 redo log（redo log 也是一个文件，保存在磁盘上），然后 MySQL 启动时会先检查一下 redo log，看里面有没有内容，有的话说明就说明存在未落盘的数据，此时就可以通过 redo log 将这些数据重新写入到磁盘，从而保证数据不丢失。</del></p>
<p><del>redo log 的工作原理参见上面</del></p>
<h1 id="如果-rollback-了，之前已经写入到-redolog-的数据会一起删除吗？此外，redolog-的刷盘时机是什么？它不会把未提交事务的数据刷盘吗？"><a href="#如果-rollback-了，之前已经写入到-redolog-的数据会一起删除吗？此外，redolog-的刷盘时机是什么？它不会把未提交事务的数据刷盘吗？" class="headerlink" title="如果 rollback 了，之前已经写入到 redolog 的数据会一起删除吗？此外，redolog 的刷盘时机是什么？它不会把未提交事务的数据刷盘吗？"></a>如果 rollback 了，之前已经写入到 redolog 的数据会一起删除吗？此外，redolog 的刷盘时机是什么？它不会把未提交事务的数据刷盘吗？</h1><p> ✅ 问题一：如果 rollback 了，之前已经写入到 redo log 的内容会一起删除吗？</p>
<p><strong>不会删除！但会被标记为无效。</strong></p>
<p>原因：</p>
<ol>
<li><p><strong>redo log 是顺序写入的日志文件，不支持“回滚删除”</strong></p>
<ul>
<li><p>redo log 是一种物理日志，只记录数据页的修改操作，底层是顺序写入、环形结构。</p>
</li>
<li><p>不会因为事务回滚而“物理删除”之前写入的日志。</p>
</li>
</ul>
</li>
<li><p><strong>rollback 时会写 undo log 来“逻辑回滚”</strong></p>
<ul>
<li><p>当你 <code>ROLLBACK</code> 一个事务时，InnoDB 会根据 <strong>undo log</strong> 来将数据恢复到原始状态。</p>
</li>
<li><p>redo log 里虽然还存在那些未提交时的修改记录，但这些事务是未提交的，因此恢复时会 <strong>忽略</strong>。</p>
</li>
</ul>
</li>
<li><p><strong>crash recovery 时：</strong></p>
<ul>
<li><p>InnoDB 会遍历 redo log 日志：</p>
<ul>
<li><p>找到 <strong>已提交事务的日志</strong> → redo 恢复（应用日志）</p>
</li>
<li><p>找到 <strong>未提交事务的日志</strong> → <strong>不执行</strong>，等事务恢复机制清理它。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>🔁 所以你可以理解为：<strong>rollback 不会删除 redo log 中的数据，而是通过 undo log 做逻辑回退，redo log 留着作为 crash recovery 的一部分，但不会真正重放。</strong></p>
<p><strong>redo log 的刷盘时机</strong></p>
<p>InnoDB 会根据两种时机刷盘 redo log：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>1. 写入 redo log buffer（内存）时</td>
<td>不立即刷盘（写入内存）</td>
</tr>
<tr>
<td>2. 满足以下任何一种情况时才会刷盘（fsync 到磁盘）</td>
<td></td>
</tr>
<tr>
<td>- <code>COMMIT</code> 提交事务</td>
<td>✅ 刷盘（取决于 <code>innodb_flush_log_at_trx_commit</code> 参数）</td>
</tr>
<tr>
<td>- redo log buffer 空间不足</td>
<td>✅ 刷盘</td>
</tr>
<tr>
<td>- 后台定时刷新（如每秒）</td>
<td>✅ 刷盘</td>
</tr>
<tr>
<td>- crash recover</td>
<td>✅ 读取 redo log 日志恢复</td>
</tr>
</tbody></table>
<hr>
<p><strong>关键参数：<code>innodb_flush_log_at_trx_commit</code></strong></p>
<p>这个参数控制 <strong>事务提交时是否强制将 redo log 刷到磁盘</strong>：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td>不在事务提交时刷盘，只由后台线程周期性刷盘（如每秒）</td>
</tr>
<tr>
<td><code>1</code></td>
<td>每次事务提交时都立刻 fsync（最安全）✅ 推荐</td>
</tr>
<tr>
<td><code>2</code></td>
<td>提交时写 redo buffer，不 fsync，fsync 交给后台</td>
</tr>
</tbody></table>
<p>💡 <strong>说明：</strong></p>
<ul>
<li><p>即使你没有 commit，InnoDB 也可能把 redo log <strong>提前刷到磁盘</strong>（比如 buffer 快满了）。</p>
</li>
<li><p>所以磁盘上可能存在很多 <strong>未提交事务的 redo log 数据</strong>。</p>
</li>
</ul>
<hr>
<p><strong>这安全吗？为啥不怕刷了未提交事务？</strong></p>
<p>这正是 <strong>InnoDB crash recovery 机制</strong> 的关键设计点：</p>
<ul>
<li><p><strong>刷盘 ≠ 提交成功</strong></p>
</li>
<li><p>redo log 中必须有 <code>COMMIT</code> 标志，才表示这个事务成功提交，才会在恢复时执行。</p>
</li>
<li><p>所以即使 redo log 中刷了很多还没提交的数据也没关系，<strong>崩溃恢复时不会重放这些“半成品”</strong>。</p>
</li>
</ul>
<p><strong>✅ 总结</strong></p>
<table>
<thead>
<tr>
<th>问题</th>
<th>答案</th>
</tr>
</thead>
<tbody><tr>
<td>rollback 时 redo log 数据会删除吗？</td>
<td>❌ 不会删除，但会被标记为“未提交”，恢复时不会执行</td>
</tr>
<tr>
<td>redo log 会不会写未提交事务的数据？</td>
<td>✅ 会，为了性能提前写入</td>
</tr>
<tr>
<td>redo log 会不会把未提交事务的数据刷盘？</td>
<td>✅ 会，但恢复时会根据是否有 COMMIT 标记判断是否应用</td>
</tr>
<tr>
<td>为啥这样设计是安全的？</td>
<td>因为 InnoDB crash recovery 会忽略没有 commit 的日志</td>
</tr>
</tbody></table>
<h2 id="✅-redo-log-并不会“主动”将数据写入-ibd-文件"><a href="#✅-redo-log-并不会“主动”将数据写入-ibd-文件" class="headerlink" title="✅ redo log 并不会“主动”将数据写入 .ibd 文件"></a>✅ redo log 并不会“主动”将数据写入 <code>.ibd</code> 文件</h2><ul>
<li><p><strong>redo log 是物理日志</strong>，它的主要作用是：<strong>在数据库崩溃后用于恢复未刷盘的脏页</strong>。</p>
</li>
<li><p>它<strong>不直接负责</strong>将内存中修改后的数据写入 <code>.ibd</code> 表空间文件。</p>
</li>
</ul>
<h2 id="✅-ibd-文件的写入由-脏页刷盘机制-来完成："><a href="#✅-ibd-文件的写入由-脏页刷盘机制-来完成：" class="headerlink" title="✅ .ibd 文件的写入由 脏页刷盘机制 来完成："></a>✅ <code>.ibd</code> 文件的写入由 <strong>脏页刷盘机制</strong> 来完成：</h2><ul>
<li><p>当 InnoDB 在 Buffer Pool 中修改了某个数据页后，该页变成了 <strong>dirty page（脏页）</strong>。</p>
</li>
<li><p>InnoDB 的后台线程（如 Page Cleaner）会根据策略（时间、水位、压力）<strong>异步将这些脏页 flush 到磁盘 <code>.ibd</code> 文件中</strong>。</p>
</li>
<li><p>这个过程 <strong>与 redo log 是否写入或刷盘没有直接关系</strong>，它们是<strong>并行的两个机制</strong>。</p>
</li>
</ul>
<h1 id="undolog-在宕机时怎么保证原子性"><a href="#undolog-在宕机时怎么保证原子性" class="headerlink" title="undolog 在宕机时怎么保证原子性"></a>undolog 在宕机时怎么保证原子性</h1><p><strong>🔧 假设的未提交事务：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>);<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Alice&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">-- 还没 commit，MySQL 崩溃了 💥</span><br></code></pre></td></tr></table></figure>

<p>这个事务还没提交，MySQL 崩溃了。现在我们来看看：</p>
<p>每条操作的流程：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>redo log 中记录了什么</th>
</tr>
</thead>
<tbody><tr>
<td><code>INSERT INTO user VALUES (2, &#39;Jerry&#39;)</code></td>
<td>哪个页插入了什么值的位置，插入前页的状态，插入的值</td>
</tr>
<tr>
<td><code>INSERT INTO user VALUES (3, &#39;Bob&#39;)</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>UPDATE user SET name = &#39;Alice&#39; WHERE id = 1</code></td>
<td>该页中某个记录字段从 “Tom” 改为 “Alice”</td>
</tr>
<tr>
<td><code>DELETE FROM user WHERE id = 10</code></td>
<td>哪个页删除了哪一行、位置在哪里等信息</td>
</tr>
<tr>
<td>这些信息都写入 redo log 中，<strong>redo log 会打一个 “prepare” 标记</strong>，但<strong>还没有写 commit 标记</strong>。</td>
<td></td>
</tr>
</tbody></table>
<p>此外，每条操作也会生成一份 undo log，供 rollback 使用。</p>
<p>此时，我们再来模拟崩溃恢复。</p>
<p><strong>🧠 恢复过程如下：</strong></p>
<ol>
<li><p><strong>MySQL 重启</strong>，Buffer Pool 是空的</p>
</li>
<li><p>InnoDB 读取 redo log，发现该事务有 <strong>prepare</strong>，但没有 <strong>commit</strong></p>
</li>
<li><p>确认这是个 <strong>未提交事务</strong></p>
</li>
<li><p><strong>不执行 redo log 的重做</strong></p>
</li>
<li><p>找到该事务的 undo log，执行回滚操作（相当于手动执行 rollback）</p>
</li>
<li><p>Buffer Pool 重新加载时，所有对页的恢复都是基于已提交事务</p>
</li>
</ol>
<h1 id="为什么重启要做-undo？如果这个提交还没有-commit，那我直接把它扔掉不就好了吗？buffer-pool-直接加载当前数据？"><a href="#为什么重启要做-undo？如果这个提交还没有-commit，那我直接把它扔掉不就好了吗？buffer-pool-直接加载当前数据？" class="headerlink" title="为什么重启要做 undo？如果这个提交还没有 commit，那我直接把它扔掉不就好了吗？buffer pool 直接加载当前数据？"></a>为什么重启要做 undo？如果这个提交还没有 commit，那我直接把它扔掉不就好了吗？buffer pool 直接加载当前数据？</h1><p>这个问题问得非常精准！很多人第一次学 InnoDB crash recovery 时也会有这个疑惑：</p>
<blockquote>
<p>❓“未提交的事务不是没 commit 吗？为啥还要 rollback？直接别恢复它不就好了？”</p>
</blockquote>
<p>咱们今天就把这件事彻底讲清楚👇</p>
<hr>
<p> ✅ 先给出简洁回答：</p>
<blockquote>
<p><strong>InnoDB 不是真正把“未提交事务”数据忽略掉，而是需要主动用 undo log 回滚它</strong>，<br>因为：<strong>这些未提交的修改，已经写入到了数据页（甚至写入磁盘）中了！不能不管！</strong></p>
</blockquote>
<hr>
<p>📌 为什么不能“直接不恢复”？</p>
<p>我们得从 <strong>redo log 与数据页的时序关系</strong> 来看：</p>
<ol>
<li><p>redo log 是“先写日志，再修改内存页（Buffer Pool）”，对吧？</p>
</li>
<li><p>如果内存页（Buffer Pool）被刷到磁盘（.ibd 文件），但事务还没 commit，就成了“脏数据”</p>
</li>
</ol>
<hr>
<p> ⛔ 场景还原：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Alice&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>执行完：</p>
<ul>
<li><p>🔸 生成 redo log（写到 redo buffer，可能已刷盘）</p>
</li>
<li><p>🔸 Buffer Pool 中修改页内容</p>
</li>
<li><p>🔸 Buffer Pool 脏页可能已经异步刷到磁盘（.ibd）</p>
</li>
</ul>
<p>这时突然宕机！</p>
<hr>
<p>🔥 如果你“啥也不做”，直接加载当前数据页？</p>
<ul>
<li><p>数据页上已经是 “name &#x3D; ‘Alice’”</p>
</li>
<li><p>但这个事务没 commit！</p>
</li>
<li><p>你就相当于把一个“<strong>未提交事务的修改</strong>”当成“<strong>正常数据</strong>”用了！</p>
</li>
</ul>
<p>这就破坏了 MySQL 的 <strong>事务原子性 &amp; 一致性</strong>（ACID）：</p>
<blockquote>
<p>❌ 未提交的内容绝不能被恢复成正式数据！</p>
</blockquote>
<hr>
<p> ✅ 所以必须干嘛？</p>
<blockquote>
<p>🔁 在恢复阶段：</p>
<ul>
<li><p>识别 redo log 中哪些事务没 commit</p>
</li>
<li><p>用它们的 <strong>undo log 回滚</strong>这部分数据页的修改</p>
</li>
<li><p>让数据页回到事务开始之前的样子</p>
</li>
</ul>
</blockquote>
<p>这样才能做到 <strong>事务一致性</strong>：崩溃恢复后只留下那些“已经提交”的结果。</p>
<hr>
<p>🧠 简单总结一句话：</p>
<blockquote>
<p><strong>InnoDB 不是简单地“忽略”未提交事务，而是必须“显式地撤销”它做过的事。</strong></p>
</blockquote>
<p>因为它的修改很可能已经影响了磁盘数据，必须还原！</p>
<hr>
<p>如果你想更深入，我可以模拟一次“未提交事务刷脏页”+“undo 回滚”的具体过程（页号 + offset + undo slot），你要不要看看硬核版本的？😎</p>
<h1 id="什么是-buffer-pool"><a href="#什么是-buffer-pool" class="headerlink" title="什么是 buffer pool"></a>什么是 buffer pool</h1><p><strong>Buffer Pool 是什么？</strong></p>
<p>简单来说，<strong>Buffer Pool 是 InnoDB 存储引擎在内存中开辟的一块区域，用于缓存磁盘上数据文件（.ibd 文件）中的数据页 (Data Page) 和索引页 (Index Page)。</strong></p>
<p>你可以把它想象成是数据库为了<strong>减少磁盘 I&#x2F;O</strong> 而在内存里建立的一个高速缓存区。</p>
<p><strong>为什么需要 Buffer Pool？</strong></p>
<ul>
<li><p><strong>磁盘 I&#x2F;O 很慢:</strong> 相比于内存访问，磁盘的随机读写速度要慢好几个数量级。如果每次读写数据都要直接操作磁盘，数据库性能会非常低下。</p>
</li>
<li><p><strong>数据访问局部性原理:</strong> 应用程序访问数据通常具有局部性，即最近访问过的数据或其附近的数据很可能在不久的将来再次被访问。将这些热点数据缓存到内存中，可以极大地提高访问速度。</p>
</li>
</ul>
<p><strong>Buffer Pool 如何工作？</strong></p>
<ol>
<li><p><strong>缓存数据页和索引页:</strong> 当 InnoDB 需要读取某个数据页或索引页时，它会首先检查这个页是否已经在 Buffer Pool 中：</p>
<ul>
<li><p><strong>缓存命中 (Cache Hit):</strong> 如果页在 Buffer Pool 中，InnoDB 直接从内存读取，速度非常快。</p>
</li>
<li><p><strong>缓存未命中 (Cache Miss):</strong> 如果页不在 Buffer Pool 中，InnoDB 需要从磁盘上的数据文件将其读取到 Buffer Pool 中一个空闲的缓存页位置，然后再从 Buffer Pool 读取。这个过程相对较慢，因为涉及磁盘 I&#x2F;O。</p>
</li>
</ul>
</li>
<li><p><strong>缓存修改后的数据 (脏页 Dirty Pages):</strong> 当 InnoDB 需要修改某个数据页时（例如执行 UPDATE 或 INSERT）：</p>
<ul>
<li><p>它会先将该页读入 Buffer Pool（如果不在的话）。</p>
</li>
<li><p>然后，<strong>直接修改内存中 Buffer Pool 里的这个页</strong>。这个被修改过但尚未写回磁盘的页被称为“脏页 (Dirty Page)”。</p>
</li>
<li><p><strong>重要：</strong> 修改<strong>不会</strong>立即写回磁盘的数据文件。这是为了性能。内存修改非常快。</p>
</li>
<li><p>为了保证持久性（ACID 中的 D），对数据页的修改操作会先被记录到 <strong>Redo Log</strong> 中，并且 Redo Log 会在事务提交时（或根据策略）被刷到磁盘。</p>
</li>
</ul>
</li>
<li><p><strong>脏页的刷盘 (Flush):</strong> Buffer Pool 中的脏页最终需要被写回到磁盘上的数据文件中。这个过程通常由后台线程异步、批量地完成，主要触发时机包括：</p>
<ul>
<li><p><strong>Checkpoint 机制:</strong> InnoDB 会定期执行 Checkpoint，将某个时间点之前的脏页刷新到磁盘，以推进 Redo Log 的可重用空间。</p>
</li>
<li><p><strong>Buffer Pool 空间不足:</strong> 当需要加载新页到 Buffer Pool 但没有足够空闲页时，需要将一些“最久未使用”的脏页刷盘腾出空间。</p>
</li>
<li><p><strong>Redo Log 写满:</strong> 为了推进 Redo Log，需要确保对应的脏页已落盘。</p>
</li>
<li><p><strong>数据库正常关闭时:</strong> 所有脏页会被刷盘。</p>
</li>
</ul>
</li>
<li><p><strong>缓存页的淘汰 (Eviction):</strong> Buffer Pool 的大小是有限的。当需要加载新页但没有空闲缓存页时，InnoDB 需要选择一个现有的缓存页进行淘汰。它使用一种改进的 <strong>LRU (Least Recently Used - 最近最少使用)</strong> 算法来决定淘汰哪个页：</p>
<ul>
<li><p><strong>基本 LRU:</strong> 维护一个列表，最近访问的页放在列表头部，最久未访问的在尾部。淘汰时从尾部移除。</p>
</li>
<li><p><strong>InnoDB 的改进 (Midpoint Insertion Strategy):</strong> 为了防止全表扫描等操作污染缓存（将大量只访问一次的页放入热区），InnoDB 将 LRU 列表分为 “Young” (热数据) 和 “Old” (冷数据) 两个子列表。新读入的页通常先放入 Old 区的头部。只有当 Old 区的页再次被访问时，才会被移动到 Young 区的头部。淘汰优先从 Old 区的尾部进行。</p>
</li>
</ul>
</li>
</ol>
<p><strong>Buffer Pool 的重要性:</strong></p>
<ul>
<li><p><strong>性能核心:</strong> Buffer Pool 是 InnoDB 性能的关键。一个配置合理、足够大的 Buffer Pool 可以显著减少磁盘 I&#x2F;O，大幅提升数据库的读写性能。</p>
</li>
<li><p><strong>配置关键参数:</strong> innodb_buffer_pool_size 是最重要的配置参数之一，它直接决定了 Buffer Pool 的大小。在专用的数据库服务器上，通常建议将其设置为物理内存的 50% 到 80%（需要给操作系统和其他进程留出内存）。</p>
</li>
<li><p><strong>监控:</strong> 通过 SHOW ENGINE INNODB STATUS 或相关的 Performance Schema&#x2F;Information Schema 表，可以监控 Buffer Pool 的命中率、脏页数量、I&#x2F;O 活动等关键指标，用于性能分析和调优。</p>
</li>
</ul>
<p><strong>总结:</strong></p>
<p>MySQL 的 Buffer Pool (主要指 InnoDB 的) 是一个<strong>内存缓存区</strong>，用于存放从磁盘读取的数据页和索引页。它通过将热点数据保留在内存中来<strong>加速读操作</strong>，并通过在内存中修改数据（产生脏页）再异步刷盘来<strong>优化写操作</strong>。其大小和管理效率直接影响数据库性能，是性能调优时必须关注的核心组件。</p>
<h1 id="buffer-pool-可能会把未提交事务产生的数据刷到-ibd-里面吗？"><a href="#buffer-pool-可能会把未提交事务产生的数据刷到-ibd-里面吗？" class="headerlink" title="buffer pool 可能会把未提交事务产生的数据刷到 ibd 里面吗？"></a>buffer pool 可能会把未提交事务产生的数据刷到 ibd 里面吗？</h1><p>是的，<strong>Buffer Pool 完全有可能将包含未提交事务所做修改的数据页（即“脏页”）刷入到磁盘上的 .ibd 数据文件中</strong>。</p>
<p>这听起来可能有点反直觉，但这是 InnoDB 设计中正常且必要的行为，并且 <strong>不会破坏事务的原子性或隔离性</strong>，原因如下：</p>
<ol>
<li><p><strong>刷盘是基于页 (Page)，而非基于事务 (Transaction):</strong></p>
<ul>
<li><p>Buffer Pool 管理和刷盘的基本单位是<strong>数据页</strong>。一个数据页上可能同时包含来自<strong>多个不同事务</strong>（包括已提交、未提交、活跃的）所做的修改记录。</p>
</li>
<li><p>InnoDB 的后台刷盘线程（如 Page Cleaner Thread）选择哪些脏页进行刷盘，主要是基于 LRU 算法（淘汰最近最少使用的页）、Checkpoint 进度、脏页比例等因素，而<strong>不是</strong>基于这些页上的修改是否都来自已提交的事务。</p>
</li>
<li><p>因此，一个包含未提交事务修改的脏页，完全可能因为上述原因被选中并刷回到 .ibd 文件。</p>
</li>
</ul>
</li>
<li><p><strong>为什么允许这样做？性能！</strong></p>
<ul>
<li><p>如果要求必须等到页上所有的修改都来自已提交的事务才允许刷盘，那么刷盘效率会大大降低。一个包含活跃事务修改的“热点页”可能长时间无法刷盘，导致 Buffer Pool 中脏页堆积，增加恢复时间，并可能阻塞其他需要缓存空间的操作。</p>
</li>
<li><p>允许混合刷盘使得刷盘过程更加平滑和高效。</p>
</li>
</ul>
</li>
<li><p><strong>如何保证原子性和一致性？靠 Undo Log！</strong></p>
<ul>
<li><p>即使包含了未提交事务修改的数据页被写入了磁盘，这并不会导致数据不一致或破坏原子性。</p>
</li>
<li><p><strong>如果事务最终提交：</strong> 那么这些修改就是有效的，写入磁盘是应该的（虽然 Redo Log 已经保证了持久性）。</p>
</li>
<li><p><strong>如果事务最终回滚 (Rollback)：</strong></p>
<ul>
<li><p>InnoDB 会使用该事务对应的 <strong>Undo Log</strong> 来撤销这些修改。这个撤销操作<strong>同样会修改 Buffer Pool 中的数据页</strong>（应用反向操作），将这些页再次标记为“脏页”，最终这些“撤销”后的状态也会被刷回磁盘。</p>
</li>
<li><p>如果是在<strong>宕机恢复</strong>时需要回滚未提交事务：InnoDB 会先通过 Redo Log 将数据库恢复到崩溃前的状态（这可能包含未提交的修改），然后利用 Undo Log 对所有未提交事务进行回滚操作，将数据页恢复到事务开始前的状态。最终写回磁盘的也是这个回滚后的状态。</p>
</li>
</ul>
</li>
<li><p><strong>MVCC (多版本并发控制) 的作用：</strong> 对于其他正在运行的事务，它们通过 MVCC 机制读取数据。它们会根据事务的隔离级别和事务 ID，利用 Undo Log 来看到它们应该看到的、一致性的数据版本（通常是事务开始时的快照，或者已提交的数据），而<strong>不会读到</strong>其他未提交事务所做的、即使已经刷盘的修改。</p>
</li>
</ul>
</li>
</ol>
<p><strong>总结:</strong></p>
<ul>
<li><p><strong>是的，包含未提交事务修改的脏页可能会被刷入 .ibd 文件。</strong></p>
</li>
<li><p>这是 InnoDB 出于<strong>性能考虑</strong>的正常设计。</p>
</li>
<li><p>数据库的<strong>原子性</strong>（未提交事务最终无效）和<strong>隔离性</strong>（并发事务不看到未提交的修改）是通过 <strong>Undo Log 和 MVCC</strong> 机制来保证的，<strong>而不是</strong>通过阻止未提交修改的数据页刷盘来实现的。</p>
</li>
<li><p>宕机恢复时，Redo Log 先恢复所有（包括未提交的）修改，然后 Undo Log 负责回滚未提交的事务，最终确保数据文件只反映已提交事务的状态。</p>
</li>
</ul>
<h1 id="什么是-binlog"><a href="#什么是-binlog" class="headerlink" title="什么是 binlog"></a>什么是 binlog</h1><p>binlog 用于记录数据库执行的写入性操作（不包括查询）信息，以二进制的形式保存在磁盘中。binlog 是 MySQL 的逻辑日志，并且由 Server 层进行记录，使用任何存储引擎的 <a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cdb?from_column=20065&from=20065">MySQL数据库</a> 都会记录 binlog 日志。</p>
<ul>
<li>逻辑日志：可以简单理解为记录的就是 SQL 语句。</li>
<li>物理日志：因为 MySQL 数据最终是保存在数据页中的，物理日志记录的就是数据页变更。</li>
</ul>
<p>binlog 是通过追加的方式进行写入的，可以通过 max_binlog_size 参数设置每个 binlog 文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。</p>
<p>在实际应用中，binlog 的主要使用场景有两个，分别是主从复制和数据恢复。</p>
<ul>
<li>主从复制：在 Master 端开启 binlog，然后将 binlog 发送到各个 Slave 端，Slave 端重放 binlog 从而达到主从数据一致。</li>
<li>数据恢复：通过使用 mysqlbinlog 工具来恢复数据。</li>
</ul>
<h1 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h1><ul>
<li>主库的更新 SQL (update、insert、delete) 被写到 binlog。</li>
<li>从库发起连接，连接到主库。</li>
<li>此时主库创建一个 binlog dump thread，把 bin log 的内容发送到从库。</li>
<li>从库启动之后，创建一个 I&#x2F;O 线程，读取主库传过来的 bin log 内容并写入到 relay log（中继日志）。</li>
<li>从库还会创建一个 SQL 线程，从 relay log 里面读取内容，从 ExecMasterLog_Pos 位置开始执行读取到的更新事件，将更新内容写入到 slave 的 db。</li>
</ul>
<h1 id="为什么有了-redolog-还需要-binlog？二者的区别和使用场景？"><a href="#为什么有了-redolog-还需要-binlog？二者的区别和使用场景？" class="headerlink" title="为什么有了 redolog 还需要 binlog？二者的区别和使用场景？"></a>为什么有了 redolog 还需要 binlog？二者的区别和使用场景？</h1><p><strong>为什么需要两者？&#x2F; 二者的关键区别与互补性</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>特性</td>
<td>Redo Log (InnoDB)</td>
<td>Binlog (MySQL Server)</td>
</tr>
<tr>
<td><strong>层面</strong></td>
<td>存储引擎层 (InnoDB 特有)</td>
<td>Server 层 (所有引擎共享)</td>
</tr>
<tr>
<td><strong>目的</strong></td>
<td><strong>崩溃恢复</strong>, <strong>保证持久性 (Durability)</strong></td>
<td><strong>复制</strong>, <strong>数据恢复 (PITR)</strong>, <strong>审计</strong></td>
</tr>
<tr>
<td><strong>内容</strong></td>
<td><strong>物理</strong>操作 (数据页修改)</td>
<td><strong>逻辑</strong>操作 (SQL 语句或行变更)</td>
</tr>
<tr>
<td><strong>格式</strong></td>
<td>二进制物理格式</td>
<td>逻辑格式 (Statement&#x2F;Row&#x2F;Mixed), 可解析</td>
</tr>
<tr>
<td><strong>文件结构</strong></td>
<td>固定大小, <strong>循环写入</strong></td>
<td>追加写入, 文件序列, <strong>不循环</strong></td>
</tr>
<tr>
<td><strong>写入时机</strong></td>
<td>事务执行中产生, 提交时<strong>强制或按策略</strong>刷盘 (WAL)</td>
<td>事务提交过程中写入 (通常在 Redo Log Prepare 后)</td>
</tr>
<tr>
<td><strong>崩溃安全</strong></td>
<td><strong>保证</strong> InnoDB 自身崩溃安全</td>
<td><strong>不直接保证</strong> 引擎层崩溃安全 (依赖引擎的 Redo Log)</td>
</tr>
</tbody></table>
<p><strong>核心原因：职责不同</strong></p>
<ul>
<li><p><strong>Redo Log 负责让 InnoDB 自己“不出错”:</strong> 它保证了 InnoDB 存储引擎自身在面对崩溃时的恢复能力，使得 InnoDB 符合 ACID 中的 D（持久性）。它只关心物理数据页如何恢复，不关心逻辑操作是什么。</p>
</li>
<li><p><strong>Binlog 负责让 MySQL Server“能被复制”和“能回溯”:</strong> 它记录了数据库发生的逻辑变更，使得其他 MySQL 服务器（从库）可以重放这些变更，或者 DBA 可以利用它进行精确到时间点的数据恢复。它不负责保证单个事务在引擎崩溃时的持久性。</p>
</li>
</ul>
<h1 id="幻读和不可重复读的区别"><a href="#幻读和不可重复读的区别" class="headerlink" title="幻读和不可重复读的区别"></a>幻读和不可重复读的区别</h1><p>不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了</p>
<p>幻读（Phantom Read）和不可重复读（Non-repeatable Read）都是并发环境下可能出现的数据读取问题，但它们的原因和表现方式有所不同。</p>
<ol>
<li>幻读（Phantom Read）： 幻读指的是在事务中多次执行相同的查询，但在两次查询之间有其他事务插入了新的数据，导致第二次查询返回的结果集中出现了新插入的数据，就好像产生了”幻影”一样。幻读通常与范围查询（Range Query）有关，例如使用了 WHERE 子句的查询。</li>
</ol>
<p>幻读的产生原因是由于并发事务之间的插入操作，可能导致事务在同样的查询条件下获取的结果集不一致，从而出现了额外的行数据。</p>
<ol>
<li>不可重复读（Non-repeatable Read）： 不可重复读指的是在事务中多次执行相同的查询，但在两次查询之间有其他事务对同一行数据进行了修改或删除，导致第二次查询返回的结果与第一次查询不一致。</li>
</ol>
<p>不可重复读的产生原因是由于并发事务之间的更新或删除操作，导致事务在多次读取同一行数据时，数据内容发生了变化，从而出现了不一致的情况。</p>
<p>区别：</p>
<ul>
<li>幻读与范围查询有关，主要涉及到新增数据，而不可重复读主要涉及到已有数据的更新或删除。</li>
<li>幻读是指查询同样的条件下结果集的行数发生了变化，而不可重复读是指查询同样的条件下结果集的行数据内容发生了变化。</li>
</ul>
<p>解决方法：</p>
<ul>
<li>幻读通常通过使用锁或多版本并发控制（MVCC）来解决。</li>
<li>不可重复读通常通过使用锁或使用行级别的读取锁（Read Lock）来解决。</li>
</ul>
<p>需要注意的是，幻读和不可重复读是数据库事务隔离级别中的现象。在不同的事务隔离级别下，这些问题的出现与解决方式也可能有所不同。</p>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>四种事务隔离级别</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>READ UNCOMMITTED</strong></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>最低级别，可能读到未提交的数据（脏读）</td>
</tr>
<tr>
<td><strong>READ COMMITTED</strong></td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
<td>Oracle 默认，解决脏读，但可能看到别的事务提交的新数据（不可重复读）</td>
</tr>
<tr>
<td><strong>REPEATABLE READ</strong></td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
<td>MySQL InnoDB 默认，保证同一事务内多次读数据一致，但可能遇到幻读</td>
</tr>
<tr>
<td><strong>SERIALIZABLE</strong></td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>最严格，串行执行（对每行加锁），最慢最安全</td>
</tr>
</tbody></table>
<p><strong>1. 读未提交 (Read Uncommitted)</strong></p>
<ul>
<li><p><strong>级别最低：</strong> 一个事务可以读取到其他事务<strong>尚未提交</strong>的修改。</p>
</li>
<li><p><strong>存在问题：</strong></p>
<ul>
<li><p><strong>脏读 (Dirty Read):</strong> 读取到了其他事务未提交的数据，如果那个事务最终回滚，读取到的就是无效的脏数据。</p>
</li>
<li><p><strong>不可重复读 (Non-repeatable Read):</strong> 在同一事务内，两次读取同一行数据，结果可能不同，因为其他事务在此期间修改并提交了该行。</p>
</li>
<li><p><strong>幻读 (Phantom Read):</strong> 在同一事务内，两次执行相同的范围查询，结果集中的行数可能不同，因为其他事务在此期间插入或删除了符合条件的行。</p>
</li>
</ul>
</li>
<li><p><strong>并发性能：</strong> 最高，因为读操作几乎不加锁（或加锁时间极短）。</p>
</li>
<li><p><strong>使用场景：</strong> 很少使用，除非对数据一致性要求极低，能容忍脏读。</p>
</li>
</ul>
<p><strong>2. 读已提交 (Read Committed)</strong></p>
<ul>
<li><p><strong>解决了脏读：</strong> 一个事务只能读取到其他事务<strong>已经提交</strong>的修改。</p>
</li>
<li><p><strong>实现方式 (InnoDB):</strong> 通常通过 MVCC (多版本并发控制) 实现。每次 SELECT 语句执行时，都会创建一个新的读视图 (Read View)，只能看到在该视图创建之前已经提交的事务的修改。</p>
</li>
<li><p><strong>存在问题：</strong></p>
<ul>
<li><p><strong>不可重复读 (Non-repeatable Read):</strong> 因为事务内每次 SELECT 都会创建新的读视图，如果在两次 SELECT 之间，有其他事务修改了数据并提交，那么第二次 SELECT 就能看到这个提交后的新值，导致两次读取结果不一致。</p>
</li>
<li><p><strong>幻读 (Phantom Read):</strong> 同样因为每次 SELECT 创建新视图，可能看到其他事务新插入并提交的行。</p>
</li>
</ul>
</li>
<li><p><strong>并发性能：</strong> 较好，读操作不阻塞写操作，写操作也不阻塞读操作（基于 MVCC）。</p>
</li>
<li><p><strong>使用场景：</strong> 很多数据库的默认级别（如 Oracle, PostgreSQL, SQL Server 的默认 RCSI）。适用于大多数要求避免脏读，但可以容忍不可重复读和幻读的应用。</p>
</li>
</ul>
<p><strong>3. 可重复读 (Repeatable Read) - MySQL InnoDB 默认级别</strong></p>
<ul>
<li><p><strong>解决了脏读和不可重复读：</strong> 在同一个事务内，多次读取同一行数据，结果保证是一致的。</p>
</li>
<li><p><strong>实现方式 (InnoDB):</strong> 同样基于 MVCC。关键区别在于，<strong>读视图 (Read View) 是在事务第一次执行 SELECT 语句时创建的，并且在整个事务期间保持不变</strong>。后续的所有 SELECT 都使用这个<strong>初始的读视图</strong>，因此它们只能看到在事务开始时就已经提交的数据，或者本事务自己所做的修改，看不到其他并发事务在此期间提交的修改。</p>
</li>
<li><p><strong>存在问题：</strong></p>
<ul>
<li><p><strong>幻读 (Phantom Read):</strong> 理论上，标准的 RR 级别仍然允许幻读。但在 <strong>MySQL 的 InnoDB</strong> 中，通过结合 <strong>MVCC 和 Next-Key Locking (间隙锁 + 记录锁)<strong>，它在很大程度上</strong>解决了幻读问题</strong>。</p>
<ul>
<li><p>对于快照读 (SELECT)，MVCC 保证看不到新插入的行。</p>
</li>
<li><p>对于当前读 (SELECT … FOR UPDATE, SELECT … LOCK IN SHARE MODE, INSERT, UPDATE, DELETE)，Next-Key Lock 会锁定扫描到的索引记录及其间的间隙，阻止其他事务在这些间隙中插入新的、可能导致幻读的行。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>并发性能：</strong> 良好。快照读性能高。但由于 Next-Key Lock 的存在，在某些并发写入场景下可能会锁定更大范围，降低并发度，并增加死锁的风险。</p>
</li>
<li><p><strong>使用场景：</strong> MySQL InnoDB 的默认设置，提供了较高的数据一致性保证（基本避免幻读），适用于大多数需要事务内数据一致性的应用。</p>
</li>
</ul>
<p><strong>4. 串行化 (Serializable)</strong></p>
<ul>
<li><p><strong>级别最高：</strong> 解决了脏读、不可重复读和幻读。强制事务串行执行，即一个接一个地执行，完全避免了并发问题。</p>
</li>
<li><p><strong>实现方式 (InnoDB):</strong> 通常会对所有读取的行都加上**共享锁 (S Lock)<strong>，对写入的行加上</strong>排他锁 (X Lock)**。如果遇到锁冲突，事务必须等待。相当于所有读操作都隐式地变成了 SELECT … LOCK IN SHARE MODE。</p>
</li>
<li><p><strong>存在问题：</strong></p>
<ul>
<li><strong>并发性能极差：</strong> 大量的锁竞争导致事务需要排队等待，系统吞吐量会急剧下降。</li>
</ul>
</li>
<li><p><strong>并发性能：</strong> 最低。</p>
</li>
<li><p><strong>使用场景：</strong> 对数据一致性要求极其严格，且可以接受极低并发性能的场景。非常少用，通常只有在特定业务逻辑需要绝对串行保证时才会考虑。</p>
</li>
</ul>
<h1 id="间隙锁是怎么解决幻读问题的？"><a href="#间隙锁是怎么解决幻读问题的？" class="headerlink" title="间隙锁是怎么解决幻读问题的？"></a>间隙锁是怎么解决幻读问题的？</h1><p>首先说明，RR 可重复度级别，如果是 SELECT 是不会有幻读问题的，因为使用的是快照读，且 RR 级别整个事务只会使用一个快照。只有使用类似 SELECT FOR UPDATE 这种当前读（读取最新的数据）时才会出现。</p>
<p>解决的方法是间隙锁+Next-Key Lock，它的锁定范围会比行锁大一些，且这个锁会持续锁定，直到事务结束。Next-Key Lock 是间隙锁 + 行锁的结合，间隙锁锁定的是<strong>索引记录之间的间隙 (Gap)<strong>，</strong>不包括</strong>记录本身。</p>
<p><strong>示例：</strong></p>
<p>假设有一个 products 表，id 是主键，当前有数据 id &#x3D; 10 和 id &#x3D; 20。</p>
<ul>
<li><p><strong>事务 A</strong> 执行： SELECT * FROM products WHERE id &gt; 9 AND id &lt; 25 FOR UPDATE;</p>
</li>
<li><p><strong>InnoDB (RR 级别) 的锁定行为：</strong></p>
<ul>
<li><p>扫描索引，找到 id &#x3D; 10。对 id &#x3D; 10 加 Next-Key Lock（锁住记录 10 和间隙 (…, 10]）。</p>
</li>
<li><p>扫描索引，找到 id &#x3D; 20。对 id &#x3D; 20 加 Next-Key Lock（锁住记录 20 和间隙 (10, 20]）。</p>
</li>
<li><p>继续扫描，没有找到 id &#x3D; 25，但扫描会越过 id &#x3D; 20。它需要锁定 id &#x3D; 20 之后的间隙，直到下一个存在的键（或者无穷大）。所以，它会在 id &#x3D; 20 之后加上一个间隙锁，覆盖 (20, +∞) 的范围（具体范围取决于索引结构和查询）。</p>
</li>
<li><p><strong>关键效果：</strong> 现在，间隙 (10, 20] 和 (20, …) 都被事务 A 锁定了。</p>
</li>
</ul>
</li>
<li><p><strong>事务 B</strong> 尝试执行： INSERT INTO products (id) VALUES (15);</p>
</li>
<li><p><strong>InnoDB 的反应：</strong></p>
<ul>
<li><p>事务 B 想要在 id &#x3D; 15 的位置插入数据。这个位置位于间隙 (10, 20] 中。</p>
</li>
<li><p>事务 A 持有覆盖该间隙的 Gap Lock（作为 id &#x3D; 20 的 Next-Key Lock 的一部分）。</p>
</li>
<li><p>事务 B 需要获取一个<strong>插入意向锁 (Insert Intention Lock)</strong> 才能在这个间隙插入。</p>
</li>
<li><p>插入意向锁与间隙锁是<strong>不兼容</strong>的。</p>
</li>
<li><p>因此，<strong>事务 B 的 INSERT 操作会被阻塞</strong>，直到事务 A 提交或回滚，释放了那个间隙锁。</p>
</li>
</ul>
</li>
<li><p><strong>结果：</strong> 由于事务 B 被阻塞，无法插入 id &#x3D; 15 的新行，因此事务 A 在其后续的任何（当前读或快照读）查询中，都不会看到 id &#x3D; 15 这个“幻影”行。幻读被阻止了。</p>
</li>
</ul>
<h1 id="介绍下乐观锁悲观锁，以及各自的使用场景"><a href="#介绍下乐观锁悲观锁，以及各自的使用场景" class="headerlink" title="介绍下乐观锁悲观锁，以及各自的使用场景"></a>介绍下乐观锁悲观锁，以及各自的使用场景</h1><p>乐观锁和悲观锁是并发控制中常见的两种策略，用于解决多个线程或进程并发访问共享资源时可能发生的数据一致性问题。</p>
<ol>
<li>悲观锁（Pessimistic Locking）： 悲观锁是一种保守的并发控制策略，它假设并发访问的操作会发生冲突，因此在访问共享资源之前，会先对资源进行加锁，确保其他线程无法同时修改该资源。悲观锁的典型应用是使用数据库的行级锁（如行锁、表锁）来保证数据的一致性。悲观锁的特点是阻塞其他线程的访问，可能导致线程等待和性能下降。</li>
</ol>
<p>适用场景：</p>
<ul>
<li>需要修改共享资源的概率较高。</li>
<li>并发访问频率较高。</li>
<li>并发冲突的概率较大。</li>
<li>数据库事务隔离级别为串行化（Serializable）。</li>
</ul>
<ol>
<li>乐观锁（Optimistic Locking）： 乐观锁是一种乐观的并发控制策略，它假设并发访问的操作不会发生冲突，因此在访问共享资源时，不会立即对资源加锁，而是在更新操作时检查资源是否被其他线程修改过。乐观锁通过使用版本号、时间戳等机制来判断资源是否被修改。如果检测到冲突，则需要进行回滚或重试操作。乐观锁的特点是不阻塞其他线程的访问，但可能存在冲突处理的开销。</li>
</ol>
<p>适用场景：</p>
<ul>
<li>读取操作远远大于写入操作。</li>
<li>并发访问冲突较少。</li>
<li>数据库事务隔离级别为读已提交（Read Committed）或更低。</li>
</ul>
<p>选择乐观锁还是悲观锁取决于具体的应用场景和需求。在高并发环境下，悲观锁可能导致性能下降和线程阻塞，而乐观锁可以提供更好的并发性能。但是，乐观锁需要额外的冲突检测和处理机制，适用于冲突较少的场景。在实际应用中，可以根据具体情况选择合适的并发控制策略。</p>
<h1 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904009329803277">https://juejin.cn/post/6844904009329803277</a></p>
<ol>
<li><p><strong>为常作为查询条件的字段建立索引</strong></p>
<p>如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。</p>
</li>
<li><p><strong>避免索引失效（参考索引失效场景）</strong></p>
</li>
<li><p><strong>为经常需要排序、分组操作的字段建立索引</strong></p>
<p>经常需要 ORDER BY、GROUP BY、DISTINCT 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。</p>
</li>
<li><p><strong>限制索引的数目</strong></p>
<p>索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦。越多的索引，会使更新表变得很浪费时间。</p>
</li>
<li><p><strong>扩展索引</strong></p>
<p>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加 (a,b) 的索引，那么只需要修改原来的索引即可</p>
</li>
<li><p><strong>尽量使用数据量少的索引</strong></p>
<p>如果索引的值很长，那么查询的速度会受到影响。例如，对一个 CHAR(100 )类型的字段进行全文检索需要的时间要比对CHAR(10)类型的字段需要的时间要多。</p>
</li>
<li><p><strong>尽量使用前缀来索引</strong></p>
<p>如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。</p>
</li>
<li><p>删除不再使用或者很少使用的索引</p>
<p>表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</p>
</li>
</ol>
<h1 id="说一下-Mysql-二阶段提交"><a href="#说一下-Mysql-二阶段提交" class="headerlink" title="说一下 Mysql 二阶段提交"></a>说一下 Mysql 二阶段提交</h1><h1 id="索引失效场景"><a href="#索引失效场景" class="headerlink" title="索引失效场景"></a>索引失效场景</h1><p>在 MySQL 中，索引可能会失效的几种常见情况包括：</p>
<ol>
<li>不使用索引列或对索引列进行函数操作：当查询条件中对索引列进行函数操作、类型转换或计算时，索引可能无法被利用，导致失效。例如：<code>WHERE UPPER(name) = &#39;JOHN&#39;</code>。</li>
<li>使用 <code>OR</code> 进行条件判断：当查询条件 WHERE 中包含 <code>OR</code> 运算符时，如果其中一个条件无法使用索引，整个查询可能无法使用索引优化。例如：<code>WHERE name = &#39;John&#39; OR age = 25</code>。</li>
<li>使用 <code>NOT</code> 进行条件判断：<code>NOT</code> 运算符通常会导致索引失效，因为它会使索引无法直接匹配，需要全表扫描。例如：<code>WHERE NOT name = &#39;John&#39;</code>。</li>
<li>对索引使用左或者左右模糊匹配：当查询条件使用通配符在索引列开头，或者在开头和结尾，此时进行模糊匹配，索引可能无法被利用。例如：<code>WHERE name LIKE &#39;%John%&#39;, WHERE name LIKE &#39;%John&#39;</code>。</li>
<li>索引列参与运算：当查询条件中的索引列参与运算（如加减乘除）时，索引可能会失效。例如：<code>WHERE age + 5 = 30</code>。</li>
<li>隐式类型转换：当查询条件中使用的数据类型与索引列的数据类型不匹配时，MySQL 可能会进行隐式类型转换，导致索引失效。例如：索引列为整数类型，但查询条件中使用字符串进行比较。</li>
<li>联合索引不满足最左匹配原则</li>
<li>数据量过小的情况：如果表中的数据量非常小，MySQL 可能认为全表扫描比使用索引更高效，因此选择不使用索引。</li>
<li>索引列的选择性不高：如果索引列的选择性非常低，即索引列的值重复率很高，MySQL 可能不会选择使用索引进行查询，而是进行全表扫描。</li>
</ol>
<p>需要注意的是，以上情况并不是绝对的，MySQL 的查询优化器会根据具体的情况和统计信息来选择合适的执行计划，有时即使符合上述情况，MySQL 仍然可能使用索引。因此，在实际使用中，需要结合具体情况进行分析和测试，确保索引的正确使用和性能优化。</p>
<h1 id="B-树和-B-树的区别？为什么-MySQL-用-B-树实现索引？3-层-B-树有多少个节点？"><a href="#B-树和-B-树的区别？为什么-MySQL-用-B-树实现索引？3-层-B-树有多少个节点？" class="headerlink" title="B 树和 B+ 树的区别？为什么 MySQL 用 B+ 树实现索引？3 层 B+ 树有多少个节点？"></a>B 树和 B+ 树的区别？为什么 MySQL 用 B+ 树实现索引？3 层 B+ 树有多少个节点？</h1><h1 id="执行一条-SQL-的流程"><a href="#执行一条-SQL-的流程" class="headerlink" title="执行一条 SQL 的流程"></a>执行一条 SQL 的流程</h1><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/20250417150253.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ol>
<li><strong>连接器</strong></li>
</ol>
<ul>
<li>与客户端进行 TCP 三次握手建立连接；</li>
<li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li>
<li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li>
</ul>
<ol start="2">
<li><strong>查询缓存</strong></li>
</ol>
<p>​			mysql 收到 sql 后，解析第一个字段，获取语句类型，如果是 <strong>查询语句</strong>，那么就会去缓存中查找，缓存以键值对形式保存，其中键是 sql 语句，值是对应的查询结果，如果查询的语句没有命中缓存，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。</p>
<p>​			ps：这个功能因为作用不大，在 8.0 版本被删除，因为如果表里的数据经常发生变动，缓存的命中率就会变得很低，只要一个表有更新操作，那么这个表的查询缓存就会被清空。</p>
<ol start="3">
<li><strong>分析器</strong></li>
</ol>
<p>负责 <strong>词法分析</strong> 和 <strong>语法分析</strong></p>
<ul>
<li>词法分析</li>
</ul>
<p>​		MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方面后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</p>
<ul>
<li>语法分析</li>
</ul>
<p>​		根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p>
<ol start="4">
<li><strong>预处理器</strong></li>
</ol>
<ul>
<li>检查 SQL 查询语句中的表或者字段是否存在；</li>
<li>将 select * 中的 * 符号，扩展为表上的所有列；</li>
</ul>
<ol start="5">
<li><strong>优化器</strong></li>
</ol>
<p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p>
<ol start="6">
<li><strong>执行器</strong></li>
</ol>
<p>根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端</p>
<h1 id="MySQL-死锁，什么情况下会触发死锁"><a href="#MySQL-死锁，什么情况下会触发死锁" class="headerlink" title="MySQL 死锁，什么情况下会触发死锁"></a>MySQL 死锁，什么情况下会触发死锁</h1><p> ✅ 1. <strong>两个事务操作同一资源，但顺序不同</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务 A</span><br><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Alice&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">-- 等待事务 B</span><br><br><span class="hljs-comment">-- 事务 B</span><br><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Bob&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-comment">-- 等待事务 A</span><br></code></pre></td></tr></table></figure>

<p>然后：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务 A</span><br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;X&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">-- 🚫 被事务 B 锁住</span><br><br><span class="hljs-comment">-- 事务 B</span><br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Y&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">-- 🚫 被事务 A 锁住</span><br></code></pre></td></tr></table></figure>

<p>→ A 等 B，B 等 A，死锁！</p>
<p>原因是：两个事务更新同一行，<strong>会加锁</strong>，而且是 <strong>排他锁（X 锁）</strong>！多个事务同时更新同一行，会发生锁竞争，后来的事务必须等待前一个释放锁或被回滚。</p>
<h1 id="慢查询分析"><a href="#慢查询分析" class="headerlink" title="慢查询分析"></a>慢查询分析</h1><h2 id="慢查询相关系统参数"><a href="#慢查询相关系统参数" class="headerlink" title="慢查询相关系统参数"></a>慢查询相关系统参数</h2><h3 id="slow-query-log：开启慢查询日志"><a href="#slow-query-log：开启慢查询日志" class="headerlink" title="slow_query_log：开启慢查询日志"></a>slow_query_log：开启慢查询日志</h3><p>在 MySQL 中，慢查询日志默认为 OFF 状态，通过如下命令进行查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">show variables like <span class="hljs-string">&quot;slow_query_log&quot;</span>;</span><br>+----------------+-------+<br>| Variable_name  | Value |<br>+----------------+-------+<br>| slow_query_log | OFF   |<br>+----------------+-------+<br></code></pre></td></tr></table></figure>


<p>通过如下命令进行设置为 ON 状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set global slow_query_log = &quot;ON&quot;;<br></code></pre></td></tr></table></figure>

<h3 id="slow-query-log-file：慢查询日志存储位置"><a href="#slow-query-log-file：慢查询日志存储位置" class="headerlink" title="slow_query_log_file：慢查询日志存储位置"></a>slow_query_log_file：慢查询日志存储位置</h3><p><code>slow_query_log_file</code> 属性表示慢查询日志存储位置，其日志默认名称为 host 名称，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">show variables like <span class="hljs-string">&quot;slow_query_log_file&quot;</span>;</span><br>+---------------------+----------------------------------------------+<br>| Variable_name       | Value                                        |<br>+---------------------+----------------------------------------------+<br>| slow_query_log_file | /bitnami/mysql/data/mysql-primary-0-slow.log |<br>+---------------------+----------------------------------------------+<br></code></pre></td></tr></table></figure>

<p>也可使用 以下命令进行修改：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set global slow_query_log_file = $&#123;path&#125;/$&#123;filename&#125;.log;<br></code></pre></td></tr></table></figure>

<h3 id="long-query-time：慢查询超时时间"><a href="#long-query-time：慢查询超时时间" class="headerlink" title="long_query_time：慢查询超时时间"></a>long_query_time：慢查询超时时间</h3><p>慢查询查询时间，当 SQL 执行时间超过该值时，则会记录在 slow_query_log_file 文件中，其默认为 10 ，最小值为 0，(单位：秒)。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">show variables like <span class="hljs-string">&quot;long_query_time&quot;</span>;</span><br>+-----------------+-----------+<br>| Variable_name   | Value     |<br>+-----------------+-----------+<br>| long_query_time | 10.000000 |<br>+-----------------+-----------+<br></code></pre></td></tr></table></figure>

<p>可通过以下命令进行修改：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash"><span class="hljs-built_in">set</span> global long_query_time = 5;</span><br></code></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>调用 sleep 函数，让这条 sql 的执行时间超过慢查询的超时时间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash"><span class="hljs-keyword">select</span> <span class="hljs-built_in">sleep</span>(11);</span><br></code></pre></td></tr></table></figure>

<p>查看慢查询日志内容（记得执行 quit 退出 mysql）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /bitnami/mysql/data/mysql-primary-0-slow.log</span><br>/opt/bitnami/mysql/bin/mysqld, Version: 8.0.34 (Source distribution). started with:<br>Tcp port: 3306  Unix socket: /opt/bitnami/mysql/tmp/mysql.sock<br>Time                 Id Command    Argument<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Time: 2023-08-17T16:45:52.534231Z</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">User@Host: root[root] @ localhost []  Id: 52593</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Query_time: 11.000171  Lock_time: 0.000000 Rows_sent: 1  Rows_examined: 1</span><br>SET timestamp=1692290741;<br>select sleep(11);<br></code></pre></td></tr></table></figure>

<p>慢查询日志内容含义如下：</p>
<ol>
<li>慢查询日志以 # 作为起始符。</li>
<li>User@Host：表示用户和慢查询查询的 ip 地址。</li>
<li>如上所述，表示 root 用户 localhost 地址。</li>
<li>Query_time: 表示 SQL 查询持续时间，单位 (秒)。</li>
<li>Lock_time: 表示获取锁的时间， 单位(秒)。</li>
<li>Rows_sent: 表示发送给客户端的行数。</li>
<li>Rows_examined: 表示服务器层检查的行数。</li>
<li>set timestamp：表示慢 SQL 记录时的时间戳。</li>
<li>最后一行的 select sleep(11) 则表示慢 SQL 语句。</li>
</ol>
<h1 id="Innodb-页合并和页分裂"><a href="#Innodb-页合并和页分裂" class="headerlink" title="Innodb 页合并和页分裂"></a>Innodb 页合并和页分裂</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/mysql/">#mysql</a>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">#面试题</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MySQL 面试题</div>
      <div>https://autsu.github.io/2021/07/25/mysql-mian-jing/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>void</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年7月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/07/28/bian-cheng-ti-er-cha-shu-de-xia-yi-ge-jie-dian/" title="[编程题]二叉树的下一个结点">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">[编程题]二叉树的下一个结点</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/07/25/redis-mian-jing/" title="Redis 面试题">
                        <span class="hidden-mobile">Redis 面试题</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"6KXGn05vaODkTMKM7zd5lWwl-gzGzoHsz","appKey":"qIMQwH4WrxTe8ds3Ua4HAbet","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
